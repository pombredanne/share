= link:../python.html[GAE / Python] / Datastore API =
:title: [GAE][Python] Datastore API

 * `from google.appengine.ext import db`
 * `db.Key.from_path(model, key_name)`
 * `db.get(key)`
 * `Model(key_name)` - 其中 `key_name` 必須要是 string，否則會丟出 `BadKeyError: Name must be string type, not int`。
 * `Model.key().name()`



== 參考資料 ==

.手冊
--
 * https://developers.google.com/appengine/docs/python/datastore/keyclass[The Key Class - Google App Engine — Google Developers]
--

 * https://developers.google.com/appengine/docs/python/datastore/overview[Datastore Overview - Google App Engine — Google Developers]
   ** https://developers.google.com/appengine/docs/python/datastore/entities[Entities, Properties, and Keys]
   ** https://developers.google.com/appengine/docs/python/datastore/indexes[Indexes]
   ** https://developers.google.com/appengine/docs/python/datastore/transactions[Transactions]
   ** https://developers.google.com/appengine/docs/python/datastore/datamodeling[Data Modeling]
   ** https://developers.google.com/appengine/docs/python/datastore/structuring_for_strong_consistency[Structuring Data for Strong Consistency]
   ** https://developers.google.com/appengine/docs/python/datastore/usingmasterslave[Using the Master/Slave Datastore]
   ** https://developers.google.com/appengine/docs/python/datastore/metadataqueries[Metadata]
   ** https://developers.google.com/appengine/docs/python/datastore/stats[Datastore Statistics]
   ** https://developers.google.com/appengine/docs/python/datastore/async[Async Datastore API]
 * https://developers.google.com/appengine/docs/python/gettingstartedpython27/usingdatastore[Using the Datastore - Google App Engine — Google Developers]

////////////////////////////////////////////////////////////////////////////////

--------------------------------------------------------------------------------
INFO     2013-03-26 21:13:17,184 datastore_stub_index.py:266] Updating /storage/dev/gae-python-1.7.6/workspace/helloworld/index.yaml

$ cat index.yaml 
indexes:

# AUTOGENERATED

# This index.yaml is automatically updated whenever the dev_appserver
# detects that a new type of query is run.  If you want to manage the
# index.yaml file manually, remove the above marker line (the line
# saying "# AUTOGENERATED").  If you want to manage some indexes
# manually, move them above the marker line.  The index.yaml file is
# automatically uploaded to the admin console when you next deploy
# your application using appcfg.py.

- kind: Greeting
  ancestor: yes
  properties:
  - name: date
    direction: desc
--------------------------------------------------------------------------------

 * App Engine's infrastructure takes care of all of the distribution, replication, and load balancing of data behind a simple API—and you get a powerful query engine and transactions as well.
 * App Engine's data repository, the High Replication Datastore (HRD), uses the Paxos algorithm to replicate data across multiple data centers.
 * Data is written to the Datastore in objects known as entities. Each entity has a key that uniquely identifies it.
 * An entity can optionally designate another entity as its parent; the first entity?? is a child of the parent entity.
   ** The entities in the Datastore thus form a hierarchically structured space similar to the directory structure of a file system. An entity's parent, parent's parent, and so on recursively, are its ancestors; its children, children's children, and so on, are its descendants. An entity without a parent is a root entity.
 * entity group
   ** The Datastore is extremely resilient in the face of catastrophic failure, but its consistency guarantees may differ from what you're familiar with.
   ** Entities descended from a common ancestor are said to belong to the same entity group; the common ancestor's key is the "group's parent key", which serves to identify the entire group. 這裡 "group's parent key" 的說法很怪，應該是 "group's key" 吧?? 因為 "group's parent" 又更上一層了。
   ** Queries over a single entity group, called "ancestor queries", refer to the parent key instead of a specific entity's key.
   ** Entity groups are a unit of both consistency and transactionality: whereas queries over multiple entity groups may return stale, "eventually consistent" results, those limited to a single entity group always return up-to-date, "strongly consistent" results.
 * organize related entities into entity groups, and use ancestor queries on those entity groups to return strongly consistent results. 不同的 entity kinds 可以歸在同一個 entiry group 下嗎??

--------------------------------------------------------------------------------
import cgi
import datetime
import urllib
import webapp2

from google.appengine.ext import db
from google.appengine.api import users


class Greeting(db.Model): # <1>
  """Models an individual Guestbook entry with an author, content, and date."""
  author = db.StringProperty()
  content = db.StringProperty(multiline=True)
  date = db.DateTimeProperty(auto_now_add=True)


def guestbook_key(guestbook_name=None): # <2>
  """Constructs a Datastore key for a Guestbook entity with guestbook_name."""
  return db.Key.from_path('Guestbook', guestbook_name or 'default_guestbook')


class MainPage(webapp2.RequestHandler):
  def get(self):
    self.response.out.write('<html><body>')
    guestbook_name=self.request.get('guestbook_name')

    # Ancestor Queries, as shown here, are strongly consistent with the High
    # Replication Datastore. Queries that span entity groups are eventually
    # consistent. If we omitted the ancestor from this query there would be a
    # slight chance that greeting that had just been written would not show up
    # in a query.
    greetings = db.GqlQuery("SELECT * "
                            "FROM Greeting "
                            "WHERE ANCESTOR IS :1 " # <3>
                            "ORDER BY date DESC LIMIT 10",
                            guestbook_key(guestbook_name))

    for greeting in greetings:
      if greeting.author:
        self.response.out.write(
            '<b>%s</b> wrote:' % greeting.author)
      else:
        self.response.out.write('An anonymous person wrote:')
      self.response.out.write('<blockquote>%s</blockquote>' %
                              cgi.escape(greeting.content))

    self.response.out.write("""
          <form action="/sign?%s" method="post">
            <div><textarea name="content" rows="3" cols="60"></textarea></div>
            <div><input type="submit" value="Sign Guestbook"></div>
          </form>
          <hr>
          <form>Guestbook name: <input value="%s" name="guestbook_name">
          <input type="submit" value="switch"></form>
        </body>
      </html>""" % (urllib.urlencode({'guestbook_name': guestbook_name}),
                          cgi.escape(guestbook_name)))


class Guestbook(webapp2.RequestHandler):
  def post(self):
    # We set the same parent key on the 'Greeting' to ensure each greeting is in
    # the same entity group. Queries across the single entity group will be
    # consistent. However, the write rate to a single entity group should
    # be limited to ~1/second.
    guestbook_name = self.request.get('guestbook_name')
    greeting = Greeting(parent=guestbook_key(guestbook_name)) # <4>

    if users.get_current_user():
      greeting.author = users.get_current_user().nickname()

    greeting.content = self.request.get('content')
    greeting.put() # <5>
    self.redirect('/?' + urllib.urlencode({'guestbook_name': guestbook_name}))


app = webapp2.WSGIApplication([('/', MainPage),
                               ('/sign', Guestbook)],
                              debug=True)
--------------------------------------------------------------------------------
<1> Models an individual Greeting entry with an author, content, and date. 注意是宣告 class attributes。
+
--
App Engine includes a data modeling API for Python. It's similar to Django's data modeling API, but uses App Engine's scalable Datastore behind the scenes.

Some property constructors take parameters to further configure their behavior. Giving the db.StringProperty constructor the multiline=True parameter says that values for this property can contain newline characters. Giving the db.DateTimeProperty constructor a auto_now_add=True parameter configures the model to automatically give new objects a date of the time the object is created, if the application doesn't otherwise provide a value.
--
+
<2> Constructs a Datastore key for a Guestbook entity with guestbook_name. 第一個 `'GuestBook'` 是 entity kind，後面接的 `guestbook_name` 是什麼?? 
<3> Ancestor Queries, as shown here, are strongly consistent with the High Replication Datastore. Queries that span entity groups are eventually consistent. If we omitted the ancestor from this query there would be a slight chance that greeting that had just been written would not show up in a query.
+
--
The App Engine Datastore has a sophisticated query engine for data models. Because the App Engine Datastore is not a traditional relational database, queries are not specified using SQL. Instead, you can prepare queries using a SQL-like query language we call GQL. GQL provides access to the App Engine Datastore query engine's features using a familiar syntax. As with SQL, keywords (such as SELECT) are case insensitive. Names, however, are case sensitive.

Because the query returns "full data objects", it does not make sense to select specific properties from the model. All GQL queries start with `SELECT * FROM model` (or are so implied by the model's gql(...) method) so as to resemble their SQL equivalents.

Alternatively, you can call the gql(...) method on the Greeting class, and omit the SELECT * FROM Greeting from the query:

 greetings = Greeting.gql("WHERE ANCESTOR IS :1 ORDER BY date DESC LIMIT 10", guestbook_key(guestbook_name))

A GQL query can have a WHERE clause that filters the result set by one or more conditions based on property values. Unlike SQL, GQL queries may not contain value constants: Instead, GQL uses parameter binding for all values in queries. For example, to get only the greetings posted in the past seven days:

--------------------------------------------------------------------------------
greetings = Greeting.gql(
            "WHERE ANCESTOR IS :1 AND date > :2 ORDER BY date DESC",
            guestbook_key(guestbook_name),
            datetime.datetime.now() + datetime.timedelta(days=-7)) # 這個寫法也太直覺了吧！
--------------------------------------------------------------------------------

You can also use named parameters instead of positional parameters:

--------------------------------------------------------------------------------
greetings = Greeting.gql("WHERE ANCESTOR = :ancestor AND date > :date ORDER BY date DESC",
                         ancestor=guestbook_key(guestbook_name),
                         date=datetime.datetime.now() + datetime.timedelta(days=-7))
--------------------------------------------------------------------------------

In addition to GQL, the Datastore API provides another mechanism for building query objects using methods.

--------------------------------------------------------------------------------
greetings = Greeting.all()
greetings.ancestor(guestbook_key(guestbook_name))
greetings.filter("date >",
                 datetime.datetime.now() + datetime.timedelta(days=-7))
greetings.order("-date") # 這種在 property names 前後加上 ">" 或 "-" 語法還滿妙的！
--------------------------------------------------------------------------------
--
+
<4> creates a new Greeting object, then sets its author and content properties with the data posted by the user.
+
--
The parent has an entity of kind Guestbook. There is no need to create the Guestbook entity before setting it to be the parent of another entity. In this example, the parent is used as a placeholder for transaction and consistency purposes. 注意 GuestBook > Greeting 的階層關係是兩種不同 kind 的 entities，雖然我們沒有明確做 GuestBook 的 modeling。

Because querying in the High Replication Datastore is strongly consistent only within entity groups, we assign all of one book's greetings to the same entity group in this example by setting the same parent for each greeting. This means a user will always see a greeting immediately after it was written.

However, the rate at which you can write to the same entity group is limited to 1 write to the entity group per second. When you design a real application you'll need to keep this fact in mind. Note that by using services such as Memcache, you can mitigate the chance that a user won't see fresh results when querying across entity groups immediately after a write??
--
+
<5> Finally, greeting.put() saves our new object to the Datastore. If we had acquired this object from a query, put() would have updated the existing object. Since we created this object with the model constructor, put() adds the new object to the Datastore.

 * Index
   ** Exercising the queries in your application locally causes App Engine to create or update index.yaml. If index.yaml is missing or incomplete, you will see index errors when your uploaded application executes queries for which the necessary indexes have not been specified. To avoid missing index errors in production, always test new queries at least once locally before uploading your application.
   ** Every query in the App Engine Datastore is computed from one or more indexes. Indexes are tables that map ordered property values to entity keys. This is how App Engine is able to serve results quickly regardless of the size of your application's Datastore. Many queries can be computed from the builtin indexes, but the Datastore requires you to specify a custom index for some, more complex, queries. Without a custom index, the Datastore can't execute the query efficiently.
   ** Our guest book example above, which filters by guestbook and orders by date, uses an ancestor query and a sort order. This query requires a custom index to be specified in your application's index.yaml file. When you upload your application, the custom index definition will be automatically uploaded, too. You will need to add an entry to your index.yaml file for this query that looks like: 因為程式沒對 GuestBook 做 query，所以不用為 GuestBook 做 index??
+
--------------------------------------------------------------------------------
indexes:
- kind: Greeting
  ancestor: yes
  properties:
  - name: date
    direction: desc
--------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////

