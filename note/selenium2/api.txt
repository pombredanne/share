= link:selenium2.html[Selenium 2/WebDriver] / API =
:title: [Selenium 2/WebDriver] API

從官網 http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions[FAQ] 的幾段文字，可以看出 WebDriver 很強調 “模仿使用者的行為“ 這件事：

 * It aims to mimic the behaviour of a real user, and as such interacts with the HTML of the application.
 * You can't interact with hidden elements without making them un-hidden.
 * WebDriver aims to emulate user interaction - so the API reflects the ways a user can interact with various elements. Triggering a specific event cannot be achieved directly using the API.
 * Since a user cannot read text in a hidden element, WebDriver will not allow access to it as well.

 * Advanced User Interactions API?
 * [[blocking]] Blocking API （如果某個操作會造成 page reload，會自動等到 onload 時才回來，所以只要專注下一個操作即可）, implicit waiting
 * 看不到的可以讀取，但不能操作。
 * 不能直接引發 JavaScript events。
 * 取得 driver 時 session 就建立了，不需要像 Selenium 1/RC 一樣呼叫 `start()`。

WebDriver 會儘可能從 OS level 發出 native event，這跟過去 Selenium 1.0 用 JavaScript 模擬出使用者行為的做法大不相同。

WebDriver (object-oriented) API 支援 Python、Ruby、Java 及 C# 這些 binding，分別由熟悉不同語言特性的開發人員設計，所以 API 用起來不會覺得不順手。

最主要的兩個操作介面是 `WebDriver` 跟 `WebElement`，前者代表 browser instance 本身，而後者則代表畫面上的某個 element。

理論上透過 WebDriver API 操作不同的 browser 的方式相同，最大的差異應該是開啟 browser 的部份。常見的操作有：

 * link:form.html[處理表單的內容]
 * link:locate.html[定位操作的目標]

object-oriented，設計更貼近不同 languages 的慣用方式（善用不同語言的特性），所以差異可能很大，尤其是開啟 browsers 的方式？

 * link:python/python.html[Python]
 * link:java/java.html[Java]

但有些概念是相通的，雖然各 language bindings 詮釋的方式不同：

 * WebDriver
 * WebElement
 * link:desired-capabilities.html[Desired Capabilities]

== 延伸閱讀 ==

 * link:drivers/drivers.html[Drivers]

== 參考資料 ==

.文件
--
 * http://selenium.googlecode.com/svn/trunk/docs/api/py/index.html[Introduction — Selenium 2.0 documentation]
 * http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html[Selenium Documentation > Migrating From Selenium RC to Selenium WebDriver > Why Migrate to WebDriver] ^http://diigo.com/0w2vb[閱讀]^
--

