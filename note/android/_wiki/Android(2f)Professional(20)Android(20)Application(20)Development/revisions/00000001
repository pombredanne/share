= Professional Android Application Development =
http://www.wrox.com/WileyCDA/WroxTitle/Professional-Android-Application-Development.productCd-0470344717.html
<<TableOfContents>>

== Introduction ==

Now is an exciting time for mobile developers. Mobile phones have never been more popular, and powerful smartphones are now a regular choice for consumers. Stylish(時髦的) and versatile(多功能的) phones packing hardware features like GPS, accelerometers(加速計), and touch screens are an enticing(誘人的) platform upon which to create innovative mobile applications.

__Android hardware will be designed to tempt(引誘) consumers, but the real win is for developers. With existing mobile development built on proprietary operating systems that restrict third-party applications, Android offers an open and equal alternative.__ Without ''artificial barriers'', Android developers are free to write applications that take full advantage of increasingly powerful mobile hardware. As a result, developer interest in Android devices has made their 2008 release a hugely anticipated(預期的) mobile technology event.

Built on an open source framework, and featuring powerful SDK libraries and an ''open philosophy'', Android has opened mobile phone development to thousands of developers who haven’t had access to tools for building mobile applications. Experienced mobile developers can now expand into the Android platform, leveraging the unique features to enhance existing products or create innovative new ones.

__This book is a hands-on guide to building mobile applications using version 1.0 of the Android software development kit.__ Chapter by chapter, it takes you through a series of sample projects, each introducing new features and techniques to get the most out of Android. It covers all the basic functionality as well as exploring the advanced features through concise(簡潔的) and useful examples.

__Since Android is a brand-new, version 1 product, there are only a small number of handsets currently available that support it. As with any early release, there are likely to be regular changes and improvements to the software and development libraries.__ The explanations and examples included in this book will give the grounding(基礎) and knowledge you need to write compelling mobile applications using the current SDK, along with the flexibility to quickly adapt to future enhancements.

=== Whom This Book Is For ===

This book is for anyone interested in creating applications for the Android mobile phone platform. It includes information that will be valuable, whether you’re an experienced mobile developer or making your first foray(開創性的嘗試), via Android, into writing mobile applications.

It will help if readers have used mobile phones (particularly phones running Android), but it’s not necessary, nor is prior experience in mobile phone development. It’s expected that you’ll have some experience in software development and be familiar with basic development practices. __While knowledge of Java is helpful, it’s not a necessity.__

Chapters 1 and 2 introduce mobile development and contain instructions to get you started in Android. Beyond that, there’s no requirement to read the chapters in order, although a good understanding of the core components described in Chapters 3 through 6 is important before you venture into(冒然進入) the remaining chapters. Chapters 7 through 11 cover a variety of optional and advanced functionality and can be read in whatever order interest or need dictates(要求).

=== What This Book Covers ===

Chapter 1 introduces Android, including what it is and how it fits into existing mobile development. What Android offers as a development platform and why it’s an exciting opportunity for creating mobile phone applications are then examined in greater detail.

Chapter 2 covers some best practices for mobile development and explains how to download the Android SDK and start developing applications. It also introduces the Android developer tools and demonstrates how to create new applications from scratch.

Chapters 3 through 6 take an in-depth look at the fundamental Android application components. Starting with examining the pieces that make up an Android application and its ''life cycle'', you’ll quickly move on to the ''application manifest'' and ''external resources'' before learning about “Activities,” their lifetimes, and their life cycles.

You’ll then learn how to create User Interfaces with ''layouts'' and ''Views'', before being introduced to the ''Intent mechanism'' used to perform actions and send messages between application components. Internet resources are then covered before a detailed look at ''data storage'', retrieval, and sharing. You’ll start with the ''preference-saving mechanism'' before moving on to file handling and databases. This section finishes with a look at sharing application data using ''Content Providers''.

Chapters 7 to 10 look at more advanced topics. Starting with maps and ''location-based services'', you’ll move on to Services, background Threads, and using Notifications.

__Android’s communication abilities are next, including sending and receiving messages through instant messaging and SMS. Hardware is then covered, starting with media recording and playback, before introducing the camera, accelerometers, and ''compass(指南針)'' sensors. Chapter 10 concludes with a look at phone and networking hardware, starting with telephony APIs and going on to Bluetooth and network management (both Wi-Fi and mobile data connections; '''其中 Bluetooth 的通訊能力與各式各樣的 sensors, 看起來好像很適合拿來與 Lego NXT 綁在一起做開發[...]''').__

Chapter 11 includes several advanced development topics, among them security, IPC, advanced graphics techniques, and user–hardware interactions.

=== How This Book Is Structured ===

This book is structured in a logical sequence to help readers of different development backgrounds learn how to write advanced Android applications.

There’s no requirement to read each chapter sequentially, but several of the sample projects are developed over the course of several chapters, adding new functionality and other enhancements at each stage.

Experienced mobile developers with a working Android development environment can skim the first two chapters — which are an introduction to mobile development and instructions for creating your development environment — and dive in at Chapters 3 to 6. These cover the fundamentals of Android development, so it’s important to have a solid understanding of the concepts they describe. With this covered, you can move on to the remaining chapters, which look at maps, location-based Services, background applications, and more advanced topics such as hardware interaction and netwoking.

=== What You Need to Use This Book ===

To use the code samples in this book, you will need to create an Android development environment by downloading the Android SDK libraries and developer tools and the Java development kit. You may also wish to download and install Eclipse and the Android Developer Tool plug-in to ease your development, but neither is a requirement.

__Android development is supported in Windows, MacOS, and Linux, with the SDK available from the Android web site.__

You do not need an Android device to use this book or develop Android applications.

Chapter 2 outlines these requirements in more detail as well as describing where to download and how to install each component.

== Chapter 1. Hello, Android ==

Whether you’re an experienced mobile engineer, a desktop or web developer, or a complete programming novice, Android represents an exciting new opportunity to write innovative applications for mobile devices.

Despite the name, Android will not help you create an unstoppable army(軍團) of emotionless(沒有情感的) robot warriors(戰士) on a relentless(冷酷的) quest to cleanse the earth of the scourge(災難) of humanity. __Instead, Android is an open source ''software stack'' that includes the operating system, ''middleware'', and key applications along with a set of API libraries for writing mobile applications that can shape(塑造) the look, feel, and function of mobile handsets. (這裡的 Android 指的是 "人形機器人", 而一般我們所說的 Robot 指的單純只是 "自動機械" 而已)__

Small, stylish, and versatile, modern mobile phones have become powerful tools that incorporate cameras, media players, GPS systems, and touch screens. __As technology has evolved, mobile devices have become about more than simply making calls, but their software and development platforms have ''struggled to keep pace''.__

__Until recently, mobile phones were largely ''closed'' environments built on proprietary operating systems that required proprietary development tools. The phones themselves often ''prioritized(優先考慮)'' native applications over those written by third parties. This has introduced an artificial barrier for developers hoping to build on increasingly powerful mobile hardware.__

__'''In Android, ''native'' and third-party applications are written using the same APIs and executed on the same run time.'''__ These APIs feature hardware access, location-based services, support for background services, map-based activities, relational databases, ''interdevice peer-to-peer messaging'', and 2D and 3D graphics.

Using this book, you will learn how to use these APIs to create your own Android applications. In this chapter, you’ll learn some mobile development guidelines and be introduced to the features available from the Android development platform.

__Android has powerful APIs, excellent documentation, a thriving(興旺的) developer community, and ''no development or distribution costs''. As mobile devices continue to increase in popularity, this is an exciting opportunity to create innovative mobile phone applications no matter what your development background.__

=== A Little Background ===

In the days before Twitter and Facebook, when Google was still a twinkle(閃爍) in its founders’ eyes and dinosaurs roamed(閒逛) the earth, mobile phones were just that — portable phones small enough to fit inside a briefcase(公事包), featuring batteries that could last up to several hours; they offered the freedom to make calls without being physically connected to a landline.

Increasingly small, stylish, and powerful mobile phones are now as ubiquitous as they are indispensable(不可缺少的). Hardware advancements(提升) have made mobiles smaller and more efficient while including an increasing number of peripherals(外圍設備).

__Beginning with cameras and media players, mobiles now include GPS systems, accelerometers, and touch screens. While these hardware innovations should prove fertile(豐富的) ground for software development, the applications available for mobile phones have generally ''lagged behind the hardware''. (一直以來軟體總是落後於硬體的發展, 在 PC/NB 上也是如此...)__

==== The Not So Distant Past ====

__Historically, developers, generally coding in low-level C or C++, have needed to understand the specific hardware they were coding for, generally a single device or possibly a range of devices from a single manufacturer. As hardware technology has advanced, this ''closed approach'' has struggled to keep pace.__

More recently, platforms like Symbian have been created to provide developers a wider target audience. These systems have proved more successful in encouraging mobile developers to provide rich applications that better leverage the hardware available.

These platforms offer some access to the device hardware, but require writing complex C/C++ code and making heavy use of proprietary APIs that are notoriously difficult to use. This difficulty is amplified when developing applications that must work on different hardware implementations and is particularly true when developing for a particular hardware feature like GPS.

__雖然 Symbian 被 Nokia 買走後, 2008/07 左右開始決定開放源碼, 但看起來 Symbian 本身還是有許多開發上的問題存在... http://www.openfoundry.org/index.php?option=com_content&Itemid=345&id=1652&lang=en&task=view[這裡]提到: Symbian 現在的高安裝率雖然是優勢, 但同時也將 Symbian 平台開發鎖死在過時 API 上, 就像微軟在 Vista 與 XP 相容性面臨的難題.__

__In recent years, the biggest advance(進展) in mobile phone development has been the introduction of Java-hosted MIDlets. MIDlets are executed on a Java virtual machine, abstracting the underlying hardware and letting developers create applications that run on the wide variety of hardware that supports the Java run time. '''Unfortunately, this convenience comes at the price of ''restricted access to the device hardware''.'''__

In mobile development, it’s considered normal for third-party applications to receive different hardware access and execution rights compared to native applications written by the phone manufacturers, with MIDlets often receiving few of either.

__The introduction of Java MIDlets has expanded developers’ audiences, but the lack of low-level hardware access and ''sandboxed execution'' have meant that '''most mobile applications are desktop programs designed to run on a smaller screen rather than take advantage of the inherent mobility of the handheld platform.'''__

==== The Future ====

Android sits alongside a new wave of mobile operating systems designed for increasingly powerful mobile hardware. Windows Mobile and Apple’s iPhone now provide a richer, simplified development environment for mobile applications. __However, unlike Android, they’re built on proprietary operating systems that often prioritize native applications over those created by third parties and '''restrict communication among applications and native phone data. (這就是上面所說的 "artificial barrier")''' Android offers new possibilities for mobile applications by offering an open development environment built on an open source Linux kernel. Hardware access is available to all applications through a series of API libraries, and application interaction, while ''carefully controlled'', is fully supported.__

__In Android, all applications have ''equal standing''. Third-party and native Android applications are written using the same APIs and are executed on the same run time. '''Users can remove and replace any native application with a third-party developer alternative; even the dialer and home screens can be replaced. (印證了一開始作者所說的 "the real win is for developers"!!)'''__

=== What It Isn’t ===

As a disruptive(造成混亂的) addition to a mature field, it’s not hard to see why there has been some confusion about what exactly Android is. Android is not:

 * A Java ME implementation - __'''Android applications are written using the Java language, but they are not run within a Java ME virtual machine, and Java-compiled classes and executables will not run natively in Android. (只用到 "語言" 的部份而已; 這對開發者的影響不大, 因為一直以來 Java 開發者早就習慣在不同的 implementations 之間切換...)'''__

 * Part of the Linux Phone Standards Forum (LiPS) or the Open Mobile Alliance (OMA) - Android runs on an open source Linux kernel, but, while their goals are similar, Android’s complete software stack approach goes further than the focus of these ''standards-defining'' organizations.

 * __Simply an ''application layer'' (like UIQ or S60) - While it does include an application layer, “Android” also describes the entire software stack encompassing the underlying operating system, API libraries, and the applications themselves. (可以參考 Understanding the Android Software Stack 一節, application layer 只是其中的一環而已)__

 * A mobile phone handset - __Android includes a ''reference design'' for mobile handset manufacturers, but unlike the iPhone, there is no single “Android Phone.” Instead, '''Android has been designed to support many alternative hardware devices. (這完全符合 Java 的精神)'''__

 * Google’s answer to the iPhone - The iPhone is a fully proprietary hardware and software platform released by a single company (Apple), while __Android is an open source software stack produced(推出) and supported by the Open Handset Alliance and designed to operate on ''any handset that meets the requirements''. There’s been a lot of speculation(推測) regarding a Google-branded Android phone, but even should Google produce one, it will be just one company’s hardware implementation of the Android platform. (一再地強調 Android 只是一個規格, 沒有限定任何實作方式)__

=== An Open Platform for Mobile Development ===

Google describes Android as:

 The first truly open and comprehensive platform for mobile devices, all of the software to run a mobile phone but without the proprietary obstacles(障礙) that have hindered(妨礙) mobile innovation. http://googleblog.blogspot.com/2007/11/wheres-my-gphone.html

Android is made up of several necessary and dependent (= optional) parts including the following:

 * __'''A hardware ''reference design'' that describes the capabilities required of a mobile device in order to support the software stack (這裡的 "software stack" 可以把它視為 API - 實作細節並不重要, 重要的是要實現 API 對開發人員的承諾)'''__

 * A Linux operating system kernel that provides the low-level interface with the hardware, memory management, and process control, all optimized for mobile devices (因此所有的 Android 手機一定都是跑 Linux OS)

 * __Open source libraries for application development including http://www.sqlite.org/[SQLite], http://webkit.org/[WebKit], http://www.opengl.org/[OpenGL], and a media manager (不只規格本身開放, 連 API libraries 也是開發源碼的)__

 * __A run time used to execute and ''host'' Android applications, including the http://en.wikipedia.org/wiki/Dalvik_virtual_machine[Dalvik] virtual machine and the core libraries that provide Android specific functionality. The run time is designed to be small and efficient for use on mobile devices.__

 * __An ''application framework'' that agnostically(不可知論地) exposes system services to the ''application layer'', including the window manager, content providers, location manager, telephony, and ''peer-to-peer'' services__

 * __A ''user interface framework'' used to host and launch applications__

 * Preinstalled applications (= key applications) shipped as part of the stack

 * A software development kit used to create applications, including the tools, plug-ins, and documentation

__At this stage, not all of the Android stack has been released as open source, although this is expected to happen by the time phones are released to market. It’s also worth noting that '''the applications you develop for Android do not have to be open source. (平台本身要開放, 但商業上還是要能賺錢才有搞頭...)'''__

What really makes Android compelling is its open philosophy, which ensures that any deficiencies(缺陷) in user interface or native application design can be fixed by writing an extension or ''replacement''. __Android provides you, as a developer, the opportunity to create mobile phone interfaces and applications designed to look, feel, and function exactly as you image them. (呼應上面 "shape" 的說法, 可以創造出一支完完全全屬於自己的手機!!)__

=== Native Android Applications ===

Android phones will normally come with a suite of preinstalled applications including, but not limited to: (從這裡內建許多 Google 網路應用程式, 就可以看出它的意圖, 不過還是強調 "not limited to"...)

 * An e-mail client compatible with Gmail but not limited to it

 * An SMS management application

 * A full PIM (personal information management) suite including a calendar and contacts list, both tightly integrated with Google’s online services

 * __A fully featured mobile Google Maps application including StreetView, business finder, driving directions, satellite view, and traffic conditions__

 * A WebKit-based web browser

 * An Instant Messaging Client

 * A music player and picture viewer

 * __The http://www.android.com/market/[Android Marketplace] client for downloading thied-party Android applications. (商業模型)__

 * The Amazon MP3 store client for purchasing ''DRM free'' music.

__'''All the native applications are written in Java using the Android SDK and are run on Dalvik. (這一句話充份說明了 Java/SDK/Dalvik 三者之間的關係)'''__

__The data stored and used by the native applications — like contact details — are also available to thirdparty applications. Similarly, your applications can handle events such as an incoming call or a new SMS message.__

__'''The exact makeup of the applications available on new Android phones is likely to vary based on the hardware manufacturer and/or the phone carrier(營運商) or distributor(經銷商).''' This is especially true in the United States, where carriers have significant influence on the software included on shipped devices.__

=== Android SDK Features ===

The true appeal of Android as a development environment lies in the APIs it provides.

As an ''application-neutral'' platform, Android gives you the opportunity to create applications that are as much a part of the phone as anything provided out of the box. The following list highlights some of the most noteworthy Android features:

 * No licensing, distribution, or development fees

 * Wi-Fi hardware access

 * GSM, EDGE, and 3G networks for telephony or data transfer, allowing you to make or receive calls or SMS messages, or to send and retrieve data across mobile networks

 * Comprehensive APIs for location-based services such as GPS

 * __Full multimedia hardware control including playback and recording using the camera and microphone (有機會改寫成實用的錄音筆[...])__

 * APIs for accelerometer and compass hardware

 * IPC message passing

 * Shared data stores

 * An integrated open source WebKit-based browser

 * Full support for applications that integrate Map controls as part of their user interface

 * __Peer-to-peer (P2P) support using Google Talk__

 * Mobile-optimized hardware-accelerated graphics including a path-based 2D graphics library and support for 3D graphics using http://www.khronos.org/opengles/[OpenGL ES]

 * Media libraries for playing and recording a variety of audio/video or still(靜態的) image formats

 * __'''An application framework that encourages ''reuse'' of application components and the ''replacement'' of native applications'''__

==== Access to Hardware including Camera, GPS, and Accelerometer ====

Android includes API libraries to simplify development involving the device hardware. These ensure that you don’t need to create specific implementations of your software for different devices, so you can create Android applications that work as expected on any device that supports the Android software stack.

__The Android SDK includes APIs for location-based hardware (such as GPS), camera, network connections, Wi-Fi, Bluetooth, accelerometers, touch screen, and power management. (對照官網在 http://code.google.com/android/what-is-android.html[What is Android?] 中 GPS/Camera/Bluetooth 等都是 "hardware dependent" 的說法, 雖然不知道它明確的意義為何? 但至少可以確認 - 設備不一定提供這些週邊, 但如果有的話就一定能透過標準的 API 做存取[...])__ You can explore the possibilities of some of Android’s hardware APIs in more detail in Chapter 10.

==== Native Google Maps, Geocoding, and Location-Based Services ====

Native map support lets you create a range of map-based applications that leverage the mobility of Android devices. Android lets you create activities that include interactive Google Maps as part of your user interface with full access to maps that you can control programmatically and ''annotate'' using Android’s rich graphics library.

__Android’s location-based services manage technologies like GPS and Google’s GSM cell-based location technology to determine the device’s current position. '''These services enforce an abstraction from specific location-detecting technology and let you specify minimum requirements (e.g., accuracy or cost) rather than choosing a particular technology.''' It also means that your location-based applications will work no matter what technology the ''host handset'' supports.__

__To ''combine maps with locations'', Android includes an API for forward and reverse ''geocoding(地理編碼)'' that lets you find map coordinates for an address, and the address of a map position. '''(這說明了 location-based 與 map-based 是兩種不同的應用, 前者指的是經緯度, 後者則是更容易理解的街道編號)'''__

You’ll learn the details of using maps, the ''geocoder'', and location-based services in Chapter 7.

==== Background Services ====

Android supports applications and ''services'' designed to run invisibly in the background.

__Modern mobiles are by nature multifunction devices; however, their limited screen size means that generally only one interactive application can be visible at any time. Platforms that don’t support ''background execution'' limit the viability of applications that don’t need your ''constant attention''.__

__Background services make it possible to create invisible application components that perform automatic processing without direct user action. '''Background execution allows your applications to become ''event-driven'' and to support ''regular updates'',''' which is perfect for monitoring game scores or market prices, generating location-based ''alerts'', or prioritizing and ''pre-screening'' incoming calls and SMS messages.__

Learn more about how to get the most out of background services in Chapter 8.

==== SQLite Database for Data Storage and Retrieval ====

Rapid and efficient data storage and retrieval are essential for a device whose storage capacity is limited by its compact nature.

Android provides a lightweight relational database for each application using SQLite. Your applications can take advantage of the managed relational database engine to store data securely and efficiently.

__'''By default, each application database is ''sandboxed'' — its content is available only to the application that created it — but Content Providers supply a mechanism for the managed sharing of these application databases.'''__

Databases, Content Providers, and other ''data persistence options'' available in Android are covered in detail in Chapter 6.

==== Shared Data and Interapplication Communication ====

Android includes three techniques for transmitting information from your applications for use elsewhere: Notifications, Intents, and Content Providers.

__Notifications are the standard ways in which a mobile device traditionally alerts users. Using the API, you can trigger audible(聽得見的) alerts, cause vibration(震動), and flash the device’s LED, as well as control ''status bar'' notification icons as shown in Chapter 8.__

__Intents(意圖) provide a mechanism for message passing within and between applications. Using Intents, you can broadcast a desired ''action'' (such as dialing the phone or editing a contact) system-wide for other applications to handle. (這聽起來跟事件處理機制很像[...])__ Intents are an important core component of Android and are covered in depth in Chapter 5.

__Finally, Content Providers are a way to give ''managed access'' to your application’s private database. The data stores for native applications, such as the Contact Manager, are exposed as Content Providers so you can create your own applications that read or modify these data stores.__ Chapter 6 covers Content Providers in detail, including the ''native providers'' and demonstrating how to create and use providers of your own.

==== P2P Services with Google Talk ====

Based on earlier SDK versions, it’s expected that in later releases you will once again be able to send ''structured messages'' (非 instant messaging 而言) from your application to any other Android mobile using Android’s peer-to-peer (P2P) communications service.

__The Android P2P service uses a ''specialized version'' of http://xmpp.org/[XMPP] (Extensible Messaging and Presence Protocol). Based on Google’s Google Talk instant messaging service, it creates a ''persistent socket connection'' between your device and any other online Android handset that ensures communication with low latency(傳輸延遲時間) and rapid response times.__

__When made available, you’ll be able to use the Google Talk service for conventional instant messaging, '''or an interface to send data between application instances on separate devices. (這真是太妙了!! Google Talk 已經搖身成為設備之間交換資料的平台... 這裡的 "Talk" 不再單純是指人與人之間的對話, 也可能是 "程式與程式之間的對話"...)''' This is strong sauce(增加趣味的東西) for creating interactive applications that involve multiple users, such as real-time multiplayer games or social applications.__

The P2P service also offers ''presence notification'', which is used to see if a contact is online. While the P2P service is very attractive in itself, it also plays very well with other Android features. __Imagine a background service that transmits locations between friends and a corresponding mapping application that displays these locations or alerts you when friends are nearby. (無限的可能...)__

Owing to(由於) security concerns, sending data messages with Google Talk isn’t possible in Android 1.0. An instant messaging client is available, and it’s expected that XMPP-compatible IM and data messaging will be made available to developers in a future SDK release. (呼應一開始 "based on earlier SDK versions..." 的說法)

==== Extensive Media Support and 2D/3D Graphics ====

Bigger screens and brighter, higher-resolution displays have helped make mobiles multimedia devices. To make the most of the hardware available, Android provides graphics libraries for 2D ''canvas drawing'' and 3D graphics with OpenGL.

Android also offers comprehensive libraries for handling still images, video, and audio files including the MPEG4, http://en.wikipedia.org/wiki/H.264[H.264], MP3, AAC, AMR, JPG, PNG, and GIF formats.

2D and 3D graphics are covered in depth in Chapter 11, while Android media management libraries are covered in Chapter 10.

==== Optimized Memory and Process Management ====

__Android’s process and memory management is a little unusual. Like Java and .NET, Android uses its own run time and virtual machine to manage application memory. Unlike either of these frameworks, the Android run time also manages the process lifetimes. '''Android ensures application responsiveness by stopping and killing processes as necessary to free resources for higher-priority applications. (這對需要跟使用者直接互動的程式而言是很重要的設計, 但為什麼 Java 與 .NET 都沒有納入考量?)'''__

__'''In this context, priority is determined depending on the application with which the user is interacting. (依使用者的操作情形, 自動調整 priority 而言)''' Ensuring that your applications are prepared for a ''swift(迅速的) death'' (呼應下面 "silent assassin" 的說法) but are still able to remain responsive and update or restart in the background if necessary, is an important consideration in an environment that does not allow applications to control their own lifetimes.__

You will learn more about the Android application life cycle in Chapter 3.

=== Introducing the Open Handset Alliance ===

The http://www.openhandsetalliance.com/[Open Handset Alliance] (OHA) is a collection of more than 30 technology http://www.openhandsetalliance.com/oha_members.html[companies] (獨缺 Nokia, 因為它想以開放的 Symbian 跟 Android 力拼) including hardware manufacturers, mobile carriers, and software developers. Of particular note are the prominent(著名的) mobile technology companies Motorola, HTC(宏達電), http://www.t-mobile.com/[T-Mobile], and Qualcomm. In their own words, the OHA represents:

 A commitment to openness, a shared vision for the future, and concrete plans to make the vision a reality. To accelerate innovation in mobile and offer consumers a richer, less expensive, and better mobile experience. http://www.openhandsetalliance.com/oha_faq.html

__The OHA hopes to deliver a better mobile software experience for consumers by providing the platform needed for innovative mobile development at a faster rate and a higher quality without licensing fees for software developers or handset manufacturers.__

__Ultimately the success of Android as a mobile platform will depend largely on the success of OHA partners in releasing desirable handsets and mobile services that encourage the widespread adoption of Android phones. Developers meanwhile have the opportunity to create innovative new mobile applications for Android to encourage more mobile technology companies to become part of the OHA. (市場要把它做大, 但革命尚未成功...)__

=== What Does Android Run On? ===

__The first Android mobile handset, the http://www.t-mobileg1.com/[T-Mobile G1] (事實上 T-Mobile 是電信公司, HTC 才是手機的製造商), was released in the US in October 2008 and in the UK in November 2008. The Open Handset Alliance has further committed to deploying additional handsets and services that support Android early in 2009.__

Rather than a mobile OS created for a single hardware implementation, Android is designed to support a large variety of hardware platforms, from touch-screen phones to devices with ''no screens'' at all.

Beyond that, with no licensing fees or proprietary software, the cost to handset manufacturers for providing Android-compatible variations of their handsets is comparatively(相對地) low. It’s hoped that once demand for hardware capable of running popular Android applications reaches a ''critical mass(臨界質量)'', more device manufacturers will produce increasingly tailored hardware to meet that demand.

=== Why Develop for Android? ===

If you have a background in mobile application development, you don’t need me to tell you that:

 * A lot of what you can do with Android is already possible.
 * But doing it is painful.

Android represents a clean break(徹底的改變), a mobile framework based on the reality of modern mobile devices.

With a simple and powerful SDK, no licensing fees, excellent documentation, and a thriving developer community, Android is an excellent opportunity to create software that changes how and why people use their mobile phones.

__Android is backed by more than 30 OHA members and is surrounded by significant industry buzz.__

__In market terms, the growth in portable devices is a worldwide phenomenon(現象), with mobile-phone ownership outstripping(超前) computer ownership in many countries. The increasing popularity of smartphones — multifunction devices including a phone but featuring cameras, Internet access, media players, Wi-Fi, and GPS services — combined with the increasing availability of mobile broadband and Wi-Fi has created a growth market for advanced mobile applications.__

==== What Will Drive Android Adoption? ====

__'''Android is targeted primarily at developers, with Google and the OHA betting(確信) that the way to deliver better mobile software to consumers is by making it easier for developers to write it themselves. (或許手機製造商也漸漸地體認到, 唯有殺手級的應用才能刺激手機的銷售...)'''__

As a development platform, Android is powerful and intuitive, letting developers who have never programmed for mobile devices create useful applications quickly and easily. It’s easy to see how innovative Android applications could create demand for the devices necessary to run them, particularly if developers write applications for Android because they can’t write them for other platforms. (但程式設計師不就被綁死在 Android 平台上了?)

__Open access to the nuts and bolts(具體細節) of the underlying system is what’s always driven software development and platform adoption.__ The Internet’s inherent openness and neutrality have seen it become the platform for a multi-billion-dollar industry within 10 years of its inception(開端). Before that, it was open systems like Linux and the powerful APIs provided as part of the Windows operating system that enabled the explosion in personal computers and the movement of computer programming from the arcane(晦澀難解的) to the mainstream.

This openness and power ensure that anyone with the inclination(傾向) can bring a vision to life at minimal cost. So far, that’s not been the case for mobile phones, and that’s why there are so few good mobile phone applications and fewer still available for free.

__Corporations will also be attracted to Android for the level of control it offers. By using a ''popular enterprise programming language'' in Java, no licensing fees, and offering the level of access and control users demand, Android offers an excellent enterprise platform. '''(或許是因為在各個領域 Java 都是最受歡迎的語言的關係, 所以 Android 才會採用 Java 做為開發專用的語言; 按 http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html[TIOBE] 於 2009/01 的調查, Java 仍然是最受歡迎的程式語言, 其次是 C)'''__

==== What Does It Have That Others Don’t? ====

Many of the features listed previously, such as 3D graphics and ''native database support'', are also available in other mobile SDKs. Here are some of the unique features that set Android apart:

 * Google Map Applications - __Google Maps for Mobile has been hugely popular, and Android offers a Google Map as an atomic(不可分割的), reusable control for use in your applications.__ The `MapView` widget lets you display, manipulate, and annotate a Google Map within your Activities to build map-based applications using the familiar Google Maps interface.

 * Background Services and Applications - Background services let you create applications that use an ''event-driven model'', working silently while other applications are being used or while your mobile sits ignored until it rings, flashes, or vibrates to get your attention. __Maybe it’s an application that tracks the stock market, alerting you to significant changes in your portfolio(投資組合), or a service that changes your ring tone or volume depending on your current location, the time of day, and the identity of the caller.__

 * Shared Data and Interprocess Communication - Using Intents and Content Providers, Android lets your applications exchange messages, perform processing, and share data. You can also use these mechanisms to leverage the data and functionality provided by the native Android applications. __To mitigate(緩和) the risks of such an open strategy, each application’s process, data storage, and files are private unless explicitly shared with other applications using a full ''permission-based security mechanism''__ detailed in Chapter 11.

 * All Applications Are Created Equal - __Android doesn’t differentiate between native applications and those developed by third parties. This gives consumers unprecedented(空前的) power to change the look and feel of their devices by letting them completely replace every native application with a third-party alternative that has access to the same underlying data and hardware. '''Every rule needs an exception and this one has two. The “unlock” and “in-call experience” screens can not be replaced in the initial SDK release.'''__

 * P2P Interdevice Application Messaging - Android offers peer-to-peer messaging that supports presence, instant messaging, and ''interdevice/interapplication communication''.

==== Changing the Mobile Development Landscape ====

__Existing mobile development platforms have created an aura(氣息) of exclusivity(排他性) around mobile development. Whether by design or as a side-effect of the cost or complexity involved in developing native applications, most mobile phones will remain nearly identical to what they were when first unwrapped. (沒有新意!!)__

__In contrast, Android allows, even encourages, radical(徹底的) change. As consumer devices, Android handsets ship with a core set of standard applications that consumers demand on a new phone, '''but the real power lies in the ability for users to completely change how their device looks, feels, and functions. (未來手機客製化的市場會變得很大[...])'''__

__Android gives developers a great opportunity. All Android applications are a ''native part'' of the phone, not just software that’s run in a sandbox on top of it. '''Rather than writing small-screen versions of software that can be run on low-power devices, you can now write mobile applications that change the way people use their phones.'''__

While Android will still have to compete with existing and future mobile development platforms as an open source developer framework, the strength of use of the development environment is strongly in its favor. Certainly its free and open approach to mobile application development, with ''total access'' to the phone’s resources, is a giant(巨大的) step in the right direction.

=== Introducing the Development Framework ===

With the PR(公關; public relations) job done, it’s time to look at how you can start developing applications for Android. __Android applications are written using Java as a programming language but are executed using a custom virtual machine called Dalvik rather than a traditional Java VM. '''(嚴格來說 Dalvik 並不能稱做 Java VM, 因為它在執行期是讀取由 `.class` 檔進一步加工出來的 `.dex` 檔, 而非我們所認知的 bytecode...)'''__

Later in this chapter, you’ll be introduced to the framework, starting with a technical explanation of the Android software stack, a look at what’s included in the SDK, an introduction to the Android libraries, and a look at the Dalvik virtual machine.

__'''Each Android application runs in a separate process within its own http://www.dalvikvm.com[Dalvik] instance, relinquishing(讓出) all responsibility for memory and process management to the Android run time, which stops and kills processes as necessary to manage resources.'''__

__Dalvik and the Android run time sit on top of a Linux kernel that handles low-level hardware interaction including drivers and memory management, while a set of APIs provides access to all of the underlying services, features, and hardware.__

==== What Comes in the Box ====

The Android software development kit (SDK) includes everything you need to start developing, testing, and debugging Android applications. Included in the SDK download are:

 * The Android APIs - __The core of the SDK is the Android API libraries that provide developer access to the Android stack. These are the same libraries used at Google to create native Android applications.__

 * Development Tools - To ''turn'' Android source code into executable Android applications, the SDK includes several development tools that let you compile and debug your applications. You will learn more about the developer tools in Chapter 2.

 * __The Android Emulator - The Android Emulator is a fully interactive Android device emulator featuring several alternative skins. Using the emulator, you can see how your applications will look and behave on a real Android device. '''All Android applications run within the Dalvik VM so that the software emulator is an excellent environment — in fact, as it is hardware-neutral, it provides a better independent test environment than any single hardware implementation. (從這個角度來看, 日前有人成功地將 Android 運行在 Notebook 上就不足為奇了; 由於 Android 是衝著開發者而來, 因此模擬器的提供是很重要的一環, 有了 Dalvik VM 這一抽象層的幫助, 模擬器可以更容易地被實作出來...)'''__

 * Full Documentation - The SDK includes extensive ''code-level reference information'' detailing exactly what’s included in each package and class and how to use them. In addition to the code documentation, Android’s reference documentation explains how to get started and gives detailed explanations of the fundamentals behind Android development.

 * Sample Code - The Android SDK includes a selection of sample applications that demonstrate some of the possibilities available using Android, as well as simple programs that highlight how to use individual API features.

 * Online Support - Despite its relative youth, Android has generated a vibrant(活躍的) developer community. The Google Groups at http://code.google.com/android/groups.html are active forums of Android developers with regular input from the Android development team at Google.

__For those using the popular Eclipse IDE, Android has released a special plug-in that simplifies project creation and tightly integrates Eclipse with the Android Emulator and debugging tools.__ The features of the ADT plug-in are covered in more detail in Chapter 2.

==== Understanding the Android Software Stack ====

The Android software stack is composed of the elements shown in Figure 1-1 and described in further detail below it. __Put simply, a Linux kernel and a collection of C/C++ libraries are ''exposed'' through an application framework that provides services for, and management of, the run time and applications. (一層一層往上疊, 因此才會有 software stack 的說法)__

{{attachment:figure_1-1.png}} <<BR>> Figure 1-1

 * Linux Kernel - __Core services (including hardware drivers, process and memory management, security, network, and power management) are handled by a ''Linux 2.6 kernel''. The kernel also provides an ''abstraction layer'' between the hardware and the remainder of the stack.__

 * Libraries Running on top of the kernel, Android includes various C/C++ core libraries such as http://www.gnu.org/software/libc/[libc] and SSL, as well as:

   * A media library for playback of audio and video media

   * A ''Surface manager'' to provide display management

   * Graphics libraries that include http://sgl.sourceforge.net/[SGL] and OpenGL for 2D and 3D graphics

   * SQLite for native database support

   * SSL and WebKit for integrated web browser and Internet security

 * Android Run Time - What makes an Android phone an Android phone rather than a ''mobile Linux implementation'' is the Android run time. (從這一層開始才是 Android 專有的部份) Including the core libraries and the Dalvik virtual machine, the Android run time is the engine that powers your applications and, along with the libraries, forms the basis for the application framework.

   * Core Libraries - __While Android development is done in Java, Dalvik is not a Java VM. '''The core Android libraries provide most of the functionality available in the core Java libraries (包含那些東西[?]) as well as the Android-specific libraries.'''__

   * Dalvik Virtual Machine - __'''Dalvik is a register-based virtual machine that’s been optimized to ensure that a device can ''run multiple instances efficiently''. (這呼應了上面 "Each Android application runs in a separate process within its own Dalvik instance" 的說法)''' It relies on the Linux kernel for threading and low-level memory management.__

 * Application Framework - __The application framework provides the classes used to create Android applications. It also provides a ''generic abstraction'' for hardware access and manages the user interface and application resources.__

 * Application Layer - __All applications, both native and third party, are built on the application layer using the same API libraries. The application layer runs within the Android run time using the classes and services made available from the application framework.__

==== The Dalvik Virtual Machine ====

__One of the key elements of Android is the Dalvik virtual machine. Rather than use a traditional Java virtual machine (VM) such as Java ME (Java Mobile Edition), Android uses its own custom VM designed to ensure that ''multiple instances'' run efficiently on a single device.__

The Dalvik VM uses the device’s underlying Linux kernel to handle low-level functionality including security, threading, and process and memory management. __It’s also possible to write C/C++ applications that run directly on the underlying Linux OS. While you can do this, in most cases there’s no reason you should need to. (這並不違反官網 FAQ 所說的 - 目前並不支援用 C/C++ 來撰寫 Android 應用程式, 因為在 Android Runtime 的下層撰寫程式, 應該稱不上是 Android 應用程式吧?)__

This book focuses exclusively on writing applications that run within Dalvik. If your inclinations run toward exploring the Linux kernel and C/C++ underbelly of Android, modifying Dalvik, or otherwise tinkering(修補) with things under the hood, check out the Android Internals Google Group at http://groups.google.com/group/android-internals

__All Android hardware and system service access is managed using Dalvik as a middle tier. By using a VM to host application execution, developers have an abstraction layer that ensures they never have to worry about a particular hardware implementation.__

__'''The Dalvik VM executes Dalvik executable files, a format optimized to ensure ''minimal memory footprint''. The `.dex` executables are created by transforming Java language compiled classes using the tools supplied within the SDK.'''__ You’ll learn more about how to create Dalvik executables in the next chapter.

==== Android Application Architecture ====

__'''Android’s architecture encourages the concept of ''component reuse'',''' allowing you to publish and share activities, services, and data with other applications with access managed by the security restrictions you put in place.__

__The same mechanism that lets you produce a replacement contact manager or phone dialer can let you expose your application components to let other developers create new ''UI front ends'' and ''functionality extensions'', or otherwise build on them.__

The following application services are the architectural cornerstones(基石) of all Android applications, providing the framework you’ll be using for your own software:

 * Activity Manager - Controls the life cycle of your activities, including management of the ''activity stack'' described in Chapter 3.

 * Views - Are used to construct the user interfaces for your activities as described in Chapter 4.

 * Notification Manager - Provides a consistent and ''non-intrusive mechanism'' for signaling your users as described in Chapter 8.

 * Content Providers - Lets your applications share data between applications as described in Chapter 6.

 * Resource Manager - Supports ''non-code resources'' like strings and graphics to be ''externalized'' as shown in Chapter 3.

==== Android Libraries ====

Android offers a number of APIs for developing your applications. The following list of core APIs should provide an insight into what’s available; __all Android devices will offer support for at least these APIs: (可以推導出背後 hardware implementation 的最低要求...)__

 * `android.util` - The core utility package contains low-level classes like specialized containers, string formatters, and ''XML parsing'' utilities.

 * `android.os` - The operating system package provides access to basic operating system services like message passing, interprocess communication, clock functions, and debugging.

 * `android.graphics` - The graphics API supplies the low-level graphics classes that support canvases, colors, and drawing primitives, and lets you draw on canvases.

 * `android.text` - The text processing tools for displaying and parsing text.

 * `android.database` - Supplies the low-level classes required for handling ''cursors'' when working with databases.

 * `android.content` - The content API is used to manage data access and publishing by providing services for dealing with resources, content providers, and packages.

 * `android.view` - Views are the core user interface class. All user interface elements are constructed using a series of Views to provide the user interaction components.

 * `android.widget` - __Built on the View package, the widget classes are the “here’s one we created earlier” user-interface elements for you to use in your applications. They include lists, buttons, and layouts.__

 * `com.google.android.maps` - A high-level API that provides access to native map controls that you can use within your application. Includes the `MapView` control as well as the `Overlay` and `MapController` classes used to annotate and control your embedded maps.

 * `android.app` - __A high-level package that provides access to the ''application model''. The application package includes the Activity and Service APIs that form the basis for all your Android applications.__

 * `android.provider` - To ease developer access to certain standard Content Providers (such as the contacts database), the Provider package offers classes to provide access to ''standard databases'' included in all Android distributions.

 * `android.telephony` - __The telephony APIs give you the ability to directly interact with the device’s phone stack, letting you make, receive, and monitor phone calls, phone status, and SMS messages.__

 * `android.webkit` - The WebKit package features APIs for working with Web-based content, including a `WebView` control for embedding browsers in your activities and a cookie manager.

In addition to the Android APIs, the Android stack includes a set of C/C++ libraries that are exposed through the application framework. These libraries include:

 * OpenGL - The library used to support 3D graphics based on the Open GL ES 1.0 API
 * __http://www.freetype.org/[FreeType] - Support for bitmap and vector font rendering (字體則是來自於 http://en.wikipedia.org/wiki/Droid_(font)[Droid])__
 * SGL - The core library used to provide a 2D graphics engine
 * libc - The standard C library optimized for Linux-based embedded devices
 * SQLite - The lightweight relation database engine used to store application data
 * SSL - Support for using the Secure Sockets Layer cryptographic protocol for secure Internet communications

==== Advanced Android Libraries ====

The core libraries provide all the functionality you need to start creating applications for Android, but it won’t be long before you’re ready to delve into the advanced APIs that offer the really exciting functionality.

__Android hopes to target a wide range of mobile hardware, so be aware that the suitability and implementation of the following APIs will vary depending on the device upon which they are implemented.__

 * `android.location` - The location-based services API gives your applications access to the device’s current physical location. Location-based services provide generic access to location information using whatever ''position-fixing(定位) hardware'' or technology is available on the device.

 * `android.media` - The media APIs provide support for playback and recording of audio and video media files, including streamed media.

 * `android.opengl` - Android offers a powerful 3D rendering engine using the OpenGL ES API that you can use to create dynamic 3D user interfaces for your applications.

 * __`android.hardware` - '''Where available, the hardware API exposes ''sensor hardware'' including the camera, accelerometer, and compass sensors as shown in Chapter 10. (這與 NXT 的規劃實在太像了!!)'''__

 * `android.bluetooth`, `android.net.wifi`, and `android.telephony` - Android also provides low-level access to the hardware platform, including Bluetooth, Wi-Fi, and telephony hardware as shown in Chapter 10.

=== Summary ===

This chapter explained that despite significant advances in the hardware features available on modern mobile phones, the software available for them has lagged. __A lack of openness, hard-to-use development kits, and hardware-specific APIs have stifled(扼殺) innovation in mobile software.__

Android offers an opportunity for developers to create innovative software applications for mobile devices without the restrictions generally associated with the existing proprietary mobile development frameworks.

You were shown the complete Android software stack, which includes not only an application layer and development toolkit but also the Dalvik VM, a custom runtime, core libraries, and a Linux kernel; all of which will be available as open source.

__The Open Handset Alliance was introduced along with the responsibility that developers — as the primary target audience for Android — have to create applications that will make consumers want Android phones on which to run them.__

You also learned:

 * How handsets with an expanding range of hardware features have created demand for tools that give developers better access to these features.

 * About some of the features available to developers using Android, including peer-to-peer messaging, native map support, hardware access, background services, interprocess and interdevice messaging, shared databases, and 2D and 3D graphics.

 * That all Android applications are built equal, allowing users to completely replace one application with another, including the replacement of the core native applications.

 * That the Android SDK includes developer tools, APIs, and comprehensive documentation.

The next chapter will help you get started by downloading and installing the Android SDK and setting up an Android development environment in Eclipse.

You’ll also learn how to use the Android developer tools plug-in to streamline development, testing, and debugging before creating your first Android application.

After learning about the building blocks of Android applications, you’ll be introduced to the different types of applications you can create, and __you’ll start to understand some of the ''design considerations'' that should go into developing applications for mobile devices.__

== Chapter 2. Getting Started ==

All you need to start writing your own Android applications is a copy of the Android SDK and the Java development kit. Unless you’re a masochist(被虐待狂), you’ll probably want a Java IDE — Eclipse is particularly well supported — to make development a little easier.

Versions of the SDK, Java, and Eclipse are available for Windows, Mac OS, and Linux, so you can explore Android from the comfort of whatever OS you favor. __The SDK includes an emulator for all three OS environments, and because Android applications are run on a virtual machine, there’s no advantage to developing from any particular operating system.__

__Android code is written using ''Java syntax'', and the core Android libraries include most of the features from the core Java APIs. Before they can be run, though, your projects are first translated into ''Dalvik byte code''. '''As a result, you get the benefits of using Java, while your applications have the advantage of running on a virtual machine optimized for Android devices. (下面 Be Efficient 一節說明了為何 efficiency 這麼重要, 甚至要把 Java ME VM 換掉...)'''__

The SDK download includes all the Android libraries, full documentation, and excellent sample applications. It also includes tools to help you write and debug your applications, like the Android Emulator to run your projects and the ''Dalvik Debug Monitoring Service'' (DDMS) to help debug them.

By the end of this chapter, you’ll have downloaded the Android SDK, set up your development environment, completed two new applications, and run and debugged them using the emulator and DDMS.

__If you’ve developed for mobile devices before, you already know that their ''small-form factor'', limited power, and restricted memory create some unique design challenges. '''Even if you’re new to the game, it’s obvious that some of the things you can take for granted(認為理所當然) on the desktop or the Web aren’t going to work on a mobile.'''__

__As well as the hardware limitations, the user environment brings its own challenges. Mobile devices are used on the move and are often a distraction(分心) rather than the focus of attention, so your applications need to be fast, responsive, and easy to use.__

This chapter examines some of the best practices for writing mobile applications to help overcome the inherent hardware and environmental challenges. Rather than try to tackle(對付) the whole topic, we’ll focus on using the Android SDK in a way that’s consistent with good ''mobile design principles''.

=== Developing for Android ===

The Android SDK includes all the tools and APIs you need to write compelling and powerful mobile applications. The biggest challenge with Android, as with any new development toolkit, is learning the features and limitations of its APIs.

__If you have experience in Java development, you’ll find that the techniques, syntax, and grammar you’ve been using will translate directly into Android, although some of the specific optimization techniques may seem counterintuitive(違反直覺的).__

If you don’t have experience with Java but have used other object-oriented languages (such as C#), you should find the transition straightforward. __The power of Android comes from its APIs, not from Java, so being unfamiliar with all the Java specific classes won’t be a big disadvantage.__

==== What You Need to Begin ====

Because Android applications run within the Dalvik virtual machine, you can write them on any platform that supports the developer tools. This currently includes the following:

 * Microsoft Windows (XP or Vista)
 * Mac OS X 10.4.8 or later (Intel chips only)
 * Linux

To get started, you’ll need to download and install the following:

 * The Android SDK
 * Java Development Kit (JDK) 5 or 6

You can download the latest JDK from Sun at http://java.sun.com/javase/downloads/index.jsp If you already have a JDK installed, make sure that it meets the version requirements listed above, and note that the Java runtime environment (JRE) is not sufficient.

===== Downloading and Installing the SDK =====

__The Android SDK is completely open. There’s no cost to download and use the API, and Google doesn’t charge to allow distribution of your finished programs.__ You can download the latest version of the SDK for your development platform from the Android development home page at http://code.google.com/android/download.html __Unless otherwise noted, the version of the Android SDK used for writing this book was version 1.0 r1. (目前 @2009/01/17 最新版已經來到 1.0 Release 2, 大小約 90 MB, 解開後約 241 MB)__

The SDK is presented as a ZIP file containing the API libraries, developer tools, documentation, and several sample applications and API demos that highlight the use of particular API features. Install it by unzipping the SDK into a new folder. (Take note of this location, as you’ll need it later.)

__The examples and step-by-step instructions provided are targeted at developers using Eclipse with the Android Developer Tool (ADT) plug-in. (顯然官方是鼓勵使用 IDE 的)__ Neither is required, though — you can use any text editor or Java IDE you’re comfortable with and use the developer tools in the SDK to compile, test, and debug the code snippets and sample applications.

If you’re planning to use them, the next sections explain how to set up Eclipse and the ADT plug-in as your Android development environment. Later in the chapter, we’ll also take a closer look at the developer tools that come with the SDK, so if you’d prefer to develop without using Eclipse or the ADT plugin, you’ll particularly want to check that out.

The examples included in the SDK are well documented and are an excellent source for full, working examples of applications written for Android. Once you’ve finished setting up your development environment, it’s worth going through them.

===== Developing with Eclipse =====

Using Eclipse with the ADT plug-in for your Android development offers some significant advantages.

Eclipse is an open source IDE (integrated development environment) particularly popular for Java development. It’s available to download for each of the development platforms supported by Android (Windows, Mac OS, and Linux) from the Eclipse foundation homepage: http://www.eclipse.org/downloads/

There are many variations available when selecting your Eclipse download; the following is the recommended ''configuration'' for Android:

 * Eclipse 3.3, 3.4 (Ganymede)
 * Eclipse JDT plug-in
 * WST

WST and the JDT plug-in are included in most Eclipse IDE packages.

Installing Eclipse consists of uncompressing the download into a new folder. When that’s done, run the Eclipse executable. When it starts for the first time, create a new workspace for your Android development.

===== Using the Eclipse Plug-in =====

The ADT plug-in for Eclipse simplifies your Android development by integrating the developer tools, including the emulator and ''.class-to-.dex converter'', directly into the IDE. While you don’t have to use the ADT plug-in, it does make creating, testing, and debugging your applications faster and easier.

The ADT plug-in integrates the following into Eclipse:

 * An Android Project Wizard that simplifies creating new projects and includes a basic ''application template''

 * __Forms-based manifest, layout, and resource editors to help create, edit, and validate your XML resources__

 * __Automated building of Android projects, conversion to Android executables (`.dex`), packaging to package files (`.apk`), and installation of packages onto Dalvik virtual machines__

 * __'''The Android Emulator, including control of the emulator’s appearance, network connection settings, and the ability to simulate incoming calls and SMS messages'''__

 * __The Dalvik Debug Monitoring Service (DDMS), which includes ''port forwarding''; stack, heap, and thread viewing; process details; and screen capture facilities '''(它並不能取代 Eclipse 內建的 Debug Perspective, 事實上它是用來幫助測試、監控狀態的 "控制台"... 工具相當的齊全!!)'''__

 * Access to the device or emulator’s filesystem, allowing you to navigate the folder tree and transfer files

 * Runtime debugging, so you can set breakpoints and view call stacks

 * All Android/Dalvik log and console outputs

Figure 2-1 shows the DDMS perspective within Eclipse with the ADT plug-in installed.

{{attachment:figure_2-1.png}} <<BR>> Figure 2-1

====== Installing the ADT Plug-in ======

Install the developer tools plug-in by the following steps:

 1. Select Help > Software Updates > Find and Install... from within Eclipse.

 2. In the resulting dialog box, choose Search for new features to install.

 3. Select New Remote Site, and enter the following address into the dialog box, as shown in Figure 2-2: https://dl-ssl.google.com/android/eclipse/

    .{{attachment:figure_2-2.png}} <<BR>> Figure 2-2

 4. The new site you entered should now be checked. Click Finish.

 5. Eclipse will now download the plug-in. When it’s finished, select Android Plugin > Developer Tools from the resulting Search Results dialog box, and click Next. (按http://code.google.com/android/intro/installing.html#installingplugin[官網]的說法, 在 Eclipse 3.4 下除了 "Android Developer Tools" 外, 也建議一起安裝 "Android Editors")

 6. Read and then Accept the terms of the license agreement, and click Next and then Finish. As the ADT plug-in is not signed, you’ll be prompted before the installation continues.

 7. When complete, you’ll have to restart Eclipse and update the ADT preferences. Restart and select Window > Preferences... (or Eclipse > Preferences for the Mac OS).

 8. Then select Android from the left panel.

 9. Click Browse..., and navigate to the folder into which you unzipped the Android SDK, as shown in Figure 2-3; then click Apply and OK.

    .{{attachment:figure_2-3.png}} <<BR>> Figure 2-3

If you download a new version of the SDK and place it in a different location, you will need to update this preference to reflect the SDK with which the ADT should be building.

====== Updating the Plug-in ======

As the Android SDK matures, there are likely to be frequent updates to the ADT plug-in. In most cases, to update your plug-in, you simply:

 1. Navigate to Help > Software Updates > Find and Install …
 2. Select Search for updates of the currently installed features, and click Finish...
 3. If there are any ADT updates available, they will be presented. Simply select them and choose Install.

Sometimes a plug-in upgrade is so significant that the dynamic update mechanism can’t be used. In those cases, you may have to remove the previous plug-in completely before installing the newer version as described in the previous section.

==== Creating Your First Android Activity ====

You’ve downloaded the SDK, installed Eclipse, and plugged in the plug-in. You’re now ready to start programming for Android. Start by creating a new project and setting up your Eclipse run and debug configurations.

===== Starting a New Android Project =====

To create a new Android project using the Android New Project Wizard:

 1. Select File > New > Project.

 2. Select the Android Project application type from the Android folder, and click Finish.

 3. In the dialog that appears (shown in Figure 2-4), enter the details for your new project. The “Project name” is the name of your project file; the “Package name” specifies its package; __the “Activity name” is the name of the class that is your ''initial Activity''; and the “Application name” is the friendly name for your application.__

    .{{attachment:figure_2-4.png}} <<BR>> Figure 2-4 (範例 Project name 為 "Hello World", Package name 為 "com.paad.helloworld", Activity name 為 "HelloWorld", Application name 為 "Hello World")

 4. When you’ve entered the details, click Finish. The ADT plug-in then creates a new project that includes a new class that extends `Activity`. Rather than being completely empty, the default template implements “Hello World.” Before modifying the project, take this opportunity to configure run and debug launch configurations.

===== Creating a Launch Configuration =====

Launch configurations let you specify runtime options for running and debugging applications. Using a launch configuration you can specify the following:

 * The Project and Activity to launch
 * The emulator options to use
 * Input/output settings (including console defaults)

You can specify different launch configurations for Run and Debug modes. The following steps show how to create a launch configuration for an Android application:

 1. Select Run > Open Run Dialog... (or Run > Open Debug Dialog...).

 2. Right-click Android Application on the project type list, and select New.

 3. Enter a name for the configuration. You can create multiple configurations for each project, so create a descriptive title that will help you identify this particular setup.

 4. Now choose your start-up options. The first (Android) tab lets you select the project and Activity that you want to start when you run (or debug) the application. Figure 2-5 shows the settings for the project you created earlier.

    .{{attachment:figure_2-5.png}} <<BR>> Figure 2-5

 5. __Use the Target tab to configure the emulator. There are options to choose the screen size, device skin, and network connection settings. You can also optionally wipe(抹掉) the user data on the emulator and enable or disable the start-up animation. Using the command-line textbox, you can specify additional emulator start-up options if needed.__

 6. Finally, set any additional properties in the Common tab.

 7. Click Apply, and your launch configuration will be saved.

===== Running and Debugging Your Android Applications =====

You’ve created your first project and created the run and debug configurations for it. Before making any changes, test your installation and configurations by running and debugging the Hello World project.

From the Run menu, select Run or Debug to launch the most recently selected configuration, or select Open Run Dialog... or Open Debug Dialog... to select a configuration to use.

If you’re using the ADT plug-in, running or debugging your application:

 * Compiles the current project and converts it to an Android executable (`.dex`).
 * Packages the executable and external resources into an Android package (`.apk`).
 * Starts the emulator (if it’s not already running; 不知道為什麼關機要 40 秒? 而且 CPU 持續在 60% 以上[?]).
 * Installs your application onto the emulator.
 * Starts your application.

If you’re debugging, the Eclipse debugger will then be attached, allowing you to set breakpoints and debug your code.

If everything is working correctly, you’ll see a new `Activity` running in the emulator, as shown in Figure 2-6.

{{attachment:figure_2-6.png}} <<BR>> Figure 2-6

===== Understanding Hello World =====

With that confirmed, let’s take a step back and have a real look at your first Android application.

__`Activity` is the base class for the visual, interactive components of your application; it is roughly equivalent to a ''Form'' in traditional desktop development. '''(這裡的 Activity 指的是一個 screen/dialog, 而 View 則是 screen/dialog 裡面組成的控制項)'''__ The following snippet shows the ''skeleton code'' for an Activity-based class; note that it extends `Activity`, overriding the `onCreate` method.

 {{{
package com.paad.helloworld;

import android.app.Activity;
import android.os.Bundle;

public class HelloWorld extends Activity {

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
  }

}
 }}}

What’s missing from this template is the ''layout'' of the visual interface. __In Android, visual components are called ''Views'', which are similar to ''controls'' in traditional desktop development.__

In the Hello World template created by the wizard, the `onCreate` method is overridden to call `setContentView`, which lays out the user interface by inflating(使膨脹[?]) a layout resource, as highlighted below:

 {{{
@Override
public void onCreate(Bundle icicle) {
  super.onCreate(icicle);
  setContentView(R.layout.main);
}
 }}}

__The resources for an Android project are stored in the `res` folder of your project hierarchy, which includes `drawable`, `layout`, and `values` subfolders. The ADT plug-in interprets these ''XML resources'' to provide ''design time access'' to them through the `R` variable as described in Chapter 3. (透過下面 `findViewById` 的實驗, 就可以發現 `R.java` 是由 ADT plug-in 自動依 XML resources 動態產生的...)__

The following code snippet shows the UI layout defined in the `main.xml` file created by the Android project template:

 {{{
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical"
  android:layout_width="fill_parent"
  android:layout_height="fill_parent">
  <TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="Hello World, HelloWorld"
  />
</LinearLayout>
 }}}

__'''Defining your UI in XML and inflating it is the preferred way of implementing your user interfaces, as it neatly(乾淨地) decouples your application logic from your UI design. (符合 declarative UI 的設計潮流)'''__

__To get access to your UI elements in code, you add ''identifier attributes'' to them in the XML definition. You can then use the `findViewById` method to return a reference to each named item.__ The following XML snippet shows an ID attribute added to the `TextView` widget in the Hello World template:

 {{{
<TextView
  android:id="@+id/myTextView"
  android:layout_width="fill_parent"
  android:layout_height="wrap_content"
  android:text="Hello World, HelloWorld"
/>
 }}}

And the following snippet shows how to get access to it in code: (修改 `main.xml` 加入 `android:id` 的宣告之後, `R.java` 就會由 ADT plug-in 自動更新)

 {{{
TextView myTextView = (TextView)findViewById(R.id.myTextView);
 }}}

Alternatively (although it’s not considered good practice), if you need to, you can create your layout directly in code as shown below:

 {{{
public void onCreate(Bundle icicle) {
  super.onCreate(icicle);

  LinearLayout.LayoutParams lp;
  lp = new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);

  LinearLayout.LayoutParams textViewLP;
  textViewLP = new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);

  LinearLayout ll = new LinearLayout(this);
  ll.setOrientation(LinearLayout.VERTICAL);
  TextView myTextView = new TextView(this);
  myTextView.setText("Hello World, HelloWorld");
  ll.addView(myTextView, textViewLP);
  this.addContentView(ll, lp);
}
 }}}

__All the properties available in code can be set with attributes in the ''XML layout''. As well as allowing easier substitution of layout designs and individual UI elements, keeping the visual design decoupled from the application code helps keep the code more concise.__

The Android web site (http://code.google.com/android/documentation.html) includes several excellent step-by-step guides that demonstrate many of the features and good practices you will be using as an Android developer. They’re easy to follow and give a good idea of how Android applications ''fit together''.

==== Types of Android Applications ====

Most of the applications you create in Android will fall into one of the following categories:

 * Foreground Activity - __An application that’s only useful when it’s in the foreground and is effectively(實際上) ''suspended'' when it’s not visible. Games and map mashups are common examples.__

 * Background Service - An application with limited interaction that, apart from when being configured, spends most of its lifetime hidden. Examples of this include ''call screening'' applications or ''SMS auto-responders''.

 * Intermittent(間歇性的) Activity - __Expects some interactivity but does most of its work in the background. Often these applications will be set up and then run silently, notifying users when appropriate. A common example would be a media player.__

__Complex applications are difficult to pigeonhole(分類) into a single category and include elements of all three. When creating your application, you need to consider how it’s likely to be used and then design it accordingly.__ Let’s look more closely at some of the design considerations for each application type described above.

===== Foreground Activities =====

__When creating foreground applications, you need to consider the Activity life cycle (described in Chapter 3) carefully so that the Activity switches seamlessly between the foreground and the background. '''(這裡點出了 foreground/activity 或 background/service 兩者間並沒有必然的對應關係, 事實上它指的是 foreground/background execution, 跟 UI 上 active/visible 等概念是無關的...)'''__

__'''Applications have no control over their life cycles, and a backgrounded application, with no Services, is a prime(最先的) candidate for cleanup by Android’s ''resource management''.''' This means that you need to save the state of the application when the Activity becomes invisible, and present the exact same state when it returns to the foreground.__

It’s also particularly important for foreground Activities to present a slick(靈活地) and intuitive user experience.

You’ll learn more about creating ''well-behaved'' and attractive foreground Activities in Chapter 3.

===== Background Services =====

__These applications run silently in the background with very little user input. They often listen for messages or ''actions'' caused by the hardware, system, or other applications, rather than rely on user interaction.__

__'''It’s possible to create completely invisible services, but in practice, it’s better form to provide at least some sort of user control.''' At a minimum, you should let users confirm that the service is running and let them configure, pause, or terminate it as needed.__

Services, the powerhouse(動力室) of background applications, are covered in depth in Chapter 8.

====== Intermittent Activities ======

__Often you’ll want to create an application that reacts to user input but is still useful when it’s not the active foreground Activity. These applications are generally a union(合而為一) of a visible controller Activity with an invisible background Service.__

__These applications need to be aware of their state when interacting with the user. This might mean updating the Activity UI when it’s visible and sending notifications to keep the user updated when it’s in the background,__ as seen in the section on Notifications and Services in Chapter 8.

=== Developing for Mobile Devices ===

__'''Android does a lot to simplify mobile-device software development, but it’s still important to understand the reasons behind the ''conventions''. (這讓我想起 Better Builds with Maven: The How-to Guide for Maven 2.0 一書中 1.2.1. Convention Over Configuration 的論點[...])'''__ There are several factors to account for when writing software for mobile and embedded devices, and when developing for Android, in particular.

In this chapter, you’ll learn some of the techniques and best practices for writing efficient Android code. In later examples, efficiency is sometimes compromised(妥協) for ''clarity(清楚)'' and ''brevity(簡潔)'' when introducing new Android concepts or functionality. In the best traditions of “Do as I say, not as I do,” the examples you’ll see are designed to show the simplest (or easiest-to-understand) way of doing something, not necessarily the best way of doing it. (範例是為了方便說明所設計的, 不一定是最好的寫法...)

==== Hardware-Imposed Design Considerations ====

Small and portable, mobile devices offer exciting opportunities for software development. Their limited screen size and reduced memory, storage, and processor power are far less exciting, and instead present some unique challenges.

Compared to desktop or notebook computers, mobile devices have relatively:

 * Low processing power
 * Limited RAM
 * Limited permanent storage capacity
 * Small screens with low resolution
 * Higher costs associated with data transfer
 * Slower data transfer rates with higher latency
 * Less reliable data connections
 * Limited battery life

__It’s important to keep these restrictions in mind when creating new applications.__

===== Be Efficient =====

__Manufacturers of embedded devices, particularly mobile devices, value(看重) small size and long battery life over potential improvements in processor speed. For developers, that means losing the head start(有利的開始) traditionally afforded thanks to Moore’s law. '''The yearly performance improvements you’ll see in desktop and server hardware usually translate into smaller, more power-efficient mobiles without much improvement in processor power. (這說明了為何要用 Dalvik VM 做為 runtime 的原因)'''__

__In practice, this means that you always need to optimize your code so that it runs quickly and responsively, assuming that hardware improvements over the lifetime of your software are unlikely to do you any favors(幫助).__

Since code efficiency is a big topic in software engineering, I’m not going to try and capture it here. This chapter covers some Android-specific efficiency tips below, but for now, just note that efficiency is particularly important for resource-constrained environments like mobile devices.

===== Expect Limited Capacity =====

Advances in flash memory and http://en.wikipedia.org/wiki/Solid-state_disk[solid-state disks(固態硬碟)] have led to a dramatic increase in mobile-device storage capacities (although people’s MP3 collections tend to expand to fill the available space). __In practice, most devices still offer relatively limited storage space for your applications. While the ''compiled size'' of your application is a consideration, more important is ensuring that your application is polite(有禮貌的) in its use of system resources. (應用程式產生的資料量才有大小的問題; 應用程式本身的大小通常不是問題, 重點在於運行的效率...)__

You should carefully consider how you store your ''application data''. To make life easier, you can use the Android databases and Content Providers to persist, reuse, and share large quantities of data, as described in Chapter 6. __For smaller data storage, such as ''preferences or state settings'', Android provides an optimized framework, as described in Chapter 6.__

__'''Of course, these mechanisms won’t stop you from writing directly to the filesystem when you want or need to, but in those circumstances, always consider how you’re structuring these files, and ensure that yours is an efficient solution.'''__

__Part of being polite is cleaning up after yourself. Techniques like ''caching'' are useful for limiting repetitive network lookups, but don’t leave files on the filesystem or records in a database when they’re no longer needed.__

===== Design for Small Screens =====

The small size and portability of mobiles are a challenge for creating good interfaces, particularly when users are demanding an increasingly striking(醒目的) and information-rich graphical user experience.

__Write your applications knowing that users will often only glance at the (small) screen. (也因此才會衍生出 foreground/background 的概念) Make your applications intuitive and easy to use by reducing the number of controls and putting the most important information front and center.__

__Graphical controls, like the ones you’ll create in Chapter 4, are an excellent way to convey(傳達) dense(密集的) information in an easy-to-understand way. Rather than a screen full of text with lots of buttons and text entry boxes, use colors, shapes, and graphics to display information.__

__If you’re planning to include touch-screen support (and if you’re not, you should be), you’ll need to consider how touch input is going to affect your interface design. '''The time of the stylus(尖筆) has passed; now it’s all about ''finger input'', so make sure your Views are ''big enough'' to support interaction using a finger on the screen.'''__ There’s more information on touch-screen interaction in Chapter 11.

__Of course, mobile-phone resolutions and screen sizes are increasing, so it’s smart to design for small screens, but also make sure your UIs scale.__

===== Expect Low Speeds, High Latency =====

In Chapter 5, you’ll learn how to use Internet resources in your applications. The ability to incorporate some of the wealth of online information in your applications is incredibly powerful.

__The mobile Web unfortunately isn’t as fast, reliable, or readily available as we’d often like, so when you’re developing your Internet-based applications, it’s best to assume that the network connection will be slow, intermittent, and expensive. With unlimited 3G data plans and city-wide Wi-Fi, this is changing, '''but designing for the worst case ensures that you always deliver a high-standard user experience.'''__

__This also means making sure that your applications can handle losing (or not finding) a data connection. The Android Emulator lets you control the speed and latency of your network connection when setting up an Eclipse launch configuration.__ Figure 2-7 shows the emulator’s network connection speed and latency set up to simulate a distinctly suboptimal(未達最佳標準的) EDGE connection.

{{attachment:figure_2-7.png}} <<BR>> Figure 2-7

__Experiment to ensure responsiveness no matter what the speed, latency, and availability of network access. You might find that in some circumstances, it’s better to limit the functionality of your application or reduce network lookups to cached bursts(爆炸[?]), based on the network connection(s) available.__ Details on how to detect the kind of network connections available at run time, and their speeds, are included in Chapter 10.

===== At What Cost? =====

If you’re a mobile owner, you know all too well that some of the more powerful features on your mobile can literally(不誇張地) come at a price. Services like SMS, GPS, and data transfer often incur an additional tariff from your ''service provider''.

__It’s obvious why it’s important that any costs associated with functionality in your applications are minimized, and that users are aware when an action they perform might result in them being charged.__

It’s a good approach to assume that there’s a cost associated with any action involving an interaction with the ''outside world''. Minimize interaction costs by the following:

 * Transferring as little data as possible
 * Caching data and GPS results to eliminate redundant or repetitive lookups
 * Stopping all data transfers and GPS updates when your activity is not visible in the foreground if they’re only being used to update the UI
 * Keeping the refresh/update rates for data transfers (and location lookups) as low as practicable
 * Scheduling ''big updates or transfers'' at “off peak” times(離峰時間) using alarms as shown in Chapter 8

Often the best solution is to use a lower-quality option that comes at a lower cost.

__When using the location-based services described in Chapter 7, you can select a ''location provider'' based on whether there is an associated cost. Within your location-based applications, consider giving users the choice of ''lower cost'' or ''greater accuracy''.__

In some circumstances, costs are hard to define, or they’re different for different users. Charges for services vary between service providers and user plans. While some people will have free unlimited data transfers, others will have free SMS.

Rather than enforcing a particular technique based on which seems cheaper, consider letting your users choose. For example, when downloading data from the Internet, you could ask users if they want to use any network available or limit their transfers to only when they’re connected via Wi-Fi.

==== Considering the Users’ Environment ====

You can’t assume that your users will think of your application as the most important feature of their phones.

__Generally, a mobile is first and foremost a phone, secondly an SMS and e-mail communicator, thirdly a camera, and fourthly an MP3 player. The applications you write will most likely be in a fifth category of “useful mobile tools.”__

That’s not a bad thing — it’s in good company with others including Google Maps and the web browser. That said, each user’s usage model will be different; some people will never use their mobiles to listen to music, and some phones don’t include a camera, but the multitasking principle inherent in a device as ubiquitous as it is indispensable(不可缺少的) is an important consideration for ''usability design''.

It’s also important to consider when and how your users will use your applications. People use their mobiles all the time — on the train, walking down the street, or even while driving their cars. __You can’t make people use their phones appropriately, but you can make sure that your applications don’t distract them any more than necessary.__

What does this mean in terms of software design? Make sure that your application:

 * Is well behaved - __Start by ensuring that your Activities suspend when they’re not in the foreground. Android triggers event handlers when your Activity is suspended or resumed so you can pause UI updates and network lookups when your application isn’t visible — there’s no point updating your UI if no one can see it. '''If you need to continue updating or processing in the background, Android provides a `Service` class designed to run in the background without the ''UI overheads''.'''__

 * Switches seamlessly from the background to the foreground - __With the ''multitasking nature'' of mobile devices, it’s very likely that your applications will regularly switch into and out of the background. When this happens, it’s important that they “come to life” quickly and seamlessly. '''Android’s ''nondeterministic(非確定的) process management'' means that if your application is in the background, there’s every chance it will get killed to free up resources. This should be invisible to the user. You can ensure this by saving the application state and ''queuing(排隊) updates'' so that your users don’t notice a difference between ''restarting'' and ''resuming'' your application. Switching back to it should be seamless with users being shown the exact UI and application state they last saw.'''__

 * Is polite - __Your application should never steal focus or interrupt a user’s current activity. Use Notifications and ''Toasts(吐司[?])'' (detailed in Chapter 8) instead to inform or remind users that their attention is requested if your application isn’t in the foreground.__ There are several ways for mobile devices to alert users. For example, when a call is coming in, your phone rings; when you have unread messages, the LED flashes; and when you have new voice mail, a small “mail” icon appears in your status bar. All these techniques and more are available through the ''notification mechanism''.

 * Presents a consistent user interface - Your application is likely to be one of several in use at any time, so it’s important that the UI you present is easy to use. Don’t force users to interpret and relearn your application every time they load it. Using it should be simple, easy, and obvious — particularly given the limited screen space and ''distracting(很容易分散注意力的) user environment''.

 * Is responsive - __'''Responsiveness is one of the most important design considerations on a mobile device. You’ve no doubt experienced the frustration(挫折) of a “frozen” piece of software; the multifunction nature of a mobile makes it even more annoying. (手機當機真的讓人很受不了!!)''' With possible delays due to slow and unreliable data connections, it’s important that your application use ''worker threads'' and background services to keep your activities responsive and, more importantly, stop them from preventing other applications from responding in a timely manner.__

==== Developing for Android ====

Nothing covered so far is specific to Android; the design considerations above are just as important when developing applications for any mobile. In addition to these general guidelines, Android has some particular considerations.

To start with, it’s worth taking a few minutes to read Google’s Android ''design philosophy'' at http://code.google.com/android/toolbox/philosophy.html.

The Android design philosophy demands(要求) that applications be:

 * Fast
 * Responsive
 * Secure
 * Seamless

===== Being Fast and Efficient =====

__In a resource-constrained environment, being fast means being efficient. '''A lot of what you already know about writing efficient code will be just as effective in Android, but the limitations of embedded systems and the use of the Dalvik VM mean you can’t take things for granted.'''__

The smart bet for advice is to go to the source. The Android team has published some specific guidance on writing efficient code for Android, so rather than rehash(重講) their advice, I suggest you visit http://code.google.com/android/toolbox/performance.html and take note of their suggestions.

__You may find that some of these performance suggestions contradict(違反) established design practices — for example, avoiding the use of internal setters and getters or preferring ''virtual(實質的)'' over interface. '''When writing software for resource-constrained systems like embedded devices, there’s often a compromise(妥協) between conventional design principles and the demand for greater efficiency. (別太執著於設計的理論, 隨著環境做調整才是相對務實的做法...)'''__

__One of the keys to writing efficient Android code is to not carry over assumptions from desktop and server environments to embedded devices.__

At a time when 2 to 4 GB of memory is standard for most desktop and server rigs(裝備), even advanced smartphones are lucky to feature 32 MB of RAM. With memory such a scarce(稀有的) commodity(日用品), you need to take special care to use it efficiently. __This means thinking about how you use the ''stack'' and ''heap'', limiting object creation, and being aware of how variable scope affects memory use. '''(透過撰寫 Android 應用程式的撰寫, 可以訓練自己寫出更有效率的程式... 寫桌面應用程式太久了, 常誤以為資源取之不盡、用之不竭, 直到應用程式變得很大時才發現效能很差, 這是一個很不好的現象[...])'''__

===== Being Responsive =====

Android takes responsiveness very seriously.

__Android enforces responsiveness with the Activity Manager and Window Manager. If either service detects an unresponsive application, it will display the unambiguous(明確的) ''Application unresponsive (AUR) message'', as shown in Figure 2-8.__

__This alert is modal, steals focus, and won’t go away until you hit a button or your application starts responding — it’s pretty much the last thing you ever want to confront(面對) a user with.__

Android monitors two conditions to determine responsiveness:

 * __'''An application must respond to any user action, such as a key press or screen touch, within 5 seconds.'''__
 * __A Broadcast Receiver must return from its `onReceive` handler within 10 seconds.__

{{attachment:figure_2-8.png}} <<BR>> Figure 2-8

__The most likely culprits(罪犯) for causing unresponsiveness are network lookups, complex processing (such as calculating game moves), and file I/O. There are a number of ways to ensure that these actions don’t exceed the responsiveness conditions, in particular, using ''services'' and ''worker threads'', as shown in Chapter 8. (這是寫任何 UI 應用程式都會遇到的問題...)__

__The AUR dialog is a ''last resort(手段)'' of usability; the generous(慷慨的) 5-second limit is a worst-case scenario, not a benchmark to aim for. '''Users will notice a regular pause of anything more than half a second between key press and action.''' Happily, a side effect of the efficient code you’re already writing will be faster, more responsive applications.__

===== Developing Secure Applications =====

Android applications have direct hardware access, can be distributed independently, and are built on an open source platform featuring open communication, so it’s not particularly surprising that security is a big concern.

__'''For the most part, users will take responsibility for what applications they install and what permissions they grant them. (通常使用者還是不知道要怎麼做決定[...])''' The Android security model restricts access to certain services and functionality by forcing applications to request permission before using them. During installation, users then decide if the application should be granted the permissions requested.__ You can learn more about Android’s security model in Chapter 11 and at http://code.google.com/android/devel/security.html.

__This doesn’t get you off the hook(擺脫困境). You not only need to make sure your application is secure for its own sake(爲了自己的利益), but you also need to ensure that it can’t be ''hijacked(劫持)'' to compromise the device.__ You can use several techniques to help maintain device security, and they’ll be covered in more detail as you learn the technologies involved. In particular, you should:

 * Consider requiring permissions for any services you create or ''broadcasts'' you transmit.

 * Take special care when accepting input to your application from external sources such as the Internet, SMS messages, or instant messaging (IM). You can find out more about using IM and SMS for application messaging in Chapter 9.

 * __Be cautious when your application may expose access to lower-level hardware.__

For reasons of clarity and simplicity, many of the examples in this book take a fairly relaxed approach to security. When creating your own applications, particularly ones you plan to distribute, this is an area that should not be overlooked. You can find out more about Android security in Chapter 11.

===== Ensuring a Seamless User Experience =====

__The idea of a ''seamless user experience'' is an important, if somewhat nebulous(模糊不清的), concept. What do we mean by seamless? The goal is a consistent user experience where applications start, stop, and ''transition(轉換)'' instantly and without noticeable delays or jarring(不和諧的) transitions. (這裡的 transition 指的正是 foreground/background 及 started/suspended/killed 等狀態的轉換)__

__The speed and responsiveness of a mobile device shouldn’t degrade(降低) the longer it’s on. '''Android’s process management helps by acting as a ''silent assassin(刺客)'', killing background applications to free resources as required.''' Knowing this, your applications should always present a consistent interface, regardless of whether they’re being ''restarted'' or ''resumed''.__

With an Android device typically running several third-party applications written by different developers, it’s particularly important that these applications interact seamlessly.

Use a consistent and intuitive approach to usability. You can still create applications that are revolutionary(革命性的) and unfamiliar, but even they should integrate cleanly with the wider Android environment.

__Persist data between ''sessions'', and suspend tasks that use ''processor cycles'', network bandwidth, or battery life when the application isn’t visible. If your application has processes that need to continue running while your activity is out of sight, use a Service, but hide these implementation decisions from your users.__

__When your application is brought back to the front, or restarted, it should seamlessly return to its last visible state. As far as your users are concerned, '''each application should be sitting silently ready to be used but just out of sight.'''__

You should also follow the best-practice guidelines for using Notifications and use generic UI elements and themes to maintain consistency between applications.

There are many other techniques you can use to ensure a seamless user experience, and you’ll be introduced to some of them as you discover more of the possibilities available in Android in the coming chapters.

=== To-Do List Example ===

In this example, you’ll be creating a new Android application from scratch. This simple example creates a new to-do list application using native Android View controls. It’s designed to illustrate the basic steps involved in starting a new project.

Don’t worry if you don’t understand everything that happens in this example. Some of the features used to create this application, including `ArrayAdapters`, `ListViews`, and `KeyListeners`, won’t be introduced properly until later chapters, where they’re explained in detail. You’ll also return to this example later to add new functionality as you learn more about Android.

 1. Start by creating a new Android project. Within Eclipse, select File > New > Project..., then choose Android (as shown in Figure 2-9) before clicking Next.

    .{{attachment:figure_2-9.png}} <<BR>> Figure 2-9

 2. In the dialog box that appears (shown in Figure 2-10), enter the details for your new project. The “Application name” is the friendly name of your application, and the “Activity name” is the name of your `Activity` subclass. With the details entered, click Finish to create your new project.

    .{{attachment:figure_2-10.png}} <<BR>> Figure 2-10 (範例 Project name 為 "Todo_List", Package name 為 "com.paad.todolist", Activity name 為 "ToDoList", Application name 為 "To Do List")

 3. Take this opportunity to set up debug and run configurations by selecting Run > Open Debug Dialog... and then Run > Open Run Dialog..., creating a new configuration for each, specifying the `Todo_List` project. You can leave the launch actions as Launch Default Activity or explicitly set them to launch the new `ToDoList` Activity, as shown in Figure 2-11.

    .{{attachment:figure_2-11.png}} <<BR>> Figure 2-11

 4. Now decide what you want to show the users and what actions they’ll need to perform. Design a user interface that will make this as intuitive as possible.

    .In this example, we want to present users with a list of to-do items and a text entry box to add new ones. There’s both a list and a text entry control (View) available from the Android libraries. You’ll learn more about the Views available in Android and how to create new ones in Chapter 4.

    .The preferred method for laying out your UI is using a layout resource file. Open the `main.xml` layout file in the `res/layout` project folder, as shown in Figure 2-12.

    .{{attachment:figure_2-12.png}} <<BR>> Figure 2-12

 5. Modify the main layout to include a `ListView` and an `EditText` within a `LinearLayout`. It’s important to give both the `EditText` and `ListView` controls IDs so you can get references to them in code.

    {{{
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical"
  android:layout_width="fill_parent"
  android:layout_height="fill_parent">
  <EditText
    android:id="@+id/myEditText"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="New To Do Item"
  />
  <ListView
    android:id="@+id/myListView"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
  />
</LinearLayout>
    }}}

 6. With your user interface defined, open the `ToDoList.java` `Activity` class from your project’s source folder. In this example, you’ll make all your changes by overriding the `onCreate` method. Start by inflating your UI using `setContentView` and then get references to the `ListView` and `EditText` using `findViewById`.

    {{{
public void onCreate(Bundle icicle) {
  // Inflate your view
  setContentView(R.layout.main);

  // Get references to UI widgets
  ListView myListView = (ListView)findViewById(R.id.myListView);
  final EditText myEditText = (EditText)findViewById(R.id.myEditText);
}
    }}}

 7. Still within `onCreate`, define an `ArrayList` of Strings to store each to-do list item. You can ''bind'' a `ListView` to an `ArrayList` using an `ArrayAdapter`, so create a new `ArrayAdapter` instance to bind the to-do item array to the `ListView`. We’ll return to `ArrayAdapters` in Chapter 5.

    {{{
public void onCreate(Bundle icicle) {
  setContentView(R.layout.main);

  ListView myListView = (ListView)findViewById(R.id.myListView);
  final EditText myEditText = (EditText)findViewById(R.id.myEditText);

  // Create the array list of to do items
  final ArrayList<String> todoItems = new ArrayList<String>();

  // Create the array adapter to bind the array to the listview
  final ArrayAdapter<String> aa;
  aa = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, todoItems);

  // Bind the array adapter to the listview.
  myListView.setAdapter(aa);
}
    }}}

 8. The final step to make this to-do list functional is to let users add new to-do items. Add an `onKeyListener` to the `EditText` that listens for a “D-pad center button” click before adding the contents of the `EditText` to the to-do list array and notifying the `ArrayAdapter` of the change. Then clear the `EditText` to prepare for another item.

    {{{
public void onCreate(Bundle icicle) {
  // 這裡一定要補上 super.onCreate(icicle) 才行 (), 否則手機會出現 "The application To Do List (process com.paad.todolist) has stopped unexpectedly. Please try again" 的錯誤訊息 @2009/01/31
  // 同時在 DDMS 下的 LogCat 也可以觀察到 "android.app.SuperNotCalledException: Activity {com.paad.todolist/com.paad.todolist.ToDoList} did not call through to super.onCreate()"
  super.onCreate(icicle);

  setContentView(R.layout.main);

  ListView myListView = (ListView)findViewById(R.id.myListView);
  final EditText myEditText = (EditText)findViewById(R.id.myEditText);

  final ArrayList<String> todoItems = new ArrayList<String>();
  final ArrayAdapter<String> aa;
  aa = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, todoItems);
  myListView.setAdapter(aa);

  myEditText.setOnKeyListener(new OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
      if (event.getAction() == KeyEvent.ACTION_DOWN)
        if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
          todoItems.add(0, myEditText.getText().toString());
          aa.notifyDataSetChanged();
          myEditText.setText("");
          return true;
        }

      return false;
    }
  });
}
    }}}

 9. Run or debug the application, and you’ll see a text entry box above a list, as shown in Figure 2-13.

    .{{attachment:figure_2-13.png}} <<BR>> Figure 2-13

 10. You’ve now finished your first “real” Android application. Try adding breakpoints to the code to test the debugger and experiment with the ''DDMS perspective''.

As it stands, this to-do list application isn’t spectacularly useful. It doesn’t save to-do list items between sessions, you can’t edit or remove an item from the list, and typical task list items like due dates and task priority aren’t recorded or displayed. On balance(總而言之), it fails most of the criteria laid out so far for a good mobile application design.

You’ll rectify(糾正) some of these deficiencies when you return to this example in later chapters.

=== Android Development Tools ===

The Android SDK includes several tools and utilities to help you create, test, and debug your projects. A detailed examination of each developer tool is outside the scope of this book, but it’s worth briefly reviewing what’s available. For more detail than is included here, check out the Android documentation at: http://code.google.com/android/intro/tools.html

As mentioned earlier, the ADT plug-in conveniently incorporates most of these tools into the Eclipse IDE, where you can access them from the DDMS perspective, including:

 * The Android Emulator - __An implementation of the Android virtual machine designed to run on your development computer.__ You can use the emulator to test and debug your android applications.

 * Dalvik Debug Monitoring Service (DDMS) - Use the DDMS perspective to ''monitor and control'' the Dalvik virtual machines on which you’re debugging your applications.

 * Android Asset Packaging Tool (AAPT) - Constructs the distributable Android package files (`.apk`).

 * Android Debug Bridge (ADB) - __The ADB is a client-server application that provides a link to a running emulator. It lets you copy files, install compiled application packages (`.apk`), and run shell commands.__

The following additional tools are also available:

 * SQLite3 - A database tool that you can use to access the SQLite database files created and used by Android

 * Traceview - Graphical analysis tool for viewing the ''trace logs'' from your Android application (跟 LogCat 不同, 但這是什麼[?])

 * MkSDCard - __Creates an SDCard disk image that can be used by the emulator to simulate an external storage card. (什麼東西都可以模擬!!)__

 * dx - Converts Java `.class` bytecode into Android `.dex` bytecode.

 * activityCreator - __Script that builds Ant build files that you can then use to compile your Android applications without the ADT plug-in__

Let’s take a look at some of the more important tools in more detail.

==== The Android Emulator ====

The emulator is the perfect tool for testing and debugging your applications, particularly if you don’t have a real device (or don’t want to risk it) for experimentation.

The emulator is an implementation of the Dalvik virtual machine, making it as valid a platform for running Android applications as any Android phone. __Because it’s decoupled from any particular hardware, it’s an excellent baseline to use for testing your applications.__

A number of alternative user interfaces are available to represent different hardware configurations, each with different screen sizes, resolutions, orientations, and hardware features to simulate a variety of mobile device types.

__Full network connectivity(連通性) is provided along with the ability to tweak the Internet connection speed and latency while debugging your applications. You can also simulate placing and receiving voice calls and SMS messages.__

The ADT plug-in integrates the emulator into Eclipse so that it’s launched automatically when you run or debug your projects. __If you aren’t using the plug-in or want to use the emulator outside of Eclipse, you can ''telnet into the emulator'' and control it from its console. (透過 ADB)__ For more details on controlling the emulator, check the documentation at http://code.google.com/android/reference/emulator.html.

__At this stage, the emulator doesn’t implement all the mobile hardware features supported by Android, including the camera, vibration, LEDs, actual phone calls, the accelerometer, USB connections, Bluetooth, audio capture, battery charge level, and SD card insertion/ejection. (未來應該都會提供吧[...])__

==== Dalvik Debug Monitor Service (DDMS) ====

The emulator lets you see how your application will look, behave, and interact, but to really see what’s happening under the surface, you need the DDMS. __The Dalvik Debug Monitoring Service is a powerful debugging tool that lets you interrogate(質問) active processes, view the stack and heap, watch and pause active threads, and explore the filesystem of any active emulator.__

The DDMS perspective in Eclipse also provides simplified access to screen captures of the emulator and the logs generated by LogCat.

If you’re using the ADT plug-in, the DDMS is fully integrated into Eclipse and is available from the DDMS perspective. If you aren’t using the plug-in or Eclipse, you can run DDMS from the command line, and it will automatically connect to any emulator that’s running.

==== The Android Debug Bridge (ADB) ====

__The Android debug bridge (ADB) is a ''client-service application'' that lets you connect with an Android Emulator or device. It’s made up of three components: a ''daemon'' running on the emulator (這裡 "daemon" 的說法源自於 Android 底層的 Linux), a service that runs on your development hardware, and client applications (like the DDMS) that communicate with the daemon through the service.__

__As a communications conduit(導管) between your development hardware and the Android device/emulator, the ADB lets you install applications, push and pull files, and run shell commands on the target device. Using the device shell, you can change logging settings, and query or modify SQLite databases available on the device.__

__The ADT tool automates and simplifies a lot of the usual interaction with the ADB, including application installation and update, log files, and file transfer (through the DDMS perspective; 使用 IDE 的開發人員, 平常很少有機會直接接觸到 ADB, 但它確實一直運作在底層...).__

To learn more about what you can do with the ADB, check out the documentation at http://code.google.com/android/reference/adb.html.

=== Summary ===

This chapter showed you how to download and install the Android SDK; create a development environment using Eclipse on Windows, Mac OS, or Linux platforms; and how to create run and debug configurations for your projects. You learned how to install and use the ADT plug-in to simplify creating new projects and streamline your development cycle.

__You were introduced to some of the design considerations for developing mobile applications, particularly the importance of optimizing for speed and efficiency when increasing battery life and shrinking sizes are higher priorities than increasing processor power.__

As with any mobile development, there are considerations when designing for small screens and mobile data connections that can be slow, costly, and unreliable.

After creating an Android to-do list application, you were introduced to the Android Emulator and the developer tools you’ll use to test and debug your applications.

Specifically in this chapter, you:

 * Downloaded and installed the Android SDK.
 * Set up a development environment in Eclipse and downloaded and installed the ADT plug-in.
 * Created your first application and learned how it works.
 * Set up run and debug launch configurations for your projects.
 * Learned about the different types of Android applications.
 * Were introduced to some mobile-device design considerations and learned some specific Android design practices.
 * Created a to-do list application.
 * Were introduced to the Android Emulator and the developer tools.

The next chapter focuses on Activities and application design. You’ll see how to define application settings using the Android manifest and how to externalize your UI layouts and application resources. You’ll also find out more about the Android application life cycle and Android application states.

== Chapter 3. Creating Applications and Activities ==

Before you start writing Android applications, it’s important to understand how they’re constructed and have an understanding of the Android application life cycle. __In this chapter, you’ll be introduced to the ''loosely coupled'' components that make up Android applications (and how they’re ''bound together'' using the Android manifest).__ Next you’ll see how and why you should use external resources, before getting an introduction to the Activity component.

In recent years, there’s been a move toward development frameworks featuring ''managed code'', such as the Java virtual machine and the .NET Common Language Runtime.

In Chapter 1, you learned that Android uses this model, with each application running in a separate process with its own instance of the Dalvik virtual machine. In this chapter, you’ll learn more about the application life cycle and how it’s managed by the Android run time. This will lead to an introduction of the process states that represent the application priority, which, in turn, determines the likelihood(可能) of an application’s being terminated when more resources are required.

Mobile devices now come in many shapes and sizes and are used internationally. In this chapter, you’ll learn how to give your applications the flexibility to run seamlessly on different hardware, in different countries, and using ''multiple languages'' by externalizing resources.

Next you’ll examine the Activity component. __Arguably(可論證的) the most important of the Android ''building blocks'', the `Activity` class forms the basis for all your user interface screens.__ You’ll learn how to create new Activities and gain an understanding of their life cycles and how they affect the application lifetime.

Finally, you’ll be introduced to some of the `Activity` subclasses that wrap up resource management for some common user interface components such as maps and lists.

=== What Makes an Android Application? ===

__'''Android applications consist of loosely coupled components, bound using a project manifest that describes each component and how they interact. (注意這裡 component 的用法, 不要跟將它侷限在 UI 的元件, 否則常常會將 component 誤認為就是 activity 而已...)'''__

There are six components that provide the building blocks for your applications:

 * Activities - __'''Your application’s ''presentation layer''. Every ''screen'' in your application will be an ''extension'' of the `Activity` class. Activities use Views to form graphical user interfaces that display information and respond to user actions.''' In terms of desktop development, an Activity is equivalent to a Form.__ You’ll learn more about Activities later in this chapter.

 * Services - __The ''invisible workers'' of your application. Service components run invisibly, updating your ''data sources'' and visible Activities and triggering Notifications. They’re used to perform ''regular processing'' that needs to continue even when your application’s Activities aren’t active or visible.__ You’ll learn how to create Services in Chapter 8.

 * Content Providers - __A ''shareable data store''. Content Providers are used to manage and share application databases. Content Providers are the preferred way of sharing data across ''application boundaries''.__ This means that you can configure your own Content Providers to permit access from other applications and use Content Providers exposed by others to access their stored data. Android devices include several native Content Providers that expose useful databases like contact information. You’ll learn how to create and use Content Providers in Chapter 6.

 * Intents - __A simple ''message-passing framework''. Using Intents, you can ''broadcast'' messages system-wide or to a target Activity or Service, stating your intention to have an action performed. The system will then determine the target(s) that will perform any actions as appropriate. (類似於一般的事件處理機制, 但它的範圍擴及整個系統, 搭配下面的 Broadcast Receivers 來實作...)__

 * Broadcast Receivers - __Intent broadcast consumers. By creating and registering a Broadcast Receiver, your application can listen for broadcast Intents that match specific ''filter criteria''. Broadcast Receivers will automatically start your application to respond to an incoming Intent, making them ideal for ''event-driven applications''.__

 * Notifications - A user notification framework. Notifications let you signal users without stealing focus or interrupting their current Activities. __They’re the preferred technique for getting a user’s attention from within a Service or Broadcast Receiver.__ For example, when a device receives a text message or an incoming call, it alerts you by flashing lights, making sounds, displaying icons, or showing dialog messages. You can trigger these same events from your own applications using Notifications, as shown in Chapter 8.

By decoupling the dependencies between application components, you can share and interchange individual pieces, such as Content Providers or Services, with other applications — both your own and those of third parties.

=== Introducing the Application Manifest ===

__Each Android project includes a manifest file, `AndroidManifest.xml`, stored in the root of the project hierarchy. The manifest lets you define the structure and ''metadata'' of your application and its components.__

It includes nodes for each of the components (Activities, Services, Content Providers, and Broadcast Receivers) that make up your application and, using Intent Filters and Permissions, determines how they interact with each other and other applications.

It also offers attributes to specify application metadata (like its icon or ''theme''), and additional top-level nodes can be used for security settings and ''unit tests'' as described below.

The manifest is made up of a root `manifest` tag with a `package` attribute set to the project’s package. It usually includes an `xmlns:android` attribute that supplies several system attributes used within the file. A typical manifest node is shown in the XML snippet below: (這裡的 default namespace 是什麼[?])

 {{{
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.my_domain.my_app">
  [ ... manifest nodes ... ]
</manifest>
 }}}

The `manifest` tag includes nodes that define the application components, security settings, and ''test classes''[?] that make up your application. The following list gives a summary of the available manifest node tags, and an XML snippet demonstrating how each one is used:

 * `application` - A manifest can contain only one `application` node. It uses attributes to specify the metadata for your application (including its `title`, `icon`, and `theme`). It also acts as a container that includes the Activity, Service, Content Provider, and Broadcast Receiver tags used to specify the application components.

   {{{
<application android:icon="@drawable/icon" android:theme="@style/my_theme">
  [ ... application nodes ... ]
</application>
   }}}

   * `activity` - An `activity` tag is required for every Activity displayed by your application, using the `android:name` attribute to specify the class name. __This must include the ''main launch Activity (= main screen)'' and any other screen or ''dialogs'' that can be displayed. Trying to start an Activity that’s not defined in the manifest will throw a runtime exception. Each Activity node supports `intent-filter` child tags that specify which Intents launch the Activity. (這跟下面的 `receiver` 作用有何不同? 由 receiver 收下來之後再觸發符合條件的 activities[?])__

     {{{
<activity android:name=".MyActivity" android:label="@string/app_name"> <-- MyActivity 前面的 "." 指的是什麼[?]
  <intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
</activity>
     }}}

   * `service` - As with the `activity` tag, create a new `service` tag for each Service class used in your application. (Services are covered in detail in Chapter 8.) Service tags also support `intent-filter` child tags to allow ''late runtime binding''.

     {{{
<service android:enabled="true" android:name=".MyService"></service>
     }}}

   * `provider` - Provider tags are used for each of your application’s Content Providers. Content Providers are used to manage database access and sharing within and between applications and are examined in Chapter 6.

     {{{
<provider android:permission="com.paad.MY_PERMISSION"
  android:name=".MyContentProvider"
  android:enabled="true"
  android:authorities="com.paad.myapp.MyContentProvider">
</provider>
     }}}

   * `receiver` - __By adding a `receiver` tag, you can register a Broadcast Receiver without having to launch your application first. As you’ll see in Chapter 5, '''Broadcast Receivers are like ''global event listeners'' that, once registered, will execute whenever a matching Intent is broadcast by an application.''' By registering a Broadcast Receiver in the manifest, you can make this process entirely autonomous(自主的). If a matching Intent is broadcast, your application will be started automatically and the registered Broadcast Receiver will be run.__

     {{{
<receiver android:enabled="true"
  android:label="My Broadcast Receiver"
  android:name=".MyBroadcastReceiver">
</receiver>
     }}}

 * `uses-permission` - __As part of the ''security model'', `uses-permission` tags declare the permissions you’ve determined that your application needs for it to operate properly. The permissions you include will be presented to the user, to grant or deny, during installation. Permissions are required for many of the native Android services, particularly those with a cost or security implication (such as dialing, receiving SMS, or using the location-based services).__ As shown in the item below, third-party applications, including your own, can also specify permissions before providing access to shared application components.
 
   {{{
<uses-permission android:name="android.permission.ACCESS_LOCATION">
</uses-permission>
   }}}

 * `permission` - __Before you can restrict access to an application component, you need to define a permission in the manifest. Use the `permission` tag to create these permission definitions. Application components can then require(要求) them by adding the `android:permission` attribute. '''Other applications will then need to include a `uses-permission` tag in their manifests (and have it granted) before they can use these protected components.'''__

   .Within the `permission` tag, you can specify the level of access the permission will permit (`normal`, `dangerous`, `signature`, `signatureOrSystem`), a label, and an external resource containing the description that explain the risks of granting this permission.

   {{{
<permission android:name="com.paad.DETONATE_DEVICE"
  android:protectionLevel="dangerous"
  android:label="Self Destruct"
  android:description="@string/detonate_description">
</permission>
   }}}

 * `instrumentation` - __Instrumentation(儀器) classes provide a framework for running tests on your Activities and Services at run time. They provide hooks to monitor your application and its interaction with the system resources.[?]__ Create a new node for each of the test classes you’ve created for your application.

   {{{
<instrumentation android:label="My Test"
  android:name=".MyTestClass"
  android:targetPackage="com.paad.aPackage">
</instrumentation>
   }}}

A more detailed description of the manifest and each of these nodes can be found at http://code.google.com/android/devel/bblocks-manifest.html

The ADT New Project Wizard automatically creates a new manifest file when it creates a new project.

You’ll return to the manifest as each of the application components is introduced.

=== Using the Manifest Editor ===

The ADT plug-in includes a visual Manifest Editor to manage your manifest, rather than your having to manipulate the underlying XML directly.

To use the Manifest Editor in Eclipse, right-click the `AndroidManifest.xml` file in your project folder, and select Open With > Android Manifest Editor. This presents the Android Manifest Overview screen, as shown in Figure 3-1. This gives you a high-level view of your application structure and provides shortcut links to the Application, Permissions, Instrumentation, and raw XML screens.

{{attachment:figure_3-1.png}} <<BR>> Figure 3-1

Each of the next three tabs contains a visual interface for managing the application, security, and instrumentation (testing) settings, while the last tag (using the manifest’s filename) gives access to the raw XML.

Of particular interest is the Application tab, shown in Figure 3-2. Use it to manage the application node and the ''application component hierarchy'', where you specify the application components.

{{attachment:figure_3-2.png}} <<BR>> Figure 3-2

You can specify an application’s attributes — including its Icon, Label, and Theme — in the Application Attributes panel. The Application Nodes tree beneath it lets you manage the application components, including their attributes and any associated Intent Filter subnodes.

=== The Android Application Life Cycle ===

__Unlike most traditional environments, Android applications have no control over their own life cycles. '''Instead, application components must listen for changes in the application state and react accordingly, taking particular care to be prepared for ''untimely(過早的) termination''.'''__

As mentioned before, by default, each Android application is run in its own process that’s running a separate instance of Dalvik. Memory and process management of each application is handled exclusively by the run time.

__While uncommon, '''it’s possible to force application components within the same application to run in different processes or to have multiple applications share the same process''' using the `android:process` attribute on the affected component nodes within the manifest.__

__Android aggressively(侵略地) manages its resources, doing whatever it takes to ensure that the device remains responsive. '''This means that processes (and their ''hosted applications'') will be killed, without warning if necessary, to free resources for higher-priority applications — generally those that are interacting directly with the user at the time. (要注意 kill 的單位是 process 而非 application, 因為一個 process 可以跑多個 applications; 但通常都是一個 application 對應一個 process, 因此常出現 "application termination" 的說法)'''__ The prioritization process is discussed in the next section.

=== Understanding Application Priority and Process States ===

__'''The order in which processes are killed to reclaim(收回) resources is determined by the priority of the hosted applications. An application’s priority is equal to its highest-priority component. (因此 process/application/component 每一個層級都有 priority 的概念; 尤其注意)'''__

__Where two applications have the same priority, the process that has been at a lower priority longest will be killed first. (不是以 process 做為 kill 的單位嗎? 為什麼還要去考慮 application priority[?]) '''Process priority is also affected by ''interprocess dependencies''; if an application has a dependency on a Service or Content Provider supplied by a second application, the secondary application will have at least as high a priority as the application it supports.'''__

__All Android applications will remain running and in memory until the system needs its resources for other applications. (按下面 Empty Processes 的說明, 應用程式本身是可以提供 "結束" 的功能的, 但程式結束後可能還會被快取在記憶體裡...)__

Figure 3-3 shows the priority tree used to determine the order of ''application termination''.

{{attachment:figure_3-3.png}} <<BR>> Figure 3-3

__It’s important to structure your application correctly to ensure that its priority is appropriate for the work it’s doing. '''If you don’t, your application could be killed while it’s in the middle of something important.'''__

The following list details each of the application states shown in Figure 3-3, explaining how the state is determined by the application components comprising it:

 * Active Processes - __Active (foreground) processes are those hosting applications with components currently interacting with the user. These are the processes Android is trying to keep responsive by reclaiming resources. There are generally very few of these processes, and they will be killed only as a last resort.__ Active processes include:

   * Activities in an “active” state; that is, they are in the foreground and responding to user events. You will explore Activity states in greater detail later in this chapter.

   * Activities, Services, or Broadcast Receivers that are currently executing an `onReceive` event handler.

   * Services that are executing an `onStart`, `onCreate`, or `onDestroy` event handler.

 * Visible Processes - __Visible, but inactive processes are those hosting “visible” Activities. As the name suggests, visible Activities are visible, but they aren’t in the foreground or responding to user events. '''This happens when an Activity is only partially obscured (昏暗的; by a ''non-full-screen'' or ''transparent'' Activity).''' There are generally very few visible processes, and they’ll only be killed in extreme circumstances to allow active processes to continue.__

 * Started Service Processes - __Processes hosting Services that have been started. Services support ''ongoing processing'' that should continue without a visible interface. Because Services don’t interact directly with the user, they receive a slightly lower priority than visible Activities. They are still considered to be foreground processes and won’t be killed unless resources are needed for active or visible processes. '''(這一節 foreground/background processes 的概念與上面 Types of Android Applications 一節所提到的 foreground/background executions 不同, 這裡的 foreground/background 指的是 "是否在執行中", 這說明了為何 Services/Broadcast Receivers 等都被視為 active/foreground processes 的原因[...])'''__ You’ll learn more about Services in Chapter 8.

 * Background Processes - __Processes hosting Activities that aren’t visible and that don’t have any Services that have been started are considered background processes. There will generally be a large number of background processes that '''Android will kill using a ''last-seen-first-killed pattern'' to obtain resources for foreground processes. (使用者把焦點移開後就會暫停執行, 因此越舊的程式越早被踢除)'''__

 * Empty Processes - __To improve overall system performance, Android often retains applications in memory after they have reached the end of their lifetimes. Android maintains this cache to improve the start-up time of applications when they’re ''re-launched''. These processes are routinely killed as required.__

=== Externalizing Resources ===

__No matter what your development environment, it’s always good practice to keep ''non-code resources'' like images and string constants external to your code. Android supports the externalization of resources ranging from simple values such as strings and colors to more complex resources like images (''drawables''), animations, and themes. Perhaps the most powerful resources available for externalization are ''layouts''. (架構本身並不強調 declarative UI 的特殊性, 而將它泛化成 externalizing 的一部份)__

__By externalizing resources, they become easier to maintain, update, and manage. '''This also lets you easily define alternative resource values to support different hardware and internationalization. (還有 location, screen size/orientation 等...)'''__

You’ll see later in this section how Android dynamically selects resources from ''resource trees'' that let you define alternative values based on a device’s hardware configuration, language, and location. This lets you create different resource values for specific languages, countries, screens, and keyboards. __When an application starts, Android will automatically select the correct resource values without your having to write a line of code.__

Among other things, this lets you change the layout based on the screen size and orientation and customize text prompts based on language and country.

==== Creating Resources ====

Application resources are stored under the `res/` folder of your project hierarchy. In this folder, each of the available resource types can have a subfolder containing its resources.

If you start a project using the ADT wizard, it will create a `res` folder that contains subfolders for the `values`, `drawable`, and `layout` resources that contain the default layout, application icon, and string resource definitions, respectively, as shown in Figure 3-4.

{{attachment:figure_3-4.png}} <<BR>> Figure 3-4

There are seven primary resource types that have different folders: simple values, drawables, layouts, animations, XML, styles, and raw resources. __When your application is built, these resources will be compiled as efficiently as possible and included in your application package.__

__This process also creates an `R` class file that contains references to each of the resources you include in your project. This lets you reference the resources in your code, with the advantage of ''design time syntax checking''.__

The following sections describe the specific resource types available within these categories and how to create them for your applications.

__In all cases, the resource filenames should contain only lowercase letters, numbers, and the period (.) and underscore (_) symbols. (只能用小寫字母的限制好奇怪?)__

===== Creating Simple Values =====

Supported simple values include strings, colors, dimensions, and string or integer arrays. All simple values are stored within XML files in the `res/values` folder.

Within each XML file, you indicate the type of value being stored using tags as shown in the sample XML file below:

 {{{
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="app_name">To Do List</string>
  <color name="app_background">#FF0000FF</color>
  <dimen name="default_border">5px</dimen>
  <array name="string_array">
    <item>Item 1</item>
    <item>Item 2</item>
    <item>Item 3</item>
  </array>
  <array name="integer_array">
    <item>3</item>
    <item>2</item>
    <item>1</item>
  </array>
</resources>
 }}}

This example includes all of the simple value types. __By convention, resources are separated into separate files for each type; for example, `res/values/strings.xml` would contain only string resources. (好管理嗎[?])__

The following sections detail the options for defining simple resources.

====== Strings ======

Externalizing your strings helps maintain consistency within your application and makes it much easier to create localized versions.

String resources are specifi ed using the string tag as shown in the following XML snippet:

 {{{
<string name=”stop_message”>Stop.</string>
 }}}

Android supports simple text styling, so you can use the HTML tags <b>, <i>, and <u> to apply bold, italics, or underlining to parts of your text strings as shown in the example below:

 {{{
<string name=”stop_message”><b>Stop.</b></string>
 }}}

You can use resource strings as input parameters for the String.format method. However, String.format does not support the text styling described above. To apply styling to a format string, you have to escape the HTML tags when creating your resource, as shown below:

 {{{
<string name=”stop_message”>&lt;b>Stop&lt;/b>. %1$s</string>
 }}}

Within your code, use the Html.fromHtml method to convert this back into a styled character sequence:

 {{{
String rString = getString(R.string.stop_message);
String fString = String.format(rString, “Collaborate and listen.”);
CharSequence styledString = Html.fromHtml(fString);
 }}}

====== Colors ======

Use the color tag to defi ne a new color resource. Specify the color value using a # symbol followed by the (optional) alpha channel, then the red, green, and blue values using one or two hexadecimal numbers with any of the following notations:

 * #RGB
 * #RRGGBB
 * #ARGB
 * #ARRGGBB

The following example shows how to specify a fully opaque blue and a partially transparent green:

 {{{
<color name=”opaque_blue”>#00F</color>
<color name=”transparent_green”>#7700FF00</color>
 }}}

====== Dimensions ======

Dimensions are most commonly referenced within style and layout resources. They’re useful for creating layout constants such as borders and font heights.

To specify a dimension resource, use the dimen tag, specifying the dimension value, followed by an identifi er describing the scale of your dimension:

 * px Screen pixels
 * in Physical inches
 * pt Physical points
 * mm Physical millimeters
 * dp Density-independent pixels relative to a 160-dpi screen
 * sp Scale-independent pixels

These alternatives let you defi ne a dimension not only in absolute terms, but also using relative scales that account for different screen resolutions and densities to simplify scaling on different hardware.

The following XML snippet shows how to specify dimension values for a large font size and a standard border:

 {{{
<dimen name=”standard_border”>5px</dimen>
<dimen name=”large_font_size”>16sp</dimen>
 }}}

===== Styles and Themes =====

Style resources let your applications maintain a consistent look and feel by specifying the attribute values used by Views. The most common use of themes and styles is to store the colors and fonts for an application.

You can easily change the appearance of your application by simply specifying a different style as the theme in your project manifest.

To create a style, use a style tag that includes a name attribute, and contains one or more item tags. Each item tag should include a name attribute used to specify the attribute (such as font size or color) being defi ned. The tag itself should then contain the value, as shown in the skeleton code below:

 {{{
<?xml version=”1.0” encoding=”utf-8”?>
<resources>
<style name=”StyleName”>
<item name=”attributeName”>value</item>
</style>
</resources>
 }}}

Styles support inheritance using the parent attribute on the style tag, making it easy to create simple variations.

The following example shows two styles that can also be used as a theme; a base style that sets several text properties and a second style that modifi es the fi rst to specify a smaller font.

 {{{
<?xml version=”1.0” encoding=”utf-8”?>
<resources>
<style name=”BaseText”>
<item name=”android:textSize”>14sp</item>
<item name=”android:textColor”>#111</item>
</style>
<style name=”SmallText” parent=”BaseText”>
<item name=”android:textSize”>8sp</item>
</style>
</resources>
 }}}

===== Drawables =====

Drawable resources include bitmaps and NinePatch (stretchable PNG) images. They are stored as individual fi les in the res/drawable folder.

The resource identifi er for a bitmap resource is the lowercase fi lename without an extension.

The preferred format for a bitmap resource is PNG, although JPG and GIF fi les are also supported.

NinePatch (or stretchable) images are PNG fi les that mark the parts of an image that can be stretched. NinePatch images must be properly defi ned PNG fi les that end in .9.png. The resource identifi er for NinePatches is the fi lename without the trailing .9.png.

A NinePatch is a variation of a PNG image that uses a 1-pixel border to defi ne the area of the image that can be stretched if the image is enlarged. To create a NinePatch, draw single-pixel black lines that represent stretchable areas along the left and top borders of your image. The unmarked sections won’t be resized, and the relative size of each of the marked sections will remain the same as the image size changes.

NinePatches are a powerful technique for creating images for the backgrounds of Views or Activities that may have a variable size; for example, Android uses NinePatches for creating button backgrounds.

===== Layouts =====

Layout resources let you decouple your presentation layer by designing user-interface layouts in XML rather than constructing them in code.

The most common use of a layout is to defi ne the user interface for an Activity. Once defi ned in XML, the layout is “infl ated” within an Activity using setContentView, usually within the onCreate method.

You can also reference layouts from within other layout resources, such as layouts for each row in a List View. More detailed information on using and creating layouts in Activities can be found in Chapter 4.

Using layouts to create your screens is best-practice UI design in Android. The decoupling of the layout from the code lets you create optimized layouts for different hardware confi gurations, such as varying screen sizes, orientation, or the presence of keyboards and touch screens.

Each layout defi nition is stored in a separate fi le, each containing a single layout, in the res/layout folder. The fi lename then becomes the resource identifi er.

A thorough explanation of layout containers and View elements is included in the next chapter, but as an example, the following code snippet shows the layout created by the New Project Wizard. It uses a LinearLayout as a layout container for a TextView that displays the “Hello World” greeting.

 {{{
<?xml version=”1.0” encoding=”utf-8”?>
<LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android”
android:orientation=”vertical”
android:layout_width=”fill_parent”
android:layout_height=”fill_parent”>
<TextView
android:layout_width=”fill_parent”
android:layout_height=”wrap_content”
android:text=”Hello World!”
/>
</LinearLayout>
 }}}

===== Animations =====

Android supports two types of animation. Tweened animations can be used to rotate, move, stretch, and fade a View; or you can create frame-by-frame animations to display a sequence of drawable images. A comprehensive overview of creating, using, and applying animations can be found in Chapter 11.

Defi ning animations as external resources allows you to reuse the same sequence in multiple places and provides you with the opportunity to present an alternative animation based on device hardware or orientation.

====== Tweened Animations ======

Each tweened animation is stored in a separate XML file in the project’s `res/anim` folder. As with layouts and drawable resources, the animation’s filename is used as its ''resource identifier''.

An animation can be defined for changes in alpha (fading), scale (scaling), translate (moving), or rotate (rotating).

Each of these animation types supports attributes to defi ne what the sequence will do:

|| Alpha || fromAlpha and toAlpha || Float from 0 to 1 ||
||<|3> Scale || fromXScale/toXScale || Float from 0 to 1 ||
|| fromYScale/toYScale || Float from 0 to 1 ||
|| pivotX/pivotY || String of the percentage of graphic width/height from 0% to 100% ||
||<|2> Translate || fromX/toX || Float from 0 to 1 ||
|| fromY/toY || Float from 0 to 1 ||
||<|2> Rotate || fromDegrees/toDegrees || Float from 0 to 360 ||
|| pivotX/pivotY || String of the percentage of graphic width/height from 0% to 100% ||

You can create a combination of animations using the set tag. An animation set contains one or more animation transformations and supports various additional tags and attributes to customize when and how each animation within the set is run.

The following list shows some of the set tags available:

 * duration Duration of the animation in milliseconds.
 * startOffset Millisecond delay before starting this animation.
 * fi llBefore True to apply the animation transformation before it begins.
 * fi llAfter True to apply the animation transformation after it begins.
 * interpolator Interpolator to set how the speed of this effect varies over time. Chapter 11 explores the interpolators available. To specify an interpolator, reference the system animation resources at android:anim/interpolatorName.

If you do not use the startOffset tag, all the animation effects within a set will execute simultaneously.

The following example shows an animation set that spins the target 360 degrees while it shrinks and fades out:

 {{{
<?xml version=”1.0” encoding=”utf-8”?>
<set xmlns:android=”http://schemas.android.com/apk/res/android”
android:interpolator=”@android:anim/accelerate_interpolator”>
<rotate
android:fromDegrees=”0”
android:toDegrees=”360”
android:pivotX=”50%”
android:pivotY=”50%”
android:startOffset=”500”
android:duration=”1000” />
<scale
android:fromXScale=”1.0”
android:toXScale=”0.0”
android:fromYScale=”1.0”
android:toYScale=”0.0”
android:pivotX=”50%”
android:pivotY=”50%”
android:startOffset=”500”
android:duration=”500” />
<alpha
android:fromAlpha=”1.0”
android:toAlpha=”0.0”
android:startOffset=”500”
android:duration=”500” />
</set>
 }}}

====== Frame-by-Frame Animations ======

Frame-by-frame animations let you create a sequence of drawables, each of which will be displayed for a specifi ed duration, on the background of a View.

Because frame-by-frame animations represent animated drawables, they are stored in the res/drawble folder, rather than with the tweened animations, and use their fi lenames (without the xml extension) as their resource IDs.

The following XML snippet shows a simple animation that cycles through a series of bitmap resources, displaying each one for half a second. In order to use this snippet, you will need to create new image resources rocket1 through rocket3.

 {{{
<animation-list
xmlns:android=”http://schemas.android.com/apk/res/android”
android:oneshot=”false”>
<item android:drawable=”@drawable/rocket1” android:duration=”500” />
<item android:drawable=”@drawable/rocket2” android:duration=”500” />
<item android:drawable=”@drawable/rocket3” android:duration=”500” />
</animation-list>
 }}}
 
==== Using Resources ====

As well as the resources you create, Android supplies several system resources that you can use in your applications. The resources can be used directly from your application code and can also be referenced from within other resources (e.g., a dimension resource might be referenced in a layout defi nition).

Later in this chapter, you’ll learn how to defi ne alternative resource values for different languages, locations, and hardware. It’s important to note that when using resources you cannot choose a particular specialized version. Android will automatically select the most appropriate value for a given resource identifi er based on the current hardware and device settings.

===== Using Resources in Code =====

You access resources in code using the static R class. R is a generated class based on your external resources and created by compiling your project. The R class contains static subclasses for each of the resource types for which you’ve defi ned at least one resource. For example, the default new project includes the R.string and R.drawable subclasses.

If you are using the ADT plug-in in Eclipse, the R class will be created automatically when you make any change to an external resource fi le or folder. If you are not using the plug-in, use the AAPT tool to compile your project and generate the R class. R is a compiler-generated class, so don’t make any manual modifi cations to it as they will be lost when the fi le is regenerated.

Each of the subclasses within R exposes its associated resources as variables, with the variable names matching the resource identifi ers — for example, R.string.app_name or R.drawable.icon.

:::

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==
