= Java / Programming / Assertions =
<<TableOfContents>>

== Overview ==

Finding bugs in programs is not an easy task, especially when they are subtle(難以察覺的) bugs. The process of finding bugs is not exciting, and you may have gone through your program wasting your time trying to find bugs that should not have existed in the first place. Such bugs may exist because you did not understand the specifications correctly. __And as Barry Boehm, the father of software economics, put it: '''If it costs $1 to find and fix a requirement-based problem during the requirements definition process, it can cost $5 to repair it during design, $10 during coding, $20 during unit testing, and as much as $200 after delivery of the system.''' Thus, finding bugs early on in the software life cycle pays off(帶來好結果).__

You can use assertions to detect errors that may otherwise go unnoticed. Assertions contain boolean expressions that define the correct state of your program at specific points in the program source code. The designers of the Java platform, however, didn't include support for assertions. Perhaps they viewed exceptions as a superior(上好的) feature, allowing you to use try/catch/finally to throw an exception instead of aborting the program as in assertions. But the Java 2 Platform, Standard Edition (J2SE) release 1.4, has introduced a built-in assertion facility...

__When writing programs, it is a good idea to put checks at strategic places for violations of basic assumptions. These checks help in debugging code. An assertion is a statement in the Java programming language that enables you to test your assumptions about your program. '''Assertions play an important role in debugging and designing code with testability in mind.'''__ For example, if you write a method that calculates the speed of a particle(粒子), you might assert that the calculated speed is less than the speed of light.

Each assertion contains a boolean expression that you believe will be true when the assertion executes. If it is not true, the system will throw an error. By verifying that the boolean expression is indeed true, the assertion confirms your assumptions about the behavior of your program, increasing your confidence that the program is free of errors.

__'''Experience has shown that writing assertions while programming is one of the quickest and most effective ways to detect and correct bugs. As an added benefit, assertions serve to document the inner workings of your program, enhancing maintainability. Using assertions helps developers write code that is more correct, more readable, and easier to maintain. Thus, assertions improve the odds(可能性) that the behavior of a class matches the expectations of its clients. (從 class 內部做測試, 而 unit testing 則是從 class 這個 "黑箱" 外面做測試, 兩者在測試工作上有相輔相成的關係; 因此開發及測試期間, 一般都會將 assertion 開啟, 若等到上線出狀況時才開啟 assertion, 這才發現 `assert` 的條件下錯就糟了...)'''__

== Design by Contract ==

__'''We can view program correctness as proof(證明) that the computation, given correct input, terminated with correct output. The user invoking the computation has the responsibility of providing the correct input, which is a precondition. If the computation is successful, we say that the computation has satisfied the postcondition.'''__ Some programming languages (such as Eiffel; 沒想到這個語言這麼先進) encourage developers to provide formal proof of correctness by writing assertions that may appear in the following roles:

 * Precondition: A condition that the caller of an operation agrees to satisfy
 * Postcondition: A condition that the method itself promises to achieve
 * Invariant: __'''A condition that a class must satisfy anytime a client could invoke an object's method, or a condition that should always be true for a specified segment or at a specified point of a program'''__

These three roles collectively support what is called the design-by-contract model of programming, a model that is well supported by the Eiffel programming language. Java technology, on the other hand, doesn't have built-in support for the design-by-contract model of programming. In fact, the Java platform did not have built-in support for assertions until the release of J2SE 1.4.

API (Application Programming Interface) 定義了系統邊界:

__'''上述 "系統邊界" 中的 "系統", 單位可大可小, 包括 system/application/library/module/submodule 等... (模組化切割, 單位的粗細程度要適當地拿捏), 每個單位向外都有一個 API (類似於 facade 的概念, 減少公開的細節), 如此可以在內部強化內聚性.'''__

API 也在規範契約, 包含 "權利" 與 "義務" 兩個面向.

 * __承諾會如何呼叫別人 (義務), 並要求別人如何做出如預期般的回應 (權利); 例如定義 interface 讓別人實作 (主動呼叫).__
 * __要求自己如何被呼叫 (權利), 並承諾做出如預期般的回應 (義務); 例如提供 service 讓別人使用 (被動呼叫).__

__所有的 method 都可以歸入下面三種 method 之一 (其中 public/private-API method 泛稱為 API method), 這跟 method 的 access modifier 沒有直接的關係, 完全視 client/caller 相對於系統邊界的位置而定, 而且''''重點不在於對外要求了什麼, 而是相信對方能夠做多少... (相信的成份高時採用 assertion)''':__

 * public-API method: caller 在系統邊界外
 * private-API method : caller 是整合在系統邊界之內的其他系統 - framework (實作 framework 提供的 interface) 或 service provider (提供 interface 讓別人實作, 雖然實作了內部的 SPI, 但卻只能存取 public-API, 否則系統內部一旦有異動, 就會導致 SPI implementation 要重新修訂[?] protected method 也是歸入這個範圍? 因為它是底層的實作, 為了要能一致對外提供好的服務? 呼叫 SPI 後也 "可以" 用 assert 來確認, 但不一定要這麼做, 因為立場上應該相信別人會傳回沒有問題的結果[...])
 * non-API method: caller 總在系統邊界內, 但不是整合在系統邊界之內的其他系統

== Getting Started ==

=== Introduction ===

An assertion has a boolean expression that, if evaluated as `false`, indicates the applicationhas entered an incorrect state or a bug in the code. __'''This mechanism provides a way to detect when a program starts falling into an inconsistent state (= fail as quickly as possible in the event of an error). Assertions are excellent for documenting assumptions and invariants about a class.'''__ The assertion statement has two forms. The first, simpler form is:

 {{{
assert Expression1;
 }}}

where `Expression1` is a `boolean` expression. __When an assertion fails, it means that the application has entered an incorrect state. Possible behaviors may include suspending the program or allowing it to continue to run. '''A good behavior, however, might be to terminate the application, because it may start functioning inappropriately after a failure. (別一錯在錯, 否則問題最後浮出抬面時已經離問題的源頭有一段距離, 徒增除錯的難度...; 由於 assertion 平常不會開啟, 所以使用 assertion 的意義不在於總能夠在第一時間攔截到可能的錯誤, 而是後續可以更快地找到問題的源頭, 否則往往要花很長的時間才能找到根本的問題)'''__ In this case, when an assertion fails, an `java.lang.AssertionError` is thrown with no detail message. Any line that executes after the `assert` statement can safely assume that `Expression1` is true. (在執行期, assertion 會以 exception 來反應條件不符的問題; 可以使用 top-level exception handler 將它整合到 logging 機制裡)

The second form of the assertion statement is:

 {{{
assert Expression1 : Expression2;
 }}}

where:

 * `Expression1` is a `boolean` expression.
 * `Expression2` is an expression that has a value. (It cannot be an invocation of a method that is declared `void`. 也就是可以呼叫其他方法做更複雜的檢查; __'''在實務上, 如果 Expression 1 內部的檢查相當複雜, 錯誤訊息可能就要從 Expression 1 內部用 `assert false : message` 或 `throw new AssertionError(message)` 的方式來提供, 而無法由 Expression 2 對 Expression 1 內部可能發生的多種狀況做猜測'''__)

Use this version of the `assert` statement to provide a detail message for the `AssertionError`. The system passes the value of `Expression2` to the appropriate `AssertionError` constructor, which uses the string representation (指的應該就是 `toString` 的結果吧[?]) of the value as the error's detail message.

__Primitive types and `null` is also allowed in `Expression2`. There is no compelling(不得不的) reason to restrict the type of this expression. Allowing arbitrary types provides convenience for developers who, for example, want to associate a unique integer code with each assertion. '''Further, it makes this expression feel like the argument of `System.out.println(...)`, which is seen as desirable.'''__

__The purpose of the detail message is to capture and communicate the details of the assertion failure. The message should allow you to diagnose and ultimately fix the error that led the assertion to fail. '''Note that the detail message is not a user-level error message, so it is generally unnecessary to make these messages understandable in isolation(獨自), or to internationalize them. Remember that these messages are for us -- developers -- and not users. (不是寫給別人看的, 可以仿造 debug logging 的寫法. 反過來說, "be understandable in isolation" 卻是 exception 的必要條件)''' The detail message is meant to be interpreted in the context of a full stack trace, in conjunction with the source code containing the failed assertion.__

__Like all uncaught exceptions, assertion failures are generally labeled in the stack trace with the file and line number from which they were thrown. '''The second form of the assertion statement should be used in preference to the first only when the program has some additional information that might help diagnose the failure. (多寫無益)''' For example, if `Expression1` involves the relationship between two variables `x` and `y`, the second form should be used. Under these circumstances, a reasonable candidate for `Expression2` would be `"x: " + x + ", y: " + y`.__

__上述 "help diagnose" 的考量, 與拋出 exception 時要適時夾帶一些 context information 的做法是一樣的; 例如 `assert input != null : input` 的寫法是沒有意義的, 因為 input 一定是 `null` 才會導致斷言不成立, 但相對地, `assert input != null && input.length() > 0 : input` 則有意義, 因為 `input` 可能是 `null` 或者是空字串, '''另外要注意不要將它簡化成 `assert input.length() > 0 : input`, 因為若 `input` 真的是 `null`, 那麼執行期將會拋出 `NullPointerException` 而非 `AssertionError`, 兩者在意義上是相當不同的!!'''__

__In some cases `Expression1` may be expensive to evaluate. For example, suppose you write a method to find the minimum element in an unsorted list, and you add an assertion to verify that the selected element is indeed the minimum. The work done by the assert will be at least as expensive as the work done by the method itself. (檢查的成本至少與執行的成本一樣高而言) To ensure that assertions are not a performance liability(妨害) in deployed applications, assertions can be enabled or disabled when the program is started, and are disabled by default. Disabling assertions eliminates their performance penalty(不利) entirely. '''Once disabled, they are essentially equivalent to empty statements in semantics and performance. (在實務上 assertion 不會一直開著, 而是系統有問題時, 再針對可疑的區域啟用 assertion 即可, 因此運算複雜的 assertion 也都是可以接受的)'''__

In other words, this is a requirement for performance reasons. You should write assertions into software in a form that can be optionally compiled. Thus, assertions should be executed with the code only when you are debugging your program -- that is, when assertions will really help flush out errors. You can think of assertions as a uniform mechanism that replaces the use of ad hoc(僅為某一目的而做的安排) conditional tests.

__Although ad hoc implementations are possible, they are of necessity(必然地) either ugly (requiring an `if` statement for each assertion; 多少會降低可讀性) or inefficient (evaluating the condition even if assertions are disabled). Further, each ad hoc implementation has its own means of enabling and disabling assertions, which lessens(貶低) the utility of these implementations, especially for debugging in the field(= in actual use). As a result of these shortcomings, assertions have never become a part of the culture among engineers using the Java programming language. Adding assertion support to the platform stands a good chance of rectifying(矯正) this situation. It is best to have the assertion facility built into the language itself.__

__We recognize that a language change is a serious effort, not to be undertaken(承擔) lightly. '''The library approach was considered. It was, however, deemed(視為) essential that the runtime cost of assertions be negligible(可以忽略的) if they are disabled. In order to achieve this with a library, the programmer is forced to hard-code each assertion as an `if` statement. (結果會變成像是 logging, 還要透過類似 `isDebugEnabled()` 的安排來避免執行期的衝擊)''' Many programmers would not do this. Either they would omit the `if` statement and performance would suffer, or they would ignore the facility entirely. Note also that assertions were contained in James Gosling's original specification for the Java programming language. Assertions were removed from the Oak specification because time constraints prevented a satisfactory(令人滿意的) design and implementation.__

__In addition to `boolean` assertions, why not provide an assert-like construct to suppress the execution of an entire block of code if assertions are disabled? '''Providing such a construct would encourage programmers to put complex assertions inline, when they are better relegated to separate methods. (從語本身的設計開始, 就避開了不好的習慣...)'''__

__Why is `AssertionError` a subclass of `Error` rather than `RuntimeException`? '''This issue was controversial(有爭議的). The expert group discussed it at length(詳細地), and came to the conclusion that `Error` was more appropriate to discourage programmers from attempting to recover from assertion failures. It is, in general, difficult or impossible to localize(將...控制在一個地方) the source of an assertion failure. Such a failure indicates that the program is operating "outside of known space," and attempts to continue execution are likely to be harmful.''' Further, convention dictates that methods specify most runtime exceptions they may throw (with `@throws` doc comments). It makes little sense to include in a method's specification the circumstances under which it may generate an assertion failure. Such information may be regarded as an implementation detail, which can change from implementation to implementation and release to release. (意指若將 `AssertionError` 繼承自 `RuntimeException`, 就會產生要不要將 assertion failure 加以宣告的難題, 但由於 assertion 涉及內部實作, 本質上並不適合加以宣告...)__

=== Putting Assertions Into Your Code ===

There are many situations where it is good to use assertions. This section covers some of them:

  * Internal Invariants(不變式; 檢查內部狀態的一致性而言)
  * Control-Flow Invariants
  * Preconditions(前置條件), Postconditions(後置條件), and Class Invariants

There are also a few situations where you should not use them:

 * __'''Do not use assertions for argument checking in public methods (這裡的 "public" 指的是單位的 public-API methods 而言, 而非所有具 `public` 或 `protected` modifier 的方法).'''__

 __'''Argument checking is typically part of the published specifications (or contract) of a method, and these specifications must be obeyed(遵行) whether assertions are enabled or disabled. Another problem with using assertions for argument checking is that erroneous(錯誤的) arguments should result in an appropriate runtime exception (such as `IllegalArgumentException`, `IndexOutOfBoundsException`, or `NullPointerException`). An assertion failure will not throw an appropriate exception. (無法區隔錯誤的類型而言; 因為 public-API client 可能沒有原始碼可用, 使用者需要從 exception 的類型及訊息去鄰斷問題的所在, 丟出 `AssertionError` 對使用者並沒有實質的幫助, 反而會讓使用者無所適從...)'''__

 ''一個主要的原因是, 每個 public 都有其合約, 這個 method 應該做到什麼樣的任務, 執行過這個 method 必定有什麼效果(至少要維持物件的 invariant 性質), 如果這個 method 沒辦法 handle 某些狀況會丟出什麼 exception(還是得維持 object invariant 的特性), 這些都是 method 的規格(合約). 所以 public method 應該要去判斷 input 是否合乎需求, 若不合需求看是要丟出 exception 或是以傳回值來通知此 method 是否成功達成目的, 不能倚賴 assertion 來濾掉不合乎需求的 input 或狀況. 平常你在 development 階段可以用來觀察程式的運作是否正常, 執行到非預期的狀態程式停掉, 但 release public 介面出去後你不能確定 user 在執行你的碼時是否會 enable assertion, 如果 user 沒有 enable assertion facility, 然後你的碼又碰到意料外的 input 或狀況, 你的 public method 不會丟出 `AssertionError` 然後就默默地 pass 了, client code 不知道遭遇到的非預期(不正常)的情況, 而你的 public method 經過此非預期狀況可能破壞 object invariant, 導致後續程式執行一直出槌, 但沒有人知道問題在哪, 因為你的 code 會靜靜地吃案.'' (引用自 http://www.javaworld.com.tw/jute/post/print?bid=17&id=9017[Assertion 介紹與使用 / Duncan])

 * Do not use assertions to do any work that your application requires for correct operation.

 Because assertions may be disabled, programs must not assume that the boolean expression contained in an assertion will be evaluated. Violating this rule has dire(可怕的) consequences(後果). For example, suppose you wanted to remove all of the `null` elements from a list `names`, and knew that the list contained one or more `null`s. It would be wrong to do this:

 {{{
// Broken! - action is contained in assertion
assert names.remove(null);
 }}}

 The program would work fine when asserts were enabled, but would fail when they were disabled, as it would no longer remove the `null` elements from the list. The correct idiom(慣用語法) is to perform the action before the assertion and then assert that the action succeeded:

 {{{
// Fixed - action precedes assertion
boolean nullsRemoved = names.remove(null);
assert nullsRemoved;  // Runs whether or not asserts are enabled
 }}}

 __'''As a rule, the expressions contained in assertions should be free of side effects: evaluating the expression should not affect any state that is visible after the evaluation is complete. One exception to this rule is that assertions can modify state that is used only from within other assertions.'''__

==== Internal Invariants ====

__'''Before assertions were available, many programmers used comments(=textual assertion) to indicate their assumptions concerning a program's behavior. (因此下次寫程式時, 如果遇到想要寫一些註解來對接下來要做的運算做一些假設時, 記得用 assertion 來實作; 當然也可以用來檢查一小段運算的結果, 因為我們做了 "這一段運算一定沒有問題" 的假設, 但如果不放心, 還是可以加上一個 assertion 做確保)'''__ For example, you might have written something like this to explain your assumption about an `else` clause in a multiway if-statement:

 {{{
if (i % 3 == 0) {
    ...
} else if (i % 3 == 1) {
    ...
} else { // We know (i % 3 == 2)
    ...
}
 }}}

You should now use an assertion whenever you would have written a comment that asserts an invariant. For example, you should rewrite the previous if-statement like this:

 {{{
if (i % 3 == 0) {
    ...
} else if (i % 3 == 1) {
    ...
} else {
    assert i % 3 == 2 : i;
    ...
}
 }}}

Note, incidentally(附帶一提), that the assertion in the above example may fail if `i` is negative, as the `%` operator is not a true modulus(模數) operator, but computes the remainder, which may be negative.

__Another good candidate for an assertion is a `switch` statement with no `default` case. The absence of a `default` case typically indicates that a programmer believes that one of the cases will always be executed.__ The assumption that a particular variable will have one of a small number of values is an invariant that should be checked with an assertion. For example, suppose the following `switch` statement appears in a program that handles playing cards:

 {{{
switch(suit) {
  case Suit.CLUBS:
    ...
    break;

  case Suit.DIAMONDS:
    ...
    break;

  case Suit.HEARTS:
    ...
    break;

  case Suit.SPADES:
    ...
}
 }}}

It probably indicates an assumption that the `suit` variable will have one of only four values. To test this assumption, you should add the following default case:

 {{{
default:
  assert false : suit;
 }}}

__'''由於 `switch` 在使用上常會忘了加 `break` 而出現異常, 因此它比較適合用在簡單的 "邏輯分支", 因為 `switch...case` 內縮得很嚴重, 程式區域太大時會很難維護, 這時候可以改用 `if...else if...else` 的方式, 一樣可以搭配 `assert false` 使用:'''__

 {{{
if (suit == Suit.CLUBS) {
 ...
} else if (suit == Suit.DIMANDS) {
 ...
} else if (...) {
 ...
} else {
 assert false : suit;
}
 }}}

If the `suit` variable takes on another value and assertions are enabled, the assert will fail and an `AssertionError` will be thrown.

An acceptable alternative is:

 {{{
default:
  throw new AssertionError(suit);
 }}}

This alternative offers protection even if assertions are disabled, but the extra protection adds no cost: the `throw` statement won't execute unless the program has failed. Moreover, the alternative is legal under some circumstances where the `assert` statement is not. If the enclosing method returns a value, each case in the `switch` statement contains a `return` statement, and no `return` statement follows the `switch` statement, then it would cause a syntax error to add a default case with an assertion. (The method would return without a value if no case matched and assertions were disabled. __'''事實上自行做條件判斷然後丟出 `AssertionError` 與 `assert` 關鍵字的使用, 就結果來看是很類似的; 但 `assert` 關鍵字的使用, 事後可以任意進行開啟或關閉的動作, 這是手動處理所辦不到的. 因此在實務上還是儘可能地直接使用 `assert` 關鍵字, 可讀性相對比較高, 除非遇到下面 "statement is unreachable" 的狀況...'''__)

==== Control-Flow Invariants ====

The previous example not only tests an invariant, it also checks an assumption about the application's flow of control. The author of the original `switch` statement probably assumed not only that the `suit` variable would always have one of four values, but also that one of the four cases would always be executed. (注意兩者語意上的不同) It points out another general area where you should use assertions: __place an assertion at any location you assume will not be reached.__ The assertions statement to use is:

 {{{
assert false;
 }}}

For example, suppose you have a method that looks like this:

 {{{
void foo() {
    for (...) {
        if (...)
            return;
    }
    // Execution should never reach this point!!!
}
 }}}

Replace the final comment so that the code now reads:

 {{{
void foo() {
    for (...) {
        if (...)
            return;
    }
    assert false; // Execution should never reach this point!
}
 }}}

__'''Use this technique with discretion(謹慎). If a statement is unreachable as defined in the Java Language Specification ( JLS 14.20), you will get a compile time error if you try to assert that it is not reached. Again, an acceptable alternative is simply to throw an `AssertionError`. (有時候還是非手動丟出 `AssertionError` 不可...)'''__

==== Preconditions, Postconditions, and Class Invariants ====

While the `assert` construct is not a full-blown(成熟的) design-by-contract facility, it can help support an informal design-by-contract style of programming. This section shows you how to use asserts for:

 * __Preconditions — what must be true when a method is invoked.__
   * Lock-Status Preconditions — preconditions concerning whether or not a given lock is held. (運用在多緒的處理上)
 * __Postconditions — what must be true after a method completes successfully. '''(檢查 method 的運算結果或回傳值; 例如 Javadoc 上承諾會傳回 "一或多個項目" 或 "零或正數" 時, 就可以檢查內部可能會傳回 "零或多個項目" 或 "負數" 的狀況)'''__
 * Class invariants — what must be true about each instance of a class. (檢查 class 內部狀態的一致性, 也有前/後置的概念)

===== Preconditions =====

__通常指的是檢查 caller 是否有善盡責任, 傳入合宜的的參數; 按這裡及上述 "A condition that the caller of an operation agrees to satisfy" 的說法, '''其實 preconditions 檢查的對象可以不限定在 method arguments, 包括 internal state 也算...'''__

 {{{
private Type state;

public void process1(Type arg) {
  assert arg != null;
  assert state match some condition(s)...
  ...
  ... do something with arg and state ...
}

public void process2(Type arg, Type state) { // 這與上面的方法, 在概念上是一致的...
  ...
}

public void chanageState() {
  ... change state ...
}
 }}}

By convention, preconditions on public methods (= public-API methods) are enforced by explicit checks that throw particular, specified exceptions. For example:

 {{{
/**
 * Sets the refresh rate.
 *
 * @param  rate refresh rate, in frames per second.
 * @throws IllegalArgumentException if rate <= 0 or
 *          rate > MAX_REFRESH_RATE.
 */
 public void setRefreshRate(int rate) {
     // Enforce specified precondition in public method
     if (rate <= 0 || rate > MAX_REFRESH_RATE)
         throw new IllegalArgumentException("Illegal rate: " + rate);

     setRefreshInterval(1000/rate);
 }
  }}}

__This convention is unaffected by the addition of the `assert` construct. Do not use assertions to check the parameters of a public method (= public-API method). '''An assert is inappropriate because the method guarantees that it will always enforce the argument checks. It must check its arguments whether or not assertions are enabled. (這是 public-API 契約上要求 caller 必須要履行的義務, 不因 assertion 關閉而失效)''' Further, the `assert` construct does not throw an exception of the specified type. It can throw only an `AssertionError`.__

__You can, however, use an assertion to test a nonpublic (= non-API) method's precondition that you believe will be true no matter what a client does with the class.__ For example, an assertion is appropriate in the following "helper method" that is invoked by the previous method:

__'''non-API methods 在實務上都應該以 assertion 來做參數的檢查 (但這並不表示 non-API methods 內部不應該以 exception 來反應其他執行期的錯誤), 跟 public-API methods 參數的檢查方式顯然不同, 但 Javadoc 上仍然要將呼叫的條件寫清楚. 因為只有內部在使用, 所以可以在裡面斷言假設參數的傳遞一定沒問題, 傳入合法的參數本來就是 caller 的責任, 只是如果能再用 `assert` 關鍵字來確認, 就更實際了.'''__

 {{{
/**
 * Sets the refresh interval (which must correspond to a legal frame rate).
 *
 * @param  interval refresh interval in milliseconds.
 */
private void setRefreshInterval(int interval) {
    // Confirm adherence to precondition in nonpublic method
    assert interval > 0 && interval <= 1000/MAX_REFRESH_RATE : interval;

    ... // Set the refresh interval
}
 }}}

Note, the above assertion will fail if `MAX_REFRESH_RATE` is greater than 1000 and the client selects a refresh rate greater than 1000. '''This would, in fact, indicate a bug in the library!

__'''因為 non-API method 一定是由 public/private-API method 內部轉呼叫而來, 因此若參數有問題, 一定是內部造成的...; API 定義了系統邊界, 若外界的呼叫一開始就傳入了不合宜的參數, 內部要以 exception 的方式立即回應 (也就是說 `IllegalArgumentException` 完全是衝著系統邊界外的 caller 而來), 一旦認定傳入的參數是合宜的, 內部就可以對許多狀況做出斷言, 一旦斷言不成立, 當然就是內部自己的問題)'''__

===== Lock-Status Preconditions =====

Classes designed for multithreaded use often have non-public methods (= non-API methods) with preconditions relating to whether or not some lock is held. For example, it is not uncommon to see something like this:

 {{{
private Object[] a;

public synchronized int find(Object key) {
  return find(key, a, 0, a.length);
}

// Recursive helper method - always called with a lock on this object
private int find(Object key, Object[] arr, int start, int len) {
   ...
}
 }}}

A static method called `holdsLock` has been added to the `Thread` class to test whether the current thread holds the lock on a specified object. This method can be used in combination with an `assert` statement to supplement a comment describing a lock-status precondition, as shown in the following example:

 {{{
// Recursive helper method - always called with a lock on this.
private int find(Object key, Object[] arr, int start, int len) {
    assert Thread.holdsLock(this); // lock-status assertion
    ...
}
 }}}

Note that it is also possible to write a lock-status assertion asserting that a given lock isn't held.

===== Postconditions =====

You can test postcondition with assertions in both public and nonpublic methods. (事實上 preconditions 也可以用在 public-API method, 只是不適合用在 public-API method 參數檢查的工作上而已) For example, the following public method uses an `assert` statement to check a post condition immediately prior to its return: (Note that if a method has multiple `return` statements, then postconditions should be evaluated before each of these `return` statements.)

 {{{
/**
 * Returns a BigInteger whose value is (this-1 mod m).
 *
 * @param  m the modulus.
 * @return this-1 mod m.
 * @throws ArithmeticException  m <= 0, or this BigInteger
 *         has no multiplicative inverse mod m (that is, this BigInteger
 *         is not relatively prime to m).
 */
public BigInteger modInverse(BigInteger m) {
    if (m.signum <= 0)
        throw new ArithmeticException("Modulus not positive: " + m);

    ... // Do the computation

    assert this.multiply(result).mod(m).equals(ONE) : this;
    return result;
}
 }}}

__Occasionally it is necessary to save some data prior to performing a computation in order to check a postcondition. You can do this with two `assert` statements and a simple inner class that saves the state of one or more variables so they can be checked (or rechecked) after the computation. (避免因為要做 assertion 而破壞了程式碼結構或降低了可讀性, 不過除了 inner class 外, 應該有更好的做法吧[?])__ For example, suppose you have a piece of code that looks like this:

 {{{
void foo(int[] array) {
    // Manipulate array
    ...

    // At this point, array will contain exactly the ints that it did
    // prior to manipulation, in the same order.
}
 }}}

Here is how you could modify the above method to turn the textual assertion of a postcondition into a functional(相對於 textual assertion 的 assumption 更具實質上的功能而言) one:

 {{{
void foo(final int[] array) {
  // Inner class that saves state and performs final consistency check
  class DataCopy {
      private int[] arrayCopy;

      DataCopy() { arrayCopy = (int[]) array.clone(); }

      boolean isConsistent() { return Arrays.equals(array, arrayCopy); }
  }

  DataCopy copy = null; // 至少需額外增加一個 local variable 做數據的穚接

  // Always succeeds; has side effect of saving a copy of array
  assert ((copy = new DataCopy()) != null);

  ... // Manipulate array

  // Ensure array has same ints in same order as before manipulation.
  assert copy.isConsistent();
}
 }}}

You can easily generalize this idiom to save more than one data field, and to test arbitrarily complex assertions concerning pre-computation and post-computation values.

You might be tempted to replace the first `assert` statement (which is executed solely for its side-effect) by the following, more expressive statement:

 {{{
copy = new DataCopy();
 }}}

__'''Don't make this replacement. The statement above would copy the array whether or not asserts were enabled, violating the principle that assertions should have no cost when disabled.'''__

===== Class Invariants =====

__'''A class invariants is a type of internal invariant(檢查內部狀態的一致性而言; 適用於 domain model 內部檢查一致性[?]) that applies to every instance of a class at all times, except when an instance is in transition from one consistent state to another (有點像是資料庫交易, 過程中可能會有短暫的不一致, 但交易完成後一定是一致的; 所以後面 "before and after any method completes" 的說法, 並不適用於 non-public method; 如果有多緒的問題, 就要搭配 syncornized 機制做存取管制, 避免被存取到資料處理的過程中不一致的狀態). A class invariant can specify the relationships among multiple attributes, and should be true before and after any method completes. (一樣有前/後置的概念, 但這跟上述 preconditions/postconditions 定位在 method 層級是不一樣的)'''__ For example, suppose you implement a balanced tree data structure of some sort. A class invariant might be that the tree is balanced and properly ordered.

__The assertion mechanism does not enforce any particular style for checking invariants. '''It is sometimes convenient, though, to combine the expressions that check required constraints into a single internal method that can be called by assertions.'''__ Continuing the balanced tree example, it might be appropriate to implement a private method that checked that the tree was indeed balanced as per(按照) the dictates(要求) of the data structure: __'''(將 assertion 提出為 private method 的做法, 只適用於 internal state 的檢查, 不適用於 argument checking)'''__

 {{{
// Returns true if this tree is properly balanced
private boolean balanced() {
    ...
}
 }}}

__Because this method checks a constraint that should be true before and after any method completes, each public method and constructor should contain the following line immediately prior to its return: (後置條件; '''更明確地說, 應該要加在所有會改變內部狀態的 non-private method 裡頭 - unit of work, 包括所有具 package private, `protected` 或 `public` modifier 的方法''')__

 {{{
assert balanced();
 }}}

__It is generally unnecessary to place similar checks at the head of each public method unless the data structure is implemented by native methods. In this case, it is possible that a memory corruption bug could corrupt a "native peer" data structure in between method invocations (狀態會受外界影響而言). A failure of the assertion at the head of such a method would indicate that such memory corruption had occurred. Similarly, '''it may be advisable(合宜的) to include class invariant checks at the heads of methods in classes whose state is modifiable by other classes. (Better yet(不如), design classes so that their state is not directly visible to other classes! 如果狀態不會受外界影響, 就可以假設前置條件永遠成立, 因此只要做後置條件的檢查即可)'''__

=== Compiling Files That Use Assertions & Compatibility With Existing Programs ===

The addition of the `assert` keyword (through http://www.jcp.org/en/jsr/detail?id=41[JSR41]) to the Java programming language does not cause any problems with preexisting binaries (`.class` files). If you try to compile an application that uses `assert` as an identifier, however, you will receive a warning or error message. In order to ease the transition from a world where `assert` is a legal identifier to one where it isn't, the compiler supports two modes of operation in this release:

 * source mode 1.3 (default) — the compiler accepts programs that use `assert` as an identifier, but issues warnings. Otherwise, you will get the following error message: "as of release 1.4, 'assert' is a keyword, and may not be used as an identifier (try `-source 1.3` or lower to use 'assert' as an identifier)". In this mode, programs are not permitted to use the `assert` statement.
 * source mode 1.4 — the compiler generates an error message if the program uses `assert` as an identifier. In this mode, programs are permitted to use the `assert` statement.

Unless you specifically request source mode 1.4 with the `-source 1.4` flag, the compiler operates in source mode 1.3. If you forget to use this this flag, programs that use the new `assert` statement will not compile. Having the compiler use the old semantics as its default behavior (that is, allowing `assert` to be used as an identifier) was done for maximal source compatibility. Source mode 1.3 is likely to be phased out(逐步淘汰) over time.

In order for the `javac` compiler to accept code containing assertions, you must use the `-source 1.4` command-line option as in this example: (這就是所謂的 source compability)

 {{{
javac -source 1.4 MyClass.java
 }}}

This flag is necessary so as not to cause source compatibility problems. __Class files will contain calls to the new `ClassLoader` and `Class` methods, such as `desiredAssertionStatus`. If a class file containing calls to these methods is run against an older JRE (whose `ClassLoader` class doesn't define the methods), '''the program will fail at run time, throwing a `NoSuchMethodError`. It is generally the case that programs using new facilities are not compatible with older releases.'''__

=== Enabling and Disabling Assertions ===

By default, assertions are disabled at runtime (包括 system classes). Two command-line switches allow you to selectively enable or disable assertions.

To enable assertions at various granularities, use the `-enableassertions`, or `-ea`, switch. To disable assertions at various granularities, use the `-disableassertions`, or `-da`, switch. You specify the granularity with the arguments that you provide to the switch:

 * __no arguments: Enables or disables assertions in all classes ''except system classes''.__
 
 * __`packageName...`: Enables or disables assertions in the named package and any subpackages. ''Hierarchical control'' is useful, as programmers really do use package hierarchies to organize their code. For example, ''package-tree semantics'' allow assertions to be enabled or disabled in all of Swing at one time (`javax.swing...`).__
 
   .__按http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/java.html[這裡]的說法 - '''With one argument ending in "...", the switch enables assertions in the specified package and any subpackages.''' If the argument is simply "...", the switch enables assertions in the unnamed package in the current working directory. With one argument not ending in "...", the switch enables assertions in the specified class.__

 * `...`: Enables or disables assertions in the ''unnamed package(= default package)'' in the current working directory. (以 current working directory 當作是 default package 的起點[?])

 * `className`: Enables or disables assertions in the named class

For example, the following command runs a program, `BatTutor`, with assertions enabled in only package `com.wombat.fruitbat` and its subpackages:

 {{{
java -ea:com.wombat.fruitbat... BatTutor <-- 注意 -ea 與 -da 後要加上 ":"
 }}}

If a single command line contains multiple instances of these switches, they are processed in order before loading any classes. For example, the following command runs the `BatTutor` program with assertions enabled in package `com.wombat.fruitbat` but disabled in class `com.wombat.fruitbat.Brickbat`:

 {{{
java -ea:com.wombat.fruitbat... -da:com.wombat.fruitbat.Brickbat BatTutor
 }}}

__'''The above switches apply to all class loaders. With one exception, they also apply to system classes (which do not have an explicit class loader). The exception concerns(關係到...) the switches with no arguments, which (as indicated above) do not apply to system classes. This behavior makes it easy to enable asserts in all classes except for system classes, which is commonly desirable.'''__

To enable assertions in all system classes, use a different switch: `-enablesystemassertions`, or `-esa`. Similarly, to disable assertions in system classes, use `-disablesystemassertions`, or `-dsa`.

For example, the following command runs the `BatTutor` program with assertions enabled in system classes, as well as in the `com.wombat.fruitbat` package and its subpackages:

 {{{
java -esa -ea:com.wombat.fruitbat...
 }}}

The assertion status of a class (enabled or disabled) is set at the time it is initialized, and does not change. There is, however, one corner case that demands special treatment. It is possible, though generally not desirable, to execute methods or constructors prior to initialization. This can happen when a class hierarchy contains a circularity in its static initialization. If an `assert` statement executes before its class is initialized, the execution must behave as if assertions were enabled in the class.[?]

Why not provide a compiler flag to completely eliminate assertions from object files? __'''It is a firm(堅定的) requirement that it be possible to enable assertions in the field, for enhanced serviceability (難怪會有下面 "Requiring that Assertions are Enabled" 的需求; 應用在檢查不該出現在真正產品部署過程中的專用調試模式上時非常有用).'''__ It would have been possible to also permit developers to eliminate assertions from object files at compile time. (參考下面 "Removing all Trace of Assertions from Class Files" 一節) Assertions can contain side effects, though they should not, and such a flag could therefore alter the behavior of a program in significant ways. It is viewed as good thing that there is only one semantics associated with each valid Java program[?]. Also, we want to encourage users to leave asserts in object files so they can be enabled in the field. Finally, the spec demands that assertions behave as if enabled when a class runs before it is initialized. It would be impossible to offer these semantics if assertions were stripped from the class file. Note, however, that the standard "conditional compilation idiom" described in JLS 14.20 can be used to achieve this effect for developers who really want it.

== Preconditions with Exception or Assertion ==

__'''當我們將事情做切割時, 單位之間必然會產生所謂的 "介面", 而這個介面永遠都是兩個單位之間的外部關係, 沒有 "intra" 的模糊地帶;''' 就 A 單位裡面用到或包含 B, C 兩個單位時, A 還是只能透過 B 或 C 提供的介面做存取, 而無法直接存取 B 或 C 的內部細節 (同樣的, B 與 C 之間也無法直接存取對方的內部細節), 這有點像是 java package 的命名, 雖然看起來有上下關係, 不過其實每個 package 地位都是平行且獨立的. '''這個介面代表的意義是 - 每個單位都把份內的事情 "小心僅慎地" 做好, 每個用到這個單位服務的人都 "完全相信" 對方會把事情做好.'''__

__'''如果沒有做一些假設, 就會有處理不完的例外 - 例外不應被當成流程的一部份; 疑神疑鬼, 也就無法專心處理責任範圍內的業務. 每個 method 都應該設定目標聽眾 - caller 的範圍, 否則無法做出假設... (大膽假設, 小心求證!!)'''__

__'''主動呼叫時, 依據責任區分的原則, 不應該再用 `assert` 關鍵字去檢查其他 method 呼叫的回傳值 (倒是被呼叫端必須視情況用 assertion 去確認對 caller 的承諾), 除非對該 method 有不信任感 (通常是擔心 SPI/abstract protected method 沒有被正確的實作), 或者該 method 的 javadoc 寫得不清不楚, 否則就應該相信 javadoc 的承諾 - "如果我傳入了正確的參數, 就一定能夠得到預期的結果", 而不須再用 `assert` 做確認. (不過倒是可以視情況要求自己, 用 `assert` 關鍵字去檢查將傳入其他 method 的參數, 尤其是這個參數是經過自己小小複雜的運算而來的話, 但不用太刻意...)'''__

__'''被動呼叫時 (這裡尤其是指 private/non-API methods), 依據責任區分的原則, 包括 Javadoc 的承諾、framework 的設計 (例如 listener 的實作, 相信 caller - framework 會在正確的時間點, 以正確的參數呼叫我正在實作的方法; 當然這部份的細節也會在 Javadoc 提及)、資料庫內部資料的一致性 (最好能夠用 constraint 做確保) 等, 我們必須完全信任它, 當然也就沒有假設性的問題.'''__

__'''但如果上述的假設可能因內部組態不當而不再成立, 則建議對組態做 testing, 而不是再用 `assert` 做確認, 因為組態不當是內部實作的問題, 而非承諾本身有但書, 所謂的 testing 就是要測試實作是否符合要求...''', '''不過若現實狀況真的不如預期, 至少還可以從 method 最開頭的 trace logging 看出端倪 - 防人之心不可無, 因為世界並不完美, trace logging 將成為最後一道防線.'''__

 * public-API method: caller 不能依賴對方一定會依要求傳入適當的參數, 所以 "一定要" 用 exception 來擋 (通常是 `IllegalArgumentException`), 避免往下造成更大或更深層的錯誤, 並且告訴他們要怎麼更加小心地處理傳入的參數.
 * private-API method: 相信 caller 一定符合要求, 所以不用以 assertion 來確認; 如果傳入條件不符的參數 (只承諾單純地將要求轉入, 這些值都有可能沒有被適當地處理, 其至被惡意竄改), 包括可以由使用者組態的項目 (相對於內部組態, 不會由使用者調整)、URL 參數, 透過介面輸入的值等, 例如前端的 !JavaScript 被停用時. 如果前面沒有 validator 擋著, 在參數的處理上就要很小心 (經過 framework 或 validator 處理則另當別論, 因為它會做出承諾); 通常可以丟出 `RuntimeException` 將問題反應出來 (如果是為了反應使用者組態上的問題, 可以丟出 `IllegalArgumentException` 則更為合適).
 * non-API method: caller 是單位內的自己人, 當然可以相信. 但為了往系統邊界外提供更好的服務, 最好還是用 assertion 來確認, 一旦內部發生問題時, 我們就可以啟用 assertion, 更快地找到問題點.

 {{{
/**
 * public-API method
 *
 * @param data Data to be processed
 */
public void processData(Data data) {
  if (data == null)
    throw new IllegalArgumentException("data cannot be null");
  internalProcessData(data);
}

/**
 * non-API method
 *
 * @param data Data to be processed
 */
public void internalProcessData(Data data) {
  assert data != null;
  if (data.getParent() == null) // 相信內部的 caller, 否則會有處理不完的例外
    throw new RuntimeException("data cannot be null");

  Data parent = data.getParent();
  assert parent != null;
  parent.check(data);
}
 }}}

假設 `data.getParent()` 在 "正常" 狀況下不會傳回 `null` (但 javadoc 表示在特殊的情況下確實可能傳回 `null`; 如果 javadoc 上的承諾壓根說不可能傳回 `null`, 那就不會有這個假設性的問題), 既然 caller 在責任範圍內, 那麼下面一行 `data.getParent().check(data)` 的運算, 就可以做 `data.getParent()` 一定不會傳回 `null` 的假設, 並用 `assert` 來做確保 (因為理論上 `data.getParent()` 是有可能傳回 `null` 的, 雖然在理想的狀況下不會...)

這種狀況最常發生在 ORM 對應上來的 POJO, 例如:

 {{{
/**
 * 取得客戶名稱
 *
 * @return 客戶名稱, 可能是 <code>null</code>; 自資料庫取回時不會是
 *         <code>null</code>
 */
public String getName() {
    return name;
}

/**
 * 設定客戶名稱
 *
 * @param name 客戶名稱
 */
public void setName(String name) {
    this.name = name;
}
 }}}

__由於 Javadoc 的承諾是有 "自資料庫取回時" 但書的, 但我們卻無從判斷傳入的參數是否是從資料庫取回的, 還是人為造假的. (基本上程式內部也不太適合去做這個判斷, 這會使用單元測試無法進行) 因此我們只好做出傳入參數就是從資料庫取回的 "假設", 為了怕出差錯, 所以就要用 `assert` 來加以確保; '''也就是說, 如果該物件是自行取得的, 就可以完全信任而不用做 assertion;''' 這部份有沒有什麼方式可以緩解呢[?]__

== Advanced Uses ==

=== Removing all Trace of Assertions from Class Files ===

Programmers developing applications for resource-constrained devices may wish to strip(去除) assertions out of class files entirely. While this makes it impossible to enable assertions in the field, it also reduces class file size, possibly leading to improved class loading performance. In the absence of a high quality JIT, it could lead to decreased footprint and improved runtime performance.

The assertion facility offers no direct support for stripping assertions out of class files. The `assert` statement may, however, be used in conjunction with the "conditional compilation" idiom described in JLS 14.20 (原來條件式編譯是有正式被提到的...), enabling the compiler to eliminate all traces of these asserts from the class files that it generates:

 {{{
static final boolean asserts = ... ; // false to eliminate asserts

if (asserts)
    assert <expr> ;
 }}}

In this example, you cannot simply turn assertions on or off at runtime. You need to recompile the code in order to turn assertions off.

=== Requiring that Assertions are Enabled ===

Programmers of certain critical systems might wish to ensure that assertions are not disabled in the field. The following static initialization idiom prevents a class from being initialized if its assertions have been disabled: (啟用 assertion 不是相對耗資源嗎, 為何有一定要啟用 assertion 的需求[?])

 {{{
static {
    boolean assertsEnabled = false;
    assert assertsEnabled = true; // Intentional side effect!!!
    if (!assertsEnabled)
        throw new RuntimeException("Asserts must be enabled!!!");
}
 }}}

Put this static-initializer at the top of your class.

== Others ==

'''Why not provide a full-fledged design-by-contract facility with preconditions, postconditions and class invariants, like the one in the Eiffel programming language?'''

We considered providing such a facility, but were unable to convince ourselves that it is possible to graft it onto the Java programming language without massive changes to the Java platform libraries, and massive inconsistencies between old and new libraries. Further, we were not convinced that such a facility would preserve the simplicity that is the hallmark of the Java programming language. On balance, we came to the conclusion that a simple boolean assertion facility was a fairly straight-forward solution and far less risky. It's worth noting that adding a boolean assertion facility to the language doesn't preclude adding a full-fledged design-by-contract facility at some time in the future.

The simple assertion facility does enable a limited form of design-by-contract style programming. The `assert` statement is appropriate for nonpublic precondition, postcondition and class invariant checking. Public precondition checking should still be performed by checks inside methods that result in particular, documented exceptions, such as IllegalArgumentException and IllegalStateException.

== Practices ==

 * 在單一 method 的程式碼撰寫完成後, 再重新 review, 過程中才開始安插 assertion. (執疑某一行的運算為何能夠做一些假設)
 * 在開發 internal 的邏輯時, 想要做些假設少寫一些程式, 或是覺得做額外的檢查來丟出 unchecked exception 好像又多此一舉時, 可以善用 assertion, 就可以避開這個尷尬. 尤其是 JavaBean

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==

 * JavaBeans 這種 getter/setter 都開放, 而且透過 no-argument contructor 建立的狀況, 使用上會有一定的順序, 尤其是 getter 的呼叫可能一定要先呼叫過其他 setter, 這種情況最適合在 setter 檢查傳入的值是否合法, 在 getter 檢查相關的值是否都已經設定妥當.
