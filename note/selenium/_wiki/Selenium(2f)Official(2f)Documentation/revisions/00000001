= Selenium / Official / Documentation =
http://seleniumhq.org/docs/ @2010/05/17
<<TableOfContents>>

== Note to the Reader ==
http://seleniumhq.org/docs/00_Note_to-the-reader.html @2010/07/28

Hello, and welcome to Selenium! The Documentation Team would like to welcome you, and to thank you for being interested in Selenium.

We have worked very, very hard on this document. Why? We absolutely believe this is the best tool for web-application testing. We feel its extensibility and flexibility, along with its tight integration with the browser, is unmatched by available proprietary tools. We are very excited to promote Selenium and, hopefully, to expand its user community. In short, we really want to “get the word out” about Selenium.

We truly believe you will be similarly excited once you learn how Selenium approaches ''test automation''. It’s quite different from other tools. Whether you are brand-new to Selenium, or have been using it for awhile, we believe this documentation will truly help to spread the knowledge around. Also, we have aimed to write so that those completely new to test automation will be able to use this document as a stepping stone. No doubt, experienced users and “newbies” will benefit from our Selenium User’s Guide.

Please realize that this document is a work in progress. There are planned areas we haven’t written yet. However, we have written the beginning chapters first so newcomers can get started more smoothly. We have also already added some valuable information that more experienced users will appreciate. This document will be a ‘live’ document on the SeleniumHQ website where frequent updates will occur as we complete the additional planned documentation. We really want to hear about any problems you have with the documentation, or suggestions you have for improving it. For errors, please file a bug report. Improvement suggestions should be filed as an enhancement request.

Thanks very much for reading. – the Selenium Documentation Team

== Introducing Selenium ==
http://seleniumhq.org/docs/01_introducing_selenium.html @2010/07/28

=== To Automate or Not to Automate? That is the Question! ===

Is automation always advantageous? When should one decide to automate test cases?

It is not always advantageous to automate test cases. There are times when manual testing may be more appropriate. For instance, if the application’s user interface will change considerably in the near future, then any automation would need to be rewritten. Also, sometimes there simply is not enough time to build test automation. __For the short term, manual testing may be more effective. If an application has a very tight deadline, there is currently no test automation available, and it’s imperative that the testing get done within that time frame, then manual testing is the best solution.__

__However, automation has specific advantages for improving the ''long-term efficiency'' of a software team’s testing processes.__ Test automation supports:

 * __Frequent ''regression testing''__
 * Rapid feedback to developers during the development process
 * Virtually unlimited iterations of test case execution
 * Customized reporting of application defects
 * __Support for Agile and eXtreme development methodologies__
 * __'''Disciplined documentation of test cases (因為要自動化, 所以要符合一定格式的要求, 該給的東西都不能少)'''__
 * Finding defects missed by manual testing

=== Test Automation for Web Applications ===

Many, perhaps most, software applications today are written as web-based applications to be run in an Internet browser. The effectiveness of testing these applications varies widely among companies and organizations. In an era of continuously improving software processes, such as eXtreme programming (XP) and Agile, it can be argued that disciplined testing and quality assurance practices are still underdeveloped in many organizations. __Software testing is often conducted manually. At times, this is effective; however there are alternatives to manual testing that many organizations are unaware of, or lack the skills to perform.__ Utilizing these alternatives would in most cases greatly improve the efficiency of their software development by adding efficiencies to their testing.

Test automation is often the answer. Test automation means using a tool to run repeatable tests against the target application whenever necessary.

There are many advantages to test automation. Most are related to the repeatability of the tests and the speed at which the tests can be executed. There are a number of commercial and open source tools available for assisting with the development of test automation. Selenium is possibly the most widely-used open source solution. This user’s guide will assist both new and experienced Selenium users in learning effective techniques in building test automation for web applications.

This guide introduces Selenium, teaches its most widely used features, and provides useful advice in best practices accumulated from the Selenium community. Many examples are provided. Also, technical information on the internal structure of Selenium and recommended uses of Selenium are provided as contributed by a consortium of experienced Selenium users. It is our hope that this guide will get additional new users excited about using Selenium for test automation. We hope this guide will assist in “getting the word out” that quality assurance and software testing have many options beyond what is currently practiced. We hope this user’s guide and Selenium itself provide a valuable aid to boosting the reader’s efficiency in his or her software testing processes.

=== Introducing Selenium ===

__'''Selenium is a robust set of tools that supports rapid development of test automation for web-based applications.''' Selenium provides a rich set of testing functions specifically geared to the needs of testing of a web application. These operations are highly flexible, allowing many options for locating UI elements and comparing expected test results against actual application behavior.__

One of Selenium’s key features is the support for executing one’s tests on multiple browser platforms.

=== Selenium Components ===

Selenium is composed of three major tools. Each one has a specific role in aiding the development of web application test automation.

'''Selenium-IDE'''

__Selenium-IDE is the Integrated Development Environment for building Selenium ''test cases''. It operates as a Firefox add-on and provides an easy-to-use interface for developing and running individual test cases or entire ''test suites''.__ Selenium-IDE has a recording feature, which will keep account of user actions as they are performed and store them as a reusable script to play back. It also has a context menu (right-click) integrated with the Firefox browser, which allows the user to pick from a list of assertions and verifications for the selected location. Selenium-IDE also offers full editing of test cases for more precision and control.

__Although Selenium-IDE is a Firefox only add-on, tests created in it can also be run against other browsers by using Selenium-RC and '''specifying the name of the test suite on the command line'''.__

'''Selenium-RC (Remote Control)'''

Selenium-RC allows the test automation developer to use a programming language for maximum flexibility and extensibility in developing ''test logic''. For instance, if the application under test returns a result set, and if the automated test program needs to run tests on each element in the result set, the programming language’s iteration support can be used to iterate through the result set, calling Selenium commands to run tests on each item.

Selenium-RC provides an API (Application Programming Interface) and library for each of its supported languages: HTML, Java, C#, Perl, PHP, Python, and Ruby. __This ability to use Selenium-RC with a high-level programming language to develop test cases also allows the automated testing to be integrated with a project’s automated build environment.__

'''Selenium-Grid'''

Selenium-Grid allows the Selenium-RC solution to scale for large test suites or test suites that must be run in multiple environments.__ With Selenium-Grid, multiple instances of Selenium-RC are running on various operating system and browser configurations; Each of these when launching register with a ''hub''. When tests are sent to the hub they are then redirected to an available Selenium-RC, which will launch the browser and run the test.__ This allows for running tests in parallel, with the entire test suite theoretically taking only as long to run as the longest individual test.

=== Supported Browsers ===

|| Browser || Selenium-IDE || Selenium-RC || Operating Systems ||
|| Firefox 3.x || Record and playback tests || Start browser, run tests || Windows, Linux, Mac ||
|| Firefox 3 || Record and playback tests || Start browser, run tests || Windows, Linux, Mac ||
|| Firefox 2 || Record and playback tests || Start browser, run tests || Windows, Linux, Mac ||
|| IE 8 || Test execution only via Selenium-RC* || Start browser, run tests || Windows ||
|| IE 7 || Test execution only via Selenium-RC* || Start browser, run tests || Windows ||
|| IE 6 || Test execution only via Selenium-RC* || Start browser, run tests || Windows ||
|| Safari 4 || Test execution only via Selenium-RC || Start browser, run tests || Mac ||
|| Safari 3 || Test execution only via Selenium-RC || Start browser, run tests || Mac ||
|| Safari 2 || Test execution only via Selenium-RC || Start browser, run tests || Mac ||
|| Opera 10 || Test execution only via Selenium-RC || Start browser, run tests || Windows, Linux, Mac ||
|| Opera 9 || Test execution only via Selenium-RC || Start browser, run tests || Windows, Linux, Mac ||
|| Opera 8 || Test execution only via Selenium-RC || Start browser, run tests || Windows, Linux, Mac ||
|| Google Chrome || Test execution only via Selenium-RC (Windows) || Start browser, run tests || Windows ||
|| Others || Test execution only via Selenium-RC || Partial support possible** || As applicable ||

* __Tests developed on Firefox via Selenium-IDE can be executed on any other supported browser via a simple ''Selenium-RC command line''.__

** Selenium-RC server can start any executable, but depending on browser security settings there may be technical limitations that would limit certain features.

=== Flexibility and Extensibility ===

You’ll find that Selenium is highly flexible. There are multiple ways in which one can add functionality to Selenium’s framework to customize test automation for one’s specific testing needs. This is, perhaps, Selenium’s strongest characteristic when compared with proprietary test automation tools and other open source solutions. __Selenium-RC support for multiple programming and scripting languages allows the test writer to build any logic they need into their automated testing and to use a preferred programming or scripting language of one’s choice.__

__Selenium-IDE allows for the addition of user-defined “user-extensions” for creating additional commands customized to the user’s needs. Also, it is possible to re-configure how the Selenium-IDE generates its Selenium-RC code. This allows users to customize the generated code to fit in with their own test frameworks.__ Finally, Selenium is an Open Source project where code can be modified and enhancements can be submitted for contribution.

=== About this Book ===

This reference documentation targets both new users of Selenium and those who have been using Selenium and are seeking additional knowledge. It introduces the novice to Selenium test automation. __We do not assume the reader has experience in testing beyond the basics.__

The experienced Selenium user will also find this reference valuable. It compiles in one place a set of useful Selenium techniques and best practices by drawing from the knowledge of multiple experienced Selenium QA professionals.

The remaining chapters of the reference present:

 * Selenium Basics - Introduces Selenium by describing how to select the Selenium component most appropriate for your testing tasks. Also provides a general description of Selenium commands and syntax. This section allows you to get a general feel for how Selenium approaches test automation and helps you decide where to begin.

 * Selenium-IDE - Teaches how to build test cases using the Selenium Integrated Development Environment. This chapter also describes useful techniques for __making your scripts more readable when interpreting defects caught by your Selenium tests.__ We explain how your test script can be “exported” to the programming language of your choice. Finally, this section describes some configurations available for extending and customizing how the Selenium-IDE supports test case development.

 * Selenium Commands - Describes a subset of the most useful Selenium commands in detail. This chapter shows what types of actions, verifications and assertions can be made against a web application.

 * Selenium-RC - __Explains how to develop an automated test program using the ''Selenium-RC API''.__ Many examples are presented in both a programming language and a scripting language. Also, the installation and setup of Selenium-RC is covered here. __The various ''modes'', or configurations, that Selenium-RC supports are described, along with their ''trade-offs'' and limitations.__ Architecture diagrams are provided to help illustrate these points. A number of solutions to problems which are often difficult for the new user are described in this chapter. __'''This includes handling Security Certificates, https requests, pop-ups, and the opening of new windows.'''__

 * Test Design Considerations - Presents many useful techniques for using Selenium efficiently. This includes scripting techniques and programming techniques for use with Selenium-RC. __We cover examples of source code showing how to report defects in the application under test. We also cover techniques commonly asked about in the user group such as how to implement ''data-driven tests'' (tests where one can vary the data between different test passes).__

 * Selenium-Grid - This chapter is not yet developed.

 * User extensions - Presents all the information required for easily extending Selenium.

== Selenium Basics ==
http://seleniumhq.org/docs/02_selenium_basics.html @2010/07/28

=== Getting Started – Choosing Your Selenium Tool ===

Most people get started with Selenium-IDE. This is what we recommend. __It’s an easy way to get familiar with Selenium commands quickly.__ You can develop your first script in just a few minutes. Selenium-IDE is also very easy to install. See the chapter on Selenium-IDE for specifics.

You may also run your scripts from the Selenium-IDE. It’s simple to use and is recommended for less-technical users. __The IDE allows developing and running tests without the need for programming skills as required by Selenium-RC. The Selenium-IDE can serve as an excellent way to train junior-level employees in test automation.__ Anyone who understands how to conduct manual testing of a website can easily transition to using the Selenium-IDE for running and developing tests.

__Some testing tasks are too complex though for the Selenium-IDE. '''When programming logic is required Selenium-RC must be used.'''__ For example, any tests requiring iteration, such as testing each element of a variable length list requires running the script from a programming language. __Selenium-IDE does not support iteration or condition statements.__

__Finally, Selenium-Core is another way of running tests. One can run test scripts from a web-browser using the HTML interface `TestRunner.html`. This is the original method for running Selenium commands. It has limitations though; similar to Selenium-IDE, it does not support iteration.__

Selenium-Core also cannot switch between http and https protocols. Since the development of Selenium-IDE and Selenium-RC, more people are using these tools rather than Selenium-Core. __At the time of writing (April 09) it is still available and may be convenient for some. However, the Selenium community is encouraging the use of Selenium-IDE and RC and discouraging the use of Selenium-Core. '''Support for Selenium-Core is becoming less available and it may even be deprecated in a future release.'''__

=== Introducing Selenium Commands ===

==== Selenium Commands – Selenese ====

Selenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. __The command set is often called ''selenese''. These commands essentially create a ''testing language''.__

In selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for ''broken links'', input fields, selection list options, submitting forms, and table data among other things. __In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features.[?]__ The http://release.seleniumhq.org/selenium-core/1.0.1/reference.html[Command Reference] lists all the available commands.

__A command is what tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors and Assertions.__

----

'''Actions'''

__Actions are commands that generally ''manipulate the state of the application''. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.__

__Many Actions can be called with the “AndWait” suffix, e.g. “`clickAndWait`”. '''This suffix tells Selenium that the action will cause the browser to make a call to the server (更正確地講, 應該是 Page Reloading), and that Selenium should wait for a new page to load.'''__

----

'''Accessors'''

__Accessors examine the state of the application and store the results in variables, e.g. “`storeTitle`”. They are also used to automatically generate Assertions.[?]__

----

'''Assertions'''

__Assertions are like Accessors, but they verify that the state of the application conforms to what is expected.__ Examples include “make sure the page title is X” and “verify that this checkbox is checked”.

__All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and “waitFor”. For example, you can “`assertText`”, “`verifyText`” and “`waitForText`”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. '''This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.'''__

__“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the `setTimeout` action below).__

==== Script Syntax ====

Selenium commands are simple, they consist of the command and two parameters. For example:

|| `verifyText` || `//div//a[2]` || `Login` ||

The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:

|| `goBackAndWait` || || ||
|| `verifyTextPresent` || || `Welcome to My Home Page` (不是應該放到 Target 的位置嗎[?]) ||
|| `type` || `id=phone` || `(555) 666-7066` ||
|| `type` || `id=address1` || `${myVariableAddress}` ||

The command reference describes the parameter requirements for each command.

Parameters vary, however they are typically:

 * a ''locator'' for identifying a UI element within a page.
 * a ''text pattern'' for verifying or asserting expected page content
 * a text pattern or a selenium variable for entering text in an input field or for selecting an option from an option list.

Locators, text patterns, selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.

Selenium scripts that will be run from Selenium-IDE will be be stored in an HTML text file format. __This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a ''target'', and the final column contains a ''value''. The second and third columns may not require values depending on the chosen Selenium command, '''but they should be present. (意指可能跳過 Target, 只需要 Value[?])'''__ Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:

 {{{
<table>
  <tr><td>open</td><td></td><td>/download/</td></tr>
  <tr><td>assertTitle</td><td></td><td>Downloads</td></tr>
  <tr><td>verifyText</td><td>//h2</td><td>Downloads</td></tr>
</table>
 }}}

Rendered as a table in a browser this would look like the following:

|| `open` || || `/download/` ||
|| `assertTitle` || || `Downloads` ||
|| `verifyText` || `//h2` || `Downloads` ||

__The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language.__ With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.

=== Test Suites ===

__A test suite is a collection of tests. Often one will run all the tests in a test suite as one ''continuous batch-job''.__

When using Selenium-IDE, test suites also can be defined using a simple HTML file. __The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test.__ An example tells it all.

 {{{
<html>
<head>
<title>Test Suite Function Tests - Priority 1</title>
</head>
<body>
<table>
  <tr><td><b>Suite Of Tests</b></td></tr>
  <tr><td><a href="./Login.html">Login</a></td></tr>
  <tr><td><a href="./SearchValues.html">Test Searching for Values</a></td></tr>
  <tr><td><a href="./SaveValues.html">Test Save</a></td></tr>
</table>
</body>
</html>
 }}}

A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.

__Test suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways.__ Commonly JUnit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, NUnit could be employed. If using an interpreted language like Python with Selenium-RC than some simple programming would be involved in setting up a test suite. Since the whole reason for using Sel-RC is to make use of programming logic for your testing this usually isn’t a problem.

=== Commonly Used Selenium Commands ===

To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.

 * `open` - opens a page using a URL.
 * `click`/`clickAndWait` - performs a click operation, and optionally waits for a new page to load.
 * `verifyTitle`/`assertTitle` - verifies an expected page title.
 * `verifyTextPresent` - verifies expected text is ''somewhere'' on the page.
 * `verifyElementPresent` - verifies an expected UI element, as defined by its HTML tag, is present on the page.
 * `verifyText` - verifies expected text and it’s corresponding HTML tag are present on the page.
 * `verifyTable` - verifies a table’s expected contents.
 * `waitForPageToLoad` - pauses execution until an expected new page loads. __Called automatically when `clickAndWait` is used.__
 * `waitForElementPresent` - pauses execution until an expected UI element, as defined by its HTML tag, is present on the page.

=== Summary ===

Now that you’ve seen an introduction to Selenium, you’re ready to start writing your first scripts. We recommend beginning with the Selenium IDE and its context-sensitive, right-click, menu. __This will allow you to get familiar with the most common Selenium commands quickly,__ and you can have a simple script done in just a minute or two. Chapter 3 gets you started and then guides you through all the features of the Selenium-IDE.

== Selenium-IDE ==
http://seleniumhq.org/docs/03_selenium_ide.html @2010/07/28

=== Introduction ===

The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. __This is not only a time-saver, but also an excellent way of learning Selenium script syntax.__

This chapter is all about the Selenium IDE and how to use it effectively.

=== Installing the IDE ===

Using Firefox, first, download the IDE from the SeleniumHQ downloads page

When downloading from Firefox, you’ll be presented with the following window.

{{attachment:chapt3_img01_IDE_Installation.png}}

Select Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.

{{attachment:chapt3_img02_IDE_Installation.png}}

Restart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.

{{attachment:chapt3_img03_IDE_Installation.png}}

=== Opening the IDE ===

To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.

{{attachment:chapt3_img04_IDE_open.png}}

=== IDE Features ===

==== Menu Bar ====

The File menu allows you to create, open, and save test case and test suite files. The Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. __You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases.__ The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.

==== Toolbar ====

The toolbar contains buttons for controlling the execution of your test cases, including a ''step feature'' for debugging your test cases. The right-most button, the one with the red-dot, is the record button.

{{attacment:chapt3_img05_IDE_features.png}}

{{attachment:chapt3_img06_Speed_Control.png}} Speed Control: controls how fast your test case runs.

{{attachment:chapt3_img07_Run_All.png}} Run All: Runs the entire test suite when a test suite with multiple test cases is loaded.

{{attachment:chapt3_img08_Run.png}} Run: __Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.__

{{attachment:chapt3_img09_Pause.png}} Pause/Resume: Allows stopping and re-starting of a running test case.
step

{{attachment:chapt3_img11_Step.png}} __Step: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.__

{{attachment:chapt3_img12_TestRunner_Mode.png}} !TestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core !TestRunner. __The !TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the !TestRunner.__ Most users will probably not need this button.

{{attachment:chapt3_img13_Apply_Rollup_Rules.png}} Apply Rollup Rules: __This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action.[?]__ Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.

{{attachment:chapt3_img14_Record.png}} Record: Records the user’s browser actions.

==== Test Case Pane ====

Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.

{{attachment:chapt3_img15_Table_Format.png}}

The other tab - __Source displays the test case in the ''native format'' in which the file will be stored.__ By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.

The Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.

{{attachment:chapt3_img16_Entry_Fields.png}}

If you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.

==== Log/Reference/UI-Element/Rollup Pane ====

The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.

===== Log =====

__When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.__

{{attachment:chapt3_img17_Bottom_Box.png}}

===== Reference =====

The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode (下面 Table/Source View 的說法比較恰當). In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.

{{attachment:chapt3_img18_Bottom_Box_Ref.png}}

While the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.

===== UI-Element and Rollup =====

Detailed information on these two panes (which cover advanced features) can be found in the [[chrome://selenium-ide/content/selenium/scripts/ui-doc.html|UI-Element Documentation]] on the Help menu of Selenium-IDE.

=== Building Test Cases ===

There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.

==== Recording ====

Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default.

Note: This can be set to OFF as a default with an available user extension.

During recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:

 * clicking a link - click or clickAndWait commands
 * entering values - type command
 * selecting options from a drop-down listbox - select command
 * clicking checkboxes or radio buttons - click command

Here are some “gotchas” to be aware of: (顯然 Selenium IDE 不怎麼聰明)

 * __The `type` command may require clicking on some other area of the web page for it to record.__

 * __Following a link usually records a `click` command. You will often need to change this to `clickAndWait` to ensure your test case pauses until the new page is completely loaded.__ Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.

==== Adding Verifications and Asserts With the Context Menu ====

Your test cases will also need to check the properties of a web-page. This requires `assert` and `verify` commands. We won’t describe the specifics of these commands here; that is in the chapter on “Selenese” Selenium Commands. Here we’ll simply describe how to add them to your test case.

With Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing `verify` and/or `assert` commands.

The first time you use Selenium, there may only be one Selenium command listed. __As you use the IDE however, you will find additional commands will quickly be added to this menu.__ Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.

Let’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a `verifyTextPresent` command and the suggested parameter should be the text itself.

Also, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.

Try a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than `verifyTextPresent`. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting `verifyElementPresent` for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.

Again, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting though the IDE.

==== Editing ====

===== Insert Command =====

'''Table View'''

Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.

'''Source View'''

Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required). __Be sure to save your test before switching back to Table view.__

===== Insert Comment =====

Comments may be added to make your test case more ''readable''. These comments are ignored when the test case is run.

__Comments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.__

'''Table View'''

Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. __Now use the Command field to enter the comment. Your comment will appear in purple font.__

'''Source View'''

Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., `<!– your comment here –>`.

===== Edit a Command or Comment =====

'''Table View'''

Simply select the line to be changed and edit it using the Command, Target, and Value fields.

'''Source View'''

Since Source view provides the equivalent of a WYSIWYG editor (哪有?), simply modify which line you wish–command, parameter, or comment.

==== Opening and Saving a Test Case ====

The File=>Open, Save and Save As menu commands behave similarly to opening and saving files in most other programs. When you open an existing test case, Selenium-IDE displays its Selenium commands in the Test Case Pane.

Test suite files can also be opened and saved via the File menu. However, such operations have their own menu entries near the bottom; the Open, Save, and Save As items are only for files.

Note: At the time of this writing, there’s a bug, where at times, when the IDE is first opened and then you select File=>Open, nothing happens. If you see this, close down the IDE and restart it (you don’t need to close the browser itself). This will fix the problem.

=== Running Test Cases ===

The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.

 * Run a Test Case - Click the Run button to run the currently displayed test case.

 * Run a Test Suite - Click the Run All button to run all the test cases in the currently loaded test suite.

 * Stop and Start - The Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.

 * Stop in the Middle - You can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. __To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.__

 * Start from the Middle - You can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.

 * Run Any Single Command - Double-click any single command to run it by itself. This is useful when writing a single command. __It lets you immediately test a command you are constructing, when you are not sure if it is correct.__ You can double-click it to see if it runs correctly. This is also available from the context menu.

=== Using Base URL to Run Test Cases in Different Domains ===

__'''The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains.''' Suppose that a site named http://news.portal.com had an ''in-house beta site'' named http://beta.news.portal.com. Any test cases for these sites that begin with an `open` statement should specify a relative URL as the argument to `open` rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the `open` command’s argument onto the end of the value of Base URL.__ For example, the test case below would be run against http://news.portal.com/about.html:

{{attachment:chapt3_img20_BaseURL_prod.png}}

This same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:

{{attachment:chapt3_img21_BaseURL_beta.png}}

=== Debugging ===

Debugging means finding and fixing errors in your test case. This is a normal part of test case development.

We won’t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.

==== Breakpoints and Startpoints ====

The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.

To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.

It is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point. For example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests. However, you only need to login once, but you need to keep rerunning your tests as you are developing them. __You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.__

To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.

==== Stepping Through a Testcase ====

To execute a test case one command at a time (“step through” it), follow these steps:

 1. Start the test case running with the Run button from the toolbar.
 2. Immediately pause the executing test case with the Pause button.
 3. Repeatedly select the Step button.

==== Find Button ====

The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command. This is useful when building a locator for a command’s first parameter (see the section on locators in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. `click`, `clickAndWait`, `type`, and certain `assert` and `verify` commands, among others.

From Table view, select any command that has a locator parameter. __Click the Find button. Now look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.__

==== Page Source for Debugging ====

Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you’re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select ‘View->Page Source. The HTML opens in a separate window. Use its Search feature (Edit=>Find) to search for a keyword to find the HTML for the UI element you’re trying to test.

Alternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.

==== Locator Assistance ====

__Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead.__ This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.

This locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument). Below is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.

{{attachment:chapt3_img22_IDE_Locator_Assistance.png}}

=== Writing a Test Suite ===

A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE. The test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).

The test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.

__Selenium-IDE does not yet support loading pre-existing test cases into a test suite. Users who want to create or modify a test suite by adding pre-existing test cases must manually edit a test suite file.__

A test suite file is an HTML file containing a one-column table. Each cell of each row in the `<tbody>` section contains a link to a test case. The example below is of a test suite containing four test cases:

 {{{
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Sample Selenium Test Suite</title>
</head>
<body>
    <table cellpadding="1" cellspacing="1" border="1">
        <thead>
            <tr><td>Test Cases for De Anza A-Z Directory Links</td></tr>
        </thead>
    <tbody>
        <tr><td><a href="./a.html">A Links</a></td></tr>
        <tr><td><a href="./b.html">B Links</a></td></tr>
        <tr><td><a href="./c.html">C Links</a></td></tr>
        <tr><td><a href="./d.html">D Links</a></td></tr>
    </tbody>
    </table>
</body>
</html>
 }}}

Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.[?]

=== User Extensions ===

User extensions are !JavaScript files that allow one to create his or her own customizations and features to add additional functionality. __Often this is in the form of customized commands although this extensibility is not limited to additional commands.__

There are a number of useful http://wiki.openqa.org/display/SEL/Contributed+User-Extensions[extensions] created by users.

__Perhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals.__ This extension is the http://wiki.openqa.org/download/attachments/379/goto_sel_ide.js[goto_sel_ide.js]. For an example of how to use the functionality provided by this extension, look at the http://51elliot.blogspot.com/2008/02/selenium-ide-goto.html[page] created by its author.

To install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE’s Options=>Options=>General tab.

{{attachment:chapt3_img31_Extensions_install.png}}

After selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.

Information on writing your own extensions can be found near the bottom of the Selenium Reference document.

=== Format ===

Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.

If you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, i.e. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=>Save. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.

Also, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process. Each supported language has configuration settings which are editable. This is under the Options=>Options=>Format tab.

Note: At the time of this writing, this feature is not yet supported by the Selenium developers. However the author has altered the C# format in a limited manner and it has worked well.

=== Executing Selenium-IDE Tests on Different Browsers ===

__While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server.[?]__ This topic is covered in the Run Selenese tests section on Selenium-RC chapter. The `-htmlSuite` command-line option is the particular feature of interest.

=== Troubleshooting ===

Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:

{{attachment:chapt3_img30_Trouble_startup.png}}

This problem occurs occasionally when Selenium IDE is first brought up. The solution is to close and reopen Selenium IDE. The bug has been filed as SIDE-230.

{{attachment:chapt3_img24_Trouble_open.png}}

You’ve used File=>Open to try to open a test suite file. Use File=>Open Test Suite instead.

{{attachment:chapt3_img27_Trouble_timing.png}}

This type of error may indicate a ''timing problem'', i.e., the element specified by a locator in your command wasn’t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate `waitFor*` or `*AndWait` command immediately before the failing command.

{{attachment:chapt3_img28_Trouble_param.png}}

Whenever your attempt to use ''variable substitution'' fails as is the case for the `open` command above, it indicates that you haven’t actually created the variable whose value you’re trying to access. __This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa.__ In the example above, the two parameters for the `store` command have been erroneously placed in the reverse order of what is required. __'''For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.'''__

{{attachment:chapt3_img23_Trouble_ts.png}}

One of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the `.html` extension both in their filenames, and in the test suite file where they are referenced.

{{attachment:chapt3_img25_Trouble_space.png}}

__Selenium-IDE is very space-sensitive! An extra space before or after a command will cause it to be unrecognizable.__

{{attachment:chapt3_img26_Trouble_extension.png}}

Your extension file’s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=>Options=>General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.

{{attachment:chapt3_img29_Trouble_collapsed.png}}

This type of error message makes it appear that Selenium-IDE has generated a failure where there is none. However, Selenium-IDE is correct that the actual value does not match the value specified in such test cases. __The problem is that the log file error messages collapse a series of two or more spaces into a single space, which is confusing.__ In the example above, note that the parameter for `verifyTitle` has two spaces between the words “System” and “Division.” The page’s actual title has only one space between these words. Thus, Selenium-IDE is correct to generate an error, but is misleading in the nature of the error.

== Selenium Commands ==
http://seleniumhq.org/docs/04_selenese_commands.html @2010/07/29

Selenium commands, often called selenese, are the set of commands that run your tests. __A sequence of these commands is a test script.__ Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.

=== Verifying Page Elements ===

Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.

For example, will you test that...

 1. an element is present somewhere on the page?
 2. specific text is somewhere on the page?
 3. specific text is at a specific location on the page?

For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. __If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page,__ then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.

==== Assertion or Verification? ====

Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. __If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will '''allow you to review all failures on the page''' and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.__

__'''The best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands.'''__ An example follows:

|| Command || Target || Value ||
|| `open` || `/download/` || ||
|| `assertTitle` || `Downloads` || ||
|| `verifyText` || `//h2`  || `Downloads` ||
|| `assertTable` || `1.2.1` (表示第一個 Table 的 row 2, col 1[?]) || `Selenium IDE` ||
|| `verifyTable` || `1.2.2` || `June 3, 2008` ||
|| `verifyTable` || `1.2.3` || `1.0 beta 2` ||

The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.

==== verifyTextPresent ====

The command `verifyTextPresent` is used to verify specific text exists somewhere on the page. It takes a single argument–the ''text pattern'' to be verified. For example:

|| Command || Target || Value ||
|| `verifyTextPresent` || `Marketing Analysis` || ||

This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use `verifyTextPresent` when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.

==== verifyElementPresent ====

Use this command when you must test for the presence of a specific UI element, rather then its content. __This verification does not check the text, only the HTML tag.__ One common use is to check for the presence of an image.

|| Command || Target || Value ||
|| `verifyElementPresent` || `//div/p/img` || ||

This command verifies that an image, specified by the existence of an `<img>` HTML tag, is present on the page, and that it follows a `<div>` tag and a `<p>` tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.

`verifyElementPresent` can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions `<div>`, etc. Here are a few more examples.

|| Command || Target || Value ||
|| `verifyElementPresent` || `//div/p` || ||
|| `verifyElementPresent` || `//div/a` || ||
|| `verifyElementPresent` || `id=Login` || ||
|| `verifyElementPresent` || `link=Go to Marketing Research` || ||
|| `verifyElementPresent` || `//a[2]` || ||
|| `verifyElementPresent` || `//head/title` || ||

These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.

==== verifyText ====

Use `verifyText` when both the text and its UI element must be tested. `verifyText` must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.

|| Command || Target || Value ||
|| `verifyText` || `//table/tr/td/div/p` || `This is my text and it occurs right after the div inside the table.` ||

=== Locating Elements ===

For many Selenium commands, a target is required. This target identifies an element in the content of the web application, __and consists of the ''location strategy'' followed by the location in the format `locatorType=location`. The locator type can be omitted in many cases.__ The various locator types are explained below with examples for each.

==== Default Locators ====

You can choose to omit the locator type in the following situations:

 * Locators starting with “document” will use the DOM locator strategy. See Locating by DOM

 * Locators starting with “//” will use the XPath locator strategy. See Locating by XPath.

 * __Locators that start with anything other than the above or a valid locator type will default to using the identifier locator strategy.__ See Locating by Identifier.

==== Locating by Identifier ====

This is probably the most common method of locating elements and is the ''catch-all default'' when no recognised locator type is used. __With this strategy, the first element with the `id` attribute value matching the location will be used. If no element has a matching `id` attribute, then the first element with a `name` attribute matching the location will be used.__

For instance, your page source could have `id` and `name` attributes as follows:

 {{{
1 <html>
2  <body>
3   <form id="loginForm">
4    <input name="username" type="text" />
5    <input name="password" type="password" />
6    <input name="continue" type="submit" value="Login" />
7   </form>
8  </body>
9 <html>
 }}}

The following locator strategies would return the elements from the HTML snippet above indicated by line number:

 * `identifier=loginForm` (3)
 * `identifier=username` (4)
 * `identifier=continue` (5)
 * `continue` (5)

Since the identifier type of locator is the default, the `identifier=` in the first three examples above is not necessary.

==== Locating by Id ====

This type of locator is more limited than the `identifier` locator type, but also more explicit. Use this when you know an element’s `id` attribute.

 {{{
 1 <html>
 2  <body>
 3   <form id="loginForm">
 4    <input name="username" type="text" />
 5    <input name="password" type="password" />
 6    <input name="continue" type="submit" value="Login" />
 7    <input name="continue" type="button" value="Clear" />
 8   </form>
 9  </body>
10 <html>
 }}}

 * `id=loginForm` (3)

==== Locating by Name ====

__The `name` locator type will locate the first element with a matching `name` attribute. If multiple elements have the same value for a `name` attribute, then you can use ''filters'' to further refine your location strategy. The default ''filter type'' is `value` (matching the `value` attribute).__

 {{{
 1 <html>
 2  <body>
 3   <form id="loginForm">
 4    <input name="username" type="text" />
 5    <input name="password" type="password" />
 6    <input name="continue" type="submit" value="Login" />
 7    <input name="continue" type="button" value="Clear" />
 8   </form>
 9 </body>
10 <html>
 }}}

 * `name=username` (4)
 * `name=continue value=Clear` (7)
 * `name=continue Clear` (7)
 * `name=continue type=button` (7)

Note: __Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass.__ You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via `id` and `name` attributes, or really via any HTML property, becomes very important.

==== Locating by XPath ====

__XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications.__ XPath extends beyond (as well as supporting) the simple methods of locating by `id` or `name` attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

__One of the main reasons for using XPath is when you don’t have a suitable `id` or `name` attribute for the element you wish to locate. You can use XPath to either locate the element in ''absolute terms'' (not advised), or relative to an element that does have an `id` or `name` attribute. XPath locators can also be used to specify elements via attributes other than `id` and `name`.__

Absolute XPaths contain the location of all elements from the root (`html`) and as a result are likely to fail with only the slightest adjustment to the application. __By finding a nearby element with an `id` or `name` attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.__

Since only `xpath` locators start with “//”, it is not necessary to include the `xpath=` label when specifying an XPath locator.

 {{{
 1 <html>
 2  <body>
 3   <form id="loginForm">
 4    <input name="username" type="text" />
 5    <input name="password" type="password" />
 6    <input name="continue" type="submit" value="Login" />
 7    <input name="continue" type="button" value="Clear" />
 8   </form>
 9 </body>
10 <html>
 }}}

 * `xpath=/html/body/form[1]` (3) - Absolute path (would break if the HTML was changed only slightly)

 * `//form[1]` (3) - First form element in the HTML

 * `xpath=//form[@id='loginForm']` (3) - The form element with attribute named ‘id’ and the value ‘loginForm’

 * `xpath=//form[input/\@name='username']` (4) - First form element with an input child element with attribute named ‘name’ and the value ‘username’

 * `//input[@name='username']` (4) - First input element with attribute named ‘name’ and the value ‘username’

 * `//form[@id='loginForm']/input[1]` (4) - First input child element of the form element with attribute named ‘id’ and the value ‘loginForm’

 * `//input[@name='continue'][@type='button']` (7) - Input with attribute named ‘name’ and the value ‘continue’ and attribute named ‘type’ and the value ‘button’

 * `//form[@id='loginForm']/input[4]` (7) - Fourth input child element of the `form` element with attribute named ‘id’ and value ‘loginForm’

These examples cover some basics, but in order to learn more, the following references are recommended:

 * http://www.w3schools.com/Xpath/[W3Schools XPath Tutorial]
 * http://www.w3.org/TR/xpath[W3C XPath Recommendation]
 * http://www.zvon.org/xxl/XPathTutorial/General/examples.html[XPath Tutorial] - with interactive examples.

There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:

 * https://addons.mozilla.org/en-US/firefox/addon/1095?id=1095[XPath Checker] - suggests XPath and can be used to test XPath results.

 * Firebug - ''XPath suggestions'' are just one of the many powerful features of this very useful add-on.

==== Locating Hyperlinks by Link Text ====

__This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.__

 {{{
1 <html>
2  <body>
3   <p>Are you sure you want to do this?</p>
4   <a href="continue.html">Continue</a>
5   <a href="cancel.html">Cancel</a>
6 </body>
7 <html>
 }}}

 * `link=Continue` (4)
 * `link=Cancel` (5)

==== Locating by DOM ====

The Document Object Model represents an HTML document and can be accessed using !JavaScript. __This location strategy takes !JavaScript that evaluates to an element on the page, which can be simply the element’s location using the hierarchical dotted notation.__

Since only `dom` locators start with “document”, it is not necessary to include the `dom=` label when specifying a DOM locator.

 {{{
 <html>
  <body>
   <form id="loginForm">
    <input name="username" type="text" />
    <input name="password" type="password" />
    <input name="continue" type="submit" value="Login" />
    <input name="continue" type="button" value="Clear" />
   </form>
 </body>
 <html>
 }}}

 * `dom=document.getElementById('loginForm')` (3)
 * `dom=document.forms['loginForm']` (3)
 * `dom=document.forms[0]` (3)
 * `document.forms[0].username` (4)
 * `document.forms[0].elements['username']` (4)
 * `document.forms[0].elements[0]` (4)
 * `document.forms[0].elements[3]` (7)

You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on http://www.w3schools.com/HTMLDOM/dom_reference.asp[W3Schools].

==== Locating by CSS ====

CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. __CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.__

 {{{
 <html>
  <body>
   <form id="loginForm">
    <input class="required" name="username" type="text" />
    <input class="required passfield" name="password" type="password" />
    <input name="continue" type="submit" value="Login" />
    <input name="continue" type="button" value="Clear" />
   </form>
 </body>
 <html>
 }}}

 * `css=form#loginForm` (3)
 * `css=input[name="username"]` (4)
 * `css=input.required[type="text"]` (4)
 * `css=input.passfield` (5)
 * `css=#loginForm input[type="button"]` (4)
 * `css=#loginForm input:nth-child(2)` (5)

For more information about CSS Selectors, the best place to go is http://www.w3.org/TR/css3-selectors/[the W3C publication]. You’ll find additional references there.

Note: __Most experienced Selenium users recommend CSS as their locating strategy of choice as it’s considerably faster than XPath and can find the most complicated objects in an intrinsic HTML document. (如果不是互動性很高的頁面, 通常不太會去標 id, 再加上 CSS 比 XPath 快, 有些時候 CSS Locator 可能是最好的選擇)__

=== Matching Text Patterns ===

Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are `verifyTextPresent`, `verifyTitle`, `verifyAlert`, `assertConfirmation`, `verifyText`, and `verifyPrompt`. __And as has been mentioned above, '''link locators can utilize a pattern.'''__ Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.

__There are three types of patterns: globbing, regular expressions, and exact.__

==== Globbing Patterns ====

Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as `ls *.c`. In this case, globbing is used to display all the files ending with a `.c` extension that exist in the current directory. __Globbing is fairly limited. Only two special characters are supported in the Selenium implementation:__

 * `*` which translates to “match anything,” i.e., nothing, a single character, or many characters.

 * __`[ ]` (''character class'') which translates to “match any single character found inside the square brackets.” A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set).__ A few examples will make the functionality of a character class clear:

   * `[aeiou]` matches any lowercase vowel
   * `[0-9]` matches any digit
   * `[a-zA-Z0-9]` matches any alphanumeric character

__In most other contexts, globbing includes a third special character, the `?`. However, Selenium globbing patterns only support the asterisk and character class.__

__To specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a `glob:` label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself. (一般人會以為預設採用 Exact)__

Below is an example of two commands that use globbing patterns. The actual link text on the page being tested was “Film/Television Department”; by using a pattern rather than the exact text, the `click` command will work even if the link text is changed to “Film & Television Department” or “Film and Television Department”. The glob pattern’s asterisk will match “anything or nothing” between the word “Film” and the word “Television”.

|| Command || Target || Value ||
|| `click` || `link=glob:Film*Television Department` || ||
|| `verifyTitle` || `glob:*Film*Television*` || ||

The actual title of the page reached by clicking on the link was “De Anza Film And Television Department - Menu”. By using a pattern rather than the exact text, the `verifyTitle` will pass as long as the two words “Film” and “Television” appear (in that order) anywhere in the page’s title. For example, if the page’s owner should shorten the title to just “Film & Television Department,” the test would still pass. __Using a pattern for both a link and a simple test that the link worked (such as the `verifyTitle` above does) can greatly reduce the maintenance for such test cases. (聽起來有點怪怪的, 如果規格上就是 Extactly, 測試怎會有這種彈性?)__

==== Regular Expression Patterns ====

Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities `grep`, `sed`, and `awk`. __In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise.__ For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: `[0-9]+` is a simple pattern that will match a decimal number of any length.

Whereas Selenese globbing patterns support only the `*` and `[ ]` (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in !JavaScript. Below are a subset of those special characters:

|| PATTERN || MATCH ||
|| `.` || any single character ||
|| `[ ]` || character class: any single character that appears inside the brackets ||
|| `*` || quantifier: 0 or more of the preceding character (or group) ||
|| `+` || quantifier: 1 or more of the preceding character (or group) ||
|| `?` || quantifier: 0 or 1 of the preceding character (or group) ||
|| `{1,5}` || quantifier: 1 through 5 of the preceding character (or group) ||
|| `|` || alternation: the character/group on the left or the character/group on the right ||
|| `( )` || grouping: often used with alternation and/or quantifier ||

__Regular expression patterns in Selenese need to be prefixed with either `regexp:` or `regexpi:`. The former is case-sensitive; the latter is case-insensitive.__

A few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern–`.*` (“dot star”). This two-character sequence can be translated as “0 or more occurrences of any character” or more simply, “anything or nothing.” It is the equivalent of the one-character globbing pattern `*` (a single asterisk).

|| Command || Target || Value ||
|| `click` || `link=regexp:Film.*Television Department` || ||
|| `verifyTitle` || `regexp:.*Film.*Television.*` || ||

The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (`regexp:` instead of `glob:`) and the “anything or nothing” pattern (`.*` instead of just `*`).

The more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:

|| Command || Target || Value ||
|| open || `http://weather.yahoo.com/forecast/USAK0012.html` || ||
|| `verifyTextPresent` || `regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m` || ||

Let’s examine the regular expression above one part at a time:

|| `Sunrise: *` || The string Sunrise: followed by 0 or more spaces ||
|| `[0-9]{1,2}` || 1 or 2 digits (for the hour of the day) ||
|| `:` || The character `:` (no special characters involved) ||
|| `[0-9]{2}` || 2 digits (for the minutes) followed by a space ||
|| `[ap]m` || “a” or “p” followed by “m” (am or pm) ||

==== Exact Patterns ====

The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled “Real *” from a dropdown, the following code might work or it might not. The asterisk in the `glob:Real *` pattern will match anything or nothing. So, if there was an earlier select option labeled “Real Numbers,” it would be the option selected rather than the “Real *” option.

|| `select` || `//select` || `glob:Real *` ||

In order to ensure that the “Real *” item would be selected, the `exact:` prefix could be used to create an exact pattern as shown below:

|| `select` || `//select` || `exact:Real *` ||

But the same effect could be achieved via escaping the asterisk in a regular expression pattern:

|| `select` || `//select` || `regexp:Real \*` ||

It’s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.

=== The “AndWait” Commands ===

The difference between a command and its `AndWait` alternative is that the regular command (e.g. `click`) will do the action and continue with the following command as fast as it can, while the `AndWait` alternative (e.g. `clickAndWait`) tells Selenium to wait for the page to load after the action has been done.

__The `AndWait` alternative is always used when the action causes the browser to navigate to another page or reload the present one.__

Be aware, if you use an `AndWait` command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the `AndWait`‘s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.

=== The waitFor Commands in AJAX applications ===

__In AJAX driven web applications, data is retrieved from server without refreshing the page. Using `andWait` commands will not work as the page is not actually refreshed.__ Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system’s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. __'''The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.'''__

__This is done using `waitFor` commands, as `waitForElementPresent` or `waitForVisible`, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.__

=== Sequence of Evaluation and Flow Control ===

When a script runs, it simply runs in sequence, one command after another.

Selenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.

When flow control is needed, there are three options:

 1. Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language’s flow control features.

 2. __Run a small !JavaScript snippet from within the script using the `storeEval` command. (這跟 Flow Control 有什麼關係[?])__

 3. Install the `goto_sel_ide.js` extension.

Most testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (such as when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a !JavaScript snippet or the `goto_sel_ide.js` extension.

=== Store Commands and Selenium Variables ===

You can use Selenium variables to store constants at the beginning of a script. __Also, when combined with a data-driven test design (discussed in a later section), '''Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.'''__

The plain `store` command is the most basic of the many store commands and can be used to simply store a constant value in a selenium variable. It takes two parameters, the text value to be stored and a selenium variable. __Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable. (由下面的例子看來, Selenium 官方也滿習慣用駱駝文的)__

|| Command || Target || Value ||
|| `store` || `paul@mysite.org` || `userName` ||

Later in your script, you’ll want to use the stored value of your variable. __To access the value of a variable, enclose the variable in curly brackets (`{}`) and precede it with a dollar sign like this.__

|| Command || Target || Value ||
|| `verifyText` || `//div/p` || `${userName}` ||

A common use of variables is for storing input for an input field.

|| Command || Target || Value ||
|| `type` || `id=login` || `${userName}` ||

__Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.__

An equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.

'''`storeElementPresent`'''

This corresponds to `verifyElementPresent`. It simply stores a boolean value–”true” or “false”–depending on whether the UI element is found.

'''`storeText`'''

`storeText` corresponds to `verifyText`. It uses a locater to identify specific page text. The text, if found, is stored in the variable. `storeText` can be used to extract text from the page being tested.

'''`storeEval`'''

This command takes a script as its first parameter. Embedding !JavaScript within Selenese is covered in the next section. __`storeEval` allows the test to store the result of running the script in a variable.__

=== JavaScript and Selenese Parameters ===

!JavaScript can be used with two types of Selenese parameters–script and non-script (usually expressions). In most cases, you’ll want to access and/or manipulate a test case variable inside the !JavaScript snippet used as a Selenese parameter. (指的正是 `storeEval`) __All variables created in your test case are stored in a !JavaScript ''associative array''. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case’s variables is named `storedVars`.__ Whenever you wish to access or manipulate a variable within a !JavaScript snippet, you must refer to it as `storedVars['yourVariableName']`.

==== JavaScript Usage with Script Parameters ====

__Several Selenese commands specify a `script` parameter including `assertEval`, `verifyEval`, `storeEval`, and `waitForEval`. These parameters require no special syntax. (相對於下面 Non-Script Parameters 的用法)__ A Selenium-IDE user would simply place a snippet of !JavaScript code into the appropriate field, normally the Target field (because a `script` parameter is normally the first or only parameter).

The example below illustrates how a !JavaScript snippet can be used to perform a simple numerical calculation:

|| Command || Target || Value ||
|| `store` || `10` || `hits` ||
|| `storeXpathCount` || `//blockquote` || `blockquotes` ||
|| `storeEval` || `storedVars[‘hits’]-storedVars[‘blockquotes’]` || `paragraphs` ||

This next example illustrates how a !JavaScript snippet can include calls to methods, in this case the !JavaScript `String` object’s `toUpperCase` method and `toLowerCase` method.

|| Command || Target || Value ||
|| `store` || `Edith Wharton` || `name` ||
|| `storeEval` || `storedVars[‘name’].toUpperCase()` || `uc` ||
|| `storeEval` || `storedVars[‘name’].toLowerCase()` || `lc` ||

==== JavaScript Usage with Non-Script Parameters ====

__!JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type `script`. However, in this case, special syntax is required–the !JavaScript snippet must be enclosed inside curly braces and preceded by the label `javascript`, as in `javascript{*yourCodeHere*}`.__ Below is an example in which the `type` command’s second parameter value is generated via !JavaScript code using this special syntax:

|| Command || Target || Value ||
|| `store` || `league of nations` || `searchString` ||
|| `type` || `q` || `javascript{storedVars[‘searchString’].toUpperCase()}` ||

=== echo - The Selenese Print Command ===

Selenese has a simple command that allows you to print text to your test’s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. __Finally, `echo` statements can be used to print the contents of Selenium variables.__

|| Command || Target || Value ||
|| `echo` || `Testing page footer now.` || ||
|| `echo` || `Username is ${userName}` || ||

=== Alerts, Popups, and Multiple Windows ===

This section is not yet developed.

== Selenium-RC ==
http://seleniumhq.org/docs/05_selenium_rc.html @2010/10/06

=== Introduction ===

__Selenium-RC is the solution for tests that need more than simple browser actions and ''linear execution''. Selenium-RC uses the full power of programming languages to create more complex tests like reading and writing files, querying a database, and ''emailing test results''.__

You’ll want to use Selenium-RC whenever your test requires logic not supported by Selenium-IDE. What logic could this be? For example, Selenium-IDE does not directly support:

 * condition statements
 * iteration
 * logging and reporting of test results
 * error handling, particularly unexpected errors
 * database testing
 * test case grouping
 * re-execution of failed tests
 * __test case dependency__
 * __screenshot capture of test failures (雖然 IDE 支援 `captureEntirePageScreenshot`, 但無法控制在發生錯誤時截圖)__

Although these tasks are not supported by Selenium directly, all of them can be achieved by using programming techniques with a language-specific Selenium-RC client library.

In the Adding Some Spice to Your Tests section, you’ll find examples that demonstrate the advantages of using a programming language for your tests.

=== How Selenium-RC Works ===

First, we will describe how the components of Selenium-RC operate and the role each plays in running your test scripts.

==== RC Components ====

Selenium-RC components are:

 * __The Selenium Server which launches and kills browsers, interprets and runs the Selenese commands passed from the test program, and acts as an HTTP proxy, intercepting and verifying HTTP messages passed between the browser and the AUT (這裡的 AUT 指的是受測的頁面, 有別於 Selenium-Core; 跟 Same Origin Policy 有關?)__

 * __Client libraries which provide the interface between each programming language and the Selenium-RC Server.__

Here is a simplified architecture diagram....

{{attachment:chapt5_img01_Architecture_Diagram_Simple.png}}

The diagram shows __the client libraries communicate with the Server passing each Selenium command for execution. Then the server passes the Selenium command to the browser using Selenium-Core !JavaScript commands. The browser, using its !JavaScript interpreter, executes the Selenium command.__ This runs the Selenese action or verification you specified in your test script.

==== Selenium Server ====

__Selenium Server receives Selenium commands from your test program, interprets them, and ''reports back'' to your program the results of running those tests.__

__The RC server bundles Selenium Core and automatically ''injects'' it into the browser. This occurs when your test program opens the browser (using a client library API function). Selenium-Core is a !JavaScript program, actually a set of !JavaScript functions '''which ''interprets'' and executes Selenese commands using the browser’s built-in !JavaScript interpreter.'''__

__The Server receives the Selenese commands from your test program using simple HTTP GET/POST requests. This means you can use any programming language that can send HTTP requests to automate Selenium tests on the browser.__

==== Client Libraries ====

__The client libraries provide the programming support that allows you to run Selenium commands from a program of your own design. There is a different client library for each supported language. A Selenium client library provides a programming interface (API), i.e., a set of functions, which run Selenium commands from your own program.__ Within each interface, there is a programming function that supports each Selenese command.

__The client library takes a Selenese command and passes it to the Selenium Server for processing a specific action or test against the application under test (AUT). The client library also receives the result of that command and passes it back to your program.__ Your program can receive the result and store it into a program variable and report it as a success or failure, or possibly take corrective action if it was an unexpected error.

So to create a test program, you simply write a program that runs a set of Selenium commands using a client library API. And, optionally, if you already have a Selenese test script created in the Selenium-IDE, you can generate the Selenium-RC code. The Selenium-IDE can translate (using its Export menu item) its Selenium commands into a client-driver’s API function calls. See the Selenium-IDE chapter for specifics on exporting RC code from Selenium-IDE.

=== Installation ===

After downloading the Selenium-RC zip file from the downloads page, you’ll notice it has several sub-folders. These folders have all the components you need for using Selenium-RC with the programming language of your choice.

Once you’ve chosen a language to work with, you simply need to:

 * Install the Selenium-RC Server.
 * Set up a programming project using a language specific client driver.

==== Installing Selenium Server ====

__The Selenium-RC server is simply a Java jar file (`selenium-server.jar`), which doesn’t require any special installation.__ Just downloading the zip file and extracting the server in the desired directory is sufficient.

==== Running Selenium Server ====

Before starting any tests you must start the server. Go to the directory where Selenium-RC’s server is located and run the following from a command-line console.

 {{{
java -jar selenium-server.jar
 }}}

This can be simplified by creating a batch or shell executable file (`.bat` on Windows and `.sh` on Linux) containing the command above. Then make a shortcut to that executable on your desktop and simply double-click the icon to start the server.

For the server to run you’ll need Java installed and the `PATH` environment variable correctly configured to run it from the console. You can check that you have Java correctly installed by running the following on a console:

 {{{
java -version
 }}}

__If you get a version number (which needs to be 1.5 or later), you’re ready to start using Selenium-RC.__

==== Using the Java Client Driver ====

 * Download Selenium-RC from the SeleniumHQ downloads page.

 * Extract the file `selenium-java-client-driver.jar`.

 * Open your desired Java IDE (Eclipse, !NetBeans, IntelliJ, Netweaver, etc.)

 * Create a new project.

 * Add the `selenium-java-client-driver.jar` files to your project as references. (這跟下一個步驟有什麼不同?)

 * Add to your project classpath the file `selenium-java-client-driver.jar`.

 * From Selenium-IDE, export a script to a Java file and include it in your Java project, or write your Selenium test in Java using the selenium-java-client API. The API is presented later in this chapter. You can either use JUnit, or TestNG to run your test, or you can write your own simple `main()` program. These concepts are explained later in this section.

 * Run Selenium server from the console.

 * Execute your test from the Java IDE or from the command-line.

For details on Java test project configuration, see the Appendix sections Configuring Selenium-RC With Eclipse and Configuring 
Selenium-RC With Intellij.

==== Using the Python Client Driver ====

 * Download Selenium-RC from the SeleniumHQ downloads page
 * __Extract the file `selenium.py` (就這麼一支 `.py` 檔!!)__
 * Either write your Selenium test in Python or export a script from Selenium-IDE to a python file.
 * Add to your test’s path the file `selenium.py`
 * Run Selenium server from the console
 * Execute your test from a console or your Python IDE

For details on Python client driver configuration, see the appendix Python Client Driver Configuration.

=== From Selenese to a Program ===

The primary task for using Selenium-RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.

==== Sample Test Script ====

Let’s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.

|| `open` || `/` || ||
|| `type` || `q` || `selenium rc` ||
|| `clickAndWait` || `btnG` || ||
|| `assertTextPresent` || `Results * for selenium rc` || ||

Note: This example would work with the Google search page http://www.google.com

==== Selenese as Programming Code ====

Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object-oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.

In Java:

 {{{
package com.example.tests;

import com.thoughtworks.selenium.*;
import java.util.regex.Pattern;

public class NewTest extends SeleneseTestCase {
    public void setUp() throws Exception {
        setUp("http://www.google.com/", "*firefox");
    }
      public void testNew() throws Exception {
          selenium.open("/");
          selenium.type("q", "selenium rc");
          selenium.click("btnG");
          selenium.waitForPageToLoad("30000");
          assertTrue(selenium.isTextPresent("Results * for selenium rc"));
    }
}
 }}}

In Python:

 {{{
from selenium import selenium
import unittest, time, re

class NewTest(unittest.TestCase):
    def setUp(self):
        self.verificationErrors = []
        self.selenium = selenium("localhost", 4444, "*firefox",
                "http://www.google.com/")
        self.selenium.start()

    def test_new(self):
        sel = self.selenium
        sel.open("/")
        sel.type("q", "selenium rc")
        sel.click("btnG")
        sel.wait_for_page_to_load("30000")
        self.failUnless(sel.is_text_present("Results * for selenium rc"))

    def tearDown(self):
        self.selenium.stop()
        self.assertEqual([], self.verificationErrors)
 }}}

In the next section we’ll explain how to build a test program using the generated code.

=== Programming Your Test ===

Now we’ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:

 * Generate your script into a programming language from Selenium-IDE, optionally modifying the result.
 * Write a very simple main program that executes the generated code.

Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.

Here, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you’ll find a separate explanation for each.

==== Java ====

For Java, people use either JUnit or TestNG as the test engine. Some development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a “java-shop” chances are your developers will already have some experience with one of these test frameworks.

You will probably want to rename the test class from “NewTest” to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:

 {{{
selenium = new DefaultSelenium("localhost", 4444, "*iehta", "http://www.google.com/");
 }}}

The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.

 {{{
package com.example.tests;
// We specify the package of our tests

import com.thoughtworks.selenium.*;
// This is the driver's import. You'll use this for instantiating a
// browser and making it do what you need.

import java.util.regex.Pattern;
// Selenium-IDE add the Pattern module because it's sometimes used for
// regex validations. You can remove the module if it's not used in your
// script.

public class NewTest extends SeleneseTestCase {
// We create our Selenium test case

      public void setUp() throws Exception {
        setUp("http://www.google.com/", "*firefox");
             // We instantiate and start the browser
      }

      public void testNew() throws Exception {
           selenium.open("/");
           selenium.type("q", "selenium rc");
           selenium.click("btnG");
           selenium.waitForPageToLoad("30000");
           assertTrue(selenium.isTextPresent("Results * for selenium rc"));
           // These are the real test steps
     }
}
 }}}

==== Python ====

Pyunit is the test framework to use for Python. To learn Pyunit refer to its official documentation http://docs.python.org/library/unittest.html.

The basic test structure is:

 {{{
from selenium import selenium
# This is the driver's import.  You'll use this class for instantiating a
# browser and making it do what you need.

import unittest, time, re
# This are the basic imports added by Selenium-IDE by default.
# You can remove the modules if they are not used in your script.

class NewTest(unittest.TestCase):
# We create our unittest test case

    def setUp(self):
        self.verificationErrors = []
        # This is an empty array where we will store any verification errors
        # we find in our tests

        self.selenium = selenium("localhost", 4444, "*firefox",
                "http://www.google.com/")
        self.selenium.start()
        # We instantiate and start the browser

    def test_new(self):
        # This is the test code.  Here you should put the actions you need
        # the browser to do during your test.

        sel = self.selenium
        # We assign the browser to the variable "sel" (just to save us from
        # typing "self.selenium" each time we want to call the browser).

        sel.open("/")
        sel.type("q", "selenium rc")
        sel.click("btnG")
        sel.wait_for_page_to_load("30000")
        self.failUnless(sel.is_text_present("Results * for selenium rc"))
        # These are the real test steps

    def tearDown(self):
        self.selenium.stop()
        # we close the browser (I'd recommend you to comment this line while
        # you are creating and debugging your tests)

        self.assertEqual([], self.verificationErrors)
        # And make the test fail if we found that any verification errors
        # were found
 }}}

=== Learning the API ===

The Selenium-RC API uses naming conventions that, assuming you understand Selenese, much of the interface will be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.

==== Starting the Browser ====

In Java:

 {{{
setUp("http://www.google.com/", "*firefox");
 }}}

In Python:

 {{{
self.selenium = selenium("localhost", 4444, "*firefox",
                         "http://www.google.com/")
self.selenium.start()
 }}}

__Each of these examples opens the browser and represents that browser by assigning a “browser instance” to a program variable. This program variable is then used to call methods from the browser.__ These methods execute the Selenium commands, i.e. like `open` or `type` or the verify commands.

The parameters required when creating the browser instance are:

 * `host` - __Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case `localhost` is passed. In some clients this is an optional parameter.__

 * `port` - __Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.__

 * `browser` - __The browser in which you want to run the tests. This is a required parameter.__

 * `url` - __The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.__

__Note that some of the client libraries require the browser to be started explicitly by calling its `start()` method.__

==== Running Commands ====

Once you have the browser initialized and assigned to a variable (generally named “selenium”) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the `type` method of the selenium object:

 {{{
selenium.type("field-id", "string to type")
 }}}

In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by using the locator and the string you specified during the method call.

=== Reporting Results ===

:::

=== Server Options ===

When the server is launched, command line options can be used to change the default server behaviour.

Recall, the server is started by running the following.

 {{{
$ java -jar selenium-server.jar
 }}}

To see the list of options, run the server with the `-h` option.

 {{{
$ java -jar selenium-server.jar -h
 }}}

You’ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we’ve provided explanations for some of the more important options.

==== Proxy Configuration ====

If your AUT is behind an HTTP proxy which requires authentication then you should configure `http.proxyHost`, `http.proxyPort`, `http.proxyUser` and `http.proxyPassword` using the following command.

 {{{
$ java -jar selenium-server.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password
 }}}

:::

==== Specifying the Firefox Profile ====

__Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium-RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you’re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.__

First, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select “Run”, then type and enter one of the following:

 {{{
firefox.exe -profilemanager
 }}}

 {{{
firefox.exe -P
 }}}

Create the new profile using the dialog. Then __when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option `-firefoxProfileTemplate` and specify the path to the profile using it’s filename and directory path.__

 {{{
-firefoxProfileTemplate "path to the profile"
 }}}

Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.

More information about Firefox profiles can be found in Mozilla’s Knowledge Base

:::

=== Specifying the Path to a Specific Browser ===

You can specify to Selenium-RC a path to a specific browser. __This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium-RC. When specifying the ''run mode'', use the `*custom` specifier followed by the full path to the browser’s executable:__

 {{{
*custom <path to browser>
 }}}

=== Selenium-RC Architecture ===

Note: This topic tries to explain the technical implementation behind Selenium-RC. It’s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.

__To understand in detail how Selenium-RC Server works and why it uses ''proxy injection'' and heightened privilege modes you must first understand the same origin policy.[?]__

:::

