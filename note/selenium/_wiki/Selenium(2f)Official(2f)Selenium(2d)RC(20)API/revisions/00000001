= Selenium / Official / Selenium-RC API =
file:///tmp/selenium-rc-api-1.0.1.html
<<TableOfContents>>

= com.thoughtworks.selenium =

== Selenium Interface ==

 {{{
public interface Selenium
 }}}

All Known Implementing Classes: `DefaultSelenium`

Defines an object that runs Selenium commands.

:::

=== chooseCancelOnNextConfirmation() ===

 {{{
void chooseCancelOnNextConfirmation()
 }}}

By default, Selenium's overridden `window.confirm()` function will return `true`, as if the user had manually clicked OK; after running this command, the next call to `confirm()` will return `false`, as if the user had clicked Cancel. Selenium will then resume using the default behavior for future confirmations, automatically returning true (OK) unless/until you explicitly call this command for each confirmation.

__Take note - '''every time a confirmation comes up, you must consume it with a corresponding `getConfirmation`, or else the next selenium operation will fail.'''__

=== chooseOkOnNextConfirmation ===

 {{{
void chooseOkOnNextConfirmation()
 }}}

__Undo the effect of calling `chooseCancelOnNextConfirmation`.__ Note that Selenium's overridden `window.confirm()` function will normally automatically return `true`, as if the user had manually clicked OK, so you shouldn't need to use this command unless for some reason you need to change your mind prior to the next confirmation. __After any confirmation, Selenium will resume using the default behavior for future confirmations, automatically returning true (OK) unless/until you explicitly call `chooseCancelOnNextConfirmation` for each confirmation. (2010-08-04 實驗確認, 每一次 `chooseCancelOnNextConfirmation()` 的呼叫, 只能套用在一次 `window.confirm()` 的回應上, 之後又會固定回 `true`)__

Take note - every time a confirmation comes up, you must consume it with a corresponding `getConfirmation`, or else the next selenium operation will fail.

=== click ===

 {{{
void click(java.lang.String locator)
 }}}

Clicks on a link, button, checkbox or radio button. If the click action causes a new page to load (like a link usually does), call `waitForPageToLoad`. (不是 `click` 內部自己會去呼叫 `waitForPageToLoad`, 否則就不會有 `clickAndWait` 了)

Parameters:

 * `locator` - an element locator

=== createCookie ===

 {{{
void createCookie(java.lang.String nameValuePair,
                  java.lang.String optionsString)
 }}}

__Create a new cookie whose path and domain are same with those of current page under test, unless you specified a path for this cookie explicitly.__

Parameters:

 * `nameValuePair` - name and value of the cookie in a format "`name=value`"

 * `optionsString` - __options for the cookie. Currently supported options include '`path`', '`max_age`' and '`domain`'. the `optionsString`'s format is "`path=/path/, max_age=60, domain=.foo.com`". The order of options are irrelevant, the unit of the value of '`max_age`' is second. Note that specifying a domain that isn't a subset of the current domain will usually fail.__

=== getAttribute() ===

 {{{
java.lang.String getAttribute(java.lang.String attributeLocator)
 }}}

__Gets the value of an element attribute. The value of the attribute may differ across browsers (this is the case for the "style" attribute, for example).__

Parameters:

 * `attributeLocator` - an element locator followed by an `@` sign and then the name of the attribute, e.g. `"foo@bar"`

Returns: the value of the specified attribute

=== getConfirmation ===

 {{{
java.lang.String getConfirmation()
 }}}

__Retrieves the ''message'' of a !JavaScript confirmation dialog generated during the previous action. (注意!! 是使用者看到的訊息, 而非選擇的結果; 2010-08-04 實驗確認, 這個方法在 window.confirm() 之後, 至少要呼叫一次, 但最多也只能被呼叫一次)__

By default, the `confirm` function will return `true`, having the same effect as manually clicking OK. This can be changed by prior execution of the `chooseCancelOnNextConfirmation` command.

__If an confirmation is generated but you do not consume it with `getConfirmation`, the next Selenium action will fail.__

NOTE: __under Selenium, !JavaScript confirmations will NOT pop up a visible dialog.__

NOTE: __Selenium does NOT support !JavaScript confirmations that are generated in a page's `onload()` event handler. In this case a visible dialog WILL be generated and Selenium will hang until you manually click OK.__

Returns: the message of the ''most recent'' !JavaScript confirmation dialog

=== getCookie ===

 {{{
java.lang.String getCookie()
 }}}

Return all cookies of the current page under test.

Returns: all cookies of the current page under test

=== getEval ===

 {{{
java.lang.String getEval(java.lang.String script)
 }}}

Gets the result of evaluating the specified !JavaScript snippet. The snippet may have multiple lines, but only the result of the last line will be returned.

Note that, by default, the snippet will run in the context of the "selenium" object itself, so `this` will refer to the Selenium object. Use `window` to refer to the window of your application, e.g. `window.document.getElementById('foo')`

If you need to use a locator to refer to a single element in your application page, you can use `this.browserbot.findElement("id=foo")` where `"id=foo"` is your locator.

Parameters:

 * `script` - the !JavaScript snippet to run

Returns: the results of evaluating the snippet

=== mouseOver ===

 {{{
void mouseOver(java.lang.String locator)
 }}}

Simulates a user hovering a mouse over the specified element.

Parameters:

 * `locator` - an element locator

=== isTextPresent ===

 {{{
boolean isTextPresent(java.lang.String pattern)
 }}}

__Verifies that the specified text pattern appears somewhere on the rendered page ''shown'' to the user.__

Parameters:

 * `pattern` - a pattern to match with the text of the page

Returns: `true` if the pattern matches the text, `false` otherwise

=== open ===

 {{{
void open(java.lang.String url)
 }}}

__Opens an URL in the ''test frame''. This accepts both relative and absolute URLs. The "`open`" command waits for the page to load before proceeding, ie. the "`AndWait`" suffix is implicit. '''Note: The URL must be on the same domain as the ''runner HTML'' due to security restrictions in the browser (Same Origin Policy).''' If you need to open an URL on another domain, use the Selenium Server to start a new ''browser session'' on that domain.__

Parameters:

 * `url` - the URL to open; may be relative or absolute

=== setTimeout ===

 {{{
void setTimeout(java.lang.String timeout)
 }}}

Specifies the amount of time that Selenium will wait for actions to complete.

Actions that require waiting include "open" and the "waitFor*" actions.

The default timeout is 30 seconds.

Parameters:

 * `timeout` - a timeout in milliseconds, after which the action will return with an error

=== start() ===

 {{{
void start()
 }}}

Launches the browser with a new Selenium ''session''

=== start(String) ===

 {{{
void start(java.lang.String optionsString)
 }}}

Starts a new Selenium testing session with a `String`, representing a configuration

=== start(Object) ===

 {{{
void start(java.lang.Object optionsObject)
 }}}

Starts a new Selenium testing session with a configuration options object 

=== stop ===

 {{{
void stop()
 }}}

Ends the test session, killing the browser

=== type ===

 {{{
void type(java.lang.String locator,
          java.lang.String value)
 }}}

__Sets the value of an input field, as though you typed it in. (但不會觸發 Key Events)__

Can also be used to set the value of combo boxes, check boxes, etc. In these cases, value should be the value of the option selected, not the visible text. (用 `check()`/`uncheck()` 或 `select()` 等專用的方法會比較好)

Parameters:

 * `locator` - an element locator
 * `value` - the value to type

=== typeKeys ===

 {{{
void typeKeys(java.lang.String locator,
              java.lang.String value)
 }}}

__Simulates keystroke events on the specified element, as though you typed the value key-by-key.__

__This is a convenience method for calling `keyDown`, `keyUp`, `keyPress` for every character in the specified string; '''this is useful for dynamic UI widgets (like auto-completing combo boxes) that require explicit key events.'''__

__Unlike the simple "`type`" command, which forces the specified value into the page directly,__ this command may or may not have any visible effect, even in cases where typing keys would normally have a visible effect. For example, if you use "`typeKeys`" on a `form` element, you may or may not see the results of what you typed in the field.

In some cases, you may need to use the simple "`type`" command to set the value of the field and then the "`typeKeys`" command to send the keystroke events corresponding to what you just typed. (什麼情況下必須這麼做[?])

Parameters:

 * `locator` - an element locator
 * `value` - the value to type


