= Selenium RC(Remote Control) =
<<TableOfContents>>

== Overview ==

Selenium Remote Control is a test tool that allows you to write automated web application UI tests in any programming language against any HTTP website using any mainstream !JavaScript-enabled browser.

__Selenium Remote Control provides a Selenium Server, which can automatically start/stop/control any supported browser. It works by using Selenium Core, a pure-HTML+JS library that performs automated tasks in !JavaScript(在本機背景初始化一個 browser 操作, 但 browser 內部還是用 Selenium Core 做自動化測試, 同時也運用了 proxy 的技巧欺騙 browser, 巧妙地避開了 Same Origin Policy 的問題).__

__The Selenium Server communicates directly with the browser using AJAX (!XmlHttpRequest; 為何要動用到 !XmlHttpRequest[?]). You can send commands directly to the Server using simple HTTP GET/POST requests; that means that you can use any programming language that can make HTTP requests to automate Selenium tests on the browser. To further ease this process, we provide wrapper objects for a number of mainstream programming languages (Java, .NET, Perl, Python, and Ruby).__

__'''Finally, the Selenium Server acts as a client-configured HTTP proxy, to stand in between the browser and your website. This allows a Selenium-enabled browser to run !JavaScript on arbitrary websites.'''__

{{attachment:selenium-rc.png}}

The Selenium Server is great for testing complex AJAX-based web user interfaces under a Continuous Integration system. It is also an ideal solution for users of Selenium Core or Selenium IDE who want to write tests in a more expressive programming language than the Selenese HTML table format customarily(習慣上) used with Selenium Core.

Supported Platforms:

 * Windows:
   * Known working:
     * Internet Explorer 6.0 and 7.0
     * Firefox 1.5.0.8 and 2.0
     * Opera 8.5.4 and 9.0.2
   * Should work:
     * Firefox 0.8 to 2.0
     * Mozilla Suite 1.6+, 1.7+
     * Seamonkey 1.0
     * Opera 8.5+, 9
 * Mac OS X:
   * Known Working:
     * Firefox 1.5.0.4 and 2.0
   * Should work:
     * Safari 1.3+
     * Firefox 0.8 to 2.0
     * Camino 1.0a1
     * Mozilla Suite 1.6+, 1.7+
     * Seamonkey 1.0
   * Not yet supported:
     * !OmniWeb
 * Linux:
   * Known working:
     * Firefox 1.5.0.8 and 2.0
     * Opera 9.0.2
     * Konqueror 3.5.3
   * Should work:
     * Firefox 0.8 to 2.0
     * Mozilla Suite 1.6+, 1.7+
     * Konqueror 3.5+
     * Opera 8.5+, 9

== Getting Started ==

__The Selenium Server is written in Java, and requires the Java Runtime Environment (JRE) version 1.5.0 or higher in order to start. '''You'll also need to make sure that you have a supported browser installed.'''__

'''Windows''': If you're on Windows XP or Windows 2003, you can just use Internet Explorer for this example, or install Mozilla Firefox or Opera. If you're using Windows 2000, you'll need to install `reg.exe` in order to use Internet Explorer, but Firefox should work regardless. We recommend (but do not require) that you add your browser executable to your `PATH` environment variable. (If you do not explicitly add your browser's installation directory to the PATH, then you must install your browser in its standard location; Firefox's standard location is "`c:\Program Files\Mozilla Firefox\firefox.exe`"; Internet Explorer's standard location is "`c:\Program Files\Internet Explorer\iexplore.exe`".)

'''Unix/Linux''': Install Firefox and add the Firefox directory to your `PATH` environment variable. Note that on Unix/Linux we'll be trying to invoke "`firefox-bin`" directly, so make sure that executable is on the path; also don't forget to add the Firefox libraries to your `LD_LIBRARY_PATH`. If needed, we can invoke Firefox using a shell script (e.g. "`firefox`" or "`run-mozilla.sh`"), but in that case, we may not be able to stop Firefox until the server is shut down.

'''Mac OS X''': On Mac OS X, it should be enough to install `Firefox.app` in your `/Applications` directory. Note in order to control the browser accurately, we need to invoke the embedded Firefox executable (`firefox-bin`) directly in `/Applications/Firefox.app/Contents/MacOS`; if your browser isn't installed there, then you'll want to add the correct embedded location to your `PATH` environment variable as well as your `DYLD_LIBRARY_PATH` environment variable.

=== Interactive Mode ===

__'''Selenium Server "interactive mode" is a way of rapidly prototyping tests that requires no coding whatsoever''', so it's a good way to introduce new users to Selenium Remote Control.__ In interactive mode, you type your commands one by one into the Selenium Server command window; this allows you to immediately see the results of running your command in a working browser, on-the-spot(當場的). With that said, normally you'll be coding these tests in your favorite programming language, so the whole thing is completely automated(這裡的 "automated" 指的是自動轉換成程式語言嗎[?]).

Once you've got Java installed and ready to go, you can start the Selenium Server from the command line like this:

 `java -jar selenium-server.jar -interactive`

That will start the Selenium Server and allow you to type commands in the command window. After a number of log messages, you should see the following message:

 `Entering interactive mode... type Selenium commands here (e.g: cmd=open&1=http://www.yahoo.com)`

Let's begin by using Selenium Server to open up a browser. If you're on Windows and want to run your Selenium commands using Internet Explorer, try typing this:

 `cmd=getNewBrowserSession&1=*iexplore&2=http://www.google.com`

If you want to use Firefox, try this:

 `cmd=getNewBrowserSession&1=*firefox&2=http://www.google.com`

You're running the "`getNewBrowserSession`" command, using the browser of your choice (`*iexplore` for Internet Explorer, `*firefox` for Firefox, or `*opera` for Opera), starting at `www.google.com`(這裡只是組態 "starting at", 並沒有實際開啟 `www.google.com` 的網頁). Typing commands in this window automatically fires off HTTP web requests to the Selenium Server, requesting work to be done. (In non-interactive mode, you can use any automated tool you like to send these HTTP requests to the server, instead of typing them by hand.) When you press Enter, you'll see a message describing the request you just made:

 `---> Requesting http://localhost:4444/selenium-server/driver?cmd=getNewBrowserSession&1=*firefox&2=http://www.google.com`

If all goes well, you should see a new browser window starting with the browser of your choice. Back in the Selenium Server command window, you should see the following message:

 `Got result: OK,260113 on session 260113`

The first part of this message "`Got result: OK`" says that your request for work was successful. The second part of this message, the number, is a Session ID. The Session ID will be different every time you run the "`getNewBrowserSession`" command from the command line.

Let's try some more commands; let's do a Google search! We'll start by opening up the Google website. Type this in the Selenium Server command window, replacing the Session ID below with the number you got when you ran "`getNewBrowserSession`":

 `cmd=open&1=http://www.google.com/webhp&sessionId=260113`

When this command finishes, your browser window should reveal `google.com` in the lower frame. __(The `/webhp` makes sure we stay on `www.google.com`; otherwise, we might get redirected to a country-specific Google server, e.g., `www.google.fr`.)__ Don't forget that you need to replace the Session ID above with your own personal Session ID, the one you got when you ran the "`getNewBrowserSession`" command. __'''(If you use the wrong Session ID, you won't see an error message; the Selenium Server will just sit there, waiting for some browser to come in and do its work.)'''__

Now that Google is open, let's try typing something in the search box. Type this in the Selenium Server command window:

 `cmd=type&1=q&2=hello world&sessionId=260113`

Again, don't forget to replace the Session ID with your own Session ID. If all goes to plan, you should see "hello world" in the search box for your Google search.

Now, let's do a search!

 `cmd=click&1=btnG&sessionId=260113`

You should now see the results of your Google Search in your browser window. You can run dozens of Selenium commands to automate all manner of browsing tasks. For more information on particular commands, you can go look at the Selenium Core section at the Open QA website, or check out the reference materials available for any of our ''Client Drivers'' (Java, .NET, Perl, PHP, Python or Ruby).

The next thing we might want to do is read some information back out of the page... for example, let's retrieve the HTML title of the current page, like this:

 `cmd=getTitle&sessionId=260113`

The browser will return the title of the HTML page we've loaded, like this:

 `Got result: OK,hello world - Google Search on session 260113`

That's enough Interactive Mode for now; let's move on to writing some code! But before we go, let's stop the browser we started. Type this command in the Selenium Server command window:

 `cmd=testComplete&sessionId=260113`

When this command finishes, your browser window should automatically close. To quit the Selenium Server, type "`quit`" or just press `Ctrl-C`.

=== Programming a Selenium RC Test ===

Now that you know how to run commands in interactive mode, let's code this test up! Here's examples of writing the test we just wrote in five different programming languages:

==== Java (JUnit) ====

 {{{
import com.thoughtworks.selenium.*;
import junit.framework.*;
public class GoogleTest extends TestCase {
    private Selenium sel;
    public void setUp() {
        sel = new DefaultSelenium("localhost",
            4444, "*firefox", "http://www.google.com");
        sel.start();
    }

    public void testGoogle() {
        sel.open("http://www.google.com/webhp");
        sel.type("q", "hello world");
        sel.click("btnG");
        sel.waitForPageToLoad("5000");
        assertEquals("hello world - Google Search", sel.getTitle());
    }

    public void tearDown() {
        sel.stop();
    }
}
 }}}

==== C# (NUnit) ====

 {{{
using Selenium;
using NUnit.Framework;
namespace MyTests {
    [TestFixture]
    public class GoogleTest {
        private ISelenium sel;

        [SetUp]
        public void SetUp() {
            sel = new DefaultSelenium("localhost",
                4444, "*firefox", "http://www.google.com");
            sel.Start();
        }

        [Test]
        public void testGoogle() {
            sel.Open("http://www.google.com/webhp");
            sel.Type("q", "hello world");
            sel.Click("btnG");
            sel.WaitForPageToLoad("5000");
            Assert.AreEqual("hello world - Google Search", sel.GetTitle());
        }

        [TearDown]
        public void TearDown() {
            sel.stop();
        }
    }
}
 }}}

==== Perl (Test::More) ====

 {{{
use WWW::Selenium;
use Test::More;

plan tests => 1;

my $sel = WWW::Selenium->new( host => "localhost",
                              port => 4444,
                              browser => "*iexplore",
                              browser_url => "http://www.google.com";,
                            );
$sel->start();
$sel->open("http://www.google.com");
$sel->type("q", "hello world");
$sel->click("btnG");
$sel->wait_for_page_to_load(5000);
like($sel->get_title(), qr/Google Search/);
$sel->stop();
 }}}

==== PHP (PHPUnit) ====

 {{{
<?php

require_once 'Testing/Selenium.php';
require_once 'PHPUnit/Framework/TestCase.php';

class GoogleTest extends PHPUnit_Framework_TestCase
{
    private $selenium;

    public function setUp()
    {
        $this->selenium = new Testing_Selenium("*firefox", "http://www.google.com");
        $this->selenium->start();
    }

    public function tearDown()
    {
        $this->selenium->stop();
    }

    public function testGoogle()
    {
        $this->selenium->open("/");
        $this->selenium->type("q", "hello world");
        $this->selenium->click("btnG");
        $this->selenium->waitForPageToLoad(10000);
        $this->assertRegExp("/Google Search/", $this->selenium->getTitle());
    }

}
?>
 }}}

==== Python (unittest) ====

 {{{
import unittest
import selenium

class GoogleTest(unittest.TestCase):
    def setUp(self):
        self.selenium = selenium.selenium_class("localhost", \
            4444, "*firefox", "http://www.google.com")
        self.selenium.start()

    def test_google(self):
        sel = self.selenium
        sel.open("http://www.google.com/webhp")
        sel.type("q", "hello world")
        sel.click("btnG")
        sel.wait_for_page_to_load(5000)
        self.assertEqual("hello world - Google Search", sel.get_title())

    def tearDown(self):
        self.selenium.stop()

if __name__ == "__main__":
    unittest.main()
 }}}

==== Ruby (Test::Unit) ====

 {{{
require 'test/unit'
require 'selenium'

class GoogleTest < Test::Unit::TestCase

   def setup
      @sel = Selenium::SeleniumDriver.new("localhost", 4444,
         "*firefox", "http://www.google.com", 15000)
      @sel.start
   end

   def test_google
      @sel.open("http://www.google.com/webhp")
      @sel.type("q", "hello world")
      @sel.click("btnG")
      @sel.wait_for_page_to_load("5000")
      assert_equal("hello world - Google Search", @sel.get_title())
   end

   def teardown
      @sel.stop
   end
end
 }}}

== The Same Origin Policy ==

As you were running your tests, you may have noticed that your browser started at the following URL:

 `http://www.google.com/selenium-server/RemoteRunner.html?sessionId=260113`

__That's a rather unusual URL, because, of course, there is no such file available on `www.google.com`. If you open up your browser manually and browse to that URL, you'll get a 404 error. What's going on?__

The Selenium Server is attempting to circumvent(避開) a very difficult problem in !JavaScript automated testing: normally, !JavaScript you write yourself can't be run on `google.com`, due to a policy known as the same origin policy. (That write-up(捧場) is from the Mozilla website, but all modern !JavaScript browsers enforce this policy.) The same origin policy makes a lot of sense. Let's say you've got your browser window pointing at, let's say, your bank's website, but you also have another webpage open pointing to someone's blog. !JavaScript is allowed to read values from web pages, as well as change data appearing on webpages you've loaded. A malicious(心懷不軌的) blogger could read your bank data, or worse, rewrite your bank page to make it think it was saying something else. He could use this to trick you into giving him sensitive information. __'''The Same Origin Policy states that !JavaScript is only allowed to read/modify HTML from the same origin as its source.'''__

That creates a big problem for Selenium automated tests. If you wrote a `.js` file designed to test `google.com`, the same origin policy denies you the right to just run that `.js` file on `google.com`; instead, you'd have to somehow install that `.js` file on `google.com` in order to write automated tests against it. In the case of `google.com` we don't have the right to do this; but even if we did, it would be a hassle(爭論) to do so.

__That's where the Selenium Server comes in. '''The Selenium Server is acting as a client-configured proxy for the browser that you automatically started with "`getNewBrowserSession`". Specifically, it configures your browser to use the Selenium Server as a proxy in its browser preferences.'''__

__A proxy normally fetches HTML pages on your behalf(代表某人); if a page can't be found, it honestly(老老實實) reports that the page wasn't there. But the Selenium Server is a very different kind of proxy; when the browser requests a page through the proxy that contains "`/selenium-server/`" in its URL, the Selenium Server doesn't simply fetch the page from the remote server, but instead automatically returns its own page instead(加工過的版本而言). '''That makes the browser think that the remote server itself actually contained the page in question, which allows us to "inject" arbitrary !JavaScript into `google.com` without modifying `google.com` in any way at all.'''__

However, the solution isn't perfect. Try running your tests like this:

 {{{
cmd=getNewBrowserSession&1=*iexplore&2=http://www.yahoo.com
cmd=open&1=http://www.google.com&sessionId=260113
cmd=type&1=q&2=hello world&sessionId=260113
 }}}

In this case, the "start URL" was `yahoo.com`, so the browser opened to

 `http://www.yahoo.com/selenium-server/RemoteRunner.html?sessionId=260113`

and then we tried to open up `google.com` (which did work...) and type "`Hello World`" into the search box. But `yahoo.com` doesn't have the right to modify `google.com`, so that operation fails[?].

__All this means is that you have to choose your browser's start URL wisely: if you open up the browser to `yahoo.com`, you can't use it to test `google.com`, and vice versa.__

__However, in some cases, you may be required to test more than one domain at once. The most common case is when you need to test both `http://blah.com` and `https://blah.com`. "`http:`" and "`https:`" are considered different "origins" from !JavaScript perspective, so tests running on one can't run on the other. '''In that case, for now, you'll have to use one of our ''experimental browser launchers'' which support running in multiple domains.'''__

== Run tests under multi-window mode ==

By default, Selenium runs the application under test in a subframe. (Running the AUT in a subframe gives us a great deal of control over the AUT.) But some apps don't run properly in a subframe, preferring to be loaded into the top frame of the window. In that case, you need to make your application under test run in a seperate window rather than in the default frame. To do that, start selenium server with the `-multiWindow` parameter:

 `java -jar selenium-server.jar -multiWindow`

Note that `multiWindow` mode is a little less stable than running in a frame, so you should probably avoid doing this if you can possibly help it.

== Using the Java Client Driver ==

First, make sure you've already started the Selenium Server separately in another process(利用 `java -jar selenium-server.jar` 的方式啟動). The Selenium Server should remain up and running throughout this process; you shouldn't need to start/stop it each time you use the Client Driver. (Though, of course, if you need to start and stop the server, you certainly can, just by automatically starting it from the command line.)

__Just add `selenium-java-client-driver.jar` to your classpath, and create a new `DefaultSelenium` object. You'll need to give it the hostname and port of the Selenium Server(參考 Server 啟動後的回應, 例如 `INFO: Started SocketListener on 0.0.0.0:4444`), the browser string to use with "`getNewBrowserSession`", and the base URL at which we'll start testing. When you're ready to begin, run the `.start()` method on your `DefaultSelenium` object; when it's time to close the browser, use the `.stop()` method.__

__You do not need `selenium-server.jar` in your classpath if the Selenium Server is already running. The Java client driver just needs to connect to the Selenium Server; `selenium-server.jar` doesn't need to run in the same JVM, or even on the same machine. '''We recommend the running the Selenium Server on many different machines, ideally with many different operating systems and browsers; your client driver can connect directly to those machines by specifying a different `hostname` in the `DefaultSelenium` constructor. (適用於 Browser compatibility testing)'''__

The `DefaultSelenium` object is full of handy methods that handle your Selenium Commands. If one of them has an error (or if an "assert" command fails) the method will throw an exception with a handy error message, which you can wrap up in a try/catch block if you like.

While we recommend that you use the Java Client Driver together with a testing framework like JUnit or !TestNG, a testing framework is not required; you can use the Java Client Driver with any program whatsoever to automate tasks in your browser.

__If you do run your tests in JUnit you may run into a common issue with organizing the tests: if you start your browser during `setUp` and then stop your browser during `tearDown`, you'll very likely be stopping and starting your browser dozens or even hundreds of times throughout the test run. Furthermore, there's no easy way to configure JUnit to run the same test multiple times with different configurations (aka "data-driven" testing). '''TestNG makes these tasks very easy, so you may prefer to use !TestNG for that purpose.'''__

__With that said, JUnit is the the de facto(實際上的) standard for Java automated tests. If you want to use JUnit anyway, you'll probably want to look into using a http://www.cs.wm.edu/%7Enoonan/junit/doc/faq/faq.htm#organize_3[global setUp and tearDown]. '''Note that the JUnit team recommends that you not use !TestSetup, because JUnit is a unit testing tool (for verifying your code in isolation) rather than an integration or functional testing tool (for verifying your code's compatibility with particular browsers). Think about using !TestNG instead. (很顯然地, 不是 !TestNG 比 JUnit 好, 而是 !TestNG 比較適合用在 functional testing; 即使如此, 官方網站上的範例還是都用 JUnit 來寫)'''__

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
|| [[File:/S/Selenium RC/selenium-remote-control-0.9.0.zip|selenium-remote-control-0.9.0.zip]] || Selenium Remote Control 0.9.0 ||
|| [[attachment:GoogleTest.java|GoogleTest.java]] || Java Client Driver 範例一 ||
|| [[attachment:RealDealIntegrationTest.java|RealDealIntegrationTest.java]] || Java Client Driver 範例二 ||

=== Links ===

=== Search ===

== Scratch ==
