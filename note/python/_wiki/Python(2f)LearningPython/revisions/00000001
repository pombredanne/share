= Python / Learning Python, Third Edition =
http://oreilly.com/catalog/9780596513986/index.html
<<TableOfContents>>

== Preface ==

:::

== Chapter 1. A Python Q&A Session ==

If you’ve bought this book, you may already know what Python is, and why it’s an important tool to learn. If you don’t, you probably won’t be sold on(有購買的慾望) Python until you’ve learned the language by reading the rest of this book and have done a project or two. But before we jump into details, the first few pages of this book will briefly introduce some of the main reasons behind Python’s popularity. To begin sculpting(雕刻) a definition of Python, this chapter takes the form of a question-and-answer session, which poses(提出) some of the most common questions asked by beginners.

=== Why Do People Use Python? ===

Because there are many programming languages available today, this is the usual first question of newcomers. Given that there are roughly 1 million Python users out there at the moment, there really is no way to answer this question with complete accuracy. The choice of development tools is sometimes based on unique constraints or personal preference.

But after teaching Python to roughly 200 groups and 3,000 students during the last 10 years, some common themes have emerged(浮現). The primary factors cited by Python users seem to be these:

'''Software quality'''

For many, Python’s focus on readability, coherence(一致性), and software quality in general sets it apart from other tools in the scripting world. Python code is designed to be readable, and hence, reusable and maintainable—much more so than traditional scripting languages. The uniformity(一致) of Python code makes it easy to understand, even if you did not write it. In addition, __Python has deep support for more advanced software ''reuse mechanisms'', such as object-oriented programming (OOP).__

'''Developer productivity'''

Python boosts developer productivity many times beyond compiled or ''statically typed'' languages such as C, C++, and Java. __Python code is typically one-third to one-fifth the size of equivalent C++ or Java code. '''That means there is less to type, less to debug, and less to maintain after the fact. (從 "好不好維護" 的角度來看, 程式的大小確實有關係!!)'''__ Python programs also run immediately, without the lengthy compile and link steps of some other tools, further boosting programmer speed.

'''Program portability'''

__Most Python programs run unchanged on all major computer platforms. Porting Python code between Linux and Windows, for example, is usually just a matter of copying a script’s code between machines.__ Moreover, Python offers multiple options for coding portable graphical user interfaces, database access programs, web-based systems, and more. Even ''operating system interfaces'', including program launches and directory processing, are as portable in Python as they can possibly be.

'''Support libraries'''

__Python comes with a large collection of prebuilt and portable functionality, known as the ''standard library''. This library supports an array of ''application-level'' programming tasks,__ from text pattern matching to network scripting. In addition, Python can be extended with both homegrown libraries and a vast collection of third-party application support software. Python’s third-party domain offers tools for web site construction, numeric programming, serial port access, game development, and much more. __The http://numpy.scipy.org/[NumPy] extension, for instance, has been described as a free and more powerful equivalent to the Matlab numeric programming system.__

'''Component integration'''

__'''Python scripts can easily communicate with other parts of an application, using a variety of ''integration mechanisms''. Such integrations allow Python to be used as a ''product customization and extension tool''. (系統整合是 Python 的強項!! 這說明了為何 Python 如此強大的原因, 它習慣於把所有好用的東西 "包裝" 起來 - 而非重新造輪, 達到方便開發的好處!!)''' Today, Python code can invoke C and C++ libraries, can be called from C and C++ programs, can integrate with Java components, can communicate over frameworks such as COM and .NET, and can interact over networks with interfaces like SOAP, XML-RPC, and CORBA. It is not a standalone tool.__

'''Enjoyment'''

Because of Python’s ease of use and ''built-in toolset'', it can make the act of programming more pleasure than chore(雜務). Although this may be an intangible(無形的) benefit, its effect on productivity is an important asset. Of these factors, the first two (quality and productivity) are probably the most compelling benefits to most Python users.

==== Software Quality ====

__By design, Python implements a deliberately(故意地) ''simple and readable syntax'', and a highly coherent(一致的) programming model.__ As a slogan at a recent Python conference attests(證實), the net result is that Python seems to “fit your brain”—that is, features of the language interact in consistent and ''limited'' ways, and follow naturally from a small set of core concepts. __This makes the language easier to learn, understand, and remember. In practice, Python programmers do not need to constantly refer to manuals when reading or writing code; it’s a consistently designed system that many find yields(產生) surprisingly ''regular-looking code''.__

By philosophy, Python adopts a somewhat ''minimalist(極簡抽象派藝術的)'' approach. This means that although there are usually multiple ways to accomplish a coding task, there is usually just one obvious way, a few less obvious alternatives, and a small set of coherent interactions everywhere in the language. Moreover, __Python doesn’t make arbitrary decisions for you; when interactions are ambiguous, explicit intervention(介入) is preferred over “magic.” In the Python way of thinking, '''explicit is better than implicit, and simple is better than complex.'''__

__For a more complete look at the Python philosophy, type the command `import this` at any Python interactive prompt (you’ll see how in Chapter 2). This invokes an “Easter egg(復活節彩蛋)” hidden in Python—a collection of ''design principles'' underlying Python. The acronym EIBTI is now fashionable(時髦的) jargon(行話) for the “explicit is better than implicit” rule.__

__Beyond such design themes, Python includes tools such as ''modules'' and OOP that naturally promote ''code reusability''. And because Python is focused on quality, so too, naturally, are Python programmers.__

==== Developer Productivity ====

During the great Internet boom(急速發展) of the mid-to-late 1990s, it was difficult to find enough programmers to implement software projects; developers were asked to implement systems as fast as the Internet evolved. Now, in the post-boom era of layoffs(活動停止期間) and economic recession(衰退時期), the picture has shifted. __Today, programming staffs are often asked to accomplish the same tasks with even fewer people.__

In both of these scenarios, Python has shined as a tool that allows programmers to get more done with less effort. It is deliberately optimized for speed of development— its simple syntax, dynamic typing, lack of compile steps, and built-in toolset allow programmers to develop programs in a fraction of(一小部分的) the time needed when using some other tools. The net effect is that Python typically boosts developer productivity many times beyond the levels supported by traditional languages. That’s good news in both boom and bust(爆裂) times, and everywhere the software industry goes in between.

=== Is Python a “Scripting Language”? ===

__Python is a general-purpose programming language that is often applied in scripting roles. It is commonly defined as an object-oriented scripting language—a definition that blends(混合) support for OOP with an overall orientation toward scripting roles. In fact, people often use the word “script” instead of “program” to describe a Python code file. In this book, the terms “script” and “program” are used interchangeably, '''with a slight preference for “script” to describe a simpler ''top-level file'', and “program” to refer to a more sophisticated ''multifile application''.'''__

Because the term “scripting language” has so many different meanings to different observers, some would prefer that it not be applied to Python at all. In fact, people tend to make three very different associations, some of which are more useful than others, when they hear Python labeled as such:

'''Shell tools'''

__Sometimes when people hear Python described as a scripting language, they think it means that Python is a tool for coding operating-system-oriented scripts.__ Such programs are often launched from console command lines, and perform tasks such as processing text files and launching other programs. Python programs can and do serve such roles, but this is just one of dozens of common Python ''application domains''. It is not just a better shell-script language.

'''Control language'''

__To others, scripting refers to a “glue” layer used to control and direct (i.e., script) other application components. Python programs are indeed often deployed ''in the context of'' larger applications. For instance, to test hardware devices, Python programs may call out to components that give low-level access to a device. '''Similarly, programs may run bits of Python code at ''strategic points'' to support ''end-user product customization'' without having to ship and recompile the entire system’s source code.'''__

Python’s simplicity makes it a naturally flexible control tool. Technically, though, this is also just a common Python role; many Python programmers code standalone scripts without ever using or knowing about any integrated components. It is not just a control language.

'''Ease of use'''

__Probably the best way to think of the term “scripting language” is that it refers to a simple language used for ''quickly coding tasks''.__ This is especially true when the term is applied to Python, which allows much faster program development than compiled languages like C++. Its ''rapid development cycle'' fosters(促進) an exploratory(探究), incremental mode of programming that has to be experienced to be appreciated. Don’t be fooled, though—Python is not just for simple tasks. Rather, it makes tasks simple by its ease of use and flexibility. __Python has a simple feature set, but it allows programs to scale up in sophistication as needed. Because of that, it is commonly used for quick ''tactical(戰術型的; 短期方案而言) tasks'' and ''longer-term strategic development''.__

So, is Python a scripting language or not? It depends on whom you ask. In general, the term “scripting” is probably best used to describe the rapid and flexible mode of development that Python supports, rather than a particular application domain.

=== OK, but What’s the Downside? ===

After using Python for 15 years and teaching it for 10, the only downside to Python I’ve found is that, __as(因爲) currently implemented, its execution speed may not always be as fast as compiled languages such as C and C++.__

We’ll talk about implementation concepts in detail later in this book. __In short, the standard implementations of Python today compile (i.e., translate) source code statements to an ''intermediate format'' known as ''byte code'', and then interpret the byte code. Byte code provides portability, as it is a platform-independent format. (跟 Java 的做法很像) However, because Python is not compiled all the way down to ''binary machine code'' (e.g., instructions for an Intel chip), some programs will run more slowly in Python than in a ''fully compiled'' language like C.__

__Whether you will ever care about the execution speed difference depends on what kinds of programs you write. Python has been optimized numerous times, and Python code runs fast enough by itself in most application domains. Furthermore, whenever you do something “real” in a Python script, like process a file or construct a GUI, '''your program is actually running at ''C speed'', since such tasks are immediately ''dispatched'' to compiled C code inside the Python interpreter. More fundamentally, Python’s speed-of-development gain is often far more important than any speed-of-execution loss, especially given modern computer speeds.'''__

Even at today’s CPU speeds, though, there still are some domains that do require optimal execution speeds. Numeric programming and animation, for example, often need at least their core number-crunching(操作處理) components to run at C speed (or better). __If you work in such a domain, you can still use Python—simply split off the parts of the application that require optimal speed into ''compiled extensions'', and link those into your system for use in Python scripts. '''(有點像是 JVM Hot Spot 的概念, 花時間針對效能的瓶頸處做最佳化即可)'''__

We won’t talk about extensions much in this text, but this is really just an instance of the Python-as-control-language role that we discussed earlier. __A prime(最佳的) example of this ''dual language strategy'' is the NumPy numeric programming extension for Python; by combining compiled and optimized numeric extension libraries with the Python language, NumPy turns Python into a numeric programming tool that is efficient and easy to use.__ You may never need to code such extensions in your own Python work, but they provide a powerful optimization mechanism if you ever do.

=== Who Uses Python Today? ===

At this writing, in 2007, the best estimate anyone can seem to make of the size of the Python user base is that there are roughly 1 million Python users around the world today (plus or minus a few). This estimate is based on various statistics, like download rates and developer surveys. Because Python is open source, a more exact count is difficult— there are no license registrations to tally(計算). Moreover, Python is automatically included with Linux distributions, Macintosh computers, and some products and hardware, further clouding(使...不明確) the user-base picture.

In general, though, Python enjoys a large user base, and a very active developer community. Because Python has been around for more than 15 years and has been widely used, it is also very stable and robust. __Besides being employed by individual users, Python is also being applied in real ''revenue-generating'' products by real companies.__ For instance:

 * __'''Google makes extensive use of Python in its web search system, and employs(雇用) Python’s creator.'''__
 * __The YouTube video sharing service is largely written in Python.__
 * The popular BitTorrent peer-to-peer file sharing system is a Python program.
 * __Intel, Cisco, Hewlett-Packard, Seagate, Qualcomm, and IBM use Python for ''hardware testing''.__
 * Industrial Light & Magic, Pixar, and others use Python in the production of movie animation.
 * JPMorgan Chase, UBS, Getco, and Citadel apply Python for financial market forecasting.
 * NASA, Los Alamos, Fermilab, JPL, and others use Python for scientific programming tasks.
 * http://store.irobot.com/corp/index.jsp[iRobot] uses Python to develop commercial robotic vacuum(真空吸塵器) cleaners.
 * ESRI uses Python as an end-user customization tool for its popular GIS mapping products.
 * The NSA uses Python for cryptography and intelligence analysis.
 * The http://www.ironport.com/[IronPort] email server product uses more than 1 million lines of Python code to do its job.
 * __The One Laptop Per Child (OLPC) project builds its user interface and activity model in Python.__

And so on. Probably the only common thread amongst(在...之中) the companies using Python today is that Python is used all over the map, in terms of application domains. Its general-purpose nature makes it applicable to almost all fields, not just one. __In fact, it’s safe to say that Python is being used by virtually every substantial organization writing software, whether for ''short-term tactical tasks'' such as testing and administration, or for ''long-term strategic product development''. Python has proven to work well in both modes.__

For more details on companies using Python today, see Python’s web site at http://www.python.org.

=== What Can I Do with Python? ===

Besides being a well-designed programming language, Python is also useful for accomplishing(完成) real-world tasks—the sorts of things developers do day in and day out(每天). It’s commonly used in a variety of domains, as a tool for scripting other components and implementing standalone programs. __In fact, as a general-purpose language, Python’s roles are virtually unlimited: you can use it for everything from web site development and ''gaming'', to robotics and spacecraft control.__

However, the most common Python roles currently seem to fall into a few broad categories. The next few sections describe some of Python’s most common applications today, as well as tools used in each domain. We won’t be able to explore the tools mentioned here in any depth—if you are interested in any of these topics, see the Python web site, or other resources for more details.

==== Systems Programming ====

__Python’s built-in ''interfaces to operating-system services (= operating system interfaces)'' make it ideal for writing portable, maintainable system-administration tools and utilities (sometimes called shell tools). Python programs can search files and directory trees, launch other programs, do ''parallel processing with processes and threads'', and so on.__

__Python’s standard library comes with ''POSIX bindings'' and support for all the usual OS tools:__ environment variables, files, sockets, pipes, processes, multiple threads, regular expression pattern matching, command-line arguments, standard stream interfaces, shell-command launchers, filename expansion, and more. In addition, the bulk of(成批的) Python’s system interfaces are designed to be portable; for example, a script that copies directory trees typically runs unchanged on all major Python platforms.

==== GUIs ====

__Python’s simplicity and rapid turnaround(一件工程自接下到完成所需的時間) also make it a good match for graphical user interface (GUI) programming.__ Python comes with a standard object-oriented interface to the Tk GUI API called http://wiki.python.org/moin/TkInter[Tkinter], which allows Python programs to implement portable GUIs with a ''native look and feel''. Python/Tkinter GUIs run unchanged on MS Windows, X Windows (on Unix and Linux), and the Mac OS (both Classic and OS X). A free extension package, http://pmw.sourceforge.net/[PMW], adds advanced widgets to the Tkinter toolkit. In addition, the http://wxpython.org/[wxPython] GUI API, based on a C++ library, offers an alternative toolkit for constructing portable GUIs in Python.

Higher-level toolkits such as http://pythoncard.sourceforge.net/[PythonCard] and http://dabodev.com/[Dabo] are built on top of base APIs such as wxPython and Tkinter. __'''With the proper library, you can also use http://www.awaretek.com/toolkits.html[other GUI toolkits] in Python, such as Qt, GTK, MFC, and Swing (= Java Swing; 多到數不清!! 從沒看過 GUI 套件這麼多元的語言...).''' For applications that run in web browsers, or have simple interface requirements, both Jython (the Java version of Python, described in Chapter 2) and Python server-side CGI scripts provide additional user interface options.__

==== Internet Scripting ====

__Python comes with standard Internet modules that allow Python programs to perform a wide variety of networking tasks, in ''client and server modes''. Scripts can communicate over sockets; extract form information sent to server-side CGI scripts; transfer files by FTP; process XML files; send, receive, compose, and parse email; fetch web pages by URLs; parse the HTML and XML of fetched web pages; communicate over XML-RPC, SOAP, and Telnet; and more. Python’s libraries make these tasks remarkably simple. (一時之間, 覺得好像 Java/.NET 等這些語言都顯得大而無當?)__

In addition, there is a large collection of third-party tools available on the Web for doing Internet programming in Python. __For instance, the HTMLGen system generates HTML files from Python ''class-based descriptions'', '''the `mod_python` package runs Python efficiently within the Apache web server and supports ''server-side templating'' with its ''Python Server Pages'' (原來還有 PSP 這種東西!!), and the Jython system provides for seamless Python/Java integration, and supports coding of ''server-side applets that run on clients''[?].''' In addition, full-blown(成熟的) web development packages for Python, such as http://www.djangoproject.com/[Django], http://turbogears.org/[TurboGears], http://pylonshq.com/[Pylons], http://www.zope.org/[Zope], and http://www.webwareforpython.org/[WebWare], support quick construction of full-featured and production-quality web sites with Python.__

==== Component Integration ====

We discussed the component integration role earlier when describing Python as a control language. __'''Python’s ability to be extended by and embedded in C and C++ systems makes it useful as a flexible ''glue language'' for ''scripting the behavior of other systems and components''.''' For instance, integrating a C library into Python enables Python to test and launch the library’s components, and embedding Python in a product enables ''onsite customizations'' to be coded without having to recompile the entire product, or ship its source code at all.__

__'''Tools such as the http://www.swig.org/[SWIG] and http://www.riverbankcomputing.co.uk/software/sip/intro[SIP] code generators can automate much of the work needed to link compiled components into Python for use in scripts. (這類工具就好像 Jawin 之於 Java 一樣)''' And larger frameworks, such as Python’s COM support on MS Windows, the http://www.jython.org/[Jython] Java-based implementation, the http://www.codeplex.com/IronPython[IronPython] .NET-based implementation, and various CORBA toolkits for Python, provide alternative ways to script components.__ On Windows, for example, Python scripts can use frameworks to script MS Word and Excel.

==== Database Programming ====

__For traditional database demands, there are Python interfaces to all commonly used relational database systems—Sybase, Oracle, Informix, ODBC, MySQL, PostgreSQL, SQLite, and more. '''The Python world has also defined a portable database API for accessing SQL database systems from Python scripts, which looks the same on a variety of underlying database systems. (看起來 Python 也有 Java 所宣稱的 "Write Once Run Everywhere" 的特性, 但由於 Python 包裝現有工具而不重新造輪的傾向, 使得 Python 比 Java 來得多元!!)'''__ For instance, because vendor interfaces implement the portable API, a script written to work with the free MySQL system will work largely unchanged on other systems (such as Oracle); all you have to do is replace the ''underlying vendor interface''.

__Python’s standard http://docs.python.org/library/pickle.html[pickle] module provides a simple ''object persistence system''—it allows programs to easily save and restore entire Python objects to files and file-like objects. On the Web, you’ll also find a third-party system named http://www.zope.org/Wikis/ZODB[ZODB] that provides a complete ''object-oriented database system'' for Python scripts, and another called http://www.sqlobject.org/[SQLObject] that maps relational tables onto Python’s ''class model''. And, as of Python 2.5, http://www.sqlite.org/[SQLite] is a standard part of Python itself. '''(看起來 Python 跟 Java 一樣, 都很適合用在企業相關的開發!!)'''__

==== Rapid Prototyping ====

To Python programs, components written in Python and C look the same. Because of this, it’s possible to prototype systems in Python initially, and then move selected components to a compiled language such as C or C++ for delivery. __Unlike some prototyping tools, Python doesn’t require a complete rewrite once the prototype has solidified(固化的). Parts of the system that don’t require the efficiency of a language such as C++ can remain coded in Python for ease of maintenance and use. (不是用了就丟的 prototype 而言)__

==== Numeric and Scientific Programming ====

The NumPy numeric programming extension for Python mentioned earlier includes such advanced tools as an array object, interfaces to standard mathematical libraries, and much more. __By integrating Python with numeric routines coded in a compiled language for speed, NumPy turns Python into a sophisticated yet easy-to-use numeric programming tool, '''which can often replace existing code written in traditional compiled languages such as FORTRAN or C++.''' Additional numeric tools for Python support animation, 3D visualization, parallel processing, and so on.__

==== Gaming, Images, AI, XML, Robots, and More ====

Python is commonly applied in more domains than can be mentioned here. __For example, you can do graphics and game programming in Python with the http://www.pygame.org/news.html[pygame] system; image processing with the http://www.pythonware.com/products/pil/[PIL] package and others; robot control programming with the http://www.pyrorobotics.org/[PyRo] toolkit;__ XML parsing with the xml library package, the http://docs.python.org/library/xmlrpclib.html[xmlrpclib] module, and third-party extensions; AI programming with ''neural(神經的) network simulators'' and ''expert system shells''; and natural language analysis with the http://nltk.sourceforge.net/index.php/Main_Page[NLTK] package. You can even play solitaire(單人紙牌遊戲) with the http://www.pysol.org/[PySol] program. You’ll find support for many such fields at the http://www.vex.net/parnassus/[Vaults of Parnassus], and the newer http://pypi.python.org/pypi[PyPI] web sites (search Google or http://www.python.org for links).

__'''In general, many of these specific domains are largely just instances of Python’s component integration role in action again. (這與 linux 下有一堆 frontends 的做法是一樣的, 都相當重視 "組合應用" 而非 "重新造輪"!!)''' Adding Python as a ''frontend'' to libraries of components written in a compiled language such as C makes Python useful for scripting in a wide variety of domains. As a general-purpose language that supports integration, Python is widely applicable.__

=== What Are Python’s Technical Strengths? ===

Naturally, this is a developer’s question. If you don’t already have a programming background, the language in the next few sections may be a bit baffling(困惑的)—don’t worry, we’ll explore all of these terms in more detail as we proceed through this book. For developers, though, here is a quick introduction to some of Python’s top technical features.

==== It’s Object Oriented ====

__Python is an object-oriented language, from the ground up. Its ''class model'' supports advanced notions such as polymorphism, operator overloading, and multiple inheritance; yet, in the context of Python’s simple syntax and typing, OOP is remarkably easy to apply.__ In fact, if you don’t understand these terms, you’ll find they are much easier to learn with Python than with just about any other OOP language available.

__Besides serving as a powerful code structuring and reuse device(方法), Python’s OOP nature makes it ideal as a scripting tool for object-oriented systems languages such as C++ and Java. For example, with the appropriate ''glue code'', '''Python programs can subclass (specialize) classes implemented in C++, Java, and C#.'''__

__Of equal significance(同樣重要地), OOP is an option in Python; you can go far without having to become an object guru all at once. '''Much like C++, Python supports both ''procedural and object-oriented programming modes''. (原來 C++ 也有這種特性, 搞不好很多人都還拿 C++ 來寫 C?)''' Its object-oriented tools can be applied if and when constraints allow. This is especially useful in ''tactical development modes'', which preclude(排除) design phases.__

==== It’s Free ====

Python is completely free to use and distribute. As with other open source software, such as Tcl, Perl, Linux, and Apache, you can fetch the entire Python system’s source code for free on the Internet. __There are no restrictions on copying it, embedding it in your systems, or shipping it with your products. In fact, you can even sell Python’s source code, if you are so inclined(想要...的).__

But don’t get the wrong idea: “free” doesn’t mean “unsupported.” On the contrary, the Python online community responds to user queries with a speed that most commercial software vendors would do well to notice. Moreover, because Python comes with complete source code, it empowers developers, leading to the creation of a large team of implementation experts. Although studying or changing a programming language’s implementation isn’t everyone’s idea of fun, __it’s comforting to know that it’s available as a final resort(手段) and ultimate documentation source. You’re not dependent on the whims(反復無常) of a commercial vendor.__

Python development is performed by a community, which largely coordinates its efforts over the Internet. It consists of Python’s creator—http://en.wikipedia.org/wiki/Guido_van_Rossum[Guido van Rossum], the officially anointed(選定) Benevolent Dictator for Life (BDFL) of Python—plus a cast of thousands. __Language changes must follow a formal enhancement procedure (known as the http://www.python.org/dev/peps/[PEP process]), and be scrutinized(審查) by a formal testing system and the BDFL. Happily, this tends to make Python more conservative(謹慎的) with changes than some other languages. (跟 Java 的 JCP 做法一樣)__

==== It’s Portable ====

__The standard implementation of Python is written in portable ANSI C, and it compiles and runs on virtually every major platform currently in use.__ For example, Python programs run today on everything from PDAs to supercomputers. As a partial list, Python is available on:

 * Linux and Unix systems
 * Microsoft Windows and DOS (all modern flavors)
 * Mac OS (both OS X and Classic)
 * BeOS, OS/2, VMS, and QNX
 * Real-time systems such as VxWorks
 * http://www.cray.com[Cray] supercomputers and IBM mainframes
 * PDAs running Palm OS, PocketPC, and Linux
 * __Cell phones running Symbian OS and Windows Mobile__
 * __Gaming consoles and iPods__
 * And more

__Besides the language interpreter itself, the standard library modules that ship with Python are also implemented to be as portable across platform boundaries as possible.__ Further, Python programs are automatically compiled to portable byte code, which runs the same on any platform with a compatible version of Python installed (more on this in the next chapter).

What that means is that __Python programs using the ''core language'' and ''standard libraries'' run the same on Linux, Windows, and most other systems with a Python interpreter. Most Python ports also contain ''platform-specific extensions'' (e.g., COM support on Windows), but the core Python language and libraries work the same everywhere.__ As mentioned earlier, Python also includes an interface to the Tk GUI toolkit called Tkinter, which allows Python programs to implement full-featured graphical user interfaces that run on all major GUI platforms without program changes.

==== It’s Powerful ====

__'''From a features perspective, Python is something of a hybrid(混血兒). Its toolset places it between traditional scripting languages (such as Tcl, Scheme, and Perl), and systems development languages (such as C, C++, and Java).''' Python provides all the simplicity and ease of use of a scripting language, along with more advanced software engineering tools typically found in compiled languages. Unlike some scripting languages, this combination makes Python useful for large-scale development projects.__ As a preview, here are some of the main things you’ll find in Python’s toolbox:

'''Dynamic typing'''

Python keeps track of the kinds of objects your program uses when it runs; it doesn’t require complicated type and size declarations in your code. In fact, as you’ll see in Chapter 6, there is no such thing as a type or variable declaration anywhere in Python. Because Python code does not constrain data types, it is also usually automatically applicable to a whole range of objects.

'''Automatic memory management'''

__Python automatically allocates objects and reclaims (“garbage collects”; 回收) them when they are no longer used, and most grow and shrink on demand. As you’ll learn, Python keeps track of low-level memory details so you don’t have to.__

'''Programming-in-the-large support'''

__'''For building larger systems, Python includes tools such as ''modules'', ''classes'', and ''exceptions''. These tools allow you to organize systems into ''components'', use OOP to reuse and customize code, and handle events and errors gracefully. (原來這些都是寫小程式用不到的東西; 由於 Python 將 OOP 視為 optional, 因此用 Python 來開發任何大小的應用都很恰當; 這也使得 Python 很適合拿來做為入門語言, 進而帶出 OO 的概念 [...])'''__

'''Built-in object types'''

Python provides commonly used data structures such as lists, dictionaries, and strings as intrinsic(內在的) parts of the language; as you’ll see, they’re both flexible and easy to use. For instance, built-in objects can grow and shrink on demand, can be arbitrarily nested to represent complex information, and more.

'''Built-in tools'''

To process all those object types, Python comes with powerful and standard operations, including concatenation (joining collections), slicing (extracting sections), sorting, mapping, and more.

'''Library utilities'''

For more specific tasks, Python also comes with a large collection of precoded ''library tools'' that support everything from regular-expression matching to networking. __Python’s library tools are where much of the ''application-level'' action occurs.__

'''Third-party utilities'''

Because Python is open source, developers are encouraged to contribute precoded tools that support tasks beyond those supported by its built-ins; on the Web, you’ll find free support for COM, imaging, CORBA ORBs, XML, database access, and much more.

Despite the array of tools in Python, it retains a remarkably simple syntax and design. The result is a powerful programming tool with all the usability of a scripting language.

==== It’s Mixable ====

__Python programs can easily be “glued” to components written in other languages in a variety of ways. '''For example, Python’s C API lets C programs call and be called by Python programs flexibly. (雙向呼叫)''' That means you can add functionality to the Python system as needed, and use Python programs within other environments or systems.__

__Mixing Python with libraries coded in languages such as C or C++, for instance, makes it an easy-to-use ''frontend language'' and ''customization tool''. As mentioned earlier, this also makes Python good at rapid prototyping; '''systems may be implemented in Python first, to leverage its speed of development, and later, moved to C for delivery, ''one piece at a time'', according to performance demands.'''__

==== It’s Easy to Use ====

To run a Python program, you simply type it and run it. There are no intermediate compile and link steps, like there are for languages such as C or C++. __Python executes programs immediately, which makes for an interactive programming experience and rapid turnaround after program changes—in many cases, you can witness(目睹) the effect of a program change as fast as you can type it.__

Of course, development cycle turnaround is only one aspect of Python’s ease of use. It also provides a deliberately simple syntax and powerful built-in tools. __'''In fact, some have gone so far as to call Python “executable pseudocode.”''' Because it eliminates much of the complexity in other tools, Python programs are simpler, smaller, and more flexible than equivalent programs in languages like C, C++, and Java!__

==== Python Is Engineering, Not Art ====

When Python first emerged(出現) on the software scene in the early 1990s, it spawned what is now something of a classic conflict between its proponents(支持者) and those of another popular scripting language, Perl. Personally, I think the debate is tired and unwarranted today—developers are smart enough to draw their own conclusions. Still, this is one of the most common topics I’m asked about on the training road, so it seems fitting(適合的) to say a few words on the topic here.

__The short story is this: you can do everything in Python that you can in Perl, but you can read your code after you do it. That’s it—their domains largely overlap, but '''Python is more focused on producing ''readable code''. For many, the enhanced readability of Python translates to code reusability and maintainability, making Python a better choice for programs that will not be written once and thrown away. Perl code is easy to write, but difficult to read.''' Given that most software has a lifespan much longer than its initial creation, many see Python as a more effective tool.__

__'''相對而言, Perl 比較玩家性質, Python 則比較務實 - 寫出來的程式是要維護的; 下面說明 Python 與 Perl 兩位作者的背景, 充份地反應到語言的特性, 真是有趣!! 怪的是為什麼沒有人拿 Python 來跟 PHP 比較? 或許是 PHP 只專注於 Web 的開發吧, 所以無從比較起[...]__

The somewhat longer story reflects the backgrounds of the designers of the two languages, and underscores(強調) some of the main reasons people choose to use Python. Python’s creator is a mathematician(數學家) by training; as such, he produced a language with a high degree of uniformity—its syntax and toolset are remarkably coherent. Moreover, like math, its design is orthogonal(正交的)—most of the language follows from a small set of core concepts. For instance, once one grasps Python’s flavor of polymorphism, the rest is largely just details.

By contrast, the creator of the Perl language is a linguist(語言學家), and its design reflects this heritage(天性). There are many ways to accomplish the same tasks in Perl, and language constructs interact in ''context-sensitive'' and sometimes quite subtle ways—much like ''natural language''. __As the well-known Perl motto(箴言) states, “There’s more than one way to do it.” Given this design, both the Perl language and its user community have historically encouraged freedom of expression when writing code. '''One person’s Perl code can be radically(完全地) different from another’s. In fact, writing unique, tricky code is often a source of pride(自豪) among Perl users.'''__

__But as anyone who has done any substantial(大量的) code maintenance should be able to attest(證實), freedom of expression is great for art, but lousy(極不適的) for engineering. '''In engineering, we need a minimal feature set and predictability. In engineering, freedom of expression can lead to maintenance nightmares.''' As more than one Perl user has confided(吐露) to me, the result of too much freedom is often code that is much easier to rewrite from scratch than to modify.__

Consider this: when people create a painting or a sculpture(雕塑品), they do so for themselves for purely aesthetic(美學的) purposes. The possibility of someone else having to change that painting or sculpture later does not enter into it. This is a critical difference between art and engineering. __When people write software, they are not writing it for themselves. In fact, they are not even writing primarily for the computer. '''Rather, good programmers know that code is written for the next human being who has to read it in order to maintain or reuse it. If that person cannot understand the code, it’s all but useless in a realistic development scenario.'''__

This is where many people find that Python most clearly differentiates itself from scripting languages like Perl. Because Python’s ''syntax model'' almost forces users to write readable code, __Python programs lend themselves more directly to the full software development cycle.__ And because Python emphasizes ideas such as limited interactions, uniformity, regularity, and consistency, it more directly fosters(促進) code that can be used long after it is first written.

__In the long run(就長遠來看), Python’s focus on code quality in itself boosts programmer productivity, as well as programmer satisfaction. Python programmers can be creative, too, and as we’ll see, the language does offer multiple solutions for some tasks.__ At its core, though, Python encourages good engineering in ways that other scripting languages often do not.

At least, that’s the common consensus(同感) among many people who have adopted Python. You should always judge(評判) such claims for yourself, of course, by learning what Python has to offer. To help you get started, let’s move on to the next chapter.

==== It’s Easy to Learn ====

This brings us to a key point of this book: compared to other programming languages, the core Python language is remarkably easy to learn. In fact, you can expect to be coding significant Python programs in a matter of days (or perhaps in just hours, if you’re already an experienced programmer). That’s good news for professional developers seeking to learn the language to use on the job, as well as for end users of systems that expose a Python layer for customization or control. __'''Today, many systems rely on the fact that end users can quickly learn enough Python to tailor their Python customizations’ code onsite, with little or no support.''' Although Python does have advanced programming tools, its core language is still simple for beginners and gurus alike.__

==== It’s Named After Monty Python ====

OK, this isn’t quite a technical strength, but it does seem to be a surprisingly well kept secret that I wish to expose up front. Despite all the reptile(爬行動物) icons in the Python world, the truth is that Python creator Guido van Rossum named it after the BBC comedy series Monty Python’s Flying Circus. He is a big fan of Monty Python, as are many software developers (indeed, there seems to almost be a symmetry(對稱) between the two fields).

__This legacy inevitably(不可避免地) adds a humorous(詼諧的) quality to Python code examples. '''For instance, the traditional “foo” and “bar” for generic variable names become “spam”(罐頭豬肉) and “eggs” in the Python world.''' The occasional “Brian,” “ni,” and “shrubbery”(灌木) likewise owe(歸功於...) their appearances to this namesake(同名物). It even impacts the Python community at large: talks at Python conferences are regularly billed as “The Spanish Inquisition(研討).”__

All of this is, of course, very funny if you are familiar with the show, but less so otherwise. You don’t need to be familiar with the series to make sense of examples that borrow references to Monty Python (including many you will see in this book), but at least you now know their root(根源).

=== How Does Python Stack Up to Language X? ===

Finally, to place it in the context of what you may already know, people sometimes compare Python to languages such as Perl, Tcl, and Java. We talked about performance earlier, so here we’ll focus on functionality. While other languages are also useful tools to know and use, many people find that Python:

 * Is more powerful than Tcl. Python’s support for “programming in the large” makes it applicable to the development of larger systems.

 * Has a cleaner syntax and simpler design than Perl, which makes it more readable and maintainable, and helps reduce program bugs.

 * Is simpler and easier to use than Java. Python is a scripting language, but Java inherits much of the complexity and syntax of systems languages such as C++.

 * Is simpler and easier to use than C++, but often doesn’t compete with C++, either; as a scripting language, Python often serves different roles.

 * Is both more powerful and more cross-platform than Visual Basic. Its open source nature also means it is not controlled by a single company.

 * __Is more mature and has a more readable syntax than Ruby. '''Unlike Ruby and Java, OOP is an option in Python—Python does not impose OOP on users or projects to which it may not apply. (顯然 Ruby 強制要以 OO 的方式來撰寫的這一步走錯了...)'''__

 * Has the dynamic flavor of languages like SmallTalk and Lisp, but also has a simple, traditional syntax accessible to developers as well as end users of customizable systems.
 
Especially for programs that do more than scan text files, and that might have to be read in the future by others (or by you!), many people find that Python fits the bill better than any other scripting or programming language available today. __Furthermore, unless your application requires peak(最高的) performance, Python is often a viable(可行) alternative to systems development languages such as C, C++, and Java: Python code will be much less difficult to write, debug, and maintain.__

Of course, your author has been a card-carrying(正式的黨員) Python evangelist(傳道者) since 1992, so take these comments as you may. They do, however, reflect the common experience of many developers who have taken time to explore what Python has to offer.

=== Chapter Summary ===

And that concludes the hype(誇大的宣傳) portion of this book. In this chapter, we’ve explored some of the reasons that people pick Python for their programming tasks. We’ve also seen how it is applied, and a representative sample of who is using it today. My goal is to teach Python, though, not to sell it. The best way to judge a language is to see it in action, so the rest of this book focuses entirely on the language details we’ve glossed(解說) over here.

To get started, the next two chapters begin our technical introduction to the language. __There, we explore ways to run Python programs, peek at(窺視) Python’s ''byte code execution model'', and introduce the basics of ''module files'' for saving code.__ The goal will be to give you just enough information to run the examples and exercises in the rest of the book. You won’t really start programming until Chapter 4, but make sure you have a handle on the startup details before moving on.

==== Chapter Quiz ====

In this edition of the book, we will be closing each chapter with a quick pop quiz about the material presented to help you review the key concepts. The answers for these quizzes appear immediately after the questions, and you are encouraged to read the answers once you’ve taken a crack at the questions yourself. __In addition to these end-of-chapter quizzes, you’ll find ''lab exercises'' at the end of each part of the book, designed to help you start coding Python on your own.__ For now, here’s your first test. Good luck!

 1. What are the six main reasons that people choose to use Python?
 2. Name four notable companies or organizations using Python today.
 3. Why might you not want to use Python in an application?
 4. What can you do with Python?
 5. What’s the significance of the Python `import this` statement?
 6. Why does “spam” show up in so many Python examples in books and on the Web?
 7. What is your favorite color?

==== Quiz Answers ====

How did you do? Here are the answers I came up with, though there may be multiple solutions to some quiz questions. Again, even if you’re sure you got a question right, I encourage you to look at these answers for additional context. See the chapter’s text for more details if any of these responses don’t make sense to you.

 1. Software quality, developer productivity, program portability, support libraries, component integration, and enjoyment. Of these, the quality and productivity themes seem to be the main reasons that people choose to use Python.

 2. Google, Industrial Light & Magic, Jet Propulsion Labs, ESRI, and many more. __Almost every organization doing software development is using Python in some fashion, whether for long-term strategic product development, or for short-term tactical tasks such as testing and system administration.__

 3. Python’s downside is performance: it won’t run as quickly as fully compiled languages like C and C++. On the other hand, it’s quick enough for most applications, and typical Python code runs at close to C speed anyhow because it invokes linked-in C code in the interpreter. If speed is critical, compiled extensions are available for number-crunching parts of an application.

 4. You can use Python for nearly anything you can do with a computer—from web site development and gaming, to robotics and spacecraft control.

 5. import this triggers an Easter egg inside Python that displays some of the design philosophies underlying the language. You’ll learn how to run this statement in the next chapter.

 6. “Spam” is a reference from a famous Monty Python skit(滑稽短劇) in which people trying to order food in a cafeteria(自助餐廳) are drowned out(聲音被壓過) by a chorus(合唱團) of Vikings singing about spam. Oh, and it’s also a common variable name in Python scripts....

 7. Blue. No, yellow!

== Chapter 2. How Python Runs Programs ==

This chapter and the next give a quick look at program execution—how you launch code, and how Python runs it. In this chapter, we’ll study the Python interpreter. Chapter 3 will then show you how to get your own programs up and running.

Startup details are inherently platform-specific, and some of the material in this chapter may not apply to the platform you work on, so you should feel free to skip parts not relevant to your intended use. Likewise, more advanced readers who have used similar tools in the past and prefer to get to the meat of the language quickly may want to file(歸檔) some of this chapter away as “for future reference.” For the rest of you, let’s learn how to run some code.

=== Introducing the Python Interpreter ===

__So far, I’ve mostly been talking about Python as a programming language. But, as currently implemented, it’s also a software package called an ''interpreter''. '''An interpreter is a kind of program that ''executes other programs''.''' When you write a Python program, the Python interpreter reads your program and carries out(執行) the instructions it contains. In effect, the interpreter is a layer of software logic between your code and the computer hardware on your machine.__

When the Python package is installed on your machine, it generates a number of components—minimally, an interpreter and a ''support library''. __Depending on how you use it, the Python interpreter may take the form of an ''executable program'', or a set of libraries linked into another program. Depending on which flavor of Python you run, '''the interpreter itself may be implemented as a C program, a set of Java classes (例如 Jython), or something else.''' Whatever form it takes, the Python code you write must always be run by this interpreter.__ And, to enable that, you must install a Python interpreter on your computer.

Python installation details vary by platform, and are covered in more depth in Appendix A. In short:

 * Windows users fetch and run a self-installing executable file that puts Python on their machines. Simply double-click and say Yes or Next at all prompts.

 * On Windows Vista, you may need to take extra steps to use the Python 2.5 MSI installer file; see Appendix A for more details.

 * Linux and Mac OS X users probably already have a usable Python preinstalled on their computers—it’s a standard component on these platforms today.

 * Some Linux users (and most Unix users) typically either install Python from RPM files, or compile it from its full source code distribution package.

 * __Other platforms have installation techniques relevant to those platforms. For instance, Python is also available on cell phones, game consoles, and iPods, but the installation details vary too widely to cover here.__

Python itself may be fetched from the downloads page at Python’s web site. It may also be found through various other distribution channels. Keep in mind that you should always check to see whether Python is already present before installing it. If you’re working on Windows, you’ll usually find Python in the Start menu, as captured in Figure 2-1 (these menu options are discussed in the next chapter). On Unix and Linux, Python probably lives in your `/usr` directory tree.

{{attachment:figure_2-1.png}} <<BR>> Figure 2-1. When installed on Windows, this is how Python shows up in your Start button menu. This can vary a bit from release to release, but IDLE starts a development GUI (a Python Tkinter GUI program, 在 Ubuntu 下安裝 `idle` 套件後, 在 Applications > Programming 下就會出現 IDLE 的項目), and Python starts a simple interactive session. Also, here are the standard manuals, and the Pydoc documentation engine (Module Docs).

Because installation details are so platform-specific, we’ll finesse(用計) the rest of this story here. For more details on the installation process, consult Appendix A. For the purposes of this chapter and the next, I’ll assume that you’ve got Python ready to go.

=== Program Execution ===

What it means to write and run a Python script depends on whether you look at these tasks as a programmer, or as a Python interpreter. Both views offer important perspectives on Python programming.

==== The Programmer’s View ====

In its simplest form, a Python program is just a text file containing Python statements. For example, the following file, named `script1.py`, is one of the simplest Python scripts we could dream up, but it passes for(被認為) an official Python program:

 {{{
print 'hello world' # 用單引號來框住字串
print 2 ** 100
 }}}

This file contains two Python `print` statements, which simply print a string (the text in quotes) and a numeric expression result (2 to the power 100; 2 的 100 次方) to the output stream. Don’t worry about the syntax of this code yet—for this chapter, we’re interested only in getting it to run. I’ll explain the `print` statement, and why you can raise 2 to the power 100 in Python without overflowing, in later parts of this book.

You can create such a file of statements with any text editor you like. __By convention, Python program files are given names that end in `.py`; '''technically, this naming scheme is required only for files that are “imported,” as shown later in this book, but most Python files have `.py` names for consistency.'''__

After you’ve typed these statements into a text file, you must tell Python to execute the file—which simply means to run all the statements in the file from top to bottom, one after another. As you’ll see in the next chapter, you can launch Python program files by command lines, by clicking their icons, and with other standard techniques. If all goes well, when you execute the file, you’ll see the results of the two `print` statements show up somewhere on your computer—by default, usually in the same window you were in when you ran the program:

 {{{
hello world
1267650600228229401496703205376
 }}}

For example, here’s what happened when I ran this script from a DOS command line on a Windows laptop (typically called a Command Prompt window, found in the Accessories program menu), to make sure it didn’t have any silly typos:

 {{{
D:\temp> python script1.py
hello world
1267650600228229401496703205376
 }}}

We’ve just run a Python script that prints a string and a number. We probably won’t win any programming awards with this code, but it’s enough to capture the basics of program execution.

==== Python’s View ====

The brief description in the prior section is fairly standard for scripting languages, and it’s usually all that most Python programmers need to know. You type code into text files, and you run those files through the interpreter. Under the hood, though, a bit more happens when you tell Python to “go.” __Although knowledge of Python internals is not strictly required for Python programming, a basic understanding of the ''runtime structure'' of Python can help you grasp the bigger picture of ''program execution''.__

When you instruct Python to run your script, there are a few steps that Python carries out before your code actually starts crunching away. Specifically, it’s first compiled to something called “byte code” and then routed to something called a “virtual machine.”

===== Byte code compilation =====

Internally, and almost completely hidden from you, when you execute a program, Python first compiles your source code (the statements in your file) into a format known as byte code. __Compilation is simply a ''translation'' step, and byte code is a lower-level, platform-independent representation of your source code. Roughly, '''Python translates each of your source statements into a group of byte code instructions by decomposing(分解) them into individual steps.''' This byte code translation is performed to speed execution—byte code can be run much more quickly than the original source code statements in your text file.__

You’ll notice that the prior paragraph said that this is almost completely hidden from you. If the Python process has write access on your machine, it will store the byte code of your program in files that end with a `.pyc` extension (“.pyc” means compiled “.py” source). You will see these files show up on your computer after you’ve run a few programs alongside the corresponding source code files (that is, in the same directories).

__Python saves byte code like this as a ''startup speed optimization''. The next time you run your program, Python will load the `.pyc` and skip the compilation step, as long as you haven’t changed your source code since the byte code was last saved.__ Python automatically checks the timestamps of source and byte code files to know when it must recompile—if you resave your source code, byte code is automatically re-created the next time your program is run.

__If Python cannot write the byte code files to your machine, your program still works—the byte code is generated in memory and simply discarded on program exit. However, because `.pyc` files speed startup time, you’ll want to make sure they are written for larger programs. '''Byte code files are also one way to ship Python programs— Python is happy to run a program if all it can find are `.pyc` files, even if the original `.py` source files are absent. (某種程度上, 這違反了 Python 自由開放的精神)'''__ (See “Frozen Binaries” later in this chapter for another shipping option.)

__'''And, strictly speaking, byte code is saved only for files that are imported, not for the top-level file of a program. (難怪剛才執行 `script1.py` 之後, 並沒有產生 `script1.pyc`)'''__ We’ll explore imports in Chapter 3, and again in Part V. Byte code is also never saved for code typed at the interactive prompt, which is described in Chapter 3.

===== The Python Virtual Machine (PVM) =====

Once your program has been compiled to byte code (or the byte code has been loaded from existing `.pyc` files), it is shipped off(遣送) for execution to something generally known as the ''Python Virtual Machine'' (PVM, for the more acronym-inclined among you). __The PVM sounds more impressive than it is; really, it’s not a separate program, and it need not be installed by itself. '''In fact, the PVM is just a ''big loop'' that iterates through your byte code instructions, one by one, to carry out their operations. The PVM is the ''runtime engine'' of Python;''' it’s always present as part of the Python system, and it’s the component that truly runs your scripts.__ Technically, it’s just the last step of what is called the “Python interpreter.”

Figure 2-2 illustrates the runtime structure described here. __Keep in mind that all of this complexity is deliberately hidden from Python programmers. Byte code compilation is automatic, and the PVM is just part of the Python system that you have installed on your machine. Again, programmers simply code and run files of statements.__

{{attachment:figure_2-2.png}} <<BR>> Figure 2-2. Python’s traditional ''runtime execution model'': source code you type is translated to byte code, which is then run by the Python Virtual Machine. Your code is automatically compiled, but then it is interpreted.

===== Performance implications =====

Readers with a background in fully compiled languages such as C and C++ might notice a few differences in the Python model. For one thing, there is usually no build or “make” step in Python work: code runs immediately after it is written. For another, Python byte code is not binary machine code (e.g., instructions for an Intel chip). Byte code is a Python-specific representation.

__This is why some Python code may not run as fast as C or C++ code, as described in Chapter 1—the PVM loop, not the CPU chip, still must interpret the byte code, and ''byte code instructions'' require more work than ''CPU instructions''. On the other hand, unlike in classic interpreters, there is still an ''internal compile step''—Python does not need to reanalyze and reparse each source statement repeatedly. The net effect is that pure Python code runs at speeds somewhere between those of a traditional compiled language and a traditional interpreted language.__ See Chapter 1 for more on Python performance implications.

===== Development implications =====

__Another ramification(分派) of Python’s execution model is that there is really no distinction between the development and execution environments. That is, the systems that compile and execute your source code are really one and the same. (不像 Java 有區分 `java` 與 `javac` 一樣, 分別來自 JRE 與 JDK) This similarity may have a bit more significance to readers with a background in traditional compiled languages, '''but in Python, the compiler is always present at runtime, and is part of the system that runs programs.'''__

This makes for a much more rapid development cycle. There is no need to precompile and link before execution may begin; simply type and run the code. __This also adds a much more dynamic flavor to the language—it is possible, and often very convenient, for Python programs to ''construct and execute other Python programs at runtime''. The `eval` and `exec` built-ins, for instance, accept and run strings containing Python program code. This structure is also why Python lends itself to product customization— because Python code can be changed on the fly, users can modify the Python parts of a system onsite without needing to have or compile the entire system’s code.__

__At a more fundamental level, keep in mind that all we really have in Python is runtime— there is no initial compile-time phase at all, and everything happens as the program is running. '''This even includes operations such as the creation of functions and classes and the ''linkage of modules''. Such events occur before execution in more static languages, but happen as programs execute in Python.''' As we’ll see, the net effect makes for a much more dynamic programming experience than that to which some readers may be accustomed(習慣的).__

=== Execution Model Variations ===

Before moving on, I should point out that the internal execution flow described in the prior section reflects the standard implementation of Python today, and is not really a requirement of the Python language itself. Because of that, the execution model is prone to changing with time. In fact, there are already a few systems that modify the picture in Figure 2-2 somewhat. Let’s take a few moments to explore the most prominent of these variations.

==== Python Implementation Alternatives ====

Really, as this book is being written, there are three primary implementations of the Python language—CPython, Jython, and IronPython—along with a handful of secondary implementations such as http://www.stackless.com/[Stackless Python]. __In brief, CPython is the ''standard implementation''; all the others have very specific purposes and roles. '''All implement the same Python language, but execute programs in different ways. (只是實作 "語言" 的部份而已, Jython 與 IronPython 可以往外引用現有的 third-party extensions 嗎[?])'''__

===== CPython =====

The original, and standard, implementation of Python is usually called CPython, when you want to contrast it with the other two. Its name comes from the fact that it is coded in portable ANSI C language code. This is the Python that you fetch from http://www.python.org, get with the http://www.activestate.com/Products/activepython/index.mhtml[ActivePython] distribution, and have automatically on most Linux and Mac OS X machines. If you’ve found a preinstalled version of Python on your machine, it’s probably CPython, unless your company is using Python in very specialized ways.

__Unless you want to script Java or .NET applications with Python, you probably want to use the standard CPython system. Because it is the ''reference implementation'' of the language, it tends to run the fastest, be the ''most complete'', and be more robust than the alternative systems.__ Figure 2-2 reflects CPython’s runtime architecture.

===== Jython =====

The Jython system (originally known as JPython) is an alternative implementation of the Python language, targeted for integration with the Java programming language. __Jython consists of Java classes that compile Python source code to Java byte code and then route the resulting byte code to the Java Virtual Machine (JVM). Programmers still code Python statements in `.py` text files as usual;__ the Jython system essentially just replaces the rightmost two bubbles in Figure 2-2 with Java-based equivalents.

__'''Jython’s goal is to allow Python code to script Java applications (與 Groovy 的功能重複), much as CPython allows Python to script C and C++ components.''' Its integration with Java is remarkably seamless. Because Python code is translated to Java byte code, it looks and feels like a true Java program at runtime. '''Jython scripts can serve as web applets and servlets, build Java-based GUIs, and so on.''' Moreover, Jython includes integration support that allows Python code to import and use Java classes as though they were coded in Python.__ Because Jython is slower and less robust than CPython, though, it is usually seen as a tool of interest primarily to Java developers looking for a scripting language to be a frontend to Java code.

===== IronPython =====

A third (and, at this writing, still somewhat new) implementation of Python, __IronPython is designed to allow Python programs to integrate with applications coded to work with Microsoft’s .NET Framework for Windows, as well as the Mono open source equivalent for Linux. .NET and its C# programming language runtime system are designed to be a language-neutral object communication layer, in the spirit of Microsoft’s earlier COM model. '''IronPython allows Python programs to act as both client and server components, accessible from other .NET languages.'''__

By implementation, IronPython is very much like Jython (and, in fact, is being developed by the same creator)—it replaces the last two bubbles in Figure 2-2 with equivalents for execution in the .NET environment. Also, like Jython, __IronPython has a special focus—it is primarily of interest to developers integrating Python with .NET components. Because it is being developed by Microsoft, though, IronPython might also be able to leverage some important optimization tools for better performance.__ IronPython’s scope is still evolving as I write this; for more details, consult the Python online resources, or search the Web.

__Jython and IronPython are completely independent implementations of Python that compile Python source for different runtime architectures. '''It is also possible to access Java and .NET software from standard CPython programs: the http://jpype.sourceforge.net/[JPype] and http://pythonnet.sourceforge.net/[Python for .NET] systems, for example, allow CPython code to call out to Java and .NET components. (只是整合度不同而已)'''__

==== Execution Optimization Tools ====

CPython, Jython, and IronPython all implement the Python language in similar ways: by compiling source code to byte code, and executing the byte code on an appropriate virtual machine. Still other systems, including the Psyco just-in-time compiler, and the Shedskin C++ translator, instead attempt to optimize the basic execution model. These systems are not required knowledge at this point in your Python career, but a quick look at their place in the execution model might help demystify(弄清楚) the model in general.

===== The Psyco just-in-time compiler =====

The Psyco system is not another Python implementation, but rather, a component that extends the byte code execution model to make programs run faster. In terms of Figure 2-2, __Psyco is an enhancement to the PVM that collects and uses type information while the program runs to translate ''portions'' of the program’s byte code all the way down to real binary machine code for faster execution. '''Psyco accomplishes this translation without requiring changes to the code or a separate compilation step during development. (類似於 Java 的 JIT 技術)'''__

Roughly, while your program runs, Psyco collects information about the kinds of objects being passed around; that information can be used to generate highly efficient machine code tailored for those object types. Once generated, the machine code then replaces the corresponding part of the original byte code to speed your program’s overall execution. __The net effect is that, with Psyco, your program becomes much quicker over time, and as it is running. In ideal cases, some Python code may become as fast as compiled C code under Psyco.__

__Because this translation from byte code happens at program runtime, Psyco is generally known as a just-in-time (JIT) compiler. Psyco is actually a bit different from the JIT compilers some readers may have seen for the Java language, though. (只針對 data types 的部份?)__ Really, Psyco is a specializing JIT compiler—it generates machine code tailored to the ''data types'' that your program actually uses. For example, if a part of your program uses different data types at different times, Psyco may generate a different version of machine code to support each different type combination.

Psyco has been shown to speed Python code dramatically(顯著地). According to its web page, Psyco provides “2x to 100x speed-ups, typically 4x, with an unmodified Python interpreter and unmodified source code, just a dynamically loadable C extension module.” __Of equal significance, the largest speedups are realized for algorithmic code written in pure Python—exactly the sort of code you might normally migrate to C to optimize. '''With Psyco, such migrations become even less important.'''__

Psyco is not yet a standard part of Python; you will have to fetch and install it separately. It is also still something of a research project, so you’ll have to track its evolution online. In fact, at this writing, although Psyco can still be fetched and installed by itself, __it appears that much of the system may eventually be absorbed into the newer http://codespeak.net/pypy/dist/pypy/doc/home.html[“PyPy”] project—an attempt to reimplement Python’s PVM in Python code, to better support optimizations like Psyco.__

Perhaps the largest downside of Psyco is that it currently only generates machine code for Intel x86 architecture chips, though this includes Windows, Linux, and recent Macs. For more details on the Psyco extension, and other JIT efforts that may arise, consult http://www.python.org; you can also check out Psyco’s home page, which currently resides at http://psyco.sourceforge.net.

===== The Shedskin C++ translator =====

__http://code.google.com/p/shedskin/[Shedskin] is an emerging system that takes a different approach to Python program execution—it attempts to translate Python source code to C++ code, which your computer’s C++ compiler then compiles to machine code.__ As such, it represents a platform-neutral approach to running Python code. Shedskin is still somewhat experimental as I write these words, and it limits Python programs to an implicit statically typed constraint that is technically not normal Python, so we won’t go into further detail here. Initial results, though, show that it has the potential to outperform(優於) both standard Python and the Psyco extension in terms of execution speed, and it is a promising(有前途的) project. Search the Web for details on the project’s current status.

==== Frozen Binaries ====

Sometimes when people ask for a “real” Python compiler, what they’re really seeking is simply a way to generate ''standalone binary executables'' from their Python programs. This is more a ''packaging and shipping'' idea than an execution-flow concept, but it’s somewhat related. With the help of third-party tools that you can fetch off the Web, __it is possible to turn your Python programs into true executables— known as ''frozen binaries'' in the Python world.__

__'''Frozen binaries bundle together the byte code of your program files, along with the PVM (interpreter), and any Python support files your program needs, into a single package. (使用者不用額外安裝 Python 或其他相關的套件; 包裝進來的是 byte code, 而非極端的 source code 或 binary machine code, 因此 interpreter 也要一起包進去)''' There are some variations on this theme, but the end result can be a single binary executable program (e.g., an `.exe` file on Windows) that can easily be shipped to customers.__ In Figure 2-2, it is as though the byte code and PVM are merged into a single component—a frozen binary file.

__Today, three primary systems are capable of generating frozen binaries: http://www.py2exe.org/[py2exe] (for Windows), http://pyinstaller.python-hosting.com/[PyInstaller] (which is similar to py2exe, but works on Linux and Unix, too, and is also capable of generating self-installing binaries), and http://wiki.python.org/moin/Freeze[freeze] (the original). You may have to fetch these tools separately from Python itself, but they are available free of charge.__ They are also constantly evolving, so see http://www.python.org and the Vaults of Parnassus web site (http://www.vex.net/parnassus/) for more on these tools. To give you an idea of the scope of these systems, py2exe can freeze standalone programs that use the Tkinter, Pmw, wxPython, and PyGTK GUI libraries; programs that use the pygame game programming toolkit; win32com client programs; and more.

Frozen binaries are not the same as the output of a true compiler—they run byte code through a virtual machine. __Hence, apart from a possible startup improvement, frozen binaries run at the same speed as the original source files. '''Frozen binaries are not small (they contain a PVM), but by current standards, they are not unusually large either. (視 support files 的大小而定)''' Because Python is embedded in the frozen binary, it does not have to be installed on the receiving end to run your program. Moreover, because your code is embedded in the frozen binary, it is effectively hidden from recipients.__

__This ''single file-packaging scheme'' is especially appealing to developers of commercial software.__ For instance, a Python-coded user interface program based on the Tkinter toolkit can be frozen into an executable file and shipped as a self-contained program on a CD or on the Web. End users do not need to install (or even have to know about) Python to run the shipped program.

==== Future Possibilities? ====

__'''Finally, note that the runtime execution model sketched here is really an ''artifact'' of the current implementation of Python, and not the language itself. (就像 Java 除了 Sun JVM 以外, 還有 JRockit、Kaffe 等, 不過好像沒有像 Python 的發展一樣多元...)'''__ For instance, it’s not impossible that a full, traditional compiler for translating Python source code to machine code may appear during the shelf life of this book (although one has not in over a decade). New byte code formats and implementation variants may also be adopted in the future. For instance:

 * __'''The emerging http://www.parrotcode.org/[Parrot] project aims to provide a common byte code format, virtual machine, and optimization techniques for a variety of programming languages (see http://www.python.org) .'''__

 * The Stackless Python system is a standard CPython implementation variant that does not save state on the C language call stack. This makes Python more easily ported to small stack architectures, and opens up novel(新奇的) programming possibilities, such as coroutines(協同程序).

 * The new PyPy project is an attempt to reimplement the PVM in Python itself to enable new implementation techniques.

Although such future ''implementation schemes'' may alter the runtime structure of Python somewhat, it seems likely that the byte code compiler will still be the standard for some time to come. The portability and runtime flexibility of byte code are important features of many Python systems. __Moreover, adding type constraint declarations to support static compilation would break the flexibility, conciseness, simplicity, and overall spirit of Python coding. Due to Python’s highly dynamic nature, any future implementation will likely retain many artifacts of the current PVM.__

=== Chapter Summary ===

This chapter introduced the execution model of Python (how Python runs your programs) and explored some common variations on that model (just-in-time compilers and the like). Although you don’t really need to come to grips with Python internals to write Python scripts, a passing acquaintance(認識) with this chapter’s topics will help you truly understand how your programs run once you start coding them. In the next chapter, you’ll start actually running some code of your own. First, though, here’s the usual chapter quiz.

==== Chapter Quiz ====

 1. What is the Python interpreter?
 2. What is source code?
 3. What is byte code?
 4. What is the PVM?
 5. Name two variations on Python’s standard execution model.
 6. How are CPython, Jython, and IronPython different?

==== Quiz Answers ====

 1. The Python interpreter is a program that runs the Python programs you write.

 2. Source code is the statements you write for your program—it consists of text in text files that normally end with a .py extension.

 3. Byte code is the lower-level form of your program after Python compiles it. Python automatically stores byte code in files with a `.pyc` extension.

 4. The PVM is the Python Virtual Machine—the runtime engine of Python that interprets your compiled code.

 5. Psyco, Shedskin, and frozen binaries are all variations on the execution model.

 6. CPython is the standard implementation of the language. Jython and IronPython implement Python programs for use in Java and .NET environments, respectively; they are alternative compilers for Python.

== Chapter 3. How You Run Programs ==

OK, it’s time to start running some code. Now that you have a handle on program execution, you’re finally ready to start some real Python programming. At this point, I’ll assume that you have Python installed on your computer; if not, see the prior chapter and Appendix A for installation and configuration hints.

There are a variety of ways to tell Python to execute the code you type. This chapter discusses all the ''program-launching techniques'' in common use today. Along the way, you’ll learn how to type code ''interactively'', and how to save it in files to be run with system command lines, ''icon clicks'', ''module imports'', IDE GUIs such as IDLE and Eclipse, and more.

If you just want to find out how to run a Python program quickly, you may be tempted to read the parts that pertain(適合) only to your platform and move on to Chapter 4. __'''But don’t skip the material on module imports, as that’s essential to understanding Python’s program architecture.''' I also encourage you at least to skim the sections on IDLE and other IDEs, so you’ll know what tools are available for when you start developing more sophisticated Python programs.__

=== Interactive Coding ===

Perhaps the simplest way to run Python programs is to type them at Python’s interactive command line. There are a variety of ways to start this command line—in an IDE, from a system console, and so on. Assuming the interpreter is installed as an executable program on your system, the most platform-neutral way to start an interactive interpreter session is usually just to type `python` at your operating system’s prompt, without any arguments. For example:

 {{{
% python
Python 2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
 }}}

Typing the word “python” at your system shell prompt begins an ''interactive Python session'' (the “%” character stands for your system’s prompt, not input that you type yourself). The notion of a system shell prompt is generic, but exactly how you access the prompt varies by platform:

 * On Windows, you can type `python` in a DOS console window (a.k.a. the Command Prompt, usually found in the Accessories section of the Programs menu of your Start button) or in the Start ➝ Run... dialog box.

 * On Unix, Linux, and Mac OS X, you might type this command in a shell or terminal window (e.g., in an xterm or console running a shell such as ksh or csh).

 * __Other systems may use similar or platform-specific devices. On PalmPilots, for example, click the Python home icon to launch an interactive session.__

If you have not set your shell’s `PATH` environment variable to include Python’s install directory, you may need to replace the word “python” with the full path to the Python executable on your machine. On Windows, try typing `C:\Python25\python` (for version 2.5); on Unix and Linux, `/usr/local/bin/python` (or `/usr/bin/python`) will often suffice. Alternatively, you can run a change-directory command to go to Python’s install directory before typing “python” (try a `cd c:\python25` command on Windows, for instance).

__The Python interactive session begins by printing two lines of informational text (which I’ll omit from this book’s examples to save space), then prompts for input with `>>>` when it’s waiting for you to type a ''new Python statement or expression''. When working interactively, the results of your code are displayed after the `>>>` lines.__ Here are the results of two Python `print` statements:

 {{{
% python
>>> print 'Hello world!'
Hello world!
>>> print 2 ** 8
256
 }}}

Again, you don’t need to worry about the details of the `print` statements shown here yet (we’ll start digging into syntax in the next chapter). In short, they print a Python string and an integer, as shown by the ''output lines'' that appear after each `>>>` ''input line''.

__When working interactively like this, you can type as many Python commands as you like; each is run immediately after it’s entered. Moreover, because the interactive session automatically prints the results of expressions you type, you don’t usually need to say “print” explicitly at this prompt: (注意這裡 session 的概念, 因此變數的指定或修改, 效果都能延續到下一行指令, 直到關閉該 session 為止)__

 {{{
>>> lumberjack = 'okay'
>>> lumberjack
'okay'
>>> 2 ** 8
256
>>> # Use Ctrl-D or Ctrl-Z to exit <-- 註解用 "#" 字元
%
 }}}

Here, the last two lines typed are ''expressions'' (`lumberjack` and `2 ** 8`), and their results are displayed automatically. __To exit an interactive session like this one and return to your system shell prompt, type Ctrl-D on Unix-like machines; on MS-DOS and Windows systems, type Ctrl-Z to exit. In the IDLE GUI discussed later, either type Ctrl-D or simply close the window.__

Now, we didn’t do much in this session’s code—just typed some Python `print` and ''assignment'' statements, and a few expressions, which we’ll study in detail later. The main thing to notice is that the interpreter executes the code entered on each line immediately, when the Enter key is pressed.

For instance, when we typed the first `print` statement at the `>>>` prompt, the output (a Python string) was echoed back right away. There was no need to create a sourcecode file, and no need to run the code through a compiler and linker first, as you’d normally do when using a language such as C or C++. As you’ll see in later chapters, you can also run ''multiline statements'' at the interactive prompt; such a statement runs immediately after you’ve entered all of its lines.

Besides typing `python` in a shell window, you can also begin similar interactive sessions by starting IDLE’s main window or, on Windows, by selecting the “Python (command-line)” menu option from the Start button menu for Python, as shown in Figure 2-1. Both spawn a `>>>` prompt with equivalent functionality—code is run as it is typed.

==== Testing Code at the Interactive Prompt ====

Because code is executed immediately, the interactive prompt turns out to be a great place to experiment with(對...進行試驗) the language. It will be used often in this book to demonstrate smaller examples. __In fact, this is the first rule of thumb to remember: if you’re ever in doubt about(對...表示懷疑) how a piece of Python code works, fire up the interactive command line and try it out to see what happens. (可以善用 Gedit 下面的 Python Console 來做實驗)__ Chances are good that you won’t break anything. (You need to know more about system interfaces before you will become dangerous.)

Although you won’t do the bulk of your coding in interactive sessions (because the code you type there is not saved), __the interactive interpreter is also a great place to test code you’ve put in files. You can ''import'' your module files interactively and run tests on the tools they define by typing calls at the interactive prompt. '''More generally, the interactive prompt is a place to test program components, regardless of their source— you can type calls to linked-in C functions, exercise Java classes under Jython, and more.''' Partly because of this interactive nature, Python supports an ''experimental and exploratory programming style'' you’ll find convenient when getting started.__

==== Using the Interactive Prompt ====

Although the interactive prompt is simple to use, there are a few tips that beginners will need to keep in mind:

 * Type Python commands only. First of all, remember that you can only type Python code at the Python prompt, not system commands. There are ways to run system commands from within Python code (e.g., with `os.system`), but they are not as direct as simply typing the commands themselves.

 * `print` statements are required only in files. Because the interactive interpreter automatically prints the results of expressions, you do not need to type complete `print` statements interactively. This is a nice feature, but it tends to confuse users when they move on to writing code in files: __within a code file, you must use `print` statements to see your output, because expression results are not ''automatically echoed''. Remember, you must say `print` in files, but not interactively.__
 
 * __'''Don’t indent at the interactive prompt (yet). When typing Python programs, either interactively or into a text file, be sure to start all your ''unnested statements'' in column 1''' (that is, all the way to the left). If you don’t, Python may print a “SyntaxError” message.__ Until Chapter 10, all statements you write will be unnested, so this includes everything for now. This seems to be a recurring(經常的) confusion in introductory Python classes. A leading space generates an error message.

 * Watch out for prompt changes and ''compound statements''. We won’t meet compound (multiline) statements until Chapter 10, but, as a preview, you should know that when typing lines 2 and beyond of a compound statement interactively, the prompt may change. __In the simple shell window interface, the interactive prompt changes to `...` instead of `>>>` for lines 2 and beyond; in the IDLE interface, lines after the first are automatically indented. '''In either case, inserting a blank line (done by hitting the Enter key at the start of a line) is needed to tell interactive Python that you’re done typing the multiline statement;''' by contrast, blank lines are ignored in files.__

   .You’ll see why this matters in Chapter 10. For now, if you happen to come across a `...` prompt or a blank line when entering your code, it probably means that you’ve somehow confused interactive Python into thinking you’re typing a multiline statement. __Try hitting the Enter key or a Ctrl-C combination to get back to the ''main prompt''.__ The `>>>` and `...` prompts can also be changed (they are available in the built-in module `sys`), but I’ll assume they have not been in the book’s example listings.
   
=== System Command Lines and Files ===

Although the interactive prompt is great for experimenting and testing, it has one big disadvantage: programs you type there go away as soon as the Python interpreter executes them. The code you type interactively is never stored in a file, so you can’t run it again without retyping it from scratch. Cut-and-paste and ''command recall'' can help some here, but not much, especially when you start writing larger programs. To cut and paste code from an interactive session, you have to edit out Python prompts, program outputs, and so on.

__To save programs permanently, you need to write your code in files, which are usually known as ''modules''. '''Modules are simply text files containing Python statements. (原來 module 只是一支 code file, 因為它可以被 import, 跟我們一般所認知的 "模組" 不太一樣 [...])'''__ Once coded, you can ask the Python interpreter to execute the statements in such a file any number of times, and in a variety of ways—by system command lines, by file icon clicks, by options in the IDLE user interface, and more. Regardless of how it is run, Python executes all the code in a module file from top to bottom each time you run the file.

__Terminology in this domain can vary somewhat. For instance, module files are often referred to as ''programs'' in Python—that is, a program is considered to be a series of precoded statements stored in a file for repeated execution. '''Module files that are run directly are also sometimes called ''scripts''—an informal term meaning a ''top-level program'' file. Some reserve the term “module” for a file imported from another file. (所有的 code files 都是 modules, 但通常將直接被執行的 module 稱為 script, 間接被引入的 modules 稱為 programs; 其中的 script 就是 entry point [...])'''__ (More on the meaning of “top-level” and imports in a few moments.)

Whatever you call them, the next few sections explore ways to run code typed into module files. In this section, you’ll learn how to run files in the most basic way: by listing their names in a `python` command line entered at a system prompt. As a first example, start your favorite text editor (e.g., vi, Notepad, or the IDLE editor), and type two Python statements into a text file named `spam.py`:

 {{{
print 2 ** 8 # Raise to a power
print 'the bright side ' + 'of life' # + means concatenation
 }}}

This file contains two Python `print` statements, and some Python comments to the right. (Text after a `#` is simply ignored as a human-readable comment, and is not considered part of the statement’s syntax.) Again, ignore the syntax of the code in this file for now. The point to notice is that you’ve typed the code into a file, rather than at the interactive prompt. In the process, you’ve coded a fully functional Python script.

Once you’ve saved this text file, you can ask Python to run it by listing its full filename as the first argument to a `python` command, typed at the system shell prompt:

 {{{
% python spam.py
256
the bright side of life
 }}}

Here again, you will type such a system shell command in whatever your system provides for command-line entry—a Windows Command Prompt window, an xterm window, or similar. Remember to replace “python” with a full directory path if your `PATH` setting is not configured. The output of this little script shows up after the command is typed—it’s the result of the two `print` statements in the text file.

__Notice that the module file is called `spam.py`. As for all top-level files, it could also be called simply `spam`, but files of code you want to import into a client have to end with a `.py` suffix.__ We’ll study imports later in this chapter.

__Because you may want to import a file in the future, it’s a good idea to use `.py` suffixes for most Python files that you code. Also, some text editors detect Python files by their `.py` suffix;__ if the suffix is not present, you may not get features like syntax colorization and automatic indentation.

Because this scheme uses shell command lines to start Python programs, all the usual shell syntax applies. For instance, you can route the output of a Python script to a file to save it for later use or inspection by using special shell syntax:

 {{{
% python spam.py > saveit.txt
 }}}

In this case, the two output lines shown in the prior run are stored in the file `saveit.txt` instead of being printed. This is generally known as ''stream redirection''; it works for input and output text, and it works on Windows and Unix-like systems. It also has little to do with Python (Python simply supports it), so we will skip further details on redirection here.

If you are working on a Windows platform, this example works the same, but the system prompt is normally different:

 {{{
C:\Python25> python spam.py
256
the bright side of life
 }}}

As usual, be sure to type the full path to Python if you haven’t set your `PATH` environment variable, and haven’t run a change-directory command:

 {{{
D:\temp> C:\python25\python spam.py
256
the bright side of life
 }}}

On newer versions of Windows, you can also type just the name of your script, regardless of the directory in which you’re working. __Because newer Windows systems use the Windows Registry to find a program with which to run a file, you don’t need to list it on the command line explicitly.__ The prior command, for example, could be simplified to this on a recent version of Windows:

 {{{
D:\temp> spam.py
 }}}

Finally, remember to give the full path to your script file if it lives in a different directory from the one in which you are working. For example, the following system command line, run from `D:\other`, assumes Python is in your system path but runs a file located elsewhere:

 {{{
D:\other> python c:\code\myscript.py
 }}}

==== Using Command Lines and Files ====

Running program files from system command lines is also a fairly straightforward launch option, especially if you are familiar with command lines in general from prior work. For newcomers, though, here are a few pointers about common beginner traps:

 * Beware of automatic extensions on Windows. If you use the Notepad program to code program files on Windows, be careful to pick the type All Files when it comes time to save your file, and give the file a `.py` suffix explicitly. Otherwise, Notepad will save your file with a `.txt` extension (e.g., as `spam.py.txt`), making it difficult to run in some launching schemes.

   .__Worse, Windows hides file extensions by default, so unless you have changed your view options, you may not even notice that you’ve coded a text file and not a Python file.__ The file’s icon may give this away—if it doesn’t have a snake on it, you may have trouble. Uncolored code in IDLE and files that open to edit instead of run when clicked are other symptoms of this problem.

   .Microsoft Word similarly adds a `.doc` extension by default; much worse, it adds formatting characters that are not legal Python syntax. __As a rule of thumb, always pick All Files when saving under Windows, or use more programmer-friendly text editors such as IDLE.__ IDLE does not even add a `.py` suffix automatically—a feature programmers tend to like, and users do not.

 * Use file extensions at system prompts, but not for imports. Don’t forget to type the full name of your file in system command lines—that is, use `python spam.py` rather than `python spam`. __Python `import` statements, which we’ll meet later in this chapter, omit both the `.py` file suffix, and the directory path (e.g., `import spam`). This may seem simple, but it’s a common mistake.__

   .__'''At the system prompt, you are in a system shell, not Python, so Python’s ''module file search rules'' do not apply.''' Because of that, you must include the `.py` extension, and you can optionally include a full directory path leading to the file you wish to run. For instance, to run a file that resides in a different directory from the one in which you are working, you would typically list its full path (i.e., `C:\python25>python d:\tests\spam.py`). '''Within Python code, however, you just say `import spam`, and rely on the Python ''module search path'' to locate your file, as described later.'''__

 * Use `print` statements in files. Yes, we’ve already been over this, but it is such a common mistake that it’s worth repeating here. Unlike in interactive coding, you generally must use `print` statements to see output from program files.

==== Unix Executable Scripts (#!) ====

If you are going to use Python on a Unix, Linux, or Unix-like system, you can also turn files of Python code into ''executable programs'', much as you would for programs coded in a shell language such as csh or ksh. Such files are usually called ''executable scripts''. In simple terms, Unix-style executable scripts are just normal text files containing Python statements, but with two special properties:

 * __Their first line is special. Scripts usually start with a line that begins with the characters `#!` (often called “hash bang”), followed by the path to the Python interpreter on your machine.__

 * __They usually have ''executable privileges''. Script files are usually marked as executable to tell the operating system that they may be run as ''top-level programs''. '''(做為 executable scripts 時, 我們通常不會加 `.py` 做為檔名, 因為使用者並不需要知道這支程式是用什麼 script 寫的, 而且加了 `.py` 之後, 用起來反而不方便或不直覺...)'''__

On Unix systems, a command such as `chmod +x file.py` usually does the trick. Let’s look at an example for Unix-like systems. Use your text editor again to create a file of Python code called `brian`:

 {{{
#!/usr/local/bin/python
print 'The Bright Side of Life...' # Another comment here
 }}}

The special line at the top of the file tells the system where the Python interpreter lives. Technically, the first line is a Python comment. __As mentioned earlier, all comments in Python programs start with a `#` and span to the end of the line; they are a place to insert extra information for human readers of your code. But when a comment such as the first line in this file appears, it’s special because the operating system uses it to find an interpreter for running the program code in the rest of the file.__

Also, note that this file is called simply `brian`, without the `.py` suffix used for the module file earlier. Adding a `.py` to the name wouldn’t hurt (and might help you remember that this is a Python program file), but because you don’t plan on letting other modules import the code in this file, the name of the file is irrelevant. If you give the file executable privileges with a `chmod +x brian` shell command, you can run it from the operating system shell as though it were a binary program:

 {{{
% brian
The Bright Side of Life...
 }}}

__A note for Windows users: the method described here is a Unix trick, and it may not work on your platform.__ Not to worry; just use the basic command-line technique explored earlier. List the file’s name on an explicit `python` command line:

 {{{
C:\book\tests> python brian <-- 可以寫一支 .bat 檔來包裝
The Bright Side of Life...
 }}}

As we discussed when exploring command lines, modern Windows versions also let you type just the name of a `.py` file at the system command line—they use the Registry to determine that the file should be opened with Python (e.g., typing `brian.py` is equivalent to typing `python brian.py`). This command-line mode is similar in spirit to the Unix `#!`. __Note that some programs may actually interpret and use a first `#!` line on Windows much like on Unix, but the DOS system shell on Windows ignores it completely.__

__In this case, you don’t need the special `#!` comment at the top (although Python just ignores it if it’s present), and the file doesn’t need to be given executable privileges. In fact, if you want to run files portably between Unix and Microsoft Windows, your life will probably be simpler if you always use the basic command-line approach, not Unix-style scripts, to launch programs. (習慣上還是會加上 "#!" 的宣告, 因為它在不支援的環境下並不會影響執行)__

==== The Unix env Lookup Trick ====

On some Unix systems, you can avoid hardcoding the path to the Python interpreter by writing the special first-line comment like this:

 {{{
#!/usr/bin/env python
...script goes here...
 }}}

__When coded this way, the `env` program locates the Python interpreter according to your system ''search path'' settings (i.e., in most Unix shells, by looking in all the directories listed in the `PATH` environment variable). This scheme can be more ''portable'', as you don’t need to hardcode a Python install path in the first line of all your scripts.__

Provided you have access to `env` everywhere, your scripts will run no matter where Python lives on your system—you need only change the `PATH` environment variable settings across platforms, not in the first line in all your scripts. __Of course, this assumes that `env` lives in the same place everywhere (on some machines, it may also be in `/sbin`, `/bin`, or elsewhere); if not, all portability bets(打賭) are off.__

=== Clicking File Icons ===

On Windows, the Registry makes opening files with icon clicks easy. Python automatically registers itself to be the program that opens Python program files when they are clicked. Because of that, it is possible to launch the Python programs you write by simply clicking (or double-clicking) on their file icons with your mouse.

On non-Windows systems, you will probably be able to perform a similar trick, but the icons, file explorer, navigation schemes, and more may differ slightly. __On some Unix systems, for instance, you may need to register the `.py` extension with your ''file explorer'' GUI, make your script executable using the `#!` trick discussed in the prior section, or associate the file ''MIME type'' with an application or command by editing files, installing programs, or using other tools.__ See your file explorer’s documentation for more details if clicks do not work correctly right off the bat.

__'''Nautilus 裡有個 Executable Text Files 的設定, 預設為 "Ask each time", 也就是每次 double-click 可執行的腳本時, 會跳出 "Run in Terminal"、"Display"、"Cancel"、"Run" 四個選項, 顯然 "Run in Terminal" 與 "Run" 是不同的. 實驗發現將 Open with 指向 `/usr/bin/gnome-terminal` 再配合 "View executable text files when they are opened" 的 behavior, 可以達到類似 Windows 的效果, 但 behavior 設定為 "Ask each time" 時, 會淩駕 Open With 的設定, 還是會跳出四個選項... 如果是要佈署程式, 最好的方式還是建立 Launcher, 只要記得將 Type 設定為 "Application in Terminal", 再配合 script 開頭的 "`#!`" 宣告, 並將腳本的權限設定為可執行就可以了... @2009/04/09'''__

 * http://ubuntuforums.org/archive/index.php/t-838754.html[[gnome] [SOLVED] Run a file in Terminal from an icon? [Archive] - Ubuntu Forums]
 * http://brainstorm.ubuntu.com/idea/10095/[Idea #10095: "Associate Python, Perl and bash scripts by extension" - Ubuntu brainstorm]
 * http://ubuntuforums.org/archive/index.php/t-326031.html[Gnome-terminal equivalent to "konsole --noclose -e" [Archive] - Ubuntu Forums]
 * http://ubuntuforums.org/showthread.php?p=4559942&mode=linear#post4559942[how run a python program by clicking its icon? - Ubuntu Forums]

==== Clicking Icons on Windows ====

To illustrate, suppose you create the following program file with your text editor and save it as `script4.py`:

 {{{
# A comment
import sys
print sys.platform
print 2 ** 100
 }}}

There’s not much new here—just an import and two prints again (`sys.platform` is just a string that identifies the kind of computer you’re working on; it lives in a module called `sys`, which you must import to load). You can run this file from a system command line:

 {{{
D:\LP3E\Examples> c:\python25\python script4.py
win32
1267650600228229401496703205376
 }}}

However, icon clicks allow you to run the file without any typing at all. If you find this file’s icon—for instance, by selecting My Computer and working your way down on the D drive—you will get the file explorer picture captured in Figure 3-1 (Windows XP is being used here). __In Python 2.5, source files show up with white backgrounds on Windows, and byte code files show up with black backgrounds. You will normally want to click (or otherwise run) the source code file, in order to pick up your most recent changes.__ To launch the file here, simply click on the icon for `script4.py`.

{{attachment:figure_2-3.png}} <<BR>> Figure 3-1. On Windows, Python program files show up as icons in file explorer windows, and can automatically be run with a double-click of the mouse (though you might not see printed output or error messages this way).

==== The raw_input Trick ====

Unfortunately, on Windows, the result of clicking on a file icon may not be incredibly(非常地) satisfying. In fact, as it is, this example script generates a perplexing “flash” when clicked—not the sort of feedback that budding(初出茅廬的) Python programmers usually hope for! This is not a bug, but it has to do with the way the Windows port handles printed output.

By default, Python generates a pop-up black DOS console window to serve as a clicked file’s input and output. If a script prints and exits, then, well, it just prints and exits—the console window appears, and text is printed there, but the console window closes and disappears on program exit. Unless you are very fast, or your machine is very slow, you won’t get to see your output at all. Although this is normal behavior, it’s probably not what you had in mind.

Luckily, it’s easy to work around this. __If you need your script’s output to stick around when you launch it with an icon click, simply put a call to the built-in `raw_input` function at the very bottom of the script.__ For example:

 {{{
# A comment
import sys
print sys.platform
print 2 ** 100
raw_input() # ADDED, 要加括號
 }}}

__In general, `raw_input` reads the next line of standard input, waiting if there is none yet available. The net effect in this context will be to pause the script, thereby keeping the output window shown in Figure 3-2 open until you press the Enter key.__

{{attachment:figure_3-2.png}} <<BR>> Figure 3-2. When you click a program’s icon on Windows, you will be able to see its printed output if you add a `raw_input()` call to the very end of the script. But you only need to do so in this context!

__Now that I’ve shown you this trick, keep in mind that it is usually only required for Windows, and then only if your script prints text and exits, and only if you will launch the script by clicking its file icon. You should add this call to the bottom of your top-level files if and only if all of these three conditions apply. There is no reason to add this call in any other contexts.__

__It is also possible to completely suppress(使隱匿) the pop-up DOS console window for clicked files on Windows. '''Files whose names end in a `.pyw` extension will display only windows constructed by your script, not the default DOS console window. (跟 Java 區分為 `java` 與 `javaw` 兩個不同的執行方式一樣)''' `.pyw` files are simply `.py` source files that have this special operational behavior on Windows. They are mostly used for Python-coded user interfaces that build windows of their own, often in conjunction with various techniques for saving printed output and errors to files.__

Before we move ahead, note that the `raw_input` call applied here is the ''input counterpart'' of using the `print` statement for outputs. It is the simplest way to read user input, and it is more general than this example implies. For instance, raw_input:

 * Optionally accepts a string that will be printed as a prompt (e.g., `raw_input('Press Enter to exit')`)
 * Returns to your script the line of text read as a string (e.g., `nextinput = raw_input()`)
 * __Supports input stream redirections at the ''system shell level'' (e.g., python `spam.py < input.txt`), just as the `print` statement does for output__

We’ll use `raw_input` in more advanced ways later in this text; for instance, Chapter 10 will apply it in an interactive loop.

==== Other Icon-Click Limitations ====

Even with the `raw_input` trick, clicking file icons is not without its perils(危險). You also may not get to see Python error messages. __If your script generates an error, the error message text is written to the pop-up console window—which then immediately disappears. Worse, adding a `raw_input` call to your file will not help this time because your script will likely abort long before it reaches this call. (為什麼會有卡住的情形?) In other words, you won’t be able to tell what went wrong.__

__'''Because of these limitations, it is probably best to view icon clicks as a way to launch programs after they have been debugged.'''__ Especially when starting out, use other techniques—such as system command lines and IDLE (discussed later in this chapter)— so that you can see generated error messages and view your normal output without resorting to(求助於) coding tricks. __When we discuss exceptions later in this book, you’ll also learn that it is possible to intercept and recover from errors so that they do not terminate your programs. Watch for the discussion of the `try` statement later in this book for an alternative way to keep the console window from closing on errors.__

=== Module Imports and Reloads ===

So far, I’ve been talking about “importing modules” without really explaining what this term means. We’ll study modules and larger program architecture in depth in Part V, but because imports are also a way to launch programs, this section will introduce enough module basics to get you started.

__'''In simple terms, every file of Python source code whose name ends in a `.py` extension is a module. Other files can access the items a module defines by importing that module;''' import operations essentially load another file, and grant access to that file’s contents. The contents of a module are made available to the ''outside world'' through its ''attributes'' (a term I’ll define in the next section).__

__This ''module-based services model'' turns out to be the core idea behind ''program architecture'' in Python. Larger programs usually take the form of multiple module files, which import tools from other module files. '''One of the modules is designated as the main or top-level file, and is the one launched to start the entire program.'''__

We’ll delve into such architectural issues in more detail later in this book. __This chapter is mostly interested in the fact that '''import operations run the code in a file that is being loaded as a final step.''' Because of this, importing a file is yet another way to launch it.__

For instance, if you start an interactive session (in IDLE, from a command line, or otherwise), you can run the `script4.py` file you created earlier with a simple import:

 {{{
D:\LP3E\Examples> c:\python25\python
>>> import script4 # 不用加 ".py", 因此要在 script4.py 所在的目錄執行 python 才行
win32
1267650600228229401496703205376
 }}}

__This works, but only once ''per session (really, process)'', by default. After the first import, later imports do nothing, even if you change and save the module’s source file again in another window: (指同一個 module 在同一個 session 下被 import 時, 只會第一次才會連帶被執行, 後續 import 其他 modules 時還是會執行該 modules 一次)__

 {{{
>>> import script4
>>> import script4
 }}}

__This is by design; imports are too expensive an operation to repeat more than once per program run. As you’ll learn in Chapter 18, imports must find files, compile to byte code, and run the code.__

If you really want to force Python to run the file again in the same session (without stopping and restarting the session), you need to instead call the built-in `reload` function:

 {{{
>>> reload(script4)
win32
65536
<module 'script4' from 'script4.py'>
>>>
 }}}

__The `reload` function loads and runs the current version of your file’s code if you’ve changed it in another window. This allows you to edit and pick up new code on the fly within the current Python interactive session.__ In this session, for example, the second `print` statement in `script4.py` was changed in another window to `print 2 ** 16` between the time of the first `import` and the `reload` call.

__The `reload` function expects the name of an already loaded ''module object'', so you have to have successfully imported a module once before you reload it. '''Notice that `reload` also expects parentheses around the module object name, whereas `import` does not. `reload` is a function that is called, and `import` is a statement.''' That’s why you must pass the module name to `reload` as an ''argument'' in parentheses, and that’s why you get back an extra output line when reloading. The last output line is just print’s representation of the `reload` call’s ''return value'', a Python module object. (呼應了上面 "automatically echoed" 的說法)__

Functions will be discussed further in Chapter 15.

==== The Grander Module Story: Attributes ====

Imports and reloads provide a natural program launch option because import operations execute files as a last step. __In the broader scheme of things, though, modules serve the role of ''libraries of tools'', as you’ll learn in Part V. '''More generally, a module is mostly just ''a package of variable names'', known as a ''namespace''. The ''names'' within that package are called ''attributes''—that is, an attribute is a variable name that is attached to a specific object (= module object).'''__

__'''按http://docs.python.org/tutorial/modules.html[官方文件]的說法 - Packages are a way of structuring Python’s module namespace by using “dotted module names”. 因此這裡 "package" 的用法很容易讓人誤導!!'''__

__In typical use, ''importers'' gain access to all the names assigned at the ''top level'' of a module’s file. These names are usually assigned to tools ''exported'' by the module— ''functions'', ''classes'', ''variables'', and so on—that are intended to be used in other files and other programs. '''(這裡 tools 的說法很特別 - 例如下面的 "tools as functions", 有點類於 Java 的 helper methods/classes[...])'''__ Externally, a module file’s names can be fetched with two Python statements, `import` and `from`, as well as the `reload` call.

To illustrate, use a text editor to create a one-line Python module file called `myfile.py` with the following contents:

 {{{
title = "The Meaning of Life"
 }}}

This may be one of the world’s simplest Python modules (it contains a single assignment statement), but it’s enough to illustrate the basics. __When this file is imported, its code is ''run to generate'' the module’s attribute. The assignment statement creates a module attribute named `title`. '''(這呼應了上面 "everything happens as the program is running" 的說法, 也解釋了為什麼 modules 在第一次被 import 時要執行的原因)'''__

You can access this module’s `title` attribute in other components in two different ways. __First, you can load the module ''as a whole'' with an `import` statement, and then ''qualify'' the module name with the attribute name to access it:__

 {{{
% python # Start Python
>>> import myfile # Run file; load module as a whole
>>> print myfile.title # Use its attribute names: '.' to qualify
The Meaning of Life
 }}}

In general, the dot expression syntax `object.attribute` lets you fetch any attribute attached to any object, and this is a common operation in Python code. Here, we’ve used it to access the string variable `title` inside the module `myfile`—in other words, `myfile.title`.

__Alternatively, you can fetch (really, ''copy'') names out of a module with `from` statements:__

 {{{
% python # Start Python
>>> from myfile import title # Run file; copy its names
>>> print title # Use name directly: no need to qualify
The Meaning of Life
 }}}

As you’ll see in more detail later, `from` is just like an `import`, with an extra assignment to names in the importing component. __'''Technically, `from` copies a module’s attributes, such that they become simple variables in the recipient—thus, you can simply refer to the imported string this time as `title` (a variable) instead of `myfile.title` (an ''attribute reference''; 注意這裡 "attribute copy" 與 "attribute reference" 的不同? 還是因為 string 是 immutable 的關係[?]).'''__

 {{{
% python
>>> import myfile
>>> myfile.title = 'changed'
>>> myfile.title
'changed'
>>> from myfile import title # 複製出來
>>> title
'changed'
>>> title = 'local'
>>> myfile.title # 只改到複製出來那一份
'changed'
>>> title
'local'
 }}}

Notice that `import` and `from` both list the name of the module file as simply `myfile` without its `.py` suffix. __As you’ll learn in Part V, when Python looks for the actual file, it knows to include the suffix in its search procedure. Again, you must remember to include the suffix in system shell command lines, but not in `import` statements.__

__Whether you use `import` or `from` to invoke an ''import operation'', the statements in the module file `myfile.py` are ''executed'' (只有在第一次時, 不論是單純用 `import` 還是 `from ... import ...`), and the ''importing component'' (here, the interactive prompt) gains access to names assigned at the top level of the file.__ There’s only one such name in this simple example—the variable `title`, assigned to a string—but the concept will be more useful when you start defining objects such as functions and classes in your modules. __Such objects become reusable software components that can be accessed by name from one or more ''client modules (= importers)''.__

In practice, module files usually define more than one name to be used in and outside the files. Here’s an example that defines three:

 {{{
a = 'dead' # Define three attributes
b = 'parrot' # Exported to other files
c = 'sketch'
print a, b, c # Also used in this file
 }}}

This file, `threenames.py`, assigns three variables, and so ''generates'' three attributes for the outside world. It also uses its own three variables in a `print` statement, as we see when we run this as a top-level file:

 {{{
% python threenames.py
dead parrot sketch
 }}}

__All of this file’s code runs as usual the first time it is imported elsewhere (by either an `import` or `from`). Clients of this file that use `import` get a module with attributes, while clients that use `from` get copies of the file’s names:__

 {{{
% python
>>> import threenames # Grab the whole module
dead parrot sketch
>>>
>>> threenames.b, threenames.c
('parrot', 'sketch')
>>>
>>> from threenames import a, b, c # Copy multiple names
>>> b, c
('parrot', 'sketch')
 }}}

The results here are printed in parentheses because they are really http://en.wikipedia.org/wiki/Tuple[tuples] (a kind of object covered in the next part of this book).

__Once you start coding modules with multiple names like this, the built-in `dir` function starts to come in handy. You can use it to fetch a list of the names available inside a module:__

 {{{
>>> dir(threenames)
['_ _builtins_ _', '_ _doc_ _', '_ _file_ _', '_ _name_ _', 'a', 'b', 'c']
 }}}

When the `dir` function is called with the name of an ''imported'' module passed in parentheses like this, it returns all the attributes inside that module. __Some of the names it returns are names you get “for free”: '''names with leading and trailing double underscores are built-in names that are always predefined by Python, and that have special meaning to the interpreter.'''__ The variables our code defined by assignment— a, b, and c—show up last in the `dir` result.

===== Modules and namespaces =====

Module imports are a way to run files of code, but, as we’ll discuss later in the book, __modules are also the ''largest program structure'' in Python programs. '''In general, Python programs are composed of multiple module files, linked together by `import` statements. Each module file is a ''self-contained'' package of variables—that is, a ''namespace''.''' One module file cannot see the names defined in another file unless it explicitly imports that other file, so modules serve to minimize name collisions(衝突) in your code—because each file is a self-contained namespace, the names in one file cannot clash with(不調和) those in another, even if they are spelled the same way.__

In fact, as you’ll see, modules are one of a handful of ways that Python goes to great lengths to package your variables into compartments(隔間) to avoid name clashes. __We’ll discuss modules and other ''namespace constructs'' (including classes and function scopes) further later in the book.__ For now, modules will come in handy as a way to run your code many times without having to retype it.

==== import and reload Usage Notes ====

For some reason, once people find out about running files using `import` and `reload`, many tend to focus on this alone and forget about other launch options that always run the current version of the code (e.g., icon clicks, IDLE menu options, and system command lines). This can quickly lead to confusion—you need to remember when you’ve imported to know if you can reload, you need to remember to use parentheses when you call `reload` (only), and you need to remember to use `reload` in the first place to get the current version of your code to run.

__Because of these complications (and others we’ll meet later), it’s a good idea to avoid the temptation(誘惑) to launch by imports and reloads for now. The IDLE Run ➝ Run Module menu option, for example, provides a simpler and less error-prone way to run your files. On the other hand, imports and reloads have proven to be a popular testing technique in Python classes. You may prefer using this approach, but if you find yourself running into a wall, stop. (可以用, 但如果造成困擾就不要用...)__

There is more to the module story than we’ve exposed here. For instance, the `execfile('module.py')` built-in function is another way to launch files from the interactive prompt without having to import and later reload. It has a similar effect, but doesn’t technically import the module—by default, __each time you call `execfile`, it runs the file anew(重新), as though you had ''pasted'' it in at the place where `execfile` is called. Because of that, `execfile`, like the `from` statement mentioned earlier, '''has the potential to silently overwrite variables you may currently be using. (把它想成 include 就不難理解這裡的問題)''' The basic `import` statement, on the other hand, runs the file only once per process, and makes the file a separate namespace so that it will not change variables in your scope.__

In addition, you may run into trouble if you use modules in unusual ways at this point in the book. __For instance, if you want to import a module file that is stored in a directory other than the one you’re working in, you’ll have to skip ahead to Chapter 18 and learn about the ''module search path''.__ For now, if you must import, try to keep all your files in the directory you are working in to avoid complications.

In case you can’t wait until Chapter 18, the short story is that __Python searches for imported modules in every directory listed in `sys.path`—a Python list of directory name strings in the `sys` module, '''which is initialized from a `PYTHONPATH` environment variable, plus a set of standard directories. (之後可以先 `import sys` 再 `print sys` 查看內容)''' If you want to import from a directory other than the one you are working in, that directory must generally be listed in your `PYTHONPATH` setting.__ For more details, see Chapter 18.

=== The IDLE User Interface ===

So far, we’ve seen how to run Python code with the interactive prompt, system command lines, icon clicks, and module imports. If you’re looking for something a bit more visual, IDLE provides a graphical user interface (GUI) for doing Python development, and it’s a standard and free part of the Python system. It is usually referred to as an integrated development environment (IDE), because it binds together various development tasks into a single view. __IDLE is officially a corruption(訛誤) of IDE, but it’s really named in honor of(為紀念...) Monty Python member http://en.wikipedia.org/wiki/Eric_Idle[Eric Idle].__

In short, IDLE is a GUI that lets you edit, run, browse, and debug Python programs, all from a single interface. __Moreover, because IDLE is a Python program that uses the Tkinter GUI toolkit, it runs portably on most Python platforms, (不過 UI 真的有點遭!!)__ including Microsoft Windows, X Windows (for Linux, Unix, and Unix-like platforms), and the Mac OS (both Classic and OS X). For many, IDLE represents an easy-to-use alternative to typing command lines, and a less problem-prone alternative to clicking on icons.

==== IDLE Basics ====

Let’s jump right into an example. IDLE is easy to start under Windows—it has an entry in the Start button menu for Python (see Figure 2-1), and it can also be selected by right-clicking on a Python program icon. On some Unix-like systems, you may need to launch IDLE’s top-level script from a command line, or, alternatively, by clicking on the icon for the `idle.pyw` or `idle.py` file located in the `idlelib` subdirectory of Python’s Lib directory. (On Windows, IDLE is a Python script that currently lives in `C:\Python25\Lib\idlelib`.)

IDLE is a Python program that uses the standard library’s Tkinter GUI toolkit to build the IDLE GUI. This makes IDLE portable, but it also means that you’ll need to have Tkinter support in your Python to use IDLE. The Windows version of Python has this by default, but some Linux and Unix users may need to install the appropriate Tkinter support (a `yum tkinter` command may suffice on some Linux distributions, but see the installation hints in Appendix A for details). Mac OS X may have everything you need preinstalled, too; look for an `idle` command or script on your machine.

Figure 3-3 shows the scene after starting IDLE on Windows. The Python shell window that opens initially is the main window, which runs an interactive session (notice the `>>>` prompt). This works like all interactive sessions—code you type here is run immediately after you type it—and serves as a testing tool.

{{attachment:figure_3-3.png}} <<BR>> Figure 3-3. The main Python shell window of the IDLE development GUI, shown here running on Windows. Use the File menu to begin (New Window), or change (Open...) a source file; use the file edit window’s Run menu to run the code in that window (Run Module).

IDLE uses familiar menus with keyboard shortcuts for most of its operations. To make (or edit) a source code file under IDLE, open a text edit window: in the main window, select the File pull-down menu, and pick New Window to open a text edit window (or Open...to edit an existing file). A new window will appear. This is an IDLE text edit window, where the code for the file you are creating or changing is entered and displayed.

Although it may not show up fully in this book, IDLE uses syntax-directed colorization for the code typed in both the main window and all text edit windows— keywords are one color, literals are another, and so on. This helps give you a better picture of the components in your code.

To run a file of code that you are editing in IDLE, select the file’s text edit window, pick that window’s Run pull-down menu, and choose the Run Module option listed there (or use the equivalent keyboard shortcut, given in the menu). Python will let you know that you need to save your file first if you’ve changed it since it was opened or last saved.

When run this way, the output of your script and any error messages it may generate show up back in the ''main interactive window'' (the Python shell window). In Figure 3-3, for example, the last three lines in the window reflect an execution of a script opened in a separate edit window; __the “RESTART” message tells us that the user-code process was restarted to run the edited script, and serves to separate script output.__

Hint of the day: if you want to repeat prior commands in IDLE’s main interactive window, you can use the Alt-P key combination to scroll backward through the command history, and Alt-N to scroll forward (on some Macs, try Ctrl-P and Ctrl-N instead). Your prior commands will be recalled and displayed, and may be edited and rerun. You can also recall commands by positioning the cursor on them, or use cut-and-paste operations, but these tend to be more work. Outside IDLE, you may be able to recall commands in an interactive session with the arrow keys on Windows.

:::

=== Other IDEs ===

Because IDLE is free, portable, and a standard part of Python, it’s a nice first development tool to become familiar with if you want to use an IDE at all. Again, I recommend that you use IDLE for this book’s exercises if you’re just starting out, unless you are already familiar with a command-line-based development mode. There are, however, a handful of alternative IDEs for Python developers, some of which are substantially more powerful and robust than IDLE. Here are some of the most commonly used IDEs:

'''Eclipse and PyDev'''

Eclipse is an advanced open source IDE GUI. Originally developed as a Java IDE, Eclipse also supports Python development when you install the http://pydev.sourceforge.net/[PyDev] (or similar) plug-in. __Eclipse is a popular and powerful option for Python development, and it goes well beyond IDLE’s feature set. Its downsides seem to be that it is a large system to install, and its PyDev plug-in requires a ''shareware'' extensions package for some features (including an integrated interactive console) that is not strictly open source. (從 http://www.fabioz.com/pydev/updates 安裝, 分別有 PyDev for Eclipse 及 PyDev Mylyn Integration; 由此顯見 Eclipse 的野心!!)__ Still, when you are ready to graduate from IDLE, the Eclipse/PyDev combination is worth your attention.

'''Komodo'''

A full-featured development environment GUI for Python (and other languages), http://www.activestate.com/Products/komodo_ide/index.mhtml[Komodo] includes standard syntax-coloring, text-editing, debugging, and other features. In addition, Komodo offers many advanced features that IDLE does not, including project files, source-control integration, regular-expression debugging, and a drag-and-drop GUI builder that generates Python/Tkinter code to implement the GUIs you design interactively. At this writing, Komodo is not free; it is available at http://www.activestate.com.

'''PythonWin'''

PythonWin is a free Windows-only IDE for Python that ships as part of ActiveState’s ActivePython distribution (and may also be fetched separately from http://www.python.org resources). It is roughly like IDLE, with a handful of useful Windows-specific extensions added; for example, __PythonWin has support for COM objects. Today, IDLE is probably more advanced than PythonWin (for instance, IDLE’s dual-process architecture more often prevents it from becoming hung). However, PythonWin still offers tools for Windows developers that IDLE does not.__ See http://www.activestate.com for more information.

'''Others'''

There are roughly half a dozen other well-known IDEs that I’m aware of (e.g., WingIDE, PythonCard), and more will probably appear over time. In fact, almost every programmer-friendly text editor has some sort of support for Python development these days, whether it be preinstalled or fetched separately. Emacs and Vim, for instance, also have substantial Python support. Rather than trying to document all such options here, see the resources available at http:// www.python.org, or run a Google web search for “Python editors”—this should lead you to a Wiki page that maintains information about many IDE and text editor options for Python programming.

=== Embedding Calls ===

At this point, we’ve seen how to run code typed interactively, and how to launch code saved in files with system command lines, Unix executable scripts, icon clicks, module imports, and IDEs like IDLE. That covers most of the cases you’ll see in this book.

__But, in some specialized domains, Python code may also be run by an ''enclosing system''. In such cases, we say that the Python programs are ''embedded'' in (i.e., run by) another program.__ The Python code itself may be entered into a text file, stored in a database, fetched from an HTML page, parsed from an XML document, and so on. But from an operational perspective, another system—not you—may tell Python to run the code you’ve created. __Such an ''embedded execution mode'' is commonly used to support end user customization—a game program, for instance, might allow for play modifications by running user-accessible embedded Python code at strategic points in time.__

As an example, it’s possible to create and run strings of Python code from a C program by calling functions in the Python runtime API (a set of services exported by the libraries created when Python is compiled on your machine):

 {{{
#include <Python.h>
...
Py_Initialize();
PyRun_SimpleString("x = brave + sir + robin");
 }}}

In this C code snippet, a program coded in the C language embeds the Python interpreter by linking in its libraries, and passes it a Python assignment statement string to run. __C programs may also gain access to Python objects and process or execute them using other Python API tools.__

__This book isn’t about Python/C integration, but you should be aware that, depending on how your organization plans to use Python, you may or may not be the one who actually starts the Python programs you create. '''Regardless, you can still likely use the interactive and file-based launching techniques described here to test code ''in isolation'' from those enclosing systems that may eventually use it.'''__

__See Programming Python (O’Reilly) for more details on embedding Python in C/C++. The embedding API can call Python functions directly, load modules, and more. Also, note that the Jython system allows Java programs to invoke Python code using a Java-based API (a Python interpreter class).__

=== Frozen Binary Executables ===

Frozen binary executables, described in the preceding chapter, are packages that combine your program’s byte code and the Python interpreter into a single executable program. With these, Python programs can be launched in the same ways that you would launch any other executable program (icon clicks, command lines, etc.). __While this option works well for delivery of products, it is not really intended for use during program development. You normally freeze just before shipping (after development is finished).__ See the prior chapter for more on this option.

=== Text Editor Launch Options ===

As mentioned previously, although not full-blown IDE GUIs, most programmer friendly text editors have support for editing, and possibly running, Python programs. Such support may be built in or fetchable on the Web. For instance, if you are familiar with the Emacs text editor, you can do all your Python editing and launching from inside the text editor itself. See the text editor resources page at http://www.python.org/editors for more details, or search the Web for the phrase “Python editors.”

=== Other Launch Options ===

Depending on your platform, there may be additional ways that you can start Python programs. For instance, on some Macintosh systems, you may be able to drag Python program file icons onto the Python interpreter icon to make them execute. And on Windows, you can always start Python scripts with the Run... option in the Start menu. Finally, the Python standard library has utilities that allow Python programs to be started by other Python programs (e.g., `execfile`, `os.popen`, `os.system`); however, these tools are beyond the scope of the present chapter.

=== Future Possibilities? ===

Although this chapter reflects current practice, much of it has been both platformand time-specific. Indeed, many of the execution and launch details presented arose during the shelf life of this book’s editions. As with program execution options, it’s not impossible that new program launch options may arise over time.

New operating systems, and new versions of existing systems, may also provide execution techniques beyond those outlined here. In general, because Python keeps pace with such changes, you should be able to launch Python programs in whatever way makes sense for the machines you use, both now and in the future—be that by drawing on tablet PCs or PDAs, grabbing icons in a virtual reality, or shouting a script’s name over your coworkers’ conversations.

Implementation changes may also impact launch schemes somewhat (e.g., a full compiler could produce normal executables that are launched much like frozen binaries today). If I knew what the future truly held, though, I would probably be talking to a stockbroker(經紀人) instead of writing these words!

=== Which Option Should I Use? ===

With all these options, one question naturally arises: which one is best for me? In general, you should use the IDLE interface for development if you are just getting started with Python. It provides a user-friendly GUI environment, and can hide some of the underlying configuration details. It also comes with a platform-neutral text editor for coding your scripts, and it’s a standard and free part of the Python system.

If, on the other hand, you are an experienced programmer, you might be more comfortable with simply the text editor of your choice in one window, and another window for launching the programs you edit via system command lines and icon clicks (indeed, this is how your author develops Python programs, but he has a Unix-biased(有偏見的) past). Because development environments are a very subjective choice, I can’t offer much more in the way of universal guidelines; in general, whatever environment you like to use will usually be the best for you to use.

=== Chapter Summary ===

In this chapter, we’ve looked at common ways to launch Python programs: by running code typed interactively, and by running code stored in files with system command lines, file-icon clicks, module imports, and IDE GUIs such as IDLE. We’ve covered a lot of pragmatic startup territory(領域) here. This chapter’s goal was to equip you with enough information that you can start working along with the code we’ll start writing in the next part of the book. There, we will start exploring the Python language itself, beginning with its core data types.

First, though, take the usual chapter quiz to exercise what you’ve learned here. Because this is the last chapter in this part of the book, it’s followed with a set of more complete exercises that test your mastery(掌握) of this entire part’s topics. For help with the latter set of problems, or just for a refresher, turn to Appendix B.

==== Chapter Quiz ====

 1. How can you start an interactive interpreter session?
 2. Where do you type a system command line to launch a script file?
 3. Name two pitfalls related to clicking file icons on Windows.
 4. Why might you need to reload a module?
 5. How do you run a script from within IDLE?
 6. Name two pitfalls related to using IDLE.
 7. What is a namespace, and how does it relate to module files?

==== Quiz Answers ====

 1. You can start an interactive session on Windows by clicking your Start button, picking the All Programs option, clicking the Python entry, and selecting the “Python (command line)” menu option. You can also achieve the same effect on Windows and other platforms by typing `python` as a system command line in your system’s console window (a Command Prompt window on Windows). Another alternative is to launch IDLE, as its main Python shell window is an interactive session. If you have not set your system’s `PATH` variable to find Python, you may need to `cd` to where Python is installed, or type its full directory path instead of just python (e.g., `C:\Python25\python` on Windows).

 2. You type system command lines in whatever your platform provides as a system console: a Command Prompt window on Windows; an xterm or terminal window on Unix, Linux, and Mac OS X; and so on.

 3. Scripts that print and then exit cause the output file to disappear immediately, before you can view the output (which is why the `raw_input` trick comes in handy); error messages generated by your script also appear in an output window that closes before you can examine its contents __(which is why system command lines and IDEs such as IDLE are better for most development).__

 4. Python only imports (loads) a module once per process, by default, so if you’ve changed its source code and want to run the new version without stopping and restarting Python, you’ll have to reload it. You must import a module at least once before you can reload it. Running code from a system command line, or via an icon click, or an IDE such as IDLE generally makes this a nonissue(不成問題的問題), as those launch schemes usually run the current version of the source code file each time.

 5. Within the text edit window of the file you wish to run, select the window’s Run ➝ Run Module menu option. This runs the window’s source code as a top-level script file, and displays its output back in the interactive Python shell window.

 6. __IDLE can still be hung by some types of programs—especially GUI programs that perform multithreading (an advanced technique beyond this book’s scope). Also, IDLE has some usability features that can burn you once you leave the IDLE GUI:__ a script’s variables are automatically imported to the interactive scope in IDLE, for instance, but not by Python in general.
 
7. A namespace is just a package of variables (i.e., names). It takes the form of an object with attributes in Python. __Each module file is automatically a namespace__— that is, a package of variables reflecting the assignments made at the top level of the file. Namespaces help avoid name collisions in Python programs: because each module file is a self-contained namespace, files must explicitly import other files in order to use their names.

=== Part I Exercises ===

:::

== Chapter 4. Introducing Python Object Types ==

This chapter begins our tour of the Python language. In an informal sense, in Python, we do things with stuff. “Things” take the form of operations like addition and concatenation, and “stuff” refers to the objects on which we perform those operations. In this part of the book, our focus is on that stuff, and the things our programs can do with it.

__Somewhat more formally, in Python, data takes the form of ''objects''—either built-in objects that Python provides, or objects we create using Python or external ''language tools'' such as C extension libraries. Although we’ll firm up(明確化) this definition later, objects are essentially just ''pieces of memory'', with ''values'' and sets of ''associated operations''.__

Because objects are the most fundamental notion in Python programming, we’ll start this chapter with a survey of Python’s built-in ''object types''.

By way of introduction, however, let’s first establish a clear picture of how this chapter fits into the overall Python picture. From a more concrete perspective, Python programs can be decomposed into modules, statements, expressions, and objects, as follows:

 1. Programs are composed of modules.
 2. Modules contain statements.
 3. Statements contain expressions.
 4. Expressions create and process objects.

The discussion of modules in Chapter 3 introduced the highest level of this hierarchy. This part’s chapters begin at the bottom, exploring both built-in objects and the expressions you can code to use them.

=== Why Use Built-in Types? ===

__If you’ve used lower-level languages such as C or C++, '''you know that much of your work centers on implementing objects—also known as ''data structures''—to represent the components in your application’s ''domain''.'''__ You need to lay out memory structures, manage memory allocation, implement search and access routines, and so on. These chores(雜務) are about as tedious (and error prone) as they sound, and they usually distract(分心) from your program’s real goals.

In typical Python programs, most of this grunt work goes away. Because Python provides powerful object types as an intrinsic(內在的) part of the language, there’s usually no need to code object implementations before you start solving problems. In fact, unless you have a need for special processing that built-in types don’t provide, you’re almost always better off using a built-in object instead of implementing your own. Here are some reasons why:

 * Built-in objects make programs easy to write. __For simple tasks, built-in types are often all you need to represent the structure of ''problem domains''. Because you get powerful tools such as ''collections (lists)'' and ''search tables (dictionaries)'' for free,__ you can use them immediately. You can get a lot of work done with Python’s built-in object types alone.

 * Built-in objects are components of ''extensions'' (效能相對較好). For more complex tasks, you still may need to provide your own objects, using Python classes or C language interfaces. But as you’ll see in later parts of this book, __objects implemented manually are often built on top of built-in types such as lists and dictionaries. (組合應用) For instance, a ''stack'' data structure may be implemented as a class that manages or customizes a built-in list.__

 * __Built-in objects are often more efficient than custom data structures. Python’s built-in types employ already optimized data structure algorithms that are implemented in C for speed.__ Although you can write similar object types on your own, you’ll usually be hard-pressed(面臨困難的) to get the level of performance built-in object types provide.

 * __Built-in objects are a standard part of the language. In some ways, Python borrows both from languages that rely on built-in tools (e.g., LISP) and languages that rely on the programmer to provide ''tool implementations or frameworks'' of their own (e.g., C++). '''(例如 Java 就是以 collection framework 來實作 List/Set/Map 這些概念, 因此它無法像 Python 一樣提供 Table 4-1 那樣直覺的字面表示法)'''__ Although you can implement unique object types in Python, you don’t need to do so just to get started. Moreover, because Python’s built-ins are standard, they’re always the same; proprietary frameworks, on the other hand, tend to differ from site to site.

In other words, not only do built-in object types make programming easier, but they’re also more powerful and efficient than most of what can be created from scratch. Regardless of whether you implement new object types, built-in objects form the core of every Python program.

==== Python’s Core Data Types ====

__Table 4-1 previews Python’s built-in object types and some of the syntax used to code their ''literals''—that is, the expressions that generate these objects.__ Some of these types will probably seem familiar if you’ve used other languages; for instance, numbers and strings represent numeric and textual values, respectively, and ''files'' provide an interface for processing files stored on your computer.

__In this book, '''the term ''literal(字面表示法)'' simply means an expression whose syntax ''generates an object''—sometimes also called a ''constant''.''' Note that the term “constant” does not imply objects or variables that can never be changed__ (i.e., this term is unrelated to C++’s const or Python’s “immutable”—a topic explored later in this chapter; 有些概念的解釋與其他語言很不一樣, 例如 module、constant 等, 連檔案都有 literal...).

Table 4-1. Built-in objects preview

|| Object type || Example literals/creation ||
|| Numbers || 1234, 3.1415, 999L, 3+4j, Decimal ||
|| Strings || `'spam'`, `"guido's"` ||
|| Lists || `[1, [2, 'three'], 4]` ||
|| Dictionaries || `{'food': 'spam', 'taste': 'yum'}` (這跟 JSON 的表示法很像) ||
|| Tuples || `(1, 'spam', 4, 'U')` ||
|| Files || `myfile = open('eggs', 'r')` ||
|| Other types || Sets, types, None, Booleans ||

Table 4-1 isn’t really complete, because everything we process in Python programs is a kind of object. For instance, when we perform text pattern matching in Python, we create ''pattern'' objects, and when we perform network scripting, we use ''socket'' objects. __These other kinds of objects are generally created by importing and using modules, and they have behavior all their own. (相對於 core data types 不用額外引入)__

__We call the object types in Table 4-1 ''core data types'' because they are effectively built into the Python language—that is, there is specific syntax for generating most of them.__ For instance, when you run the following code:

 {{{
>>> 'spam'
 }}}

__you are, technically speaking, '''running a ''literal expression'', which generates and returns a new string object.''' There is specific Python language syntax to make this object. Similarly, an expression wrapped in square brackets makes a list, one in curly braces makes a dictionary, and so on. Even though, as we’ll see, '''there are no ''type declarations'' in Python, the syntax of the expressions you run determines the types of objects you create and use.''' In fact, ''object-generation expressions'' like those in Table 4-1 are generally where types originate in the Python language.__

__Just as importantly, '''once you create an object, you ''bind'' its ''operation set'' for all time'''—you can perform only string operations on a string and list operations on a list. As you’ll learn, Python is ''dynamically typed'' (it keeps track of types for you automatically instead of requiring declaration code), but it is also ''strongly typed'' (you can only perform on an object operations that are valid for its type).__

Functionally, the object types in Table 4-1 are more general and powerful than what you may be accustomed(習慣) to. __For instance, you’ll find that lists and dictionaries alone are powerful ''data representation tools'' that obviate(免除) most of the work you do to support collections and searching in lower-level languages. In short, lists provide ordered collections of other objects, while dictionaries store objects by key; '''both lists and dictionaries may be ''nested'', can grow and shrink on demand, and may contain objects of any type.'''__

We’ll study each of the object types in Table 4-1 in detail in upcoming chapters. Before digging into the details, though, let’s begin by taking a quick look at Python’s core objects in action. The rest of this chapter provides a preview of the operations we’ll explore in more depth in the chapters that follow. Don’t expect to find the full story here—the goal of this chapter is just to whet(刺激) your appetite(食慾) and introduce some key ideas. Still, the best way to get started is to get started, so let’s jump right into some real code.

=== Numbers ===

If you’ve done any programming or scripting in the past, some of the object types in Table 4-1 will probably seem familiar. Even if you haven’t, numbers are fairly straightforward. Python’s core object set includes the usual suspects(猜想): integers (numbers without a fractional part), floating-point numbers (roughly, numbers with a decimal point in them), and more exotic(奇特的) types (unlimited-precision “long” integers, complex numbers(複數) with imaginary(虛) parts, fixed-precision decimals, and sets).

Although it offers some fancier(空想家?) options, Python’s basic number types are, well, basic. __Numbers in Python support the normal mathematical operations. For instance, the plus sign (+) performs addition, a star (*) is used for multiplication, and two stars (**) are used for exponentiation(乘冪; 表示法很直覺):__

 {{{
>>> 123 + 222 # Integer addition
345
>>> 1.5 * 4 # Floating-point multiplication
6.0
>>> 2 ** 100 # 2 to the power 100
1267650600228229401496703205376L
 }}}

Notice the `L` at the end of the last operation’s result here: __Python automatically ''converts up'' to a long integer type when ''extra precision'' is needed. You can, for instance, compute 2 to the 1,000,000 power in Python (but you probably shouldn’t try to print the result—with more than 300,000 digits, you may be waiting awhile! 是要跑一段時間, 但這也證明了 Python 能夠處理很大的數值而不會遇到 overflow 的問題).__ Watch what happens when some floating-point numbers are printed:

 {{{
>>> 3.1415 * 2 # repr: as code
6.2830000000000004
>>> print 3.1415 * 2 # str: user-friendly
6.283
 }}}

__The first result isn’t a bug; it’s a ''display issue''. It turns out that there are two ways to print every object: with ''full precision'' (as in the first result shown here), and in a ''userfriendly form'' (as in the second). '''Formally, the first form is known as an object’s ''as-code repr'', and the second is its ''user-friendly str''.''' The difference can matter when we step up to using classes; for now, if something looks odd, try showing it with a `print` statement.__

Besides expressions, there are a handful of useful numeric modules that ship with Python:

 {{{
>>> import math
>>> math.pi
3.1415926535897931
>>> math.sqrt(85)
9.2195444572928871
 }}}

__The `math` module contains more advanced numeric ''tools as functions'', while the `random` module performs random number generation and ''random selections''__ (here, from a Python list, introduced later in this chapter):

 {{{
>>> import random
>>> random.random()
0.59268735266273953
>>> random.choice([1, 2, 3, 4]) # 很實用的 tools!!
1
 }}}

Python also includes more exotic number objects—such as complex numbers, fixed-precision decimal numbers, and sets—and __the third-party open source extension domain has even more (e.g., ''matrixes'' and ''vectors'').__ We’ll defer discussion of the details of these types until later in the book.

So far, we’ve been using Python much like a simple calculator; to do better justice to its built-in types, let’s move on to explore strings.

=== Strings ===

__Strings are used to record textual information as well as ''arbitrary collections of bytes''. They are our first example of what we call a ''sequence'' in Python—that is, a ''positionally ordered collection'' of other objects. '''Sequences maintain a left-to-right order among the items they contain: their items are stored and fetched by their ''relative position''. Strictly speaking, strings are sequences of one-character strings; other types of sequences include lists and tuples (covered later).'''__

:::

== Chapter 10. Introducing Python Statements ==

Now that you’re familiar with Python’s core built-in object types, this chapter begins our exploration of its fundamental statement forms. As in the previous part, we’ll begin here with a general introduction to statement syntax, and follow up with more details about specific statements in the next few chapters.

In simple terms, statements are the things you write to tell Python what your programs should do. If programs “do things with stuff,” statements are the way you specify what sort of things a program does. __Python is a procedural, statement-based language; by combining statements, you specify a procedure that Python performs to satisfy a program’s goals.__

=== Python Program Structure Revisited ===

Another way to understand the role of statements is to revisit the concept hierarchy introduced in Chapter 4, which talked about built-in objects and the expressions used to manipulate them. This chapter climbs(爬升) the hierarchy to the next level:

 1. Programs are composed of modules.
 2. Modules contain statements.
 3. Statements contain expressions.
 4. Expressions create and process objects.

__At its core, Python syntax is composed of statements and expressions. Expressions process objects and are embedded in statements. Statements code the larger logic of a program’s operation—they use and direct expressions to process the objects we studied in the preceding chapters.__ Moreover, statements are where objects ''spring into existence'' (e.g., in expressions within ''assignment statements''), and some statements create entirely new kinds of objects (functions, classes, and so on). __'''Statements always exist in modules, which themselves are managed with statements.'''__

==== Python’s Statements ====

Table 10-1 summarizes Python’s statement set. This part of the book deals with entries in the table from the top through `break` and `continue`. You’ve informally been introduced to a few of the statements in Table 10-1 already; this part of the book will fill in details that were skipped earlier, introduce the rest of Python’s ''procedural statement set'', and cover the overall ''syntax model''. Statements lower in Table 10-1 that have to do with ''larger program units''—functions, classes, modules, and exceptions— lead to larger programming ideas, so they will each have a section of their own. More exotic(奇特的) statements like `exec` (which compiles and executes code constructed as strings) are covered later in the book, or in Python standard documentation.

Table 10-1. Python statements (Statement/Role/Example)

 * Assignment - Creating references

 {{{
a, b, c = 'good', 'bad', 'ugly'
 }}}

 * Calls - Running functions

 {{{
log.write("spam, ham\n")
 }}}

 * `print` - Printing objects

 {{{
print 'The Killer', joke
 }}}

 * `if/elif/else` - Selecting actions

 {{{
if "python" in text:
    print text
 }}}

 * `for/else` - Sequence iteration

 {{{
for x in mylist:
    print x
 }}}

 * `while/else` - General loops

 {{{
while X > Y:
    print 'hello'
 }}}

 * `pass` - Empty placeholder

 {{{
while True:
    pass
 }}}

 * `break`, `continue` - Loop jumps

 {{{
while True:
    if not line: break
 }}}

 * `try/except/finally` - Catching exceptions

 {{{
try:
    action( )
except:
    print 'action error'
 }}}

 * `raise` - Triggering exceptions

 {{{
raise endSearch, location
 }}}

 * `import`, `from` - Module access

 {{{
import sys
from sys import stdin
 }}}

 * `def`, `return`, `yield` - Building functions

 {{{
def f(a, b, c = 1, *d):
    return a + b + c + d[0]

def gen(n):
    for i in n, yield i * 2
 }}}

 * `class` - Building objects

 {{{
class subclass(Superclass):
    staticData = []
 }}}

 * `global` - Namespaces

 {{{
def function():
    global x, y
    x = 'new'
 }}}

 * `del` - Deleting references

 {{{
del data[k]
del data[i:j]
del obj.attr
del variable
 }}}

 * `exec` - Running code strings

 {{{
exec "import " + modName
exec code in gdict, ldict
 }}}

 * `assert` - Debugging checks

 {{{
assert X > Y
 }}}

 * `with/as` - Context managers (2.6)

 {{{
with open('data') as myfile:
    process(myfile)
 }}}

{{{#!wiki note
Technically speaking, in Python 2.5, `yield` became an expression instead of a statement, and the `try/except` and `try/finally` statements were merged (the two were formerly separate statements, but we can now say both `except` and `finally` in the same `try` statement). Also, a new `with/as` statement is to be added in Python 2.6 to encode context managers—roughly speaking, it’s an alternative to `try/finally` exception-related operations (in 2.5, `with/as` is an optional extension, and is not available unless you explicitly turn it on by running the statement `from _ _future_ _ import with_statement`). See Python manuals for more details. Further in the future, in 3.0, `print` and `exec` will become function calls instead of statements, and a new `nonlocal` statement will have a purpose much like that of today’s `global`. (變化很大!!)
}}}

=== A Tale(傳說) of Two ifs ===

Before we delve into the details of any of the concrete statements in Table 10-1, I want to begin our look at Python statement syntax by showing you what you are not going to type in Python code so you can compare and contrast it with other syntax models you might have seen in the past.

Consider the following `if` statement, coded in a C-like language:

 {{{
if (x > y) {
    x = 1;
    y = 2;
}
 }}}

This might be a statement in C, C++, Java, JavaScript, or Perl. Now, look at the equivalent statement in the Python language:

 {{{
if x > y:
    x = 1
    y = 2
 }}}

The first thing that may pop out(脫口說出來) at you is that the equivalent Python statement is less, well, cluttered—that is, there are fewer syntactic(句法的) components. __This is by design; as a scripting language, one of Python’s goals is to make programmers’ lives easier by requiring less typing.__

More specifically, when you compare the two syntax models, you’ll notice that Python adds one new thing to the mix, and that three items that are present in the C-like language are not present in Python code. (下面就會說明相對於 C-like languages 多了什麼? 少了什麼?)

==== What Python Adds ====

The one new syntax component in Python is the colon character (`:`). __All Python ''compound(複合的) statements'' (i.e., statements that have statements nested inside them; 相對於 "simple statement" 的說法) follow the same general pattern of a ''header line'' terminated in a colon followed by a ''nested block'' of code usually indented underneath the header line,__ like this:

 {{{
Header line:
    Nested statement block
 }}}

The colon is required, and omitting it is probably the most common coding mistake among new Python programmers—it’s certainly one I’ve witnessed(目睹) thousands of times in Python training classes. In fact, if you are new to Python, you’ll almost certainly forget the colon character very soon. __Most Python-friendly editors make this mistake easy to spot, and including it eventually becomes an unconscious(下意識的) habit (so much so that you may start typing colons into your C++ code, too, generating many entertaining(有趣的) error messages from your C++ compiler!).__

==== What Python Removes ====

Although Python requires the extra colon character, there are three things programmers in C-like languages must include that you don’t generally have to in Python.

===== Parentheses are optional =====

The first of these is the set of parentheses around the tests at the top of the statement:

 {{{
if (x < y)
 }}}

The parentheses here are required by the syntax of many C-like languages. In Python, they are not—we simply omit the parentheses, and the statement works the same way:

 {{{
if x < y
 }}}

__Technically speaking, because every expression can be enclosed in parentheses, including them will not hurt in this Python code, and they are not treated as an error if present. But don’t do that: you’ll be wearing out(消磨) your keyboard needlessly, and broadcasting to the world that you’re an ex-C programmer (這裡的 "ex-" 有 "前..." 的意思, 例如 "前教育部長") still learning Python (I was once, too).__ The Python way is to simply omit the parentheses in these kinds of statements altogether.

===== End of line is end of statement =====

The second and more significant syntax component you won’t find in Python code is the semicolon. You don’t need to terminate statements with semicolons in Python the way you do in C-like languages:

 {{{
x = 1;
 }}}

__In Python, the general rule is that the end of a line automatically terminates the statement that appears on that line.__ In other words, you can leave off the semicolons, and it works the same way:

 {{{
x = 1
 }}}

There are some ways to work around this rule, as you’ll see in a moment. But, in general, you write one statement per line for the vast majority of Python code, and no semicolon is required.

Here, too, if you are pining for(懷念) your C programming days (if such a state is possible...), you can continue to use semicolons at the end of each statement—the language lets you get away with(做錯事而不用受到責備) them if they are present. __But don’t do that either (really!); again, '''doing so tells the world that you’re still a C programmer who hasn’t quite made the switch to Python coding.'''__ The Pythonic style is to leave off the semicolons altogether.

===== End of indentation is end of block =====

The third and final syntax component that Python removes, and perhaps the most unusual one to soon-to-be-ex-C programmers (until they use it for 10 minutes, and realize it’s actually a feature), is that you do not type anything explicit in your code to syntactically mark the beginning and end of a nested block of code. You don’t need to include begin/end, then/endif, or braces around the nested block, as you do in C-like languages:

 {{{
if (x > y) {
    x = 1;
    y = 2;
}
 }}}

__Instead, in Python, we consistently indent all the statements in a given single nested block the ''same distance'' to the right, and Python uses the statements’ ''physical indentation'' to determine where the block starts and stops:__

 {{{
if x > y:
    x = 1
    y = 2
 }}}

By indentation, I mean the blank whitespace all the way to the left of the two nested statements here. __'''Python doesn’t care how you indent (you may use either spaces or tabs), or how much you indent (you may use any number of spaces or tabs; 慣例上是 4 個空白). In fact, the indentation of one nested block can be totally different from that of another. The syntax rule is only that for a given single nested block, all of its statements must be indented the same distance to the right.'''__ If this is not the case, you will get a syntax error, and your code will not run until you repair its indentation to be consistent.

==== Why Indentation Syntax? ====

:::

==== A Few Special Cases ====

As mentioned previously, in Python’s syntax model:

 * The end of a line terminates the statement on that line (without semicolons).
 * __Nested statements are blocked and ''associated(聯合的)'' by their physical indentation (without braces).__

Those rules cover almost all Python code you’ll write or see in practice. __However, Python also provides some ''special-purpose'' rules that allow ''customization'' of both statements and nested statement blocks. '''(這裡的 "special-purpose" 暗示著這麼做並不是不好, 而是大家都習慣於在特殊的場合下, 採用特殊的寫法...)'''__

===== Statement rule special cases =====

Although statements normally appear one per line, it is possible to squeeze(壓擠) more than one statement onto a single line in Python by separating them with semicolons:

 {{{
a = 1; b = 2; print a + b # Three statements on one line
 }}}

__This is the only place in Python where semicolons are required: as ''statement separators''. (因此最後面還是不用加分號) This only works, though, if the statements thus combined are not themselves compound statements.__ In other words, you can chain together only ''simple statements'', like assignments, prints, and function calls. __Compound statements must still appear on lines of their own (otherwise, you could squeeze an entire program onto one line, which probably would not make you very popular among your coworkers! 參考下面 Block rule special case 一節的說明).__

__The other special rule for statements is essentially the inverse: you can make a single statement span across multiple lines. To make this work, you simply have to enclose part of your statement in a bracketed pair—parentheses (`()`), square brackets (`[]`), or dictionary braces (`{}`). Any code enclosed in these constructs can cross multiple lines: your statement doesn’t end until Python reaches the line containing the closing part of the pair. (外圍的括弧不一定要獨立成一行)__ For instance, to continue a list literal:

 {{{
mlist = [111,
         222, <-- 不一定要保持上一行的縮排; 慣例上會與上一行的資料對齊
         333]
 }}}

Because the code is enclosed in a square brackets pair, Python simply ''drops down''(順著向下移動) to the next line until it encounters the closing bracket. __Dictionaries can also span lines this way, and parentheses handle tuples, function calls, and expressions. The indentation of the continuation lines does not matter, though common sense dictates(要求) that the lines should be aligned somehow for readability.__

Parentheses are the catchall(多用途的) device—because any expression can be wrapped up in them, simply inserting a left parenthesis allows you to drop down to the next line and continue your statement:

 {{{
X = (A + B +
     C + D)
 }}}

__This technique works with compound statements, too, by the way. Anywhere you need to code a large expression, simply wrap it in parentheses to continue it on the next line:__

 {{{
if (A == 1 and
    B == 2 and
    C == 3):
        print 'spam' * 3 <-- 這一行不一定要內縮得這麼深, 往內 4 格跟 "C" 對齊就可以了
 }}}

An older rule also allows for continuation lines when the prior line ends in a backslash:

 {{{
X = A + B + \
      C + D
 }}}

__But this alternative technique is dated(過時的), and somewhat frowned(讓人皺眉頭的) on today because it’s difficult to notice and maintain the backslashes, and it’s fairly brittle (脆弱的; there can be no spaces after the backslash). It’s also another throwback(返祖) to the C language, where it is commonly used in “#define” macros; again, '''when in ''Pythonland'', do as ''Pythonist'' as do, not as C programmers do.'''__

===== Block rule special case =====

As mentioned previously, statements in a nested block of code are normally associated by being indented the same amount to the right. __As one special case here, the ''body'' of a compound statement can instead appear on the same line as the header in Python, after the colon: '''(意指 nested simple statements 也可以直接串在冒號後面, 但習慣上都只會串接一個 statement 而已)'''__

 {{{
if x > y: print x
 }}}

This allows us to code single-line `if` statements, single-line loops, and so on. __Here again, though, this will work only if the body of the compound statement itself does not contain any compound statements. (也就是 compound statements 不能與其他 simple statements 用分號串在一起, 但 compound statement 的 body 如果都是 simple statements 的就, 就可以串接在冒號後面)__ That is, only simple statements—assignments, prints, function calls, and the like—are allowed after the colon. Larger statements must still appear on lines by themselves. Extra parts of compound statements (such as the `else` part of an `if`, which we’ll meet later) must also be on separate lines of their own. The body can consist of multiple simple statements separated by semicolons, but this tends to be frowned on(表示不贊成).

__In general, even though it’s not always required, if you keep all your statements on individual lines, and always indent your nested blocks, your code will be easier to read and change in the future.__ To see a prime and common exception to one of these rules in action, however (the use of a single-line `if` statement to break out of a loop; 這個用法還滿常見的), let’s move on to the next section and write some real code.

=== A Quick Example: Interactive Loops ===

We’ll see all these syntax rules in action when we tour Python’s specific compound statements in the next few chapters, but they work the same everywhere in the Python language. To get started, let’s work through a brief, realistic example that demonstrates the way that statement syntax and ''statement nesting'' come together in practice, and introduces a few statements along the way.

==== A Simple Interactive Loop ====

Suppose you’re asked to write a Python program that interacts with a user in a console window. Maybe you’re accepting inputs to send to a database, or reading numbers to be used in a calculation. Regardless of the purpose, you need to code a loop that reads one or more inputs from a user typing on a keyboard, and prints back a result for each. In other words, you need to write a classic read/evaluate/print loop program.

In Python, typical boilerplate(樣板文件) code for such an interactive loop might look like this:

 {{{
while True:
    reply = raw_input('Enter text:')
    if reply == 'stop': break
    print reply.upper()
 }}}

This code makes use of a few new ideas:

 * The code leverages the Python `while` loop, Python’s most general looping statement. We’ll study the `while` statement in more detail later, but in short, it consists of the word `while`, followed by an expression that is interpreted as a true or false result, followed by a nested block of code that is repeated while the test at the top is true (the word `True` here is considered always true).

 * The `raw_input` built-in function we met earlier in the book is used here for general console input—it prints its optional argument string as a prompt, and returns the user’s typed reply as a string.

 * A single-line `if` statement that makes use of the special rule for nested blocks also appears here: the body of the `if` appears on the header line after the colon instead of being indented on a new line underneath it. This would work either way, but as it’s coded, we’ve saved an extra line.

 * Finally, the Python `break` statement is used to exit the loop immediately—it simply jumps out of the loop statement altogether, and the program continues after the loop. Without this exit statement, the `while` would loop forever, as its test is always true.

In effect, this combination of statements means essentially “read a line from the user and print it in uppercase until the user enters the word ‘stop.’” There are other ways to code such a loop, but the form used here is very common in Python code.

Notice that all three lines nested under the `while` header line are indented the same amount—because they line up vertically in a column this way, they are the block of code that is associated with the `while` test and repeated. __'''Either the end of the source file or a lesser-indented statement will terminate the loop body block.'''__

When run, here is the sort of interaction we get from this code:

 {{{
Enter text:spam
SPAM
Enter text:42
42
Enter text:stop
 }}}

==== Doing Math on User Inputs ====

Our script works, but now suppose that instead of converting a text string to uppercase, we want to do some math with numeric input—squaring it, for example, perhaps in some misguided(被誤導的) effort to discourage users who happen to be obsessed with youth. We might try statements like these to achieve the desired effect:

 {{{
>>> reply = '20'
>>> reply ** 2
...error text omitted...
TypeError: unsupported operand type(s) for ** or pow( ): 'str' and 'int'
 }}}

This won’t quite work in our script, though, because (as discussed in the last part of the book) __'''Python won’t convert object types in expressions unless they are all numeric,''' and input from a user is always returned to our script as a string. We cannot raise a string of digits to a power unless we convert it manually to an integer:__

 {{{
>>> int(reply) ** 2
400
 }}}

Armed with this information, we can now recode our loop to perform the necessary math:

 {{{
while True:
    reply = raw_input('Enter text:')
    if reply == 'stop': break
    print int(reply) ** 2
print 'Bye'
 }}}

This script uses a single-line `if` statement to exit on “stop” as before, but also converts inputs to perform the required math. This version also adds an exit message at the bottom. __Because the `print` statement in the last line is not indented as much as the nested block of code, it is not considered part of the loop body, and will run only once, after the loop is exited: (通常 block 後面都會多加一行空白, 提高可讀性)__

 {{{
Enter text:2
4
Enter text:40
1600
Enter text:stop
Bye
 }}}

==== Handling Errors by Testing Inputs ====

So far so good, but notice what happens when the input is invalid:

 {{{
Enter text:xxx
...error text omitted...
ValueError: invalid literal for int( ) with base 10: 'xxx'
 }}}

The built-in `int` function raises an exception here in the face of a mistake. If we want our script to be robust, we can check the string’s content ahead of time with the string object’s `isdigit` method:

 {{{
>>> S = '123'
>>> T = 'xxx'
>>> S.isdigit( ), T.isdigit( )
(True, False)
 }}}

This also gives us an excuse(藉口) to further nest the statements in our example. The following new version of our interactive script uses a full-blown `if` statement to work around the exception on errors:

 {{{
while True:
    reply = raw_input('Enter text:')
    if reply == 'stop':
        break
    elif not reply.isdigit():
        print 'Bad!' * 8
    else:
        print int(reply) ** 2
print 'Bye'
 }}}

We’ll study the `if` statement in more detail in Chapter 12, but it’s a fairly lightweight tool for coding logic in scripts. In its full form, it consists of the word `if` followed by a test and an associated block of code, one or more optional `elif` (“else if”) tests and code blocks, and an optional `else` part, with an associated block of code at the bottom to serve as a default. __Python runs the block of code associated with the first test that is true, working from top to bottom, or the `else` part if all tests are false.__

__'''The `if`, `elif`, and `else` parts in the preceding example are associated as part of the ''same statement'' because they all line up vertically (i.e., share the same level of indentation; 上面 "same statement" 裡的 statement 指的是外層的 `while`? 按下面 "span" 的說法, `if/elif/else` 被視為單一個 statement[?]).''' The `if` statement spans from the word `if` to the start of the `print` statement on the last line if the script. In turn, the entire `if` block is part of the `while` loop because all of it is indented under the loop’s header line. Statement nesting is natural once you get the hang of it.__

When we run our new script, its code catches errors before they occur, and prints an (arguably(可論證的) silly) error message to demonstrate:

 {{{
Enter text:5
25
Enter text:xyz
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:10
100
Enter text:stop
 }}}

==== Handling Errors with try Statements ====

The preceding solution works, but as you’ll see later in the book, __the most general way to handle errors in Python is to ''catch and recover'' from them completely using the Python `try` statement.__ We’ll explore this statement in depth in the last part of this book, but, as a preview, using a `try` here can lead to code that some would claim is simpler than the prior version:

 {{{
while True:
    reply = raw_input('Enter text:')
    if reply == 'stop': break
    try:
        num = int(reply)
    except:
        print 'Bad!' * 8
    else: <-- 這裡 else 的設計好像是多餘的?
        print int(reply) ** 2
print 'Bye'
 }}}

This version works exactly like the previous one, but we’ve replaced the explicit error check with code that __''assumes'' the conversion will work, and wraps it up in an ''exception handler'' for cases when it doesn’t.__ This `try` statement is composed of the word `try` followed by the ''main'' block of code (the action we are trying to run), followed by an `except` part that gives the exception handler code, followed by an `else` part to be run if no exception is raised in the `try` part. __Python first runs `try` part, then runs either the `except` part (if an exception occurs), or the `else` part (if no exception occurs).__

In terms of statement nesting, because the words `try`, `except`, and `else` are all indented to the same level, they are all considered part of the same single `try` statement. Notice that the `else` part is associated with the `try` here, not the `if`. As we’ll see, `else` can appear in `if` statements in Python, but also in `try` statements and loops—its indentation tells you what statement it is a part of.

Again, we’ll come back to the `try` statement later in the book. __For now, be aware that because `try` can be used to intercept any error, it reduces the amount of errorchecking code you have to write, and is a very general approach to dealing with unusual cases.__

==== Nesting Code Three Levels Deep ====

Now, let’s look at one last mutation(變換) of our script. Nesting can take us even further if we need it to—we could, for example, branch to one of a set of alternatives, based on the relative magnitude of a valid input:

 {{{
while True:
    reply = raw_input('Enter text:')
    if reply == 'stop':
        break
    elif not reply.isdigit():
        print 'Bad!' * 8
    else:
        num = int(reply)
        if num < 20:
            print 'low'
        else:
            print num ** 2
print 'Bye'
 }}}

This version includes an `if` statement nested in the `else` clause of another `if` statement, which is in turn nested in the `while` loop. When code is conditional, or repeated like this, we simply indent it further to the right. The net effect is like that of the prior versions, but we’ll now print “low” for numbers less than 20:

 {{{
Enter text:19
low
Enter text:20
400
Enter text:spam
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:stop
Bye
 }}}

=== Chapter Summary ===

That concludes our quick look at Python statement syntax. This chapter introduced the general rules for coding statements and blocks of code. __As you’ve learned, in Python, we normally code one statement per line, and indent all the statements in a nested block the same amount '''(indentation is part of Python’s syntax)'''.__ However, we also looked at a few exceptions to these rules, including continuation lines and single-line tests and loops. Finally, we put these ideas to work in an interactive script that demonstrated a handful of statements, and showed statement syntax in action.

In the next chapter, we’ll start to dig deeper by going over each of Python’s basic procedural statements in depth. As you’ll see, though, all statements follow the same general rules introduced here.

:::

== Chapter 15. Function Basics ==

In Part III, we looked at basic ''procedural statements'' in Python. Here, we’ll move on to explore a set of additional statements that we can use to create functions of our own.

In simple terms, a function is a device(方法) that groups a set of statements so they can be run more than once in a program. Functions also can compute a result value and let us specify parameters that serve as function inputs, which may differ each time the code is run. __Coding an operation as a function makes it a generally useful tool, which we can use in a variety of contexts.__

__More fundamentally, functions are the alternative to programming by cutting and pasting—rather than having multiple redundant copies of an operation’s code, we can factor(分解...的因數) it into a single function. In so doing, we reduce our future work radically: if the operation must be changed later, we only have one copy to update, not many.__

__Functions are the most basic program structure Python provides for maximizing ''code reuse'' and minimizing ''code redundancy''. As we’ll see, functions are also a design tool that lets us ''split complex systems into manageable parts''.__ Table 15-1 summarizes the primary function-related tools we’ll study in this part of the book.

Table 15-1. Function-related statements and expressions

 * Calls

 {{{
myfunc(`"spam", "eggs", meat=ham)
 }}}

 * `def`, `return`, `yield`

 {{{
def adder(a, b=1, *c):
    return a+b+c[0]
 }}}

 * `global`

 {{{ 
def changer( ):
    global x; x = 'new'
 }}}

 * `lambda` (希臘語的第11個字母(Λλ))

 {{{
Funcs = [lambda x: x ** 2, lambda x: x * 3]
 }}}

:::

== Chapter 18. Modules: The Big Picture ==

__This chapter begins our in-depth look at the Python module, the ''highest-level program organization unit'', which packages program code and data for reuse. In concrete terms, modules usually correspond to Python program files (or extensions coded in external languages such as C, Java, or C#). '''Each file is a module, and modules import other modules to use the ''names'' they define.'''__ Modules are processed with two statements, and one important built-in function:

 * `import` - Lets a client (importer) fetch a module as a whole
 * `from` - Allows clients to fetch particular names from a module
 * `reload` - Provides a way to reload a module’s code without stopping Python

Chapter 3 introduced module fundamentals, and we’ve been using them ever since. Part V begins by expanding on core module concepts, then moves on to explore more advanced module usage. This first chapter offers a general look at the role of modules in overall program structure. In the next and following chapters, we’ll dig into the coding details behind the theory.

Along the way, we’ll flesh out(使充實) module details omitted so far: you’ll learn about reloads, the `__name__` and `__all__` attributes, ''package imports'', and so on. Because __modules and classes are really just glorified(美其名的) ''namespaces'',__ we’ll formalize namespace concepts here as well.

=== Why Use Modules? ===

__In short, modules provide an easy way to organize ''components'' into a system by serving as ''self-contained packages'' of variables known as ''namespaces''. All the ''names'' defined at the top level of a module file become ''attributes'' of the imported ''module object''.__ As we saw in the last part of this book, imports give access to names in a module’s global scope. That is, the module file’s global scope morphs into the module object’s attribute namespace when it is imported. Ultimately, Python’s modules allow us to link individual files into a larger program system.

More specifically, from an abstract perspective, modules have at least three roles:

 Code reuse:: As discussed in Chapter 3, modules let you save code in files permanently. Unlike code you type at the Python interactive prompt, which goes away when you exit Python, code in module files is persistent—it can be reloaded and rerun as many times as needed. More to the point, modules are a place to define names, known as attributes, that may be referenced by multiple external clients.

 System namespace partitioning:: __Modules are also the highest-level program organization unit in Python. Fundamentally, they are just packages of names. Modules seal up(密封) names into self-contained packages, which helps avoid name clashes—you can never see a name in another file, unless you explicitly import that file. '''In fact, everything “lives” in a module— code you execute and objects you create—are always implicitly enclosed in modules.[?]'''__ Because of that, modules are natural tools for grouping system components.

 Implementing shared services or data:: __From an operational perspective, modules also come in handy for implementing components that are shared across a system, and hence require only a single copy. (這有點像是 Java 裡的 class variable)__ For instance, if you need to provide a global object that’s used by more than one function or file, you can code it in a module that can then be imported by many clients.

For you to truly understand the role of modules in a Python system, though, we need to digress(離題) for a moment, and explore the general structure of a Python program.

=== Python Program Architecture ===

So far in this book, I’ve sugarcoated(粉飾的) some of the complexity in my descriptions of Python programs. In practice, programs usually involve more than just one file; for all but the simplest scripts, your programs will take the form of ''multifile systems''. And even if you can get by with coding a single file yourself, you will almost certainly wind up(上緊發條) using external files that someone else has already written.

This section introduces the general architecture of Python programs—the way you divide a program into a collection of source files (a.k.a. modules) and link the parts into a whole. Along the way, we’ll also explore the central concepts of Python modules, imports, and object attributes.

:::

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==
