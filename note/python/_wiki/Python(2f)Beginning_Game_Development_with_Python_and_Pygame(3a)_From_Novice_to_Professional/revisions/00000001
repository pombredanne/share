= Beginning Game Development with Python and Pygame: From Novice to Professional =
http://www.apress.com/book/view/1590598725
<<TableOfContents>>

== About the Author ==

WILL McGUGAN is a Scottish software developer who lives and works in North West England. Will has worked on a number of game projects, from self-published shareware games to triple A titles(頭銜), most recently on !MotorStorm, one of the first games released for Sony’s !PlayStation 3. He has been an enthusiastic(狂熱的) user of Python for many years, having written a script to automate source code backup as well as several popular desktop applications and a web site in Python. Will is currently working from home(在家工作) as a contractor(承包商) and developing a Web 2.0 site with the http://turbogears.org/[TurboGears] framework in his spare time. When not programming, Will enjoys photography, cycling(騎腳踏車兜風), and juggling(雜耍)—although not at the same time. For more information on Will’s current projects and various musings, visit his web site at http://www.willmcgugan.com.

== About the Technical Reviewer ==

RICHARD JONES organizes the biannual(一年兩次的) Python Programming Game Challenge (PyWeek http://www.pyweek.org/) challenge and develops OpenGL applications in Python for a living(為生).

== Introduction ==

I have accumulated a large collection of game development books over the years, virtually all of which are an inch or two thicker than this book—even though they cover similar subjects and techniques. __The disparity(懸殊) is not because my writing is terse(簡潔的) or I use a smaller font—it is because traditional game development tools tend to require a large amount of technical knowledge that the reader must first absorb before building even the simplest of games. Even seasoned game developers find the technical requirements of starting a game to be enough of a barrier that they are less likely to work on game ideas that are unproven or potentially not commercial-worthy. (有想法, 就要去試過才知道...)__ Game development may have become easier over the years, with simplified ''programming interfaces'' and more programmers wishing to share their knowledge, but writing a game is still a significant undertaking(任務).

When I discovered Python, it lowered a number of barriers to writing software, because I could work faster and accomplish more with less effort, and when combined with Pygame I could experiment with game ideas and build a complete game from scratch in record time(在創記錄的時間內). __The beauty of Pygame is that it makes the various tasks in creating a game (setting up a display, drawing to the screen, playing sound, etc.) only as complicated as they need to be—and it turns out that’s not particularly complicated at all! Many one-liners(簡短的妙語) in Pygame would take dozens of lines in C++, the traditional tool of game developers.__

Although Python and Pygame are superb(出色的) tools for ''rapid game development'', there is little in the way of books or web tutorials for Python game programmers, who often have no choice but to mentally(精神上) translate from another language to Python when researching a new topic in game development. __This book was conceived to(設想) fill that gap and allow the beginner game programmer to get up to speed with Python and learn the fundamentals of game programming without having to first learn C++, C#, Java, or another language first. It was also my opportunity to explain 3D game programming in a way that is accessible to nonmathematicians(非數學家)__—something that is not easy to find in other books.

In short, this is the book I would have wanted to have when I started out in game development!

=== Who This Book Is For ===

This book is for anyone who has thought about creating a computer game, or wants to learn about the technology behind game development. Although Python is the tool of choice for this book, many of the techniques covered are equally applicable to other languages.

=== How This Book Is Structured ===

Beginning Game Development with Python and Pygame is divided into 12 chapters, each of which builds on the previous chapter—with a few notable exceptions. __I’ve structured it so that you can get results quickly and see something on screen, which you may appreciate if you are as impatient(急躁的) as I am.__ Virtually all the listings are self-contained, and hopefully entertaining(有趣的), little projects that run independently. __Since experimentation is the best way to learn, you are encouraged to play with the sample code and modify it to produce different effects.__ You can also use any of the code in your own projects—with my blessing!

__The first two chapters introduce the Python language in a fairly ''conversational manner''. If you read them with a Python prompt in front of you, you should find you can quickly pick up(學會) the language.__ These two chapters don’t make a complete language tutorial, but will cover enough for you to be able to understand the Python code in the book and write some of your own. Occasionally, new syntaxes and language features are introduced in the rest of the book, but I explain them where they are first used. If you are proficient(熟練的) in Python, you can skip straight to Chapter 3.

Chapter 3 is your first introduction to Pygame and covers its history and capabilities. It also explains the basics of setting up a graphical display and handling events, skills that are essential for any game. You will become intimately(關係密切地) familiar with the code introduced in this chapter, as it is used in all the sample code for the rest of the book.

Chapter 4 dives straight into creating visuals and the various ways in which you can draw to the screen with Pygame. Chapter 5 explores the techniques that game programmers use to make those images move. You should find the discussion on ''time-based movement'' to be particularly valuable, as it is essential for any kind of animation in a game.

Chapter 6 tells you all you need to know to ''interface'' your game with virtually any gaming device. The sample code in this chapter will have you moving a ''character'' around with the keyboard, mouse, and joystick(搖桿).

Chapter 7 is a little unusual in that it is more self-contained than the others and doesn’t depend as much on previous chapters. __It covers the subject of ''artificial intelligence'' and includes a fully working simulation of an ant’s nest(巢),__ but the techniques I explain in this chapter can be used to add seemingly(表面上) intelligent characters to any game.

Chapters 8 and 9 are a gentle introduction to working with three-dimensional graphics in Pygame, which is an essential topic since most games have 3D elements these days—even if they are not full 3D games. __I explain the math in visual(直觀的) terms that make it easier to grasp, and you should find that it is not as an intimidating(嚇人的) a subject as it first appears.__

Chapter 10 takes a break from 3D graphics to discuss how to use Pygame to add sound effects and music, and even includes a fully working jukebox(自動點唱機) application.

The final two chapters build on Chapters 8 and 9 to advance your knowledge of 3D graphics, and explain how to take advantage of the dedicated game hardware on your graphics card. By the end of Chapter 11 you will have enough knowledge to render and manipulate a three-dimensional object on the screen. Chapter 12 explores several techniques you can use to create even more impressive 3D visuals and generate special effects.

In addition to the 12 chapters, there are two appendixes: Appendix A is a reference to the Game Objects library that is used throughout this book, and __Appendix B explains how you can package your game and send it to others.__

=== Prerequisites ===

__To run the code in this book, you will need at least version 2.4 of Python and version 1.7.1 of Pygame (目前 @2009/02/01 最新版是 1.8.1), which you can download from http://www.python.org and http://www.pygame.org, respectively. If you want to run the 3D sample code, you will also need PyOpenGL, which you can download from http://pyopengl.sourceforge.net .__ All are free software, and this book contains instructions on how to install them and get started.

=== Downloading the Code ===

The source code for this book is available to readers at http://www.apress.com in the Source Code section of this book’s home page. Please feel free to visit the book’s home page on the Apress web site and download all the code there. You can also check for http://www.apress.com/book/errata/718[errata] and find related titles from Apress.

=== Contacting the Author ===

I am happy to respond to any questions regarding this book’s content and source code. Feel free to e-mail me at will@willmcgugan.com, or alternatively post a comment on my blog: http://www.willmcgugan.com.

I hope you find this book informative and that you enjoy reading it! If it inspires you to write a game, I would be more than happy to be one of your play-testers.

== Chapter 1. Introducing Python ==

The language we are going to use to make games is Python, so called because the original author of the language was a fan of the UK television series Monty Python. Python is popular in game development, but it is also used to create everything from applications to web sites. __Even NASA and Google rely heavily on Python.__

__There are plenty of alternative languages that can be used to create games, but I have chosen Python because '''it has the tendency(傾向) to take care of the details and leave you—the programmer— to concentrate on solving problems.'''__ For our purposes, solving problems means displaying game characters on the screen, making them look great, and having them interact with a ''virtual environment''.

This chapter is a friendly introduction to Python; it will get you up to speed with the language so that you can read the sample code and start writing code of your own. If you are familiar with Python, then feel free to skip the first two chapters. Read on if you are completely new to Python or if you would like a refresher course.

To start working with Python, you will first need to install a Python interpreter for your computer. There are versions for PC, Linux, and Mac. We will be using version 2.4 of Python, which is not quite the most recent version but is supported by all the code libraries we will be using.

Note: By the time this book is published, it is likely that all the libraries used in this book will support a more recent version of Python. You don’t have to get the latest version, but if you do want to try out the new features then you can because new versions will run files created for older versions.

=== Your First Look at Python ===

The usual way of running Python code is to save it to a file and then run it. We will be doing this soon, but for now we are going to use Python in ''interactive mode'', which lets us enter code a line at a time and receive immediate feedback. You will find this to be one of Python’s strengths. __It is an excellent aid to learning the language, but even experienced Python programmers often return to interactive mode to do the odd(零碎的) experiment.__

Once you have installed Python on your system, you can run it like any other program. If you have Windows, it is simply a matter of double-clicking the icon or selecting it in the Start menu. For other systems with a command line, just type `python` to launch Python in interactive mode.

When you first run the Python interpreter, you will see something like the following:

 {{{
ActivePython 2.4.3 Build 12 (ActiveState Software Inc.) based on
Python 2.4.3 (#69, Apr 11 2006, 15:32:42) [MSC v.1310 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> _
 }}}

The text may vary depending on the version of Python you are running and the platform (Windows, Mac, Linux, etc.) you are running it on. But the important part is the three chevrons (V形圖案; `>>>`), which is the Python ''prompt''—it is your invitation to type in some code, which Python will then attempt to run.

A long-standing tradition in computer language tutorials is that the first program you write displays the text “Hello, World!” on the screen—and who am I to break with tradition! So take a deep breath and type `print 'Hello, World!'` after the prompt. The Python window will now display this on the prompt line:

 {{{
>>> print 'Hello, World!'
 }}}

If you hit the Enter key, Python will run the line of code you just entered, and if all goes well you will see this on the screen:

 {{{
>>> print 'Hello, World!'
Hello, World!
>>> _
 }}}

Python has executed your line of code, displayed the result, and given you a new prompt to enter more code. So how exactly does our line of code work? The word `print` is a ''statement'' that tells Python to print what follows to the screen. Following the `print` statement is a string, which is simply a collection of letters and/or digits. Python treats anything between quotes (`'`) as a string. Try entering your own text between the quote marks and you should find that Python will print it to the screen just as before.

==== Numbers ====

We will come back to strings later, but for now let’s start with the most simple piece of information that Python can work with: numbers. __Python is so good at working with numbers that you can use it almost like a calculator.__ To see it in action, type the following into Python (you don’t need to type the prompt, since Python displays it for you):

 {{{
>>> 2 + 2 <-- 在 interactive mode 下不一定要加 print
 }}}

Take a guess at what Python will make of this line and hit Enter. If you guessed 4, help yourself to(自用) a cookie—that is exactly what it does. Python has evaluated `2 + 2`, which in Python terms is known as an ''expression'', and displayed the result. You can also use `-` for subtract, `*` for multiply, and `/` for divide. These symbols are known as ''operators''. You will probably use `+`, `-`, `*`, and `/` the most. Here are some examples:

 {{{
>>> 10 - 5
5
>>> 2 * 4
8
>>> 6 / 2 + 1
4
>>> -2 + 7
5
 }}}

In the real world there is only one kind of number, but computers—and consequently Python—have several ways of representing numbers. The two most commonly used types of number are the ''integer'' and the ''float''. __Integers are whole numbers with no decimal point, whereas floats do have a decimal point and can store fractional(分數的) values.__ Often it is obvious which one you should use—for instance, if your game has the concept of lives, you would use an integer to store them because you are not likely to have half a life or 3.673 lives. Float values are more often used for ''real-world values'' that need precision—for example, in a racing game your car may have a speed of 92.4302 miles per hour, which you would store in a float.

So far the numbers you have entered have been integers. __To tell Python a number is a float, simply include a decimal point. For example, 5 and 10 are integers, but `5.` and `10.0` are floats. Something to watch out for is that '''if you do math with integers, the result is always an integer and the fractional part is discarded. (直接捨去, 不會做四捨五入的動作)'''__ To see this in action, type the following:

 {{{
>> 3 / 2
1
 }}}

Relax, Python has not gone crazy—it does understand numbers. __The reason you get the result 1 and not 1.5 is because 3 and 2 are integers and the result is also an integer, so Python discards the fractional part of the result. To get the result you would expect, simply make ''one or both'' of the numbers a float:__

 {{{
>>> 3. / 2
1.5
>>> 3 / 2.
1.5
>>> 3. / 2.
1.5
 }}}

In addition to the basic math there are a number of other things you can do with numbers. Parentheses are used to ensure that something is calculated first; here is an example:

 {{{
>>> 3. / 2. + 1.
2.5
>>> 3. / (2. + 1.)
1.0
 }}}

The first line calculates 3 divided by 2 first and then adds 1, giving the result 2.5. The second line calculates 2 plus 1 first, and so the result works out as 3 divided by 3, which is 1.

Another operator at your disposal(由某人支配) is the power operator, which raises a value to a power. For instance, 2 to the power of 3 is the same as `2*2*2`. __The power operator is `**` and works on integers and floats.__ Here are two examples of the power operator in action:

 {{{
>>> 2 ** 3
8
>>> 3. ** 4
81.0
 }}}

This would be an opportune(適當的) time to introduce you to longs, which is another type of number Python knows about. __Because of the way integers are stored, they have a maximum value and a minimum value. The value varies depending on the computer you are using, (如果 integer 的值域會變, 寫出來的程式要怎麼跨平台? 不過按下面 "automatically replace" 的說法, 數字型態的值域對寫程式的人來講好像就沒那麼重要了... '''這個特性讓 Python 很適合拿來做為小孩子的入門程式語言, 因為在真實的世界裡數字並沒有區分這些型態, 事實上這些型態最初也是因為 storage 的考量而衍生出來的''')__ but my computer can store integers in the range -2,147,483,648 to 2,147,483,647—which is a little over 4 thousand million possible values!

__So integers have a very large range, and you may not even need to store any numbers larger than the maximum or smaller than the minimum, but if you do, Python will ''automatically replace'' them with long numbers. A long can store numbers of any size, as long as they can fit in memory! (真的只受記憶體的限制嗎?) '''This may not sound like much, but most languages make long numbers very difficult to use.''' You can recognize long numbers by the `L` at the end;__ for example, `8589934592L` is a long. Let’s create a long by calculating 2 to the power of 100, which is `2*2*2*2…*2` repeated 100 times.

 {{{
>>> 2 ** 100
1267650600228229401496703205376L
 }}}

Now that is a big number! If you are feeling brave, try calculating `2**1000` or even `2**10000` and watch your screen fill up with massive numbers.

Let’s introduce you to one more operator before the next section. __The modulus (`%`) operator calculates the remainder of a division.__ For example, 15 modulus 6 is 3, because 6 goes into 15 two times with 3 left over. Let’s ask Python to do this for us:

 {{{
>>> 15 % 6
3
 }}}

With this handful of operators, you now have the ability to calculate anything that can be calculated, whether it is a 15 percent tip(小費) on two plates of fugu-sashi(河豚生魚片) or the damage done by an orc(獸人) hitting armor with a +1 axe(斧頭).

I don’t know much about orcs, but let’s calculate that tip on two plates of fugu-sashi (raw blowfish, a delicacy(珍饈) in Japan that I hope to try one day). Fugu is quite expensive, anything up to $200, because if it isn’t prepared by specially trained chefs(廚師), eating it can be fatal! Let’s say we find a restaurant in Tokyo that serves a tempting(誘人的) plate of fugu for $100. We can use Python to calculate the tip for us:

 {{{
>>> (100. * 2.) * 15. / 100.
30.0
 }}}

This calculates 15 percent of the price of two $100 plates—a $30 tip. Good enough for this restaurant but the numbers will change depending on where we buy our fugu and the quality of the service. We can make this clearer and more flexible by using ''variables''. __A variable is a label for a value, and when you create a variable you can use it in place of the number itself.__ In our tip calculation we could have three variables: the price of the fugu, the number of plates, and the tip percentage. To create a variable, type its name (區分大小寫) followed by an equal sign (`=`), then the value you want to give it: (不需要額外宣告型態)

 {{{
>>> price = 100.
>>> plates = 2.
>>> tip = 15.
 }}}

Caution: __Python variables are case sensitive, which means that if the variable names are capitalized differently, Python will treat them as being completely unique__—which means Apples, APPLES, and ApPlEs are treated as three different variables.

We can now use these three variables in place of numbers. Let’s calculate our tip again:

 {{{
>>> (price * plates) * (tip / 100.)
30.0
 }}}

__This calculates the same value, but now it is a little clearer because we can tell at a glance(一目瞭然) what the numbers represent. It’s also a lot more flexible, because we can change the variables and redo the calculation.__ Let’s say we have fugu for breakfast the following morning, but at a cheaper restaurant ($75 a plate), where the service is not quite as good and only worth a 5 percent tip:

 {{{
>>> price = 75.
>>> tip = 5.
>>> (price * plates) * (tip / 100.)
7.5
 }}}

That’s a $7.50 tip because the waiter was slow to bring the sake(日本米酒), and I hate to wait for my sake.

==== Strings ====

Another piece of information that Python can store is the string. __A string is a collection of characters (a character is a letter, number, symbol, etc.) and can be used to store literally any kind of information. '''A ''string'' could contain an image, a sound file, or even a video, but the most common use for strings is to store ''text''.''' To enter a string in Python, enclose it in either single quotes (`'`) or double quotes (`"`; 就結果來看, 單引號與雙引號這兩種用法是沒有差別的; 就下面的範例看來, 慣例上比較常用單引號[...]).__ Here are two strings; both contain exactly the same information:

 {{{
"Hello"
'Hello'
 }}}

__So why have more than one way of creating a string? Good question;__ let’s say we want to store the sentence I said "hocus pocus" to the wizard in a string. If we put the entire sentence in a string with double quotes, Python has no way of knowing that you want to end the string after the word `wizard`, and will assume that the string ends at the space after said. Let’s try it and see what happens:

 {{{
>>> print "I said "hocus pocus" to the wizard."
Traceback ( File "<interactive input>", line 1
print "I said "hocus pocus" to the wizard."
^
SyntaxError: invalid syntax
 }}}

Python has thrown an exception. More about exceptions later in the book, but for now if you see an exception like this Python is telling you that something is wrong with the code you entered. __We can get around the problem of including quotes in strings by using the ''alternative'' quote symbol.__ Let’s try the same sentence, but with single quotes (') this time:

 {{{
>>> print 'I said "hocus pocus" to the wizard.'
I said "hocus pocus" to the wizard.
 }}}

Python is quite happy with this, and does not throw an exception this time. This is probably the easiest way around the quote problem, but there are alternatives. __If you type a backslash character (`\`) before a quote, it tells Python that you don’t want to end the string here—you just want to include the quote symbol in the string.__ Here is an example:

 {{{
>>> print "I said \"hocus pocus\" to the wizard."
I said "hocus pocus" to the wizard.
 }}}

This solves the problem in a different way, but the result is the same. At the risk of burdening you with too much information, there is one more way of defining strings: __if you begin a string with triple single (`'''`) or triple double quotes (`"""`), Python knows not to end the string until it reaches another set of the same type of triple quotes. This is useful because text rarely contains three quotes in row.__ Here’s our wizard string again using triple quotes:

 {{{
>>> print """I said "hocus pocus" to the wizard."""
I said "hocus pocus" to the wizard.
 }}}

===== Concatenating Strings =====

So now you have several ways of creating strings, but what can you do with them? Just like numbers, strings have operators that can be used to create new strings. If you add two strings together, you get a new string containing the first string with the second string appended to the end. You can add strings with the `+` operator just like you do with numbers; let’s try it:

 {{{
>>> "I love " + "Python!"
'I love Python!'
 }}}

Python has added two strings together and displayed the result. Adding strings together like this is called ''string concatenation''. You can concatenate any two strings together, but you can’t concatenate a string with a number. Let’s try it anyway to see what happens:

 {{{
>>> "high " + 5
Traceback (most recent call last):
File "<interactive input>", line 1, in ?
TypeError: cannot concatenate 'str' and 'int' objects
 }}}

Here we have tried to produce the string 'high 5' by adding the number 5 to a string. This doesn’t make sense to Python, and it lets you know by throwing another exception. __If you do want to add a number to a string, you have to first ''convert'' the number to a string.__ You can easily create strings from numbers by constructing a new string from that number. Here’s how you would create our high 5 string.

 {{{
>>> "high " + str(5)
'high 5'
 }}}

This works because `str(5)` constructs a string from the number 5, which Python will happily concatenate with another string.

You can also use the multiply (`*`) operator with strings, but you can only multiply strings by integers. Take a guess at what the following line of Python code will do:

 {{{
>>> 'eek! ' * 10
 }}}

__You can see that Python can be quite intuitive; if you multiply a string by 10 it will repeat it 10 times.__ Strings do not support all mathematical operators such as `/` and `-`, because it’s not intuitive what they would do. What could `"apples" - "oranges"` possibly mean?

===== Parsing Strings =====

__Since a string can be thought of as a collection of characters, it is often useful to be able to refer to parts of it rather than as a whole. Python does this with the ''index operator'', which consists of square brackets `[]`, containing the ''offset'' of the character.__ The first character is `[0]`, the second is `[1]`, the third is `[2]`, and so forth. __Starting at 0 rather than 1 may seem a little odd, but '''it is a tradition among computer languages, and you will find it actually simplifies things when you write more Python code.'''__ Let’s see string indexing in action. First we will create a variable containing a string, which we do just like numbers:

 {{{
>>> my_string = 'fugu-sashi'
>>> print my_string
'fugu-sashi'
 }}}

Normally you would give strings a better name, but for this little example we will just call it `my_string` (the underscore character between `my` and `string` is used in place of a space because Python does not allow spaces in variable names; __'''Python 程式習慣以底線來分開變數名稱裡的組成單字, 甚至連方法也是 - 例如 `fire_at` 或 `get_pos`__'''). We can pick out individual letters from the string with the index operator:

 {{{
>>> my_string[0]
'f'
>>> my_string[3]
'u'
 }}}

`my_string[0]` gives you a string with the first character in `fugu-sashi`, which is `f`. The second line gives you the fourth character, since the first character is offset 0 and not 1. __Try to think of the offset not as the number of the character itself, but as the spaces between characters (see Figure 1-1); this will make the indexing a little more intuitive.__

{{attachment:figure_1-1.png}} <<BR>> Figure 1-1 String indexing

Let’s say we want to find the last character in a string. You can see from Figure 1-1 that the last character is “i” at offset 9, but what if we don’t know the string ahead of time? We could have extracted the string from a file, or the player may have typed it in a high score table. To find the last offset, we first need to find the length of the string, which we can do with the `len` function. __Think of a ''function'' as stored Python code; you pass the function some information, which it uses to carry out an action and then return, possibly with new information.__ This is exactly what `len` does; we give it a string and it returns the length of that string. Let’s try the `len` function on `my_string`:

 {{{
>>> len(my_string)
10
 }}}

There are 10 characters in `my_string`, but we can’t use 10 as an offset because it is right at the end of the string. To get the end character, we need the offset before 10, which is simply 9, so we subtract 1. Here’s how to use `len` to find the last character in a string:

 {{{
>>> my_string[len(my_string) - 1]
'i'
 }}}

Easy enough, I hope you will agree! __But Python can make it even easier for us by using ''negative indexing''. If you index with a negative number, Python treats it as an offset from the end of the string,__ so `[-1]` is the last character, `[-2]` is the second-to-last character, and so forth (see Figure 1-2).

{{attachment:figure_1-2.png}} <<BR>> Figure 1-2. Negative indexing

We can now find the last character with a little less code:

 {{{
>>> my_string[-1]
'i'
 }}}

===== Slicing Strings =====

In addition to extracting individual characters in a string, you can pick out groups of characters by ''slicing'' strings. __Slicing works a lot like indexing, but you use two offsets separated by a colon (`:`) character. The first offset is where Python should start slicing from; the second offset is where it should stop slicing. Again, think of the offsets as the spaces between the characters, not as the characters themselves.__

 {{{
>>> my_string[2:4]
'gu'
>>> my_string[5:10]
'sashi'
 }}}

The first line tells Python to slice between offset 2 and 4. You can see from the diagram that there are two characters between these offsets: g and u. Python returns them as a single string, 'gu'. The second line slices the string between offsets 5 and 10 and returns the string 'sashi'. __If you leave out the first offset, Python uses the start of the string; if you leave out the second, it uses the end of the string. (可以同時省略, 例如 `my_string[:]` 會傳回 `fugu-sashi` 整個字串)__

 {{{
>>> my_string[:4]
'fugu'
>>> my_string[5:]
'sashi'
 }}}

__Slicing can take one more value that is used as the ''step value''. If the step value is 1 or you don’t supply it, Python will simply return the slice between the first two offsets. If you slice with a step value of 2, then a string with every second character of the original will be returned.__ A step of 3 will return every third character, and so on. Here are some examples of this kind of slicing:

 {{{
>>> my_string[::2] <-- 同時省略 first/second offsets
'fg-ah'
>>> my_string[1::3] <-- 省略 second offset
'u-s'
 }}}

The first line slices from the beginning to the end of the string (because the first two offsets are omitted), but since the step value is 2, it takes every second character. The second line starts from offset 1 (at u) and slices to the end, taking every third character. __The step value in a slice can also be negative, which has an interesting effect. When Python sees a negative step, it reverses the order of the slicing so that it goes down from the second offset to the first. You can use this feature to easily reverse a string:__

 {{{
>>> my_string[::-1]
'ihsas-uguf'
>>> my_string[::-2]
'issuu'
 }}}

The first line simply returns a string with the characters in reverse order. Because the step value is negative, it goes from the end of the string to the beginning.

===== String Methods =====

__Along with these operators, strings have a number of ''methods'', which are ''functions contained within'' Python objects and that carry out some action on them.__ Python strings contain a number of useful methods to help you work with strings. Here are a just few of them, applied to our fugu string:

 {{{
>>> my_string.upper()
'FUGU-SASHI'
>>> my_string.capitalize()
'Fugu-sashi'
>>> my_string.title()
'Fugu-Sashi'
 }}}

Here we are applying various methods to a string. Each one returns a ''new string'' modified in some way. We can see that `upper` returns a string with all letters converted to uppercase, `capitalize` returns a new string with the first character converted to a capital, and `title` returns a new string with the first character of each word converted to a capital. __These methods don’t require any other information, but the parentheses are still necessary to tell Python to call the function. (包括下面 "`range` method" 的用法, Python 似乎不太在意 method 與 function 這兩個詞的混用)__

__Note: Python strings are ''immutable'', which means that you can’t modify a string once created, but you can create new strings from it. (跟 Java 的做法一樣; 不論是表示法或 index operator 都與下面的 list 一樣, 這呼應了 string 就是 "collection of characters" 的說法, 只不過 string 是 immutable 而已) In practice you will rarely notice this, because creating new strings is so easy.__

==== Lists and Tuples ====

Like most languages, Python has ways of storing groups of objects, which is fortunate(幸運的) because a game with only one alien(外星人), one bullet, or one weapon would be quite dull(乏味的)! __Python objects that store other objects are known as ''collections'', and one of the simplest and most often used collection is the ''list''.__ Let’s start by creating an empty list:

 {{{
>>> my_list = []
 }}}

The square brackets create an empty list, which is then ''assigned'' to the variable `my_list`. To add something to a list you can use the `append` method, which tacks(添加) any Python object you give it onto the end. Let’s pretend(假裝) our list is going to hold our shopping for the week, and add a couple of items:

 {{{
>>> my_list.append('chopsticks')
>>> my_list.append('soy sauce')
 }}}

Here we have added two strings to `my_list`, but we could just as easily have added any other of Python’s objects, including other lists. __If you now type `my_list` at the Python prompt, it will display the contents of it for you:__

 {{{
>>> my_list
['chopsticks', 'soy sauce'] <-- 輸出時也會加上中括號, 表示 list 型態
 }}}

Here we can see that the two strings are now stored inside the list. We cannot live on chopsticks(筷子) and soy sauce(醬油) alone, so let’s add a few more items to our shopping list:

 {{{
>>> my_list.append('wasabi')
>>> my_list.append('fugu')
>>> my_list.append('sake')
>>> my_list.append('apple pie')
>>> my_list
['chopsticks', 'soy sauce', 'wasabi', 'fugu', 'sake', 'apple pie']
 }}}

===== Modifying List Items =====

Python lists are ''mutable'', which means you can change them after they have been created. So as well as retrieving the contents of a list with the index operator, you can change the item at any index by assigning a new item to it. Let’s say we specifically want to get dark soy sauce; we can change the second item by assigning it a new value with the ''assignment operator'' (`=`):

 {{{
>>> my_list[1] = 'dark soy sauce'
>>> my_list
['chopsticks', 'dark soy sauce', 'wasabi', 'fugu', 'sake', 'apple pie']
 }}}

===== Removing List Items =====

Along with changing items in a list, you can remove items from it. Let’s say we want to remove apple pie because it just doesn’t seem to fit with the rest of our shopping list. __We can do this with the `del` operator, which will remove any item from our list (事實上 list 也提供了 `remove` 的方法)__—in this case, it is the last item, so we will use negative indexing:

 {{{
>>> del my_list[-1]
>>> my_list
['chopsticks', 'dark soy sauce', 'wasabi', 'fugu', 'sake']
 }}}

Lists support a number of operators that work in a similar way to strings. Let’s look at slicing and indexing, which you should find very familiar:

 {{{
>>> my_list[2]
'wasabi'
>>> my_list[-1]
'sake'
 }}}

The first line returns the string at offset 2, which is the third ''slot(縫)'' in our shopping list. Just like strings, the first item in a list is always 0. The second line uses negative indexing, and just like strings `[-1]` returns the last item.

Slicing lists works similar to slicing strings, with the exception that they return a ''new list'' rather than a string. Let’s slice our shopping list into two portions:

 {{{
>>> my_list[:2]
['chopsticks', 'dark soy sauce']
>>> my_list[2:]
['wasabi', 'fugu', 'sake']
>>>
 }}}

In the first slice we have asked Python to give us all the items from the beginning of the list to offset 2; in the second slice we have asked for everything from offset 2 to the end of the list. List offsets work just like string offsets, so try to think of them as the spaces between objects in the list and not the objects themselves. Therefore, offset 0 is before the first item and offset 1 is after the first item and before the second.

__You can also add lists together with the `+` operator. When you add lists together, it creates a single list containing the items from both lists.__ Let’s create a new list and add it to our shopping list:

 {{{
>>> my_list2 = ['ramen', 'shiitake mushrooms'] <-- 可以在建立時直接初始化
>>> my_list += my_list2
>>> my_list
['chopsticks', 'dark soy sauce', 'wasabi', 'fugu', 'sake', 'ramen', 'shiitake mushrooms']
 }}}

The first line creates a new list of strings called `my_list2`. We have created this second list slightly differently from the first; instead of creating a blank list and adding items to it one at a time, we have created a list with two items already in there. The second line uses the `+=` operator, which is useful shorthand: `my_list += my_list2` is the same as `my_list = my_list + my_list2`, which has the effect of adding the two lists together and storing the result back in `my_list`.

===== List Methods =====

Along with these operators, lists support a number of methods. Let’s use the `sort` method to sort our shopping list into ''alphabetical order'':

 {{{
>>> my_list.sort()
>>> my_list
['chopsticks', 'dark soy sauce', 'fugu', 'ramen', 'sake', 'shiitake mushrooms', 'wasabi']
 }}}

__The `sort` method sorts the contents of the list. The order depends on the contents of the list, but for a list of strings the sort is in alphabetical order.__

__You will notice that Python doesn’t print anything after the call to `sort`; this is because the `sort` does not return a sorted list but just sorts the list it was called on.__ The second line is necessary to ask Python to display the contents of our list.

Let’s say we are going shopping and we want to take an item off the list and go looking for it in the supermarket. __We can do this with the `pop` method, which removes an item from the list and returns it:__

 {{{
>>> my_list.pop(0)
'chopsticks'
 }}}

We have asked `my_list` to “pop” the item at offset 0, which is chopsticks(筷子). If we now display the contents of the shopping list, we should see that the first item has indeed been removed:

 {{{
>>> my_list
['fugu', 'ramen', 'sake', 'shiitake mushrooms', 'soy sauce', 'wasabi']
 }}}

There are more list methods than we have covered here; see Table 1-1 for more.

Table 1-1. Methods in Pythons Lists

|| Method || Description ||
|| `append` || Appends items to the list ||
|| `count` || Counts the number of times an item occurs in a list ||
|| `extend` || Adds items from another collection ||
|| `index` || Finds the offset of a string ||
|| `insert` || Inserts an item into the list ||
|| `pop` || Removes an item at an offset from the list and returns it ||
|| `remove` || Removes a particular item from a list ||
|| `reverse` || Reverses the list ||
|| `sort` || Sorts the list ||

===== Tuples =====

Another collection we are going to introduce in this section is the ''tuple''. __Tuples are similar to lists with the exception that they are ''immutable''; that is, like strings, once they have been created the contents cannot be changed. '''Tuples are generally used in preference to lists when the information they contain is ''tied together'' in some way'''—for example, a tuple could represent a phone number and area code because both parts are required to dial. They are created in a similar way to lists, but use parentheses, `()`, rather than square brackets.__ Let’s create a tuple that stores the phone number of our favorite sushi takeaway(外賣餐館):


 {{{
>>> my_tuple = ('555', 'EATFUGU')
>>> my_tuple
('555', 'EATFUGU')
 }}}

Here we have created a tuple with two strings containing the area code and number of our fugu takeaway. To prove a tuple is immutable, let’s try appending an item to it:

 {{{
>>> my_tuple.append('ramen')
Traceback (most recent call last):
File "<interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'append'
 }}}

Python has thrown an `AttributeError` exception, letting you know that tuples do not support `append`. (為何 method 不存在卻丟出 attribute 的錯誤[?]) You will get similar results if you try to do anything that modifies the tuple. __Tuples do support all the indexing and slicing operators, however, because these operators don’t modify the tuple.__

 {{{
>>> my_tuple[0]
'555'
>>> my_tuple[1]
'EATFUGU'
 }}}

===== Unpacking =====

__Since tuples are often used to pass around ''group values'', Python gives you a simple way of extracting them called ''unpacking''.__ Let’s unpack our tuple into two variables: one for the area code and one for the number.

 {{{
>>> my_tuple = ('555', 'EATFUGU')
>>> area_code, number = my_tuple <!-- 這也太誇張了吧!!
>>> area_code
'555'
>>> number
'EATFUGU'
 }}}

Here you can see that in a single line, Python has unpacked the two parts of our tuple into two separate values. __Unpacking actually works for lists and other Python objects, but you will most often use it with tuples.__

__Another way to extract the values in a tuple is to convert it into a list. You can do this by constructing a list with the tuple as a parameter—for example, `list(my_tuple)` will return the list equivalent, which is `['555', 'EATFUGU']`. You can also do the reverse and create a tuple by calling tuple on a list— for example, `tuple(['555', 'EATFUGU'])` returns our original tuple.__

__You will learn the best places to use tuples over lists in the following chapters; for now use the rule of thumb that you should use a tuple if you never need to modify the contents.__

__Note: Creating a tuple with one or zero items is a little different from lists. This is because Python also uses parentheses to define the priority in mathlike expressions. '''To define a tuple with just one item, add a comma after the item; to define an empty tuple, just include the comma by itself in parentheses.''' For example, `('ramen',)` is a tuple with one item, and `(,)` is an empty tuple.__

===== Dictionaries =====

The final collection type we are going to look at is the ''dictionary''. __The previous collections we looked at have all been ''sequence collections'', because the values are in a sequence from first to last and you access them by their position within the list. Dictionaries are mapping collections because they ''map one piece of information to another''.__ We could use a dictionary to store the prices of our shopping list by mapping the name of the food item to its price. Let’s say that fugu costs $100 and ramen costs $5; we can create a dictionary that holds this information as follows:

 {{{
>>> my_dictionary = {'ramen': 5.0, 'fugu': 100.0}
 }}}

The curly braces create a dictionary. Inside the braces we have the string 'ramen' followed by a colon, then the number 5.0 (price in dollars). This tells Python that the string maps to the number; in other words, we can look up the price if we have the name of the food item. Multiple items in a dictionary are separated with a comma; in this example we have a second item that maps 'fugu' to the value 100.0.

__To retrieve that information, we use the square brackets (`[]`) operator again, passing in the ''key'' we want to search for (in this case the key is either `fugu` or `ramen`). The dictionary returns the ''value'' associated with the key—the price of the item.__ Let’s look up our two keys:

 {{{
>>> my_dictionary['fugu']
100.0
>>> my_dictionary['ramen']
5.0
 }}}

You can also add new items to the dictionary by assigning new values to it:

 {{{
>>> my_dictionary['chopsticks'] = 7.50
>>> my_dictionary['sake'] = 19.95
>>> my_dictionary
{'sake': 19.0, 'ramen': 5.0, 'chopsticks': 7.5, 'fugu': 100.0}
 }}}

Here we have added two new items to the dictionary. You may have noticed that when Python displays the list for us, __the items are in a different order than the way we originally created it. This is because dictionaries don’t have any notion of order for keys in a dictionary and what you see displayed is in no particular order.__ The important thing is that Python remembers what key maps to what value—which it does very well!

==== Loops ====

__A loop is a way of running through a piece of code more than once. Loops are pretty fundamental in programming languages, and '''you will find that almost every line of code you write in a game is inside some kind of loop.'''__ Like many other programming languages, Python has two types of loop to handle all your looping needs: the while loop and the for loop.

===== While Loops =====

A while loop is used when you repeat a piece of code only when a condition is true. Let’s use a simple while loop to display the numbers from 1 to 5. We’ll start by entering the following lines in the interpreter:

 {{{
>>> count = 1
>>> while count <= 5:
...
 }}}

__When you hit Enter after the second line, you will notice that instead of the usual Python prompt you now see three periods (`...`). '''This is because the colon at the end of the line indicates that there is more code to follow. (也就是說, code block 除了要內縮, 它以上一行的冒號為啟始, 以空白行做為結尾)'''__ In the case of a while loop, it is the code that we want to be repeated.

__All languages need some way to mark the beginning and end of ''code blocks''. Some use symbols like curly braces (`{ }`), and others use words like `do` and `end`. '''Python does things slightly differently and uses ''indentation'' to define blocks. To tell Python that a line of code is part of the block and not the rest of the code, insert a tab before the line__ (by pressing the Tab key; 事實上用一個空白也可以, 目的是造成 indentation)''':

 {{{
...    print count
...    count += 1
 }}}

Note: On some systems you may find that a tab is automatically inserted on the first line of a block. This can be convenient if there is a lot of code in a block. Delete the tab and press Enter as normal to end the block.

__Hit Enter twice after the last line; the blank line tells the interpreter that you have finished entering the code block.__ The while loop will now run and display the numbers 1 through 5. So how does this work? Well, after the `while` statement is a condition (`count <= 5`), which can be read as “Is count less than or equal to 5?” The first time Python encounters the while loop, `count` is 1, which satisfies our condition of being less than or equal to 5—so Python runs the code block. The two lines in the code block first print the value of `count`, then add one to it. The second time around, `count` is 2, which also satisfies the condition and we go around the loop again. Eventually `count` becomes 6, which is definitely not less than or equal to 5, and this time Python skips the code block.

Less than or equal to (`<=`) is just one comparison operator. See Table 1-2 for others you can use.

Table 1-2. Comparison Operators

|| Operator || Description ||
|| `<` || Less than ||
|| `<=` || Less than or equal to ||
|| `>` || Greater than ||
|| `>=` || Greater than or equal to ||
|| `==` || Equal to ||
|| `!=` || Not equal to ||

Caution: Be careful with your loops! If you use a condition that is always true, such as `2 > 1`, Python will keep going round the loop forever. __If you do end up in this pickle(困境), hit Ctrl+Z (Ctrl+C for Linux and Mac OS X) to stop Python in its tracks. Every programmer has been stuck in an infinite loop at least once!__

===== For Loops =====

While loops have their uses and it is important you know how to use them, but often the for loop is a better choice. __A for loop runs through an ''iterable'' Python object, giving you a new value until there are no more items remaining.__ You have met iterables before: lists, tuples, dictionaries, and even strings are all iterable objects. Let’s rewrite the while loop example as a for loop:

 {{{
>>> for count in range(1, 6):
...    print count
 }}}

__Here we are iterating over the result of the `range` function, which creates a list of values from the first parameter up to—but not including—the second parameter.__ The interpreter can tell us exactly what the call to range produces:

 {{{
>>> range(1, 6)
[1, 2, 3, 4, 5]
 }}}

As you can see, the call to `range` has created a list containing the numbers 1 through 5, which is exactly what we want to display inside our loop. When Python first goes through the for loop, it picks the first value from the list and assigns it to the variable `count`; it then runs the code in the loop, which simply prints the current value of `count` to the screen. The loop finishes after five passes, when it reaches the end of the list.

__Tip: You can use the `range` method like this, but a better choice is probably `xrange`, which works identically to `range` but doesn’t create the entire list in memory. This is important if you want to use a for loop to iterate over very large ranges.__

=== Python in Practice ===

Before we move on to the next chapter, let’s put what we have learned to some practical use. Mental arithmetic has never been one of my strong points, so I’d like to write a small piece of Python code to run through our shopping list and find the total price. We’ll start by creating a list containing our groceries for the week and a dictionary that maps the name of each item on to its price:

 {{{
>>> shopping = ['fugu', 'ramen', 'sake', 'shiitake mushrooms', 'soy sauce', 'wasabi']
>>> prices = {'fugu': 100.0, 'ramen': 5.0, 'sake': 45.0, 'shiitake mushrooms': 3.5, 'soy sauce': 7.50, 'wasabi': 10.0}
>>> total = 0.00
 }}}

OK, great. We now have two Python collections that store all the information regarding our groceries(食品雜貨), and a variable to store the total. What we need to do now is loop through shopping, look up each price in prices, and add it to total:

 {{{
>>> for item in shopping:
...    total += prices[item]
>>> total
171.0
 }}}

That’s all it takes! The variable `total` now holds the sum of every item in our shopping list, and we can see the grand total(總計) is a very reasonable $171. Don’t worry, the sample code in the following chapters will be much more entertaining than a grocery list!

=== Summary ===

We have explored some of the basic Python constructs in this first chapter, most of which you will use regularly when writing new code. You can think of what you have learned so far as the most basic tools of the trade when it comes to writing games and other Python programs. The data (numbers and strings) and collections (tuples, list, and dictionaries) are particularly fundamental because you can store every aspect of a game within them.

In the following chapter you will learn how to fit together what you have learned to create more sophisticated programs. You will discover how to use logic, create functions, and leverage the power of ''object-oriented programming''.

== Chapter 2. Exploring Python ==

In the previous chapter we entered our Python code a line at a time, but now we are going to put the interactive interpreter to the side and start creating Python files. In this chapter we will cover more of the ''building blocks'' of Python code, and show you how to use classes to help with creating games. We will also explain how to use the ''code libraries'' that come with all installations of Python.

=== Creating Scripts ===

A file containing Python code is called a ''script''. All you need to create scripts is a simple text editor, but it’s best to use a Python-aware editor such as http://www.scintilla.org/SciTE.html[SciTE] (see Figure 2-1) or IDLE (which comes with the standard distribution of Python).

Just save your script with a `.py` extension, so that your operating system knows that it contains Python. To run a script, you typically just double-click it, or if you prefer the command line, type `python` followed by a space and the name of your script. Most Python editors will have a shortcut key to run the script you have been editing.

__Note: '''Python allows both spaces and tabs for indentation, but it is better to use four spaces.'''__ Most Python editors will be set this way, but you may have to check it in the Options dialog of your editor.

{{attachment:figure_2-1.png}} <<BR>> Figure 2-1. Editing Python code with SciTE (www.scintilla.org/SciTE.html)

=== Working with Logic ===

Not just for green-blooded Vulcans(瓦肯人; 星艦迷航記中「企業號」的科學官史巴克, 是來自瓦肯星的瓦肯人, 他們血中主要礦物質不是鐵而是銅, 因此血液是綠油油的一片), logic is an important part of any software—and that includes games. Any game needs to make decisions based on information it either has been given or has calculated. If a laser blast(射擊) hits the player’s hover(徘徊) tank, the game has to decide if enough damage has been done to destroy it—and display an explosion animation if it has. This is just an example of a whole host of(許多) decisions a computer game has to make in order to convince(使信服) us that it is more than just a dumb(愚蠢的) machine. So please put on your Spock ears (星艦企業號的傳奇副艦長, 有著尖耳朵) and we will cover logic.

==== Understanding Booleans ====

__The logic that computers use is ''boolean logic'', so called because it was invented by http://en.wikipedia.org/wiki/George_Boole[George Boole] way back in the 1800s—a few years before PlayStation hit the street.__

You have already seen logic used in the previous chapter as part of a while loop; `count <= 5` is a ''logical expression'', and like all logical expressions it results in either `True` or `False`. (佈林值輸出也是這個樣子) These truth values, as they are called, are used when making decisions. In the case of a while loop, a value of `True` tells Python to carry on(繼續下去) around the loop one more time, but a value of `False` causes Python to skip past the code block. (See Listing 2-1 for a few examples of logical expressions.) The important thing to remember with boolean logic is that there are no ''in-between values(中間值)'': you can’t have 25 percent true and 75 percent false—it’s always one or the other!

Listing 2-1. Simple Logic

 {{{
score = 100
health = 60
damage = 50
fugu = "tasty"
print score != 100
print health - damage > 0
print fugu == "tasty"
 }}}

Running this simple script produces the following output:

 {{{
False
True
True
 }}}

Boolean values can be treated just like any other Python type, so you could have a variable that refers to a boolean. For example, if we were to add the line `is_fugu_tasty = (fugu == "tasty")`, then `is_fugu_tasty` would refer to the value `True`.

===== If Statement =====

Logical expressions come into their own when using `if` statements. You use `if` statements to run code only when a condition is true. If the condition is false, then Python jumps past the end of your code block. Here is a simple example of the `if` statement:

 {{{
if fugu == "tasty":
    print "Eat the fugu!"
 }}}

The condition uses the comparison operator (`==`) to compare a variable with a string. Assuming we are using the value of `fugu` from Listing 2-1, this comparison will result in `True`, which gives Python the green light to run the indented code block.

===== And Operator =====

Often you have several conditions you want to check for. Let’s say we want to eat fugu if it is tasty and under $100 a plate. We can combine these two conditions with the `and` operator:

 {{{
price = 50.0
if fugu == "tasty" and price < 100.0:
    print "Eat the fugu!"
 }}}

Here we will only eat the fugu if fugu is set to "tasty" and the price has a value less than 100.0. Table 2-1 lists how the `and` operator combines values, but I hope it is self-explanatory. You can find this operator at work in real life; for example, my car will start only if the battery is not dead and I have gas.

Table 2-1. Truth Table for the And Operator

|| Logic || Result ||
|| False and False || False ||
|| True and False || False ||
|| False and True || False ||
|| True and True || True ||

===== Or Operator =====

To complement the `and` operator, we have the `or` operator, which results in `True` if either the first or second value is `True`. Let’s say we want to eat fugu if it is tasty or it is very cheap (after all, who can turn down(拒絕) cheap fugu?):

 {{{
if fugu == "tasty" or price < 20.0:
    print "Eat the fugu!"
 }}}

Just like the `and` operator, the `or` operator has plenty of applications in real life. My car will stop if I run out of gas or the battery goes dead. See Table 2-2 for the or truth table.

Table 2-2. Truth Table for the Or Operator

|| Logic || Result ||
|| False or False || False ||
|| True or False || True ||
|| False or True || True ||
|| True or True || True ||

===== Not Operator =====

The final logic operator we will look at is the `not` operator, which swaps the state of a boolean value, so `True` becomes `False` and `False` becomes `True` (see Table 2-3). You can use this to reverse any condition:

 {{{
if not (fugu == "tasty" and price < 100.0):
    print "Don't eat the fugu!"
 }}}

Here we have reversed the `fugu == "tasty" and price < 100.0` condition so that Python runs the code block only if the condition is not true (that is, false).

Table 2-3. Truth Table for the Not Operator

|| Logic || Result ||
|| not True || False ||
|| not False || True ||

===== Else Statement =====

You may have noticed that the previous snippet is the opposite of our first fugu logic statement. We have an action that occurs when a condition is true and another that runs when that same condition is not true. This is such a common situation that Python has a way of tacking on(添加) the alternative action to an `if` statement. The `else` statement follows an `if` statement and introduces a new code block that will run only if the condition is false. Let’s see an example of how else is used:

 {{{
if fugu == "tasty":
    print "Eat the fugu!"
else:
    print "Don't eat the fugu!"
 }}}

When Python runs this code, it will run the first `print` statement if the condition is true; else it will run the second condition.

===== Elif Statement =====

Often another `if` statement will follow an `else` statement. Python combines an `else` followed by an `if` into a single statement: the `elif` statement. Let’s say we want to classify the fugu into three categories based on the price. For sake of argument(為求論據), we will classify $20–$100 as reasonably priced fugu, anything above that range as expensive fugu, and anything below that as cheap fugu. Python can do this for us using `elif`:

 {{{
if price < 20:
    print "Cheap fugu!"
elif price < 100:
    print "Reasonably priced fugu."
else:
    print "Expensive fugu!"
 }}}

Here we have three code blocks, but only one of them runs. If price is less than 20, then the first block will run; if price is less than 100, then the second block will run; and any other value of price will cause the third block to run. __You can have as many `elif` statements as you want after an `if`, but if you have an `else` statement it must come at the end.__

=== Understanding Functions ===

__A ''function'' is a stored piece of Python code that you can pass information to and potentially get information back from.__ Python provides a large number of useful functions (see Table 2-4 for some examples), but you can also create your own.

Table 2-4. Some Built-in Python Functions

|| Function || Description || Example ||
|| `abs` || Finds the absolute value of a number || `abs(-3)` ||
|| `help` || Displays usage information for any Python object || `help([])` ||
|| `len` || Returns the length of a string or collection || `len("hello")` ||
|| `max` || Returns the largest value || `max(3, 5)` ||
|| `min` || Returns the smallest value || `min(3, 4)` ||
|| `range` || Returns a list containing a range of numbers || `range(1, 6)` ||
|| `round` || Rounds a float to a given precision || `round(10.2756, 2)` ||

For a more comprehensive list of Python’s built-in functions, see the Python documentation, or visit http://doc.python.org.

==== Defining Functions ====

__To define a function in Python, you use the `def` statement followed by the name you want to give to your function. You can use any name you want, but it is a good idea to give it a name that describes what it actually does! '''Function names are typically in lowercase and may use underscores to divide words. (跟 Java 完全不同的命名慣例)'''__ Listing 2-2 is a simple Python function for calculating the tip on a meal of fugu.

Listing 2-2. Calculating the Tip on Fugu

 {{{
def fugu_tip(price, num_plates, tip):
    total = price * num_plates
    tip = total * (tip / 100.)
    return tip

print fugu_tip(100.0, 2, 15.0)
print fugu_tip(50.0, 1, 5.0)
 }}}

This script produces the following output:

 {{{
30.0
2.5
 }}}

__When Python first encounters a `def` statement, it knows to expect a ''function definition'', which consists of the name of the function followed by a list of ''parameters'' in parentheses. Just as with `for`, `while`, and `if` statements, a colon is used to introduce a block of code (known as the ''function body'').__ In the aforementioned(前述的) statements, the block of code doesn’t run immediately— it’s just stored away until it is needed. Calling the function causes Python to jump to the beginning of the function body and assign information given in the call to each of the parameters. So in Listing 2-2, the first call to `fugu_tip` runs with price set to 100, `num_plates` set to 2, and `tip` set to 15.

The only thing you haven’t already encountered in `fugu_tip` is the `return` statement, which tells Python to jump back from the function, potentially with some new information. In the case of `fugu_tip` we return with the value of our tip, but a function can return any Python object.

__Note: You don’t need a `return` statement in the function. Without a `return` statement, a function will return when it gets to the end of the code block with the value `None`—which is a special Python value indicating “nothing here.”__

__You may have noticed that inside `fugu_tip` two variables are created; these are called ''local variables'', because they only exist inside the function. When the function returns, `total` and `tip` will no longer exist in Python’s memory—although it is possible to have variables with the same name outside of the function.__

===== Default Values =====

__Parameters can have a default value, which is used if you don’t supply a value in the function call. Without default values Python will throw an exception if you forget a parameter.__ Let’s give default values to `fugu_tip`. I am a generous tipper(慷慨的給小費的人), so we’ll set the default of tip to be 15 (which represents a percentage of the meal(一餐) cost), and since I don’t like to eat alone we will assign `num_plates` a default of 2.

__To set default values in Python, append the parameter name with a `=` symbol followed by the value you want to give it.__ See Listing 2-3 for a modified `fugu_tip` function with these default values. `fugu_tip` can now be called with just one value; the other two values are filled in automatically if you omit them. __There can be as many default values in a function definition as you want, but parameters with defaults must come at the end of the parameter list. (這裡指的是宣告, 還是呼叫的時候[?])__

Listing 2-3. Calculating the Tip on Fugu

 {{{
def fugu_tip(price, num_plates=2, tip=15.):
    total = price * num_plates
    tip = total * (tip / 100.)
    return tip

print fugu_tip(100.0)
print fugu_tip(50.0, 1, 5.0)
print fugu_tip(50.0, tip = 10.0)
 }}}

Running this code gives us the following values for tips:

 {{{
30.0
2.5
10.0
 }}}

You may have noticed that there is something unusual about Listing 2-3. __The third call to `fugu_tip` omits a value for `num_plates` and sets the value of `tip` by name. When you set parameters explicitly like this, they are called ''keyword arguments''. They are useful if you have a function with many parameters, but you only need to set a few of them.__ Without defaults, parameters must be given in the same order as the parameter list.

=== Introducing Object-Oriented Programming ===

You may have heard the term object-oriented programming (OOP) before. But don’t worry if you are unfamiliar with it, because the concept is remarkably simple.

So what exactly is an object in OOP terms? Well, it can literally be anything. In a game we may have an object for a particle—say, a burning ember(餘燼) emitted from an explosion, or the hover tank that caused the explosion. In fact, the entire game world could be an object. __The purpose of an object is to contain information and to give the programmer the ability to do things with that information.__

When constructing an object, it is usually best to start by working out what information, or ''properties'', it contains. Let’s think about what would be found in an object designed to represent a futuristic(新潮的) hover tank. It should contain a bare minimum of the following properties:

 * Position: Where is the tank?
 * Direction: In what direction is it facing?
 * Speed: How fast is it going?
 * Armor(裝甲): How much armor does it have?
 * Ammo(彈藥): How many shells(炮彈) does it have?

Now that we have the information to describe a tank and what it is doing, we need to give it the ability to perform all the actions that a tank needs to do in a game. In OOP-speak, these actions are called ''methods''. I can think of the following methods that a tank will definitely require, but there will likely be far more: (其中 Hit 與 Explode 規劃成 tank 自己的 methods, 好像有點怪怪的[?])

 * Move: Move the tank forward.
 * Turn: Rotate the tank left/right.
 * Fire: Launch a shell.
 * Hit: This is the action when an enemy shell hits the tank.
 * Explode: Replace the tank with an explosion animation.

__You can see that the methods typically change the properties of an object.__ When the Move method is used, it will update the tank’s Position. Similarly, when the Fire method is used, the value of Ammo will be updated (unless of course there is no Ammo left; then Fire would not do anything!).

==== Using Classes ====

A ''class'' is Python’s way of defining objects. You have actually used classes before; lists, dictionaries, and even strings are all classes, but you can also create your own. __Think of a class as a kind of a ''template'' for an object, because you define the class once and use it to create as many objects as you need.__ Let’s write a simple `Tank` class (Listing 2-4); we will use it later to create a simple game.

Listing 2-4. An Example Tank Class Definition

 {{{
class Tank(object):

  def __init__(self, name):
    self.name = name
    self.alive = True
    self.ammo = 5
    self.armor = 60
 }}}

__When Python encounters `class Tank(object):`, it creates a class called `Tank`, which is derived from the base class called `object`. (為什麼不是 `Object`[?])__ Deriving from a class means building on what it does. We could first create a class called `Vehicle`, which could handle moving and turning, and then create a tank by deriving from it and adding the ability to fire weapons. The advantage of this approach is that `Vehicle` could be reused to give other game entities the ability to rotate and move. For this example, we don’t have another class to build on, so our base class will be `object`, which is a simple class built into Python itself.

__Note: I may have given you the impression that `object` doesn’t do much, but actually it does a lot of useful things behind the scenes when working with classes—you just don’t use it directly.__

Everything in the indented code block after the `class` statement is the ''class definition''. This is where we set up the properties used to describe the object and supply all the methods that it will need. __'''In Python, properties are simply variables stored within the object, and methods are functions that work with the object.''' In our `Tank` class, there is an oddly named method called `__init__`, which has special meaning to Python. When you create an object, Python calls this method automatically. (一般都稱之為 constructors) It is typically used by Python programmers to assign properties to the object, but you can do anything else that may be needed when the object is first created.__

This `__init__` method takes two parameters: `self` and `name`. __Because methods are potentially used for many objects (一個 class 會衍生出多個 instances 而言), we need some way to know which object we are using. '''This is where `self` comes in—it is a reference to the current object that Python supplies automatically to all method calls. (固定為第一個參數, 等同於 Java 中 `this` 的用法)'''__ The second parameter (`name`) is a string we will use to tell one tank from another, because there will be more than one.

The code in `__init__` first copies the `name` parameter to a property so we can retrieve it later; it then assigns a few other properties we will need. We don’t require a great deal of information for the tank in the game I have planned; we just need to know if the tank is alive (`self.alive`), how much ammo it has (`self.ammo`), and how much armor it has remaining (`self.armor`).

__Note: You don’t have to call the first parameter `self`. You could name it anything you want, but it is a good idea to stick to `self` so you will know exactly what it is for when you read over your code. Python programmers tend to stick to this convention, so there is no confusion when exchanging code.__

Now that we have a tank definition, we can create a new tank by calling `Tank`, which we supply with a string. Let’s see an example:

 {{{
my_tank = Tank("Bob")
 }}}

This creates a new tank called Bob and calls `__init__` to initialize it. Bob the tank is then assigned to the variable `my_tank`, which is called an ''instance'' of the `Tank` class. We can now treat `my_tank` as an individual object—passing it into functions, storing it in lists, and so forth, or we can access the properties individually. For instance, `print my_tank.name` would display `Bob`.

With just one method, the Tank class can’t do anything interesting. Let’s flesh it out with a few more methods in Listing 2-5.

Listing 2-5. Extended Tank Class

 {{{
def __str__(self):

    if self.alive:
        return "%s (%i armor, %i shells)" % (self.name, self.armor, self.ammo)
    else:
        return "%s (DEAD)" % self.name

def fire_at(self, enemy):

    if self.ammo >= 1:
        self.ammo -= 1
        print self.name, "fires on", enemy.name
        enemy.hit()
    else:
        print self.name, "has no shells!"

def hit(self):
    self.armor -= 20
    print self.name, "is hit!"
    if self.armor <= 0:
        self.explode()

def explode(self):
    self.alive = False
    print self.name, "explodes!"
 }}}

The first method in Listing 2-5 is another special method. __Any name with two underscores at the front and end has a special meaning to Python. The purpose of `__str__` is to return a string that describes the object; it is called when you try to convert the object to a string with `str`, which will happen when you print it.__ So if we were to do `print my_tank`, it should display a string with some useful information about Bob the tank. The `__str__` in Listing 2-5 returns a different string depending on whether the tank is alive or dead. If the tank is alive, then this line will run:

 {{{
return "%s (%i armor, %i shells)" % (self.name, self.armor, self.ammo)
 }}}

This does something you may not have seen before. __The string `"%s (%i armor, %i shells)"` is combined with a tuple `(self.name, self.armor, self.ammo)`, using the `%` operator. This is known as ''string formatting'', which is a great way of creating complex strings without much fuss(小題大作).__ The first two characters in the string are `%s`, this tells Python to replace them with the first item in the tuple, which is a string containing the name of the tank. Later in the string Python reaches `%i`, which is replaced by the second item in the tuple (an integer) and so on until there are no more items in the tuple. String interpolation(插入) is often simpler to use than adding many small strings together. This line does the same thing, but uses simple string concatenation:

 {{{
return self.name + " (" + str(self.armor) + " armor, " + str(self.ammo) + " shells)"
 }}}

This is a little more complex, as I’m sure you will agree! String formatting can format integers, floats, and strings in a variety of ways. See the Python documentation for more information (http://docs.python.org/lib/typesseq-strings.html).

The second method in the `Tank` class, `fire_at`, is where things get interesting. It takes the parameter `enemy`, which is the tank object we want to fire at. First it checks how much ammo is remaining. If there is at least one shell, it reduces `self.ammo` by 1 (because we just fired a shell) and calls the enemy tank’s `hit` method. Inside the enemy tank’s `hit` method it reduces `self.armor` by 20. If there is no armor remaining, then the enemy is dead, so we call its `explode` method to mark the tank as deceased(已死的).

If this were a graphical game we were working on, these methods would create some visual effects. `fire_at` would create a shell image or 3D model and set its trajectory(彈道), and `explode` would likely display some kind of impressive explosion animation. But for this small test game we will just use a few `print` statements to describe what is currently happening.

Listing 2-6 shows the `Tank` class in its entirety; save it as `tank.py`. If you run this script it will do nothing, because it just defines the `Tank` class. We will create another Python script with the rest of the game code.

Listing 2-6. `tank.py`

 {{{
class Tank(object):

    def __init__(self, name):

        self.name = name
        self.alive = True
        self.ammo = 5
        self.armor = 60

    def __str__(self):

        if self.alive:
            return "%s (%i armor, %i shells)" % (self.name, self.armor, self.ammo)
        else:
            return "%s (DEAD)" % self.name

    def fire_at(self, enemy):

        if self.ammo >= 1:
            self.ammo -= 1
            print self.name, "fires on", enemy.name
            enemy.hit()
        else:
            print self.name, "has no shells!"

    def hit(self):
        self.armor -= 20
        print self.name, "is hit!"
        if self.armor <= 0:
            self.explode()

    def explode(self):
        self.alive = False
        print self.name, "explodes!"
 }}}

=== Python in Practice ===

The game we are going to create is more of a simulation than a game, but it should be enough to introduce a few important game concepts. We will create a number of tanks and let them take shots at each other. The winner is simply the last tank left in the game. Listing 2-7 shows the code that completes the tank game.

Listing 2-7. `tankgame.py`

 {{{
from tank import Tank

tanks = {"a": Tank("Alice"), "b": Tank("Bob"), "c": Tank("Carol")}
alive_tanks = len(tanks)

while alive_tanks > 1:

    print
    for tank_name in sorted(tanks.keys()):
        print tank_name, tanks[tank_name]

    first = raw_input("Who fires? ").lower()
    second = raw_input("Who at? " ).lower()

    try:
        first_tank = tanks[first]
        second_tank = tanks[second]
    except KeyError, name:
        print "No such tank!", name
        continue

    if not first_tank.alive or not second_tank.alive:
        print "One of those tanks is dead!"
        continue

    print
    print "*" * 30

    first_tank.fire_at(second_tank)
    if not second_tank.alive:
        alive_tanks -= 1

    print "*" * 30

for tank in tanks.values():
    if tank.alive:
        print tank.name, "is the winner!"
        break
 }}}

When you see any piece of code for the first time (in any language), it can be a little intimidating(嚇人的). But once you break it down you should find that it consists of familiar things. So let’s dissect Listing 2-7 like a trained chef preparing fugu!

The first thing `tankgame.py` needs to do is import our `tank` ''module'', which contains the `Tank` class. __When a new script runs, it only has access to the built-in classes, such as strings and lists. If you want to use another class that isn’t defined directly, you first have to import it from another Python file. The line `from tank import Tank` tells Python to look for the module called `tank` (`.py` is assumed; 其實所謂的 module 就是單一支 `.py` 的檔案) and read in the `Tank` class. An alternative would be to do a simple `import tank`, which would let us access everything inside `tank.py`.__

__Note: When you do `from tank import Tank`, it imports the `Tank` class (capital `T`) to the ''current namespace (= top-level namespace)''—which means you can now use `Tank` '''as if you had just cut and pasted it into your script. (這個概念適用於 module 對外公開的所有東西, 包括 properties、functions、classes)''' However, if you just do `import tank`, you have imported the `tank` namespace, which means you would have to refer to the `Tank` class as `tank.Tank`, as in `my_tank = tank.Tank("Bob")`.__ See the section “Introducing import” later in this chapter for more details on the `import` statement.

Next we create a dictionary called `tanks`, which will be used to store all our tank objects. We will work with three, but feel free to add more tanks if you like.

 {{{
tanks = {"a": Tank("Alice"), "b": Tank("Bob"), "c": Tank("Carol")}
alive_tanks = len(tanks)
 }}}

The three tanks have the strings "a", "b", and "c" as keys, so we can look them up easily. Once we create our tanks, we store the number of tanks in `alive_tanks` so we can keep count of tanks still in the game:

 {{{
while alive_tanks > 1:
 }}}

__This starts off a while loop that keeps going while there is more than one surviving tank. '''Games always have a big loop at their core. For a visual game the main loop runs once ''per frame'' to update and display visuals,''' but here the loop represents a single round in the simulation.__

Inside the while loop we first `print` a blank line to make the text for each round a little easier to separate. Then we have another loop that displays a little information on each of the tanks:

 {{{
print
for tank_name in sorted(tanks.keys()):
    print tank_name, tanks[tank_name]
 }}}

The `keys` method of dictionaries returns a list of the keys that it contains, but because of the nature of dictionaries the keys won’t necessarily be in the order that they were added. __So when we get the list of keys for tanks we immediately pass it to `sorted`, which is a built-in function that returns a sorted copy of a list. (效果等同於 list 本身的 `sort` 方法)__

The `print` statement inside the for loop looks up the key in the tanks dictionary and prints the tank object it finds. Remember, printing an object calls its `__str__` function to get some useful information.

Next we ask the user for two tanks: the tank that fires (`first`) and the tank that it hits (`second`):

 {{{
first = raw_input("Who fires? ").lower()
second = raw_input("Who at? " ).lower()
 }}}

__The built-in function `raw_input` displays a prompt and waits until the user has entered some text, which it returns as a string.__ In the preceding code we call the `lower` method of the returned string to convert it to lowercase because we need a lowercase string to look up the appropriate tank, but we don’t mind if the user enters a name using uppercase letters.

With the two tank keys in hand, we can use them to look up the actual tank object. This is simple enough: we can just do `tanks[first]` to retrieve the tank:

 {{{
try:
    first_tank = tanks[first]
    second_tank = tanks[second]
except KeyError, name: <-- 後面跟著 name 是做什麼用的? 不存在的 key[?]
    print "No such tank!", name
    continue
 }}}

But because the user could type anything at the prompt, we need some way of handling a situation where the user makes an error or deliberately(故意地) tries to break our game!

__Whenever Python is unable to do something it is asked to do, it will throw an ''exception''. If you don’t do anything to handle these exceptions, the Python script will exit—which would be disastrous(糟糕的) in a real game. Fortunately it is possible to predict potential exceptions and handle them if they occur.__ If either `first` or `second` is not a key in the `tanks` dictionary, then Python will throw a `KeyError` exception when we try to look either of them up. This won’t make the script exit because we look up the keys inside a `try:` block, which says to Python that the code block may throw an exception. If a `KeyError` does occur, Python jumps to the code under `except KeyError:` (which is ignored if no exception occurs).

__Inside our `KeyError` ''exception handler'' we first display a brief message to inform the user that they did something wrong, and then move on to a `continue` statement, which tells Python to ignore the rest of the code in this loop and jump back to the top of the ''innermost loop''.__ 

 {{{
if not first_tank.alive or not second_tank.alive:
    print "One of those tanks is dead!"
    continue
 }}}

This piece of code handles the situation if one or both of the tanks is dead—since there is no point in firing on a dead tank, and tanks that are dead can’t fire anyway! It simply displays a message and does another `continue`.

If we have managed to get to this point in the code, we have two valid tank objects:

 {{{
first_tank and second_tank:
first_tank.fire_at(second_tank)
if not second_tank.alive:
    alive_tanks -= 1
 }}}

The first tank does the firing, so we call its `fire_at` method and pass in the second tank as the enemy. If the second tank is killed by the first (armor reaches 0), its `alive` property will be set to `False`. When this happens, the `alive_tanks` count is reduced by 1.

Eventually, after a few rounds of the game the value of `alive_tanks` will reach 1. And when that happens, the main game loop will end, as it only loops when `alive_tanks` is greater than 1.

The purpose of the last section of code is to display which tank won the game: for tank in `tanks.values()`:

 {{{
if tank.alive:
    print tank.name, "is the winner!"
    break
 }}}

It is another loop that goes through each value in `tanks.values()`, which is the complement to `keys()`—it gives us a list of all our tank objects. We know that there is only one tank that has alive set to `True`, so we test it with a simple `if` statement. Once we find that last remaining tank, we print a little message and then execute the `break` statement. __The `break` statement is the partner to `continue`, but rather than jumping to the beginning of the loop, it jumps to the end and stops looping.__

So that’s our little game. Now I’d be the first to admit(承認) that it is not the most exciting of games. It’s no Quake beater, but even Quake will do similar things. All 3D shooters must keep track of health/armor and ammunition(彈藥), as well as who is still alive. By the end of this book, though, our game objects will be rendered in stunning(令人震驚的) 3D rather than a line of text. The following is the output from `tankgame.py`:

 {{{
a Alice (60 armor, 5 shells)
b Bob (60 armor, 5 shells)
c Carol (60 armor, 5 shells)
Who fires? a
Who at? b

******************************
Alice fires on Bob
Bob is hit!
******************************

a Alice (60 armor, 4 shells)
b Bob (40 armor, 5 shells)
c Carol (60 armor, 5 shells)
Who fires?
 }}}

=== Using the Standard Library ===

Python is packaged with a huge collection of classes and functions known as the ''standard library''. This is why Python is often described as having batteries included, because you can take advantage of code written by Python experts to do everything from trigonometry(三角學) to downloading web pages and sending e-mails. __Libraries are organized into ''modules'', or ''packages'', with each having a specific purpose. '''(按http://docs.python.org/tutorial/modules.html[官方文件]的說法 - Packages are a way of structuring Python’s module namespace by using “dotted module names”. For example, the module name `A.B` designates a submodule named `B` in a package named `A`.)'''__ You make use of these modules by importing them in the same way that the tank game (Listing 2-7) imported the Tank class.

__'''When you import something in Python, it will first look in the ''current directory'' for a corresponding Python file. If it doesn’t find it, Python will look for a module in the standard library.'''__

Let’s go over just a few of the modules in the standard library. We can’t cover them all— that would take a book in itself—but if you need more information on any module, take a look at the docs that came with your Python distribution or browse them online at http://docs.python.org/lib/lib.html.

==== Introducing import ====

There are few ways in which you can import things from your own code, or from the standard library. Which method you use depends on how you want to access the classes and functions contained in the module. Modules can be imported with the `import` keyword, followed by the name of a module. For example, the following line would import a module called `mymodule`:

 {{{
import mymodule
 }}}

__'''Importing a module this way ''creates a new namespace'',''' which means that you will need to type the name of the module and a dot before any of the classes or functions that you use.__ For instance, if there were a function in `mymodule` called `myfunction`, you would call it like this:

 {{{
mymodule.myfunction()
 }}}

__This is the usual way of importing modules from the standard library, because it keeps things in each module separate; if you had another function called `myfunction` in a different module, there would be no confusion as to which function is being called.__

__It is also possible to import specific classes or functions from a module, using the `from` statement. (注意) '''The following line imports `myclass` from `mymodule` to the ''current namespace'': (呼應上面 "as if you had just cut and pasted it into your script" 的說法)'''__

 {{{
from mymodule import myclass
 }}}

__Use this method if you just want a few things from the module and you know that their names won’t conflict with anything else in your script. You can import several classes, functions, and so forth by adding a comma between each one. So `from mymodule import myclass, myfunction` would import two things from the `mymodule` class (應該是 module 才對).__

__You can use a `*` symbol to indicate that you want to import everything from a module into the current namespace.__ For example, the following line would import everything from `mymodule` to the current namespace:

 {{{
from mymodule import *
 }}}

This import method saves on typing, because you don’t need the name of the module to refer to it—but only use this method if the module contains a small number of things and you know the names won’t conflict with other classes or functions in your script. __The `math` module is a good candidate for this kind of import.__

==== Useful Modules for Games ====

The standard library contains a large number of modules, but you will only use a few of them in game. Let’s go over some of the more commonly used modules.

===== Math Module =====

__People are often surprised when I tell them I’m not very good at math. “But you are a computer programmer!” they exclaim. “Exactly,” I tell them. “I get the computer to do the math for me.”__ Basic math is built into Python; you can add, subtract, and multiply without importing a special module. But you do need the `math` module for more advanced functions—the kind of thing you would find on a scientific calculator. See Table 2-5 for a few of them.

Table 2-5. Some Functions in the `math` Module

|| Function || Description || Example ||
|| `sin` || Returns the sine of a number, in radians || `sin(angle)` ||
|| `cos` || Returns the cosine of a number, in radians || `cos(angle)` ||
|| `tan` || Returns the tangent of a number, in radians || `tan(angle)` ||
|| `ceil` || Returns the largest integer greater than or equal to a number || `ceil(3.4323)` ||
|| `fabs` || Returns the absolute value (without the sign) of number || `fabs(-2.65)` ||
|| `floor` || Returns the largest integer less than or equal to a number || `floor(7.234)` ||
|| `pi` || The value of pi || `pi * radius ** 2` ||

Let’s use the `math` module to calculate the area of a circle, given its radius. If you remember from school, the formula for this is pi times the radius squared, where pi is a magic number that equals 3.14 something. Fortunately Python has a better memory for numbers than me, and you can rely on it having a more accurate representation of pi. It’s such a simple function we will use the interactive interpreter:

 {{{
>>> from math import *
>>> def area_of_circle(radius):
...     return pi * radius ** 2
...
>>> area_of_circle(5)
78.539816339744831
 }}}

__Because the `math` module has just a few small functions, we are lazy and import everything to the current module, just to use `pi`.__ We then define a very trivial function that takes the radius and returns the area of the circle. To test it, we calculate the area of a circle with a radius of 5 units, which turns out to be a little over 78.5 units squared.

===== Datetime Module =====

The `datetime` module has a number of functions and classes that deal with date and time. You can use it to query the time of your PC’s internal clock and to calculate time differences between dates. It may sound like a simple task, because we often do mental calculations(心算) about dates, but it can get a little complicated when you think about leap years(閏年) and time zones! Fortunately we can rely on the work of some smart programmers and have Python do this effortlessly. __In the `datetime` module is a class of the same name. (為什麼不以 `DateTime` 為名? 這樣很難分辨 module 與 class[?])__ Let’s use it to find the current time:

 {{{
>>> from datetime import datetime
>>> the_time = datetime.now()
>>> the_time.ctime()
'Thu Dec 28 15:35:26 2006'
 }}}

After importing the `datetime` class from the `datetime` module, we call the function `now` to return a `datetime` object with the current time. __The function `now` is what is called a ''static method'' because you use it on a class rather than an object created with that class. Once we have the current date and time stored in `the_time`, we call the `ctime` method, which returns a friendly representation of the time as a string.__ Obviously it will return a different result when you run it.

So what use is finding the time in a game? Well, you may want to store a ''time stamp'' with saved games and high scores. You could also link the game with the current time of day, so it is bright and sunny at midday but dark and gloomy(陰暗的) if you play it in the evening. Have a look at Table 2-6 for some of the things you can find in the `datetime` module.

Table 2-6. Some Classes in the `datetime` Module

|| Class || Description ||
|| `timedelta` || Stores a difference between two times ||
|| `date` || Stores a date value ||
|| `datetime` || Stores date and time values ||
|| `time` || Stores a time value ||

===== Random Module =====

You won’t be surprised to learn that the `random` module is used to generate random numbers, although __you may be surprised to learn that the numbers it generates aren’t truly random. That’s because computers aren’t actually capable of selecting something at random; they will do the same thing again given identical conditions. '''The numbers that random generates are pseudorandom(偽隨機的), which means they are pulled from a very long sequence of numbers that appear random but will eventually repeat if you generate enough of them. Fortunately you can use them in a game because nobody will notice if they repeat after a few billion times! (實驗確認, 亂數並不會在每次程式開始執行時從頭取用. 因此這並不是什麼大問題, 通常游戲會引入 "人工智慧", 而非盲目地採用亂數值來做回應)'''__

Random (or pseudorandom) numbers are very useful in games to stop them from getting predictable. If a game has no random elements, players will eventually memorize all the sequences of actions, making it less fun (for most people).

Let’s write a short script to simulate ten throws of a standard six-sided die (六面骰子; Listing 2-8).

Listing 2-8. Dice Simulator

 {{{
import random

for roll in xrange(10):
    print random.randint(1, 6)
 }}}

Wow, just three lines. All this does is import the `random` module, then call `random.randint` ten times and prints the results. The function `randint` takes two parameters, `a` and `b`, and returns a pseudorandom number in the range of `a` to `b` (possibly including the end values). So `randint(1, 6)` returns 1, 2, 3, 4, 5, or 6—as a die would.

Note: You may have noticed in Listing 2-8 that the value of `roll` is never actually used inside the loop. The call to `xrange(10)` generates numbers from 0 to 9, but we ignore them because all we are interested in is repeating the loop ten times. __Rather than thinking of a name for a value that is never used, it is common to use a ''single underscore'' in its place. So the loop in Listing 2-8 may be rewritten as `for _ in xrange(10):`.__

Although the numbers that Listing 2-8 produces appear random, they are actually pseudorandom, which means they are chosen from a large mathematically generated sequence. __Occasionally you may need to repeat a sequence of pseudorandom numbers—when playing back a demo, for instance. You can tell the random module to start generating numbers from a particular point in the sequence by calling the `random.seed` function. If you call it twice with the same value, it will cause the random module to reproduce the same sequence of numbers.__ Listing 2-9 demonstrates how the `seed` function can be used to create predictable sequences.

Listing 2-9. A Better Dice Simulator

 {{{
import random

random.seed(100)
for roll in xrange(10):
    print random.randint(1, 6)

print "Re-seeded"

random.seed(100)
for roll in xrange(10):
    print random.randint(1, 6)
 }}}

If you run this small script, you will see the same sequence of numbers, repeated twice. Have a look at Table 2-7 for a few of the capabilities of the `random` module.

Table 2-7. Some Functions in the `random` Module

|| Function || Description ||
|| `seed` || Seeds the random number generator ||
|| `randint` || Returns a random integer between two values ||
|| `choice` || Selects a random element from a collection ||
|| `random` || Return a float between 0 and 1 ||

=== Summary ===

We’ve seen that you can use boolean logic to make decisions in Python code. The `if` statement takes a boolean expression, such as `a > 3`, and runs a code block only if that condition results in `True`. You can append an `if` statement with one or more `else` statements, which run their code block only if the condition is `False`. Logic can be combined using the `and` and `or` operators, and can be reversed using the `not` operator.

Functions are stored Python code, created with the `def` statement. When you define functions, you specify a list of parameters, which is a list of the information that the function needs to run and optionally return a value. A number of built-in functions are available for you to use.

Object-oriented programming is a fancy term for a simple concept. It simply means storing the information needed to describe something together with a number of actions that work with that information. In a game, just about everything will be defined as an object. Python classes are defined with the `class` statement, which you can think of as a template for creating new objects. __Functions created within a `class` statement are called methods, which are similar to other functions with the exception that the very first parameter is the object that the method applies to. The `__init__` function is a special method that is called when an object is first created; you use it to initialize the information, or properties, contained in the object.__

Python has a large standard library that can do a variety of useful things. The library is organized into a number of modules, which can contain classes, functions, or other Python objects.

In the next chapter, we cover how to use the Pygame module to open a window and display graphics.

== Chapter 3. Introducing Pygame ==

Have you ever opened up your computer and had a look inside the case? No need to do it now, but you will find that it is built from a number of parts necessary to deliver your computing experience. The video card generates an image and sends a signal to your monitor. The sound card mixes sound together and sends audio to your speakers. Then there are the input devices, such as the keyboard, mouse, and joystick(s), and a variety of other electronic gizmos(新玩意兒)— all of which are essential in making a game.

In the early days of home computers, programmers with bad haircuts(髮型) and thick-rimmed glasses(粗邊眼鏡) had to come to grips with(掌握) each of the computer’s components. The game programmer had to read the technical manual for each device in order to write the computer code to communicate with it—all before working on the actual game. The situation only got worse when the manufacturers brought out different devices and versions of existing devices with new capabilities. Programmers wanted to support as many devices as possible so there was a bigger market for their games, but they found themselves bogged down(陷入困境) in the details of working with these new graphics and sound cards. It was also a pain for the game-buying public(民眾), who had to carefully check the box to see if they had the right combination of devices to make the game work.

__Things got a little easier with the introduction of graphical operating systems like Microsoft Windows. They gave the game programmer a single way of communicating with the devices. It meant that the programmer could throw away the technical manuals because the manufacturers supplied drivers, small programs that handle the communication between the operating system and the hardware.__

Fast-forward to more recent times, when programmers still have bad haircuts but thinner rims on their glasses. The life of a game programmer is still not an easy one. Even though there is a common way of communicating with graphics, audio, and input, it can still be tricky to write games because of the variety of hardware on the market. The cheap family PC that Mom bought at the local superstore is vastly different from the top-of-the-range machine purchased by a company executive. It’s this variety that makes it such an effort to initialize the hardware and ready it for use in the game. Fortunately, now that Pygame is here we have a way of creating games without having to worry about these details (and game programmers have time to go out and get decent(得體的) haircuts).

In this chapter we will introduce you to Pygame and explain how to use it to create a graphical display and read the state of input devices.

=== History of Pygame ===

__Pygame is built on another game creation library called http://www.libsdl.org/[Simple DirectMedia Layer] (SDL). SDL was written by Sam Lantinga while he was working for Loki Software (a now-defunct(已倒閉的) game company) to simplify the task of porting games from one platform to another.__ It provided a common way to create a display on multiple platforms as well as work with graphics and input devices. Because it was so simple to work with, it became very popular with game developers when it was released in 1998, and has since been used for many hobby(業餘愛好) and commercial games.

__SDL was written in C, a language commonly used for games because of its speed and ability to work with the hardware at a low level. But developing in C, or its successor C++, can be slow and error prone. So programmers produced ''bindings'' to their favorite languages, and SDL can now be used from just about any language out there. One such binding is Pygame, which lets Python programmers use the powerful SDL library.__

Pygame and SDL have been in active development for many years, and because they are both open source, a large number of programmers have worked to refine and enhance this superb(出色的) tool for creating games.

=== Installing Pygame ===

You can download Pygame for your operating system fromhttp://www.pygame.org/. Click the Downloads link and it will take you to a page listing the installers for a variety of systems, including Windows, Linux, and Mac. Many Unix/Linux distribution repositories already include Pygame; on this page you can learn more about these distributions.

Once you have installed an appropriate package, you can test it by opening the Python interpreter and entering the following two lines:

 {{{
>>> import pygame
>>> print pygame.ver
 }}}

If Pygame was installed successfully, then you should see the version displayed:

 {{{
1.7.1release
 }}}

At the time of this writing version 1.7.1 is the most recent, but you may find that a later version is available when this book is released. The example code will still work, since newer versions of Pygame tend to be backward compatible.

=== Using Pygame ===

The Pygame package contains a number of modules that can be used independently. There is a module for each of the devices that you might use in a game, and many others to make game creation a breeze. See Table 3-1 for all the Pygame modules. You access these modules through the `pygame` namespace; for instance, `pygame.display` refers to the `display` module.

Some of the modules you will use in every game. You will always have some sort of display, so the `display` module is essential, and you will definitely need some kind of input, whether it is keyboard, joystick, or mouse. Other modules are less commonly used, but in combination they give you one of the most powerful game creation tools around.

Table 3-1. Modules in the Pygame Package

|| Module Name || Purpose ||
|| `pygame.cdrom` || Accesses and controls CD drives ||
|| `pygame.cursors` || Loads cursor images ||
|| `pygame.display` || Accesses the display ||
|| `pygame.draw` || Draws shapes, lines, and points ||
|| `pygame.event` || Manages external events ||
|| `pygame.font` || Uses system fonts ||
|| `pygame.image` || Loads and saves an image ||
|| `pygame.joystick` || Uses joysticks and similar devices ||
|| `pygame.key` || Reads key presses from the keyboard ||
|| `pygame.mixer` || Loads and plays sounds ||
|| `pygame.mouse` || Manages the mouse ||
|| `pygame.movie` || Plays movie files ||
|| `pygame.music` || Works with music and streaming audio ||
|| `pygame.overlay` || Accesses advanced video overlays ||
|| `pygame` || Contains high-level Pygame functions ||
|| `pygame.rect` || Manages rectangular areas ||
|| `pygame.sndarray` || Manipulates sound data ||
|| `pygame.sprite` || Manages moving images ||
|| `pygame.surface` || Manages images and the screen ||
|| `pygame.surfarray` || Manipulates image pixel data ||
|| `pygame.time` || Manages timing and ''frame rate'' ||
|| `pygame.transform` || Resizes and moves images ||

* For complete documentation on the Pygame modules, seehttp://www.pygame.org/docs/.

Not all of the modules in Table 3-1 are guaranteed to be present on every platform. __It is possible that the hardware the game is running on does not have certain capabilities, or that required drivers are not installed. If this is the case, Pygame will set the module to `None`, which makes it easy to test for.__ The following snippet will detect whether the `pygame.font` module is available and exit if it isn’t:

 {{{
if pygame.font is None: <-- 這是 None 特殊的比對方式嗎? 為何不用 == None[?]
    print "The font module is not available!"
    exit()
 }}}

=== Hello World Revisited ===

As I mentioned in Chapter 1, there is a tradition when learning new languages that the first code you write displays the text “Hello, World!” on the screen. Technically we have already done this with a `print 'Hello, World!'` statement—but it is a little disappointing because as game programmers we are interested in creating appealing visuals and a line of text just does not cut it! We are going to create a Hello World script with Pygame that opens a graphical window on your desktop and draws an image under the standard mouse cursor. When run, you’ll see a window similar to what’s shown in Figure 3-1.

{{attachment:figure_3-1.png}} <<BR>> Figure 3-1. Hello World in Pygame

See Listing 3-1 for the code. Run it now if you like; we will go through it step by step in this chapter.

Listing 3-1. Hello World Redux (`helloworld.py`)

 {{{
#!/usr/bin/env python

background_image_filename = 'sushiplate.jpg'
mouse_image_filename = 'fugu.png'

import pygame
from pygame.locals import *
from sys import exit

pygame.init()

screen = pygame.display.set_mode((640, 480), 0, 32)
pygame.display.set_caption("Hello, World!") <-- 視窗的抬頭

background = pygame.image.load(background_image_filename).convert()
mouse_cursor = pygame.image.load(mouse_image_filename).convert_alpha()

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    screen.blit(background, (0,0)) <-- 擦掉後再重畫

    x, y = pygame.mouse.get_pos()
    x -= mouse_cursor.get_width() / 2
    y -= mouse_cursor.get_height() / 2
    screen.blit(mouse_cursor, (x, y))

    pygame.display.update() <-- 重畫
 }}}

We need two images for Listing 3-1: one to use as a background and another to draw as our mouse cursor. You can download the files for this and the other samples from the http://www.apress.com/book/downloadfile/3765[Source Code/ Download] section at the Apress web site. If you don’t have Internet access at the moment, you can use image files you have on your hard drive, or make them with any graphics- or photoediting software. __Any image is fine for the background, as long as it is at least 640 by 480 in size (any larger and the excess will be clipped). For the mouse cursor, you will need a smaller image that fits comfortably inside the background; a good size is 80 by 80.__ To continue with the fugu theme of the first chapter, the official background will be a picture of bowls and chopsticks, and a picture of a very raw fugu for the mouse cursor. The first two lines set the file names of the images; if you are using different images, you should replace the file names with the location of your images. Let’s break this script into bite-sized chunks. At the top of the script we import the external modules, classes, functions, and so forth we will need when running the example:

 {{{
import pygame
from pygame.locals import *
from sys import exit
 }}}

The first line imports the `pygame` package, which gives us access to all of its ''submodules'', such as `pygame.image` and `pygame.sound`. __The second line imports a number of functions and ''constants'' (values that don’t change; 慣例上會以大寫來命名) into the ''top-level namespace '' (相對而言, current namespace 的說法比較常見). It isn’t essential to do this in order to use Pygame, but it is convenient because we don’t have to precede frequently used values with the `pygame` namespace. ([官方 `pygame.locals` 的http://www.pygame.org/ctypes/pygame-api/pygame.locals-module.html[說明文件]提到 - Set of functions from PyGame that are handy to have in the local namespace for your module. '''這裡的 "local namespace" 等同於這本書所說的 current/top-level namespace''') The last `import` statement imports a single function from `sys` (a module in the standard library). As you may have guessed, the purpose of `exit` is to immediately finish with the script. Calling it will cause the Pygame window to disappear and Python to close. The script will call `exit` when the user clicks the close button; (會產生 `QUIT` 事件) otherwise, the user would have no way of closing the window!__

Tip: If you get into a situation where you can’t close the Pygame window, you may be able to stop Python in its tracks by pressing Ctrl+C. (在 console 下按才有用)

This rather simple line of Python code actually does a lot of work:

 {{{
pygame.init()
 }}}

__It initializes each of the submodules in the `pygame` package, '''which may load drivers and query hardware so that Pygame is ready to use all the devices on your computer.''' You can initialize only the modules you intend to use by calling the `init` function in each submodule individually; for example, `pygame.sound.init()` will initialize the `sound` module. This can make the script start a little quicker because only the modules you actually use will be initialized.__ For games you will require most, if not all, of the modules—so we will stick with this catchall initialize function. After we call it, we have the full power of Pygame at our disposal!

After initializing Pygame we need to create a ''display surface'':

 {{{
screen = pygame.display.set_mode((640, 480), 0, 32) <-- 注意這裡 pygame.display 是一個 module, 乍看之下好像是 property.
pygame.display.set_caption("Hello, World!")
 }}}

__'''The ''display'' could be a window on your desktop or it could be the entire screen, but you always access it via a Pygame `Surface` object. (因此才會有 "display surface" 或 "screen surface" 的說法)''' The call to `pygame.display.set_mode` in our script returns (= create) the `Surface` object representing the window on your desktop. It takes three parameters; only the first is required, which should be a tuple containing the width and height of the display we want to create.__ Our window will be 640 ×480 pixels, which is large enough so we can see what is happening, but not so large that it obscures too much of the desktop. __The next parameter we give to `set_mode` is a value containing flags used in the display creation. '''A flag is a feature that can be switched on or off; you can combine several flags together with the bitwise OR operator (`|`).''' For instance, to create a double-buffered hardware surface, set the `flags` parameter to `DOUBLEBUF | HWSURFACE`.__ See Table 3-2 for the flags you can use. I will cover them in more detail in the “Opening a Display” section later in this chapter. __We won’t be enabling any of these flags for this first Pygame script, so the value we give for `flags` is just 0, which is also the default.__

Table 3-2. Flags for `pygame.display.set_mode`

|| Flag || Purpose ||
|| `FULLSCREEN` || Creates a display that fills the entire screen. ||
|| `DOUBLEBUF` || Creates a “double-buffered” display. Recommended for `HWSURFACE` or `OPENGL`. ||
|| `HWSURFACE` || Creates a hardware-accelerated display (must be combined with the `FULLSCREEN` flag). ||
|| `OPENGL` || Creates an OpenGL renderable display. ||
|| `RESIZABLE` || Creates a resizable display. ||
|| `NOFRAME` || Removes the border and title bar from the display. ||

__The next parameter specifies the depth of the display surface, which is the amount of bits used to store colors in the display.__ A bit, or binary digit, is the most fundamental unit of storage in a computer. Bits have exactly two potential values, 1 or 0, and are arranged in memory as groups of 8. A group of 8 bits is called a byte. Don’t worry if this sounds like techno-babble to you; Python tends to hide this kind of thing from the programmer. We will use the value 32 for our bit depth because it gives us the most colors; see Table 3-3 for other potential bit-depth values. __If you don’t supply a value for the depth or set it to 0, Pygame will use the depth of your desktop.__

Table 3-3. Bit-Depth Values

|| Bit Depth || Number of Colors ||
|| 8 bits || 256 colors, chosen from a larger palette of colors ||
|| 15 bits || 32,768 colors, with a spare(多餘的) bit ||
|| 16 bits || 65,536 colors ||
|| 24 bits || 16.7 million colors ||
|| 32 bits || 16.7 million colors, with a spare 8 bits ||

* It is possible to have other bit depths, but these are the most common.

__Note: Sometimes Pygame is unable to give us the exact display we ask for. It may be that the graphics card doesn’t support the features we are requesting. Fortunately, Pygame will choose a display that is compatible with the hardware and emulates(盡力趕上) the display we actually asked for. Thank you, Pygame!__

If all goes well, the call to `set_mode` will display a Pygame window on your desktop and return a `Surface` object, which is then stored in the variable `screen`. The first thing we do with our newly created surface is call `set_caption` in the `display` module to set the title bar of the Pygame window. We set the title to “Hello, World!”—just to make it a valid Hello World script!

Next up we use the `load` function in `pygame.image` to load the two images for the background and mouse cursor. We pass in the file names of the images stored at the start of the script:

 {{{
background = pygame.image.load(background_image_filename).convert()
mouse_cursor = pygame.image.load(mouse_image_filename).convert_alpha()
 }}}

__The `load` function reads a file from your hard drive and returns a ''surface'' containing the image data. '''These are the same type of objects as our display, but they represent images stored in memory and aren’t visible until we draw them to the ''main display''.''' The first call to `pygame.image.load` reads in the background image and then immediately calls `convert`, which is a ''member function'' for `Surface` objects. '''This function converts the image to the ''same format as our display'', because it is faster to draw images if the display is ''of the same depth''.''' The mouse cursor is loaded in a similar way, but we call `convert_alpha` rather than `convert`. This is because our mouse cursor image contains ''alpha information'', which means that portions of the image could be translucent(半透明的) or completely invisible. Without alpha information in our mouse image, we are limited to an unsightly(難看的) square or rectangle as our mouse cursor! (下面 Converting Surfaces 一節有更詳細的說明)__ The next chapter will cover alpha and image formats in more detail.

The next line in the script jumps straight into the ''main game loop'':

 {{{
while True:
 }}}

This while loop has `True` as the condition, which means it will loop continually until we break out of it, or force it to exit in some other way. __'''All games will have a loop similar to this, which typically repeats once ''per screen refresh (= per frame)''.'''__

__Inside the main game loop we have another loop—the ''event loop'', which most games will also have in one form or another:__

 {{{
for event in pygame.event.get():
    if event.type == QUIT:
        exit()
 }}}

__An ''event'' is how Pygame informs you that something has happened ''outside your code''. Events are created for many things, from key presses to receiving information from the Internet, '''and are ''queued up'' for you until you handle them. The function `get` in the `pygame.event` module returns any events waiting for us, (沒想過事件機制也有 queue 的概念; 這裡的 event loop 在一個週期內將所有的事件都消化掉...)''' which we then loop through in a for loop.__ For this script, we are only interested in the `QUIT` event, which is generated by Pygame when the user clicks the close button in the Pygame window. So if the event type is `QUIT` we call `exit` to shut down, and all other events are ignored. In a game, of course, we would have to handle a greater number of events.

__The next line blits(位塊傳送) the background image to the screen '''(blitting means copying from one image to another - 即 "畫上去" 或 "合成" 的意思)''':__

 {{{
screen.blit(background, (0,0))
 }}}

__按 http://en.wikipedia.org/wiki/Blit[Wikipedia] 的說法 - BLock Image Transfer from http://en.wikipedia.org/wiki/Bit_blit[Bit blit] (Bit Block Transfer, BitBLT, blitting etc.) is '''a computer graphics operation in which two bitmap patterns are combined.'''__

This line uses the `blit` member function of the `screen` `Surface` object, which takes a source image—in this case, our 640 ×480 background—and a tuple containing the destination position. The background will never move; we just want it to cover the entire Pygame window, so we blit to the coordinate `(0, 0)`, which is the top left of the screen.

Tip: It is important that you blit to every portion of the screen. If you don’t, strange visual effects may occur when you animate things, and your game may look different on each computer it is run on. Try commenting out the call to `screen.blit` to see what happens.

After we draw the background, we want to draw `mouse_cursor` underneath the usual mouse pointer:

 {{{
x, y = pygame.mouse.get_pos()
x -= mouse_cursor.get_width()/2
y -= mouse_cursor.get_height()/2
screen.blit(mouse_cursor, (x, y))
 }}}

Getting the position of the mouse is nice and simple; the `pygame.mouse` module contains all we need to work with the mouse, including `get_pos`, which returns a tuple containing the mouse coordinates. The first line unpacks this tuple into two values for convenience: `x` and `y`. __We could use these two values as coordinates when we blit the mouse cursor, but that would place the top-left corner of the image under the mouse, and we want the center of the image to be under the mouse.__ So we do a little math (fear not!) to adjust `x` and `y` so that the mouse image is moved up by half its height and left by half its width. Using these coordinates places the center of the image right under the mouse pointer, which looks better. At least it does for an image of a fish—__if you want to use a more typical pointer image, adjust the coordinates so that the ''tip'' lies underneath the real mouse coordinates.__

Blitting the mouse image is done in the same way as blitting the background, but we use the coordinates we calculated rather than `(0, 0)`. This is enough to create the effect we are looking for, but there is one more thing we have to do before we can see anything:

 {{{
pygame.display.update()
 }}}

__When you build an image through blits to the screen surface, you won’t see them right away. '''This is because Pygame first builds up an image to a ''back buffer'', which is an invisible display in memory, before it is displayed. If we didn’t have this step, the user would see ''individual blits'' as they happen, which would flicker(閃爍) most unpleasantly(不愉快地). For games programmers, flicker is the enemy!''' We want to see silky-smooth(柔順的), convincing(有說服力的) animation. Fortunately a call to `pygame.display.update()` is all we need to ensure that the image we have created in memory is shown to the user without flicker.__

When you run this script, you should see something like Figure 3-1. If you are using the “official” images, then an odd-looking fish will dutifully(恭順地) follow the mouse cursor.

=== Understanding Events ===

In Hello World we only handled the `QUIT` event, which is essential unless you want to have immortal(不死的) Pygame windows! Pygame creates other events to inform you of things such as mouse movement and key presses.

Events can be generated at any time, no matter what your program is currently doing. For example, your code could be drawing a tank on the screen when the user presses the fire button on the joypad. __'''Because you can’t react to events the instant they happen, Pygame stores them in a queue until you are ready to handle them''' (typically at the beginning of the main game loop). You can think of the ''event queue'' as a line of people waiting to get into a building, each carrying specific information about an event.__ When the player presses the fire button, the joystick event arrives, carrying information about which key was pressed. Similarly, when the player releases the fire button, a clone of the same joystick event arrives with information about the button that was released. They could be followed by a mouse event and key event.

==== Retrieving Events ====

__In the earlier example, we called `pygame.event.get()` to retrieve all the events and remove them from the queue, which is like opening the door and letting everyone in. This is probably the best way to deal with events, as it ensures we have handled everything before we go on to draw something to the screen—but there are other ways to work with the event queue. If you call `pygame.event.wait()`, Pygame will wait for an event to occur before it returns, which is like waiting by the door until someone arrives. This function isn’t often used for games because it suspends the script until something happens (下面 Listing 3-2 有用到這個方法), but it can be useful for Pygame applications that cooperate more with other programs on your system, such as media players. An alternative is `pygame.event.poll()` (輪詢), which returns a single event if there is one waiting, or a ''dummy event'' of type `NOEVENT` if there are no events in the queue. '''Whatever method you use, it is important to not allow them to build up(堵塞), because the event queue is limited in size and events will be lost if the queue overflows.'''__

__It is necessary to call at least one of the event-handling functions at regular intervals so that Pygame can process events internally. If you don’t use any of the event-handling functions, you can call `pygame.event.pump()` (抽水; 把 event queue 裡的 events 全部泄掉的意思[?]) in place of an event loop.__

__Event objects contain a few member variables that describe the event that occurred. The information they contain varies depending on the event. The only thing common to all event objects is `type`, which is a value that indicates the type of the event. It is this value that you first query so you can decide what to do with it.__ Table 3-4 lists the standard events that you may receive; we will go over a few of them in this chapter.

Table 3-4. Standard Events

|| Event || Purpose || Parameters ||
|| `QUIT` || User has clicked the close button. || none ||
|| `ACTIVEEVENT` || Pygame has been activated or hidden. || `gain, state` ||
|| `KEYDOWN` || Key has been pressed. || `unicode, key, mod` ||
|| `KEYUP` || Key has been released. || `key, mod` ||
|| `MOUSEMOTION` || Mouse has been moved. || `pos, rel, buttons` ||
|| `MOUSEBUTTONDOWN` || Mouse button was pressed. || `pos, button` ||
|| `MOUSEBUTTONUP` || Mouse button was released. || `pos, button` ||
|| `JOYAXISMOTION` || Joystick or pad was moved. || `joy, axis, value` ||
|| `JOYBALLMOTION` || Joy ball was moved. || `joy, ball, rel` ||
|| `JOYHATMOTION` || Joystick hat was moved. || `joy, hat, value` ||
|| `JOYBUTTONDOWN` || Joystick or pad button was pressed. || `joy, button` ||
|| `JOYBUTTONUP` || Joystick or pad button was released. || `joy, button` ||
|| `VIDEORESIZE` || Pygame window was resized. || `size, w, h` ||
|| `VIDEOEXPOSE` || Part or all of the Pygame window was exposed. || none ||
|| `USEREVENT` || A user event has occurred. || `code` ||

Let’s write a simple Pygame script to display all the events that are generated. Listing 3-2 uses `pygame.event.wait()` to wait for a single event. As soon as it gets one, it turns it into a string with `str` and adds it to a list. The rest of the code displays the new event along with as many previous events as it can fit on the screen. It uses the `font` module to display text (which we will discuss later).

Tip: If you change the fill color in Listing 3-2 to `(0,0,0)` and the color of the font to `(0, 255, 0)`, it will look a little like Matrix-style code. You may have to use your imagination a little!

Listing 3-2. Displaying the Message Queue (`events.py`)

 {{{
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
SCREEN_SIZE = (800, 600)
screen = pygame.display.set_mode(SCREEN_SIZE, 0, 32)

font = pygame.font.SysFont("arial", 16);
font_height = font.get_linesize()
event_text = []

while True:

    event = pygame.event.wait() <-- 一次只消化一個
    event_text.append(str(event))
    event_text = event_text[-SCREEN_SIZE[1] / font_height:] <-- 這正是 slide 的用法, 只顯示後面放得進一個畫面的那幾筆...

    if event.type == QUIT:
        exit()

    screen.fill((255, 255, 255)) <-- 全部擦掉後再重畫

    y = SCREEN_SIZE[1] - font_height <-- 由下往上畫
    for text in reversed(event_text): <-- 最新的事件會出現在下方
        screen.blit(font.render(text, True, (0, 0, 0)), (0, y))
        y -= font_height

    pygame.display.update()
 }}}

If you run Listing 3-2, you will see a simple white window. Move the mouse over it and it will start to stream `MOUSEMOTION` events, which are created whenever the mouse changes position (see Figure 3-2). These events specify the current position of the mouse, how far the mouse has moved since the last motion event, and which buttons are currently pressed. __You can get the current position of the mouse with the `pygame.mouse` module, as we did in the Hello World example, '''but you risk losing information about what the player has been doing. This is a particular problem on desktop computers that do a lot of work in the background, and may occasionally pause your game for a brief amount of time. (Hello World 程式用 `pygame.mouse.get_pos()` 取得 "當下" 的位置, 因此漏失了中間的許多細節. 在電腦忙不過來時, 等到有時間處理 "當下" 的位置時, 可能與使用者最後的決定產生了很大的落差[...])''' For a mouse cursor, you only need to know where the mouse is at the beginning of every ''frame'', so it is reasonable to use `pygame.mouse.get_pos()`. If you were using mouse movement to drive a tank and the buttons to fire, it would be better to work with events so that the game can ''more closely monitor'' what the player has been doing.__

{{attachment:figure_3-2.png}} <<BR>> Figure 3-2. Output from the events script

==== Handling Mouse Motion Events ====

As you have seen, `MOUSEMOTION` events are issued whenever you move the mouse over the Pygame window. They contain these three values:

 * `buttons`—__A tuple of three numbers that correspond to the buttons on the mouse. So `buttons[0]` is the left mouse button, `buttons[1]` is the middle button, and `buttons[2]` is the right button. If the button is pressed, then its value is set to 1; if it is not pressed, the value will be 0. Multiple buttons can be pressed at once.__

 * `pos`—A tuple containing the position of the mouse when the event was generated.

 * `rel`—A tuple containing the distance the mouse has moved since the last mouse motion event (sometimes called the ''mouse mickies''; 為什麼距離是用 tuple 來表示, 單位又是什麼[?]).

==== Handling Mouse Button Events ====

In addition to motion events, the mouse generates `MOUSEBUTTONDOWN` and `MOUSEBUTTONUP` events. If you click the mouse on the message queue script, you will first see the down event, followed by an up event when you take your finger off the button. So why have the two events? __If you are using the mouse button as a trigger to fire a rocket, you would only need one of the events, but you may have a different type of weapon, such as a chain gun(機關槍) that fires continuously while the button is held down. In this case you would start the chain gun speeding up on the down event and have it fire until you get the corresponding up event.__ Both types of mouse button events contain the following two values:

 * `button`—__The number of the button that was pressed. A value of 1 indicates that the left mouse button was pressed, 2 indicates that the middle button was pressed, and 3 indicates the right button was pressed.__

 * `pos`—A tuple containing the position of the mouse when the event was generated.

==== Handling Keyboard Events ====

The keyboard and joystick have similar up and down events; `KEYDOWN` is issued when a key is pressed, and `KEYUP` is issued when the key is released. Listing 3-3 demonstrates how you might respond to `KEYUP` and `KEYDOWN` events to move something on screen with the cursor keys. If you run this listing, you will see a window containing a simple background image. Press up, down, left, or right and the background will slide in that direction. (移動很平順!!) Take your finger off the cursor key and the background will stop moving.

Listing 3-3. Using Keyboard Events to Move a Background (下載的 source 裡沒有這支程式)

 {{{
background_image_filename = 'sushiplate.jpg'

import pygame
from pygame.locals import *
from sys import exit

pygame.init()

screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image_filename).convert()

x, y = 0, 0
move_x, move_y = 0, 0

while True:

    for event in pygame.event.get():

        if event.type == QUIT:
            exit()
        if event.type == KEYDOWN:
            if event.key == K_LEFT:
                move_x = -1
            elif event.key == K_RIGHT:
                move_x = +1
            elif event.key == K_UP:
                move_y = -1
            elif event.key == K_DOWN:
                move_y = +1
        elif event.type == KEYUP:
            if event.key == K_LEFT:
                move_x = 0
            elif event.key == K_RIGHT:
                move_x = 0
            elif event.key == K_UP:
                move_y = 0
            elif event.key == K_DOWN:
                move_y = 0

    x+= move_x
    y+= move_y

    screen.fill((0, 0, 0))
    screen.blit(background, (x, y))

    pygame.display.update()
 }}}

Listing 3-3 begins just like Hello World; it imports and initializes Pygame, then loads a background image. The event loop in this script is different, because it handles `KEYDOWN` and `KEYUP`. These key events both contain the same three values:

 * `key`—__This is a number representing the key that was pressed or released. Each ''physical key'' on the keyboard has a constant that begins with `K_`.__ The alphabet keys are `K_a` through `K_z`, but there are also constants for all the other keys, such as `K_SPACE` and `K_RETURN`. For a complete list of the key constants you can use, see http://www.pygame.org/docs/ref/key.html.

 * `mod`—__This value represents keys that are used in combination with other keys, such as Shift, Alt, and Ctrl. Each of these modifier keys are represented by a constant that begins with `KMOD_`, such as `KMOD_SHIFT`, `KMOD_ALT`, and `KMOD_CTRL`. '''Check for these values by using the bitwise AND operator (`&`). For example, `mod & KMOD_CTRL` will evaluate to `True` if the Ctrl key is pressed. (原來 bitwise operators 也可以得到布林值!!)'''__ http://www.pygame.org/docs/ref/key.html provides a full list of the modifier keys.

 * `unicode`—__This is the Unicode value of the key that was pressed. It is produced by combining the pressed key with any of the modifier keys that was pressed. There is a Unicode value for every symbol in the English alphabet and other languages. '''You won’t often use this value in a game because keys tend to be used more like switches than for entering text.''' An exception would be for entering a high score table, where you would want the player to be able to type non-English letters as well as mix upper- and lowercase.__
 
Inside the handler for `KEYDOWN` we check for the four key constants that correspond to the cursor keys. If `K_LEFT` is pressed, then the value of `move_x` is set to -1; if `K_RIGHT` is pressed, it is set to +1. This value is later added to the `x` coordinate of the background in order to move it left or right. There is also a `move_y` value, which is set if `K_UP` or `K_DOWN` is pressed, which will move the background vertically.

__We also handle the `KEYUP` event, because we want the background to stop moving when the user releases the cursor key. '''(要注意 `KEYDOWN` 事件只會在按下按鈕後被觸發一次, 按住按鈕並不會造成多個 `KEYDOWN` 事件)'''__ The code inside the handler for `KEYUP` events is similar to the down event, but it sets `move_x` or `move_y` back to zero to stop the background from moving.

After the event loop, all we have to do is add the values `move_x` and `move_y` to x and y, then draw the background at `(x, y)`. The only thing you haven’t seen before is `screen.fill((0, 0, 0))`, which is used to clear the display to black (colors are explained in Chapter 4). __This line is necessary because if we move the background image it no longer covers the whole display— which I guess would technically mean it is no longer a background!__

==== Filtering Events ====

__Not all events need to be handled in every game, and there are often alternative ways of getting the information that events might give you. For example, if you are using `pygame.mouse.get_pos()` you will not need to respond to the `MOUSEMOTION` event.__

Occasionally you also need to suspend the handling of certain events. __If you were to play a http://en.wikipedia.org/wiki/Cutscene[cut scene] movie between levels, you would probably want to ignore input events until it is finished.__ The Pygame event module has a number of functions to help you just do that.

You can block events from the event queue with the `set_block` function. For example, the following line will disable mouse movement:

 {{{
pygame.event.set_blocked(MOUSEMOTION)
 }}}

If you pass in a list of event types, all those events will be blocked. For example, the following line will disable all keyboard input by blocking both `KEYDOWN` and `KEYUP` events:

 {{{
pygame.event.set_blocked([KEYDOWN, KEYUP])
 }}}

If you want to unblock all events, pass the value of `None` to `set_blocked`. This line will allow all events to occur in the event queue:

 {{{
pygame.event.set_blocked(None)
 }}}

The opposite of `set_blocked` is `set_allowed`, which selects the events that should be allowed (unblocked). It also takes a single event type, or a list of event types. But if you pass in the value of `None`, it effectively blocks all events. __You can ask Pygame if an event is currently blocked with `pygame.event.get_block` (取做 `is_block` 會更好), which takes a single event type.__

==== Posting Events ====

Generally it is Pygame that creates all the events for you, but you can create your own. You could use this ability to play back demos (by replicating the player’s input), or simulate the effects of a cat walking across the keyboard (I like to make my games cat proof).

__To send an event, you first construct an event object with `pygame.event.Event` and then ''post'' it with `pygame.event.post`. The event will be placed on the end of the queue, ready for retrieval in the event loop.__ Here’s how to simulate the player pressing the spacebar:

 {{{
my_event = pygame.event.Event(KEYDOWN, key = K_SPACE, mod = 0, unicode = u' ')
pgame.event.post(my_event)
 }}}

The `Event` constructor takes the type of the event, such as one of the events in Table 3-4, followed by the values the event should contain. Since we are simulating the `KEYDOWN` event, we need to supply all the values that the event handler would expect to be there. __If you prefer, you can supply these values as a dictionary. (參數的彈性也太大了吧?)__ This line will create the same event object:

 {{{
my_event = pygame.event.Event(KEYDOWN, {"key": K_SPACE, "mod": 0, "unicode": u' '})
 }}}

__In addition to simulating Pygame-generated events, you can create completely new events. All you have to do is use a value for the event that is above `USEREVENT`, which is the maximum value that Pygame will use for its own event IDs.__ This can sometimes be useful if you want to do something in the event loop before you go on to draw to the screen. Here’s an example of a user event to respond to a cat walking over the keyboard:

 {{{
CATONKEYBOARD = USEREVENT + 1
my_event = pygame.event.Event(CATONKEYBOARD, message = "Bad cat!") <-- 輕鬆延伸 Event 的屬性!!
pgame.event.post(my_event)
 }}}

Handling user events is done in the same way as the usual events that Pygame generates— just check the event type to see if it matches your custom event. Here’s how you might handle a `CATONKEYBOARD` event:

 {{{
for event in pygame.event.get():
    if event.type == CATONKEYBOARD:
        print event.message
 }}}

=== Opening a Display ===

I deliberately glossed over(粉飾) opening a display in the Hello World example because we only needed a simple display, but Pygame has a variety of options for displays. The type of display you create depends on the game. __It is generally easier to used fixed resolution (display size) because it can simplify your code. Your decision also depends on how much action you will have in the game—the more things you have moving on screen at one time, the slower the game will run. You may have to compensate(補償) by selecting a lower resolution (which will speed things up again).__

__The best solution is usually to let the player decide what resolution they want to run in so that they can adjust the display until they have a good compromise(妥協) between visual quality and how smoothly the game runs. If you go this route, you will have to make sure that your game looks OK in all potential resolutions!__

Don’t worry about this until it comes time to write your game. Just select a resolution that works for you while you are experimenting with Pygame scripts, but feel free to experiment a little.

==== Full-Screen Displays ====

In Hello World we used the following line to create a Pygame window:

 {{{
screen = pygame.display.set_mode((640, 480), 0, 32)
 }}}

The first parameter is the size of the window we want to create. A size of `(640, 480)` creates a small window that will fit comfortably on most desktops, but you can select a different size if you wish. __Running in a window is great for debugging, but most games fill the entire screen with the action and don’t have the usual borders and title bar. '''Full-screen mode is usually faster because your Pygame script doesn’t have to cooperate with other windows on your desktop. (全螢幕跟解析度的設定無關)'''__ To set full-screen mode, use the `FULLSCREEN` flag for the second parameter of `set_mode`:

 {{{
screen = pygame.display.set_mode((640, 480), FULLSCREEN, 32)
 }}}

__Caution: If something goes wrong with your script in full-screen mode, it can sometimes be difficult to get back to your desktop. '''Therefore, it’s best to test it in windowed mode first. (例如先測試在過程中按下某個鍵就可以結束程式...)''' You should also provide an alternative way to exit the script because the close button is not visible in full-screen mode.__

__When you go full screen, your video card will probably switch to a different video mode, which will change the width and height of the display, and potentially how many colors it can show at one time. Video cards only support a few combinations of size and number of colors, but Pygame will help you if you try to select a video mode that the card does not support directly. '''If the size of display you ask for isn’t supported, Pygame will select the next size up and copy your display to the center of it, which may lead to black borders at the top and bottom of your display.''' To avoid these borders, select one of the standard resolutions that virtually all video cards support: (640, 480), (800, 600), or (1024, 768). To see exactly what resolutions your display supports, you can use `pygame.display.list_modes()`, which returns a list of tuples containing supported resolutions.__ Let’s try this from the interactive interpreter:

 {{{
>>> import pygame
>>> pygame.init()
>>> pygame.display.list_modes()
[(800, 600), (1280, 1024), (1280, 960), (1280, 800), (1280, 768), (1280, 720), (1152, 864), (1088, 612), (1024, 768), (960, 600), (848, 480), (800, 600), (720, 576), (720, 480), (640, 480), (640, 400), (512, 384), (480, 360), (400, 300), (320, 240), (320, 200), (640, 480)]
 }}}

__If the video card can’t give you the number of colors you asked for, Pygame will convert colors in the display surface automatically to fit (which may result in a slight drop in image quality).__

Listing 3-4 is a short script that demonstrates going from windowed mode to full-screen mode. If you press the F key, the display will fill the entire screen (there may be a delay of a few seconds while this happens). Press F a second time, and the display will return to a window.

Listing 3-4. Full-Screen Example (`fullscreentest.py`)

 {{{
background_image_filename = 'sushiplate.jpg'

import pygame
from pygame.locals import *
from sys import exit

pygame.init()

screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image_filename).convert()

Fullscreen = False

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    if event.type == KEYDOWN:
        if event.key == K_f:
            Fullscreen = not Fullscreen
            if Fullscreen:
                screen = pygame.display.set_mode((640, 480), FULLSCREEN, 32)
            else:
                screen = pygame.display.set_mode((640, 480), 0, 32)

    screen.blit(background, (0,0))
    pygame.display.update()
 }}}

==== Resizable Pygame Windows ====

Occasionally you may want the user to be able to resize a Pygame window, which you typically do by clicking on the corner of the window and dragging with the mouse. __It’s easy enough to do this by using the `RESIZABLE` flag when you call `set_mode`. Pygame informs your code if the user has changed the window size by sending a `VIDEORESIZE` event that contains the new width and height of the window. When you get one of these events, you should call `pygame.display.set_mode` again to set the display to the new dimensions.__ Listing 3-5 demonstrates how to respond to `VIDEORESIZE` events.

Listing 3-5. Using a Resizable Window (`resize.py`)

 {{{
background_image_filename = 'sushiplate.jpg'

import pygame
from pygame.locals import *
from sys import exit

SCREEN_SIZE = (640, 480)

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)

background = pygame.image.load(background_image_filename).convert()

while True:

    event = pygame.event.wait()
    if event.type == QUIT:
        exit()

    if event.type == VIDEORESIZE:
        SCREEN_SIZE = event.size
        screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)
        pygame.display.set_caption("Window resized to " + str(event.size))

    screen_width, screen_height = SCREEN_SIZE
    for y in range(0, screen_height, background.get_height()): <-- 第三個參數做為 step
        for x in range(0, screen_width, background.get_width()):
            screen.blit(background, (x, y))

    pygame.display.update()
 }}}

When you run this script, it will display a simple Pygame window with a background image. If you click on the corner or edge of the window and drag with the mouse, the script will get a `VIDEORESIZE` event. __In the handler to that message is another call to `set_mode`, '''which creates a new screen surface that matches the new dimensions. (重新取得一個新的 Surface 物件, 但並不會開另一個視窗)'''__ The resize message contains the following values:

 * `size`—This is a tuple containing the new dimensions of the window; `size[0]` is the width and `size[1]` is the height.
 * `w`—This value contains the new width of the window. It is the same value as `size[0]`, but may be more convenient.
 * `h`—This value contains the new height of the window. It is the same value as `size[1]`, but may be more convenient.

__Because the display size can vary with this script, we draw the background slightly differently by blitting the background image as many times as necessary to cover the display.__ The two calls to `range` produce the coordinates needed to place these multiple background images.

Most games run in full screen so resizable displays are perhaps not a feature you will use very often. But it is there in your toolbox if you need it!

==== Windows with No Borders ====

Generally when you create a Pygame window you will want a standard window with title bars and border. It is possible, though, to create a window that doesn’t have these features so that the user will not be able to move or resize the window, or close it via the close button. __One instance of such a use is the window used for ''splash screens''. Some games can take a while to load because they contain many image and sound files. If there is nothing visible on the screen while this is happening, the player may feel that the game is not working and try to launch it again.__ To set a display with no borders, use the `NOFRAME` flag when calling `set_mode`. For example, the following line will create a “naked” window: (不過 taskbar 上還是會有對應的項目)

 {{{
screen = pygame.display.set_mode(SCREEN_SIZE, NOFRAME, 32)
 }}}

==== Additional Display Flags ====

There are a few more flags you can use in a call to `set_mode`. __I consider them advanced, because they can hurt performance if used incorrectly or cause compatibility problems on some platforms. It is usually best to use the value 0 for windowed displays and `FULLSCREEN` for full-screen displays to ensure your game will work well on all platforms.__ That said, if you know what you are doing you can set a few advanced flags for extra performance. There is also no harm in experimenting (it won’t hurt your computer).

__If you set the `HWSURFACE` flag, it will create what is called a ''hardware surface''. This is a special kind of display surface that is stored in the memory of your graphics card. It can only be used in combination with the `FULLSCREEN` flag, like this:__

 {{{
screen = pygame.display.set_mode(SCREEN_SIZE, HWSURFACE | FULLSCREEN, 32)
 }}}

__Hardware surfaces can be faster than surfaces created in system (regular) memory, because they can take advantage of more features of your graphics card to speed up blitting. The disadvantage of hardware surfaces is that they are not that well supported on all platforms. (如果遇到不支援的狀況會怎樣[?]) They tend to work on Windows platforms but not so well on others. Hardware surfaces will also benefit from the `DOUBLEBUF` flag. This effectively creates two hardware surfaces, but only one is visible at any one time. The following line will create a ''double-buffered'' hardware surface:__

 {{{
screen = pygame.display.set_mode(SCREEN_SIZE, DOUBLEBUF | HWSURFACE | FULLSCREEN, 32)
 }}}

__Normally '''when you call `pygame.display.update()` an entire screen is copied from memory to the display'''—which takes a little time. Double-buffered surfaces allow you to switch to the new screen instantly and thus makes your game run a little faster.__

__The last display flag you can use is `OPENGL`. OpenGL (www.opengl.org/) is a graphics library that uses the 3D graphics accelerator found on just about every graphics card. '''The downside of using this flag is that you will no longer be able to use Pygame’s 2D graphics functions.'''__ We will cover using OpenGL to create 3D in Chapter 9.

__Note: If you use a double-buffered display, you should call `pygame.display.flip()` rather than `pygame.display.update()`. This does the instant display switch rather than copying screen data. (很直覺的設計!!)__

=== Using the Font Module ===

I promised to cover the `font` module that we used in the event queue script. The ability to draw text on the screen can really help with testing scripts; you may also need it to display game instructions, menu options, and so forth. __The `font` module uses http://en.wikipedia.org/wiki/TrueType[TrueType fonts] (TTFs), which are used on most systems to render high-quality, smooth text. There will be many such fonts installed on your computer that can be used by the `font` module.__

To use a font, you must first create a `Font` object. __The easiest way to do this is with `pygame.font.SysFont`, which uses one of the fonts you have installed on your computer.__ The following line creates a `Font` object for the Arial font (a common font that is easy to read):

 {{{
my_font = pygame.font.SysFont("arial", 16)
 }}}

The first parameter is the name of font you want to create, and the next parameter specifies the font size ''in pixels''. Pygame will look for a font with the name “arial” in your installed fonts; if it doesn’t find it, a default font will be returned. __You can get a list of the fonts installed on your system by calling `pygame.font.get_fonts()`. Fonts can also be created directly from `.ttf` files by calling `pygame.font.Font`, which takes a file name.__ The following line loads the file `my_font.ttf` and returns a `Font` object:

 {{{
my_font = pygame.font.Font("my_font.ttf", 16)
 }}}

Once you have created a `Font` object, you can use it to render text to a new surface. __To render text, use the `render` member function of `Font` objects. '''It creates a new surface containing the text, which you can then blit to the display.'''__ The following line renders a piece of text and returns a new surface:

 {{{
text_surface = my_font.render("Pygame is cool!", True, (0,0,0), (255, 255, 255))
 }}}

__The first parameter of render is the text you want to render. It has to be a ''single line''; '''if you want multiple lines, you will have to break the string and use multiple render calls.''' The second parameter is a boolean (`True` or `False`), used to enable antialiased text. If it is set to `True`, the text will have a modern, smooth look; otherwise, it will appear more pixelated. The next two parameters of render are the text color, followed by the background color. The background is optional, if you leave it out (or set it to `None`), the background will be transparent.__

To finish this introduction to the `font` module, let’s write a small script to render my name to a surface and save it as an image. Feel free to change the name that is drawn to your own. If you modify the first line of Listing 3-6, it will do just that.

Listing 3-6. Writing Your Name to an Image File

 {{{
# -*- coding: utf-8 -*- <-- 不知道為什麼加上 utf-8 宣告後, 輸出中文還是有問題? 應該是字型的問題吧[?]
my_name = "Will McGugan"
import pygame
pygame.init()
my_font = pygame.font.SysFont("arial", 64)
name_surface = my_font.render(my_name, True, (0, 0, 0), (255, 255, 255))
pygame.image.save(name_surface, "name.png") <-- 寫出檔案就是這麼簡單!!
 }}}

__This script is so simple that we don’t even need to create a display!__ When you run Listing 3-6, you won’t see much happen on the screen, but the code will have created an image file called `name.png` in the same location as the script. You can open the file with any image viewer software. Saving the surface to a file is done with the `pygame.image` module, which we will cover in the next chapter.

The `font` module provides other functions as well as `Font` objects, which you may occasionally need to use. They are mostly informational, designed to retrieve various pieces of information regarding the fonts. __There are functions that will ''simulate'' bold and italic text, but it is better to use a dedicated bold or italic font.__ For complete details on the `font` module, see the documentation athttp://www.pygame.org/docs/ref/font.html.

Caution: Installed fonts vary from computer to computer, and you cannot always rely on a particular font being present. __If Pygame doesn’t find the font you are asking for, it will use a default font that may not look the same. '''The solution is to distribute the `.ttf` files with your game, but make sure you have permission from the font author to do this!''' For a free-to-distribute font, you could use something from the BitStream Vera family (http://en.wikipedia.org/wiki/Bitstream_Vera).__

=== When Pygame Goes Wrong ===

Sometimes even with Pygame’s best efforts it will be unable to give you what you ask for. For example, if you have run out of memory you will not be able to load any more images and `pygame.image.load` will have no space to read an image to. In this case, Pygame will throw a `pygame.error` exception. Other situations will also produce errors. Here’s what happens if you try to set a display mode with a height of 0 pixels:

 {{{
>>> import pygame
>>> screen = pygame.display.set_mode((640, 0))
Traceback (most recent call last):
File "<interactive input>", line 1, in ?
pygame.error: Cannot set 0 sized display mode
 }}}

__Generally speaking, there is not a great deal you can do when you get `pygame.error` exceptions '''that aren’t programming errors. (這就是 Java 所謂 checked exception!! 不過在 Python 裡並不會被要求一定要做處理...)'''__ If you can’t set the desired video mode, the game simply can’t run. Similarly, if you can only load half the image you will not be able to properly display the visuals in the game. __Often the best you can do is apologize to the player and perhaps direct them somewhere for help.__

I have omitted catching Pygame exceptions in the samples to simplify the code a little, but if you ever produce a game that you would like to distribute, it is good practice to check for errors. The following snippet will display a message and exit if `set_mode` throws an exception:

 {{{
try:
    screen = pygame.display.set_mode(SCREEN_SIZE)
except pygame.error, e:
    print "Can't create the display :-("
    print e
    exit()
 }}}

If you have chosen sensible values for the display, you are unlikely to get these exceptions. A more likely place they will occur is when reading images. If you try to load an image that you don’t have on your hard drive, or there is a typo in the file name, you will also get a `pygame.error` exception. __It is good practice to catch all exceptions that could potentially occur when your game is distributed. Nobody likes games or applications that fail unexpectedly without any information! '''Some exceptions indicate a bug (programmer error) in the code. It is reasonable to leave these uncaught, so that you can find problems'''—and hopefully fix them before the game is released.__

=== Pygame in Action ===

Back when I was a youngling, the “scrolly message” was a very popular effect among hobbyist(業餘愛好者) graphics programmers. A scrolly message, or marquee as it is now known, is simply text sliding across the screen from right to left. Listing 3-7 is a Pygame implementation of a scrolly message. __It’s not without its faults, the most major of which is that it will move at an inconsistent speed, and may be faster or slower on different computers. (可以用計時器來做控制)__ This is a problem that you will learn how to solve in the next chapter.

Most of this script should be familiar by now, so I won’t break it down. Try tweaking the code to produce different results. You may also want to insert text of your own choice, which you can do by modifying the message string at the start of the script.

Listing 3-7. Scrolly Message Script (`scrolly.py`)

 {{{
background_image_filename = 'sushiplate.jpg'
SCREEN_SIZE = (640, 480)
message=" This is a demonstration of the scrolly message script. "

import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE)

font = pygame.font.SysFont("arial", 80);
text_surface = font.render(message, True, (0, 0, 255))

x = 0
y = (SCREEN_SIZE[1] - text_surface.get_height()) / 2 <-- 文字產生之後, 就只是在不同的地方貼上而已

background = pygame.image.load(background_image_filename).convert()

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    screen.blit(background, (0,0))

    x-= 2
    if x < -text_surface.get_width():
        x = 0

    screen.blit(text_surface, (x, y))
    screen.blit(text_surface, (x+text_surface.get_width(), y)) <-- 接連貼兩張圖, 避免漏餡
    pygame.display.update()
 }}}

=== Summary ===

Pygame is a powerful platform for building games. It consists of many submodules for a variety of game-related tasks. Pygame works equally well on a large number of platforms. __Ports are available for all the major desktop systems and even some ''consoles''—so you can develop a game on your favorite platform and play it on another.__

We’ve produced a Hello World script that demonstrates the basics of starting Pygame, creating a display, receiving events, and then drawing to the screen—steps that you will use when creating more sophisticated games and demos. If you have done any game programming in C or C++, you will appreciate the simplicity of the code, especially the one-liner to create a display.

We explored the flags you can use when creating a display, which can improve performance or add capabilities. It is probably best to leave most of these flags disabled, at least until you are more familiar with Pygame and computer graphics in general. __You should find that the default settings still give you excellent performance.__

You also learned how to manage the event queue to handle the various events that Pygame can send you, and you even learned how to create custom events. Listing 2-3 lets you see exactly what events are generated and the information they contain. You will find this listing to be a handy tool when you experiment with your own script.

This chapter covered all the boilerplate(模板) code you need to get up and running with Pygame. The next chapter examines graphics, movement, and animation.

== Chapter 4. Creating Visuals ==

Computer games tend to be very visual in nature, and game developers will spend a lot of time working on manipulating graphics and refining the visuals to create the most entertaining experience for the player. This chapter will give you a strong foundation in generating visuals for computer games.

=== Using Pixel Power ===

If you peer closely at your computer screen, you should be able to make out(看出) that it is composed of rows and columns of colored dots. These dots are packed so tightly together that when you view the screen at a comfortable distance they merge to form a single image. An individual dot in the display is called a picture element, or ''pixel''. Because computer games are primarily visual in nature, pixels are very much the tools of the trade for game programmers.

I recently treated myself to a brand-new LCD monitor that has a resolution of 1280 ×1024, which means there are 1,280 pixels along the width of the screen and 1,024 pixels along the height of the screen. You can find the total number of pixels by multiplying the figures for width and height together, so my screen contains a total of 1,310,720 pixels. That’s 1.3 million pixels, or 1.3 megapixels, enough to create a high-quality image. __As a general rule, the more pixels there are on a screen, the higher quality the image.__ Computer displays can also vary in the amount of colors they can generate. The highest number of colors the typical home computer can display is 16.7 million, which is currently the most common setting for displays. Each color also has a range of brightness, from full intensity(亮度) to virtually black. To put it into perspective, __if you wanted to display every possible color on a monitor you would need a screen that is 4096 by 4096 pixels in size.__ Let’s write a small Python script to generate an image containing every possible color.

Listing 4-1 uses Pygame to create a large image with every possible color value. The script will take a couple of minutes to run, but when it is finished it will have saved an image file called `allcolors.bmp` (為了要不失真所以存成大小約 48MB 的 BMP 檔, 也難怪要花一點時間...), which you can open in an image viewer or web browser. Don’t worry about the details of Listing 4-1; we will cover the unfamiliar code in this chapter.

Caution: The image in Listing 4-1 is 48MB in size—make sure you have enough space on your hard drive!

Listing 4-1. Generating an Image Containing Every Color (`allcolors.py`)

 {{{
import pygame
pygame.init()

screen = pygame.display.set_mode((640, 480)) <-- 這支程式應該不用開窗才是?
all_colors = pygame.Surface((4096, 4096), depth = 24)

for r in xrange(256):
    print r + 1, "out of 256"
    x = (r & 15) * 256
    y = (r >> 4) * 256
    for g in xrange(256):
        for b in xrange(256):
            all_colors.set_at((x + g, y + b), (r, g, b))

pygame.image.save(all_colors, "allcolors.bmp") <-- 給定不同的副檔名, 就能輸出成不同的檔案格式!!
 }}}

Listing 4-1 is unusual for a Pygame script because it is not interactive. When it runs you will see it count from 1 to 256 and then exit after saving the bitmap file in the same location as the script. __Don’t worry that it is slow; generating bitmaps one pixel at a time is something you should never need to do in a game!__

=== Working with Color ===

You are probably familiar with how colors are created with paint. If you have a pot of blue paint and a pot of yellow paint, then you can create shades(色調) of green by mixing the two together. __In fact, you can produce any color of paint by mixing the primary colors red, yellow, and blue in various proportions. Computer color works in a similar way, but the “primary” colors are red, green, and blue.__ To understand the difference we need to cover the science behind color— don’t worry, it’s not complicated.

__To see a color, light from the sun or a bulb(燈泡) has to bounce off something and pass through the lens in your eye. Sunlight or artificial light from a bulb may appear white, but it actually contains all the colors of the rainbow mixed together. When light hits a surface, some of the colors in it are absorbed and the remainder is reflected. It’s this reflected light that enters your eye and is perceived as color. '''When colors are created in this way, it is called ''color subtraction''. Computer screens work differently. Instead of reflecting light, they generate their own and create color by adding together red, green, and blue light (a process known as ''color addition'').'''__

That’s enough science for the moment. For now we need to know how to represent color in a Python program, because it is impractical to think of names for all 16.7 million of them!

==== Representing Color in Pygame ====

When Pygame requires a color, you pass it in as a tuple of three integers, one for each color component in red, green, and blue order. The value of each component should be in the range 0 to 255, where 255 is full intensity and 0 means that the component doesn’t contribute anything to the final color. Table 4-1 lists the colors you can create by using components set to either off or full intensity.

Some early computers were limited to just these gaudy(俗氣的) colors; fortunately you can create more subtle(細緻) hues nowadays!

Table 4-1. Color Table

|| Color || Red ||| Green || Blue || Tuple ||
|| Black || 0 || 0 || 0 || (0, 0, 0) ||
|| Blue || 0 || 0 || 255 || (0, 0, 255) ||
|| Green || 0 || 255 || 0 || (0, 255, 0) ||
|| Cyan || 0 || 255 || 255 || (0, 255, 255) ||
|| Red || 255 || 0 || 0 || (255, 0, 0) ||
|| Magenta || 255 || 0 || 255 || (255, 0, 255) ||
|| Yellow || 255 || 255 || 0 || (255, 255, 0) ||
|| White || 255 || 255 || 255 || (255, 255, 255) ||

It’s well worth experimenting with different values so that you have an intuitive feel for computer-generated color. __With a little practice you should find that you can look at the three color values and make an educated guess at what the color looks like.__ Let’s write a script to help us to do this. When you run Listing 4-2, you will see a screen split into two halves. At the top of the screen are three scales—one for each of the red, green, and blue components—and a circle to represent the currently selected value. If you click anywhere on one of the scales, it will modify the component and change the resulting color, which is displayed on the lower half of the screen.

Try adjusting the sliders to (96, 130, 51), which gives a convincing shade of zombie green(僵屍綠?), or (221, 99, 20) for a pleasing fireball orange.

Listing 4-2. Script for Tweaking Colors (`colortest.py`; 有互動的感覺了...)

 {{{
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

# Creates images with smooth gradients
def create_scales(height):
    red_scale_surface = pygame.surface.Surface((640, height))
    green_scale_surface = pygame.surface.Surface((640, height))
    blue_scale_surface = pygame.surface.Surface((640, height))
    for x in range(640):
        c = int((x / 639.) * 255.) <-- 畫面水平像素分出來的刻度
        red = (c, 0, 0)
        green = (0, c, 0)
        blue = (0, 0, c)
        line_rect = Rect(x, 0, 1, height)
        pygame.draw.rect(red_scale_surface, red, line_rect)
        pygame.draw.rect(green_scale_surface, green, line_rect)
        pygame.draw.rect(blue_scale_surface, blue, line_rect)
    return red_scale_surface, green_scale_surface, blue_scale_surface <-- 一次傳回多個值!!

red_scale, green_scale, blue_scale = create_scales(80)
color = [127, 127, 127]

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    screen.fill((0, 0, 0))

    # Draw the scales to the screen
    screen.blit(red_scale, (0, 00))
    screen.blit(green_scale, (0, 80))
    screen.blit(blue_scale, (0, 160))

    x, y = pygame.mouse.get_pos()

    # If the mouse was pressed on one of the sliders, adjust the color component
    if pygame.mouse.get_pressed()[0]: <-- 左鍵如果有被按下
        for component in range(3):
            if y > component * 80 and y < (component + 1) * 80: <-- 判別左鍵落在那一區
                color[component] = int((x / 639.) * 255.)
        pygame.display.set_caption("PyGame Color Test - " + str(tuple(color)))

    # Draw a circle for each slider to represent the current setting
    for component in range(3):
        pos = (int((color[component] / 255.) * 639), component * 80 + 40)
        pygame.draw.circle(screen, (255, 255, 255), pos, 20)

    pygame.draw.rect(screen, tuple(color), (0, 240, 640, 240))
    pygame.display.update()
 }}}

Listing 4-2 introduces the `pygame.draw` module, which is used to draw lines, rectangles, circles, and other shapes on the screen. We will cover this module in more detail later in this chapter.

Once you have a color, there are a number of things you may want to do to it. Let’s say we have a soldier in a space game that has the misfortune(不幸) to be caught in a meteor shower(流星雨) without an umbrella(保護傘). We could use “fireball orange” for the meteors as they streak through the atmosphere(大氣), but when they hit the ground they would gradually fade to black. How do we find the darker colors?

==== Scaling Colors ====

To make a color darker, you simply multiply each of the components by a value between 0 and 1. If you take fireball orange (221, 99, 20) and multiply each component by 0.5 (in other words, decrease them by one-half), then you get (110.5, 49.5, 10). But because color components are integers we need to drop the fractional part to get (110, 49, 10). If you use Listing 4-2 to create this color, you should see that it is indeed a darker shade of fireball orange. __We don’t want to have to do the math in our head every time, so let’s write a function to do it for us.__ Listing 4-3 is a function that takes a color tuple, multiplies each number by a float value, and returns a new tuple.

Listing 4-3. Function for Scaling a Color

 {{{
def scale_color(color, scale):
    red, green, blue = color
    red = int(red * scale)
    green = int(green * scale)
    blue = int(blue * scale)
    return red, green, blue

fireball_orange = (221, 99, 20)
print fireball_orange
print scale_color(fireball_orange, .5)
 }}}

If you run Listing 4-3, it will display the color tuple for fireball orange and the darker version:

 {{{
(221, 99, 20)
(110, 49, 10)
 }}}

__Multiplying each of the components by a value between 0 to 1 makes a color darker, but what if you multiply by a value that is greater than 1? It will make the color brighter, but there is something you have to watch out for.__ Let’s use a scale value of 2 to make a really bright fireball orange. Add the following line to Listing 4-3 to see what happens to the color:

 {{{
print scale_color(fireball_orange, 2.)
 }}}

This adds an additional color tuple to the output:

 {{{
(442, 198, 40)
 }}}

__The first (red) component is 442—which is a problem because color components must be a value between 0 and 255! If you use this color tuple in Pygame it will throw a `TypeError` exception, so it is important that we “fix” it before using it to draw anything. All we can do is check each component and if it goes over 255, set it back to 255—a process known as ''saturating(飽和)'' the color.__ Listing 4-4 is a function that performs color saturation.

Listing 4-4. Function for Saturating a Color

 {{{
def saturate_color(color):
    red, green, blue = color
    red = min(red, 255)
    green = min(green, 255)
    blue = min(blue, 255)
    return red, green, blue
 }}}

Listing 4-4 uses the built-in function `min`, which returns the lower of the two values. If the component is in the correct range, it is returned unchanged. But if it is greater than 255, it returns 255 (which is exactly the effect we need).

If we saturate the extra bright fireball orange after scaling it, we get the following output, which Pygame will happily accept:

 {{{
(255, 198, 40)
 }}}

__'''With color components saturated(飽和的) at 255, the color will be brighter but may not be exactly the same hue.''' And if you keep scaling a color, it may eventually change to (255, 255, 255), which is bright white. So it is usually better to select the brightest shade of the color you want and scale it downward (using a factor less than 1; 不也跟另外一個方向有相同的問題嗎[?]).__

So we now know what scaling does when using a value that is greater than zero. But what if it is less than zero—that is, negative? Using negative values when scaling a color produces negative color components, which don’t make sense because you can’t have less than zero red, green, or blue in a color. So avoid scaling colors by a negative value!

==== Blending(混和) Colors ====

Something else you may want to do with colors is blend one color gradually into another. Let’s say we have a zombie in a horror(戰慄) game that is normally a sickly shade of zombie green but has recently emerged(露出) from a lava pit(熔岩坑) and is currently glowing a bright shade of fireball orange. Over time the zombie will cool down and return to its usual color. __But how do we calculate the intermediate colors to make the transition look smooth?__

__We can use something called ''linear interpolation(內插法)'', which is a fancy term for moving from one value to another in a straight line. It is such a mouthful(長又拗口的詞) that game programmers prefer to use the acronym ''lerp''. To lerp between two values, you find the difference between the second and the first value, multiply it by a factor between 0 and 1, and then add that to the first value. (將兩個顏色按不同的比例混合) A factor of 0 or 1 will result in the first or second values, but a factor of .5 gives a value that is halfway between the first and second. Any other factors will result in a proportional value between the two end points.__ Let’s see an example in Python code to make it clearer. Listing 4-5 defines a function `lerp` that takes two values and a factor and returns a blended value.

Listing 4-5. Simple Lerping Example

 {{{
def lerp(value1, value2, factor):
    return value1 + (value2 - value1) * factor

print lerp(100, 200, 0.)
print lerp(100, 200, 1.)
print lerp(100, 200, .5)
print lerp(100, 200, .25)
 }}}

This results in the following output. Try to predict what the result of lerp(100, 200, .75) will be.

 {{{
100.0
200.0
150.0
125.0
 }}}

To lerp between colors, you simply lerp between each of the components to produce a new color. If you vary the factor over time, it will result in a smooth color transition. Listing 4-6 contains the function ｀blend_color｀, which does color lerping.

Listing 4-6. Blending Colors by Lerping

 {{{
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

color1 = (221, 99, 20)
color2 = (96, 130, 51)
factor = 0.

def blend_color(color1, color2, blend_factor):
    red1, green1, blue1 = color1
    red2, green2, blue2 = color2
    red = red1 + (red2 - red1) * blend_factor
    green = green1 + (green2 - green1) * blend_factor
    blue = blue1 + (blue2 - blue1) * blend_factor
    return int(red), int(green), int(blue)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    screen.fill((255, 255, 255))

    tri = [(0,120), (639,100), (639, 140)]
    pygame.draw.polygon(screen, (0,255,0), tri)
    pygame.draw.circle(screen, (0,0,0), (int(factor * 639.), 120), 10)

    x, y = pygame.mouse.get_pos()
    if pygame.mouse.get_pressed()[0]:
        factor = x / 639.
        pygame.display.set_caption("PyGame Color Blend Test - %.3f" % factor)

    color = blend_color(color1, color2, factor)
    pygame.draw.rect(screen, color, (0, 240, 640, 240))

    pygame.display.update()
 }}}
 
If you run Listing 4-6, you will see a slider at the top of the screen. Initially it will be at the far left, representing a factor of 0 (fireball orange). If you click and drag toward the right of the screen, you can smoothly change the blending factor toward 1 (zombie green). The resulting color is displayed in the lower half of the screen.

You can experiment with blending between other colors by changing the values of `color1` and `color2` at the top of the script. Try blending between completely contrasting colors and shades of similar colors.

=== Using Images ===

Images are an essential part of most games. The display is typically assembled(組合) from a collection of images stored on the hard drive (or CD, DVD, or other media device). __In a 2D game, the images may represent background, text, player characters, or artificial intelligence (AI) opponents(對手). In a 3D game, images are typically used as ''textures'' to create 3D scenes.__

Computers store images as a grid of colors. The way these colors are stored varies depending on how many are needed to reproduce the image. Photographs require the full range of colors, but diagrams or black and white images may be stored differently. Some images also store extra information for each pixel. __In addition to the usual red, green, and blue components, there may be an ''alpha'' component (sometimes known as the ''attribute'' component). The alpha value of a color is most often used to represent translucency(半透明) so that when drawn on top of another image, parts of the background can show through. We used an image with an ''alpha channel'' in Hello World Redux (Listing 3-1). Without an alpha channel, the image of a fish would be drawn inside an ugly rectangle.__

==== Creating Images With An Alpha Channel ====

If you have taken a photo with a digital camera or drawn it with some graphics software, then it probably won’t have an alpha channel. __Adding an alpha channel to an image usually involves a little work with graphics software.__ To add an alpha channel to the image of a fish, I used Photoshop, but you can also use other software such as GIMP (www.gimp.org) to do this. For an introduction to GIMP, see Akkana Peck’s Beginning GIMP: From Novice to Professional (Apress, 2006).

__An alternative to adding an alpha channel to an existing image is to create an image with a 3D rendering package such as Autodesk’s 3ds Max or the free alternative, Blender (www.blender.org). With this kind of software you can directly output an image with an invisible background (you can also create several frames of animation or views from different angles; 似乎有點小題大作了?).__ This may produce the best results for a slick-looking game, but you can do a lot with the manual alpha channel technique. Try taking a picture of your cat, dog, or goldfish and making a game out of it!

==== Storing Images ====

There are a variety of ways to store an image on your hard drive. __Over the years, many formats for image files have been developed, each with pros and cons. Fortunately a small number have emerged as being the most useful, two in particular: JPEG and PNG. Both are well supported in image-editing software and you will probably not have to use other formats for storing images in a game.__

 * JPEG (Joint Photographic Expert Group)—JPEG image files typically have the extension `.jpg` or sometimes `.jpeg`. __If you use a digital camera, the files it produces will probably be JPEGs, because they were specifically designed for storing photographs. They use a process known as ''lossy compression'', which is very good at shrinking the file size.__ The downside of lossy compression is that it can reduce the quality of the image, but usually it is so subtle that you will not notice the difference. The amount of compression can also be adjusted to compromise between visual quality and compression. __'''They may be great for photos, but JPEGs are bad for anything with hard edges, such as fonts or diagrams, because the lossy compression tends to distort(扭曲) these kinds of images. If you have any of these kinds of images, PNG is probably a better choice.'''__

 * PNG (Portable Network Graphics)—PNG files are probably the most versatile(多用途的) of images formats because they can store a wide variety of image types and still compress very well. __They also support alpha channels, which is a real boon(恩惠) for game developers. '''The compression that PNGs use is ''lossless'', which means that images stored as PNG files will be exactly the same as the originals. (因此 PNG 不適合拿來存放照片, 難怪數位像機長久以來都還是以 JPEG 做為檔案儲存格式)''' The downside is that even with good compression they will probably be larger than JPEGs.__

In addition to JPEG and PNG, Pygame supports reading the following formats:

 * GIF (non animated)
 * BMP
 * PCX
 * TGA (uncompressed only)
 * TIF
 * LBM (and PBM)
 * PBM (and PGM, PPM)
 * XPM

__As a rule of thumb, '''use JPEG only for large images with lots of color variation; otherwise, use PNGs.'''__

==== Working with Surface Objects ====

Loading images into Pygame is done with a simple one-liner; `pygame.image.load` takes the file name of the image you want to load and returns a surface object, which is a ''container'' for an image. __Surfaces can represent many types of image, but Pygame hides most of these details from us so we can treat them in much the same way. Once you have a surface in memory, you can draw on it, transform it, or copy it to another surface to build up an image. Even the screen is represented as a surface object. The initial call to `pygame.display.set_mode` returns a surface object that represents the display.__

===== Creating Surfaces =====

A call to `pygame.image.load` is one way to create a surface. __It will create a surface that matches the colors and dimensions of the image file,__ but you can also create blank surfaces of any size that you need (assuming there is enough memory to store it). To create a blank surface, call the `pygame.Surface` constructor with a tuple containing the required dimensions. The following line creates a surface that is 256 by 256 pixels:

 {{{
blank_surface = pygame.Surface((256, 256))
 }}}

__Without any other parameters, this will create a surface with the same number of colors as the display. '''This is usually what you want, because it is faster to copy images when they have the same number of colors. (這就是為什麼上面 Listing 3-1 要額外呼叫 `convert` 或 `convert_alpha` 的關係)'''__

There are also a few optional parameters that affect how the images are created. You can set the `flags` parameter to one or both of the following parameters:

 * `HWSURFACE`—Creates a hardware surface, which may be faster than nonhardware surfaces. __It is usually better not to set this flag and leave the choice of whether to use hardware surfaces up to Pygame.__

 * `SRCALPHA`—__Creates a surface with alpha information. Set this if you want parts of the surface to be transparent, for images with irregular edges such as sprites(子畫面) and fonts. This flag also requires that you to set the `depth` parameter to 32.__

There is also a `depth` parameter for `pygame.Surface` that defines the color depth for the surface. This is similar to the `depth` parameter in `pygame.display.set_mode` and defines the maximum number of colors in the surface. __Generally it is best not to set this parameter (or set it to 0), because Pygame will select a depth that matches the display—although if you want alpha information in the surface, you should set depth to 32.__ The following line creates a surface with alpha information:

 {{{
blank_alpha_surface = pygame.Surface((256, 256), flags = SRCALPHA, depth = 32)
 }}}

===== Converting Surfaces =====

When you use surface objects, you don’t have to worry about how the image information is stored in memory because Pygame will hide this detail from you. So most of the time the image format is something you don’t need to worry about, since your code will work regardless of what type of images you use. __The only downside of this automatic conversion is that Pygame will have to do more work if you are using images with different formats, and that can potentially decrease game performance. The solution is to convert all your images to be the same format.__ Surface objects have a `convert` method for this purpose.

__If you call `convert` without any parameters, the surface will be converted to the format of the display surface. This is useful because it is usually fastest to copy surfaces when the source and destination are the same type—and most images will be copied to the display eventually.__

__It is a good idea to tack on(添加) `.convert()` to any calls to `pygame.image.load` to ensure your images will be in the fastest format for the display. The exception is when your image has an alpha channel, because `convert` can discard it. Fortunately Pygame provides a `convert_alpha` method, which will convert the surface to a fast format but preserve any alpha information in the image.__ We have used both methods in the previous chapter; the following two lines are taken from Listing 3-1:

 {{{
background = pygame.image.load(background_image_filename).convert()
mouse_cursor = pygame.image.load(mouse_image_filename).convert_alpha()
 }}}

The background is just a solid rectangle so we use `convert`. However, the mouse cursor has irregular edges and needs alpha information, so we call `convert_alpha`.

__Both `convert` and `convert_alpha` can take another surface as a parameter. If a surface is supplied, the surface will be converted to match the other surface. (否則就是跟 display 對齊)__

===== Rectangle Objects =====

__'''Pygame will often require you to give it a rectangle to define what part of the screen should be affected by a function call.'''__ For instance, you can restrict Pygame to drawing on a rectangular area of the screen by setting the ''clipping rectangle'' (covered in the next section). You can define a rectangle using a tuple that contains four values: the x and y coordinate of the top-left corner followed by the width and height of the rectangle. __Alternatively, you can give the x and y coordinate as a single tuple followed by the width and height as another tuple. (Pygame 太多地方的參數都有很大的彈性, 不知道內部是怎麼寫的[?])__ The following two lines define the rectangle with the same dimensions:

 {{{
my_rect1 = (100, 100, 200, 150)
my_rect2 = ((100, 100), (200, 150))
 }}}

You can use whichever method is most convenient at the time. For instance, you may already have the coordinate and size stored as a tuple, so it would be easier to use the second method.

__In addition to defining rectangles, Pygame has a `Rect` class that stores the same information as a rectangle tuple but contains a number of convenient methods to work with them. `Rect` objects are used so often that they are included in `pygame.locals`__—so if you have from `pygame.locals import *` at the top of your script, you don’t need to precede them with a module name.

To construct a `Rect` object, you use the same parameters as a rectangle tuple. The following two lines construct the `Rect` objects equivalent to the two rectangle tuples:

 {{{
my_rect3 = Rect(100, 100, 200, 150)
my_rect4 = Rect((100, 100), (200, 150))
 }}}

Once you have a `Rect` object, you can do such things as adjusting its position or size, detect whether a point is inside or outside, or find where other rectangles intersect (檢查是否產生碰撞...). See the Pygame documentation for more details (www.pygame.org/docs/ref/rect.html).

===== Clipping =====

Often when you are building a screen for a game, you will want to draw only to a portion of the display. For instance, in a strategy Command & Conquer–like game, you might have the top of the screen as a scrollable map, and below it a panel that displays troop(部隊) information. But when you start to draw the troop images to the screen, you don’t want to have them draw over the information panel. __To solve this problem, surfaces have a ''clipping area'', which is a rectangle that defines what part of the screen can be drawn to. To set the clipping area, call the `set_clip` method of a surface object with a `Rect`-style object. You can also retrieve the current clipping region by calling `get_clip`.__

The following snippet shows how we might use clipping to construct the screen for a strategy game. The first call to clip sets the region so that the call to `draw_map` will only be able to draw onto the top half of the screen. The second call to `set_clip` sets the clipping area to the remaining portion of the screen:

 {{{
screen.set_clip(0, 0, 640, 300)
draw_map()
screen.set_clip(0, 300, 640, 180)
draw_panel()
 }}}

===== Subsurfaces =====

__A ''subsurface'' is a surface inside another surface. When you draw onto a subsurface, it also draws onto its parent surface.__ One use of subsurfaces is to draw graphical fonts. The `pygame.font` module produces nice, crisp(活潑的)-looking text in a single color, but some games require more graphically rich lettering. You could save an image file for each letter, but it would probably be easier to create a single image with all the letters on it, and then create 26 subsurfaces when you load the image into Pygame.

To create a subsurface, you call the `subsurface` method of `Surface` objects, which takes a rectangle that defines what portion of the parent it should cover. It will return a new `Surface` object that has the same color format as the parent. Here’s how we might load a font image and divide it into letter-sized portions:

 {{{
my_font_image = Pygame.load("font.png")
letters = []
letters["a"] = my_font_image.subsurface((0,0), (80,80))
letters["b"] = my_font_image.subsurface((80,0), (80,80))
 }}}

This creates two subsurfaces of `my_font_image` and stores them in a dictionary so that we can easily look up the subsurface for a given letter. Of course, we would need more than “a” and “b,” so the call to subsurface would probably be in a loop that repeats 26 times.

__When you work with subsurfaces, it is important to remember that they have their own coordinate system. In other words, the point (0, 0) in a subsurface is always the top-left corner no matter where it sits inside its parent.__

===== Filling Surfaces =====

When you create an image on the display, you should cover the entire screen; otherwise, parts of the previous screen will show through. If you don’t draw over every pixel, you will get an unpleasant http://en.wikipedia.org/wiki/Strobing[strobing] effect when you try to animate anything. The easiest way to avoid this is to clear the screen with a call to the `fill` method of surface objects, which takes a color. The following will clear the screen to black:

 {{{{
screen.fill((0, 0, 0))
 }}}

The `fill` function also takes an optional rectangle that defines the area to clear, which is a convenient way to draw solid rectangles.

__Note: If you draw over the entire screen with other methods, you won’t need to clear it with a call to `fill`.__

===== Setting Pixels in a Surface =====

One of the most basic things you can do with a surface is set individual pixels, which has the effect of drawing a tiny dot. __It is rarely necessary to draw pixels one at a time because there are more efficient ways of drawing images, but if you ever need to do any ''offline image manipulation'' it can be useful.__

To draw a single pixel onto a surface, use the `set_at` method, which takes the coordinate of the pixel you want to set, followed by the color you want to set it to. We will test `set_at` by writing a script that draws random pixels. When you run Listing 4-7 you will see the screen slowly fill up with random-colored dots; each one is an individual pixel.

Listing 4-7. Script That Draws Random Pixels (`random.py`)

 {{{
import pygame
from pygame.locals import *
from sys import exit
from random import randint

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
    for _ in xrange(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)

    pygame.display.update()
 }}}

===== Getting Pixels in a Surface =====

The complement of `set_at` is `get_at`, which returns the color of the pixel at a given coordinate. __Getting pixels is occasionally necessary for ''collision detection'' so that the code can determine what the player character is standing on by looking at the color underneath it.__ If all platforms and obstacles(障礙物) are a certain color (or range of colors), this would work quite well. `set_at` takes just one parameter, which should be a tuple of the coordinates of the pixel you want to look at. The following line gets the pixel at coordinate (100, 100) in a surface called `screen`:

 {{{
my_color = screen.get_at((100, 100))
 }}}

__Caution: '''The `get_at` method can be very slow when reading from hardware surfaces. (沒想到讀取時反而會變慢...)''' The display can be a hardware surface, especially if you are running full screen—so you should probably avoid getting the pixels of the display.__

===== Locking Surfaces =====

__Whenever Pygame draws onto a surface, it first has to be ''locked''. When a surface is locked, Pygame has full control over the surface and no other process on the computer can use it until it is unlocked. Locking and unlocking happens automatically whenever you draw onto a surface, but it can become inefficient if Pygame has to do many locks and unlocks.__

In Listing 4-7 there is a loop that calls `set_at` 100 times, which will lead to Pygame locking and unlocking the screen surface 100 times. __We can reduce the number of locks and unlocks and speed up the loop by doing the locking manually.__ Listing 4-8 is almost identical to the previous listing, but will run faster because there is a call to `lock` before drawing and a call to `unlock` after all the pixels have been drawn.

__Caution: There should be the same number of calls to lock as there are to unlock. If you forget to unlock a surface, Pygame may become unresponsive.__

Listing 4-8. Random Pixels with Locking (randoml.py)

 {{{
import pygame
from pygame.locals import *
from sys import exit
from random import randint

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
    screen.lock()
    for _ in xrange(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)

    screen.unlock()
    pygame.display.update()
 }}}

__Not all surfaces need to be locked. Hardware surfaces do (the screen is usually a hardware surface), but plain software surfaces do not. Pygame provides a `mustlock` method in surface objects that returns `True` if a surface requires locking. You could check the return value of `mustlock` before you do any locking or unlocking, '''but there is no problem in locking a surface that doesn’t need it, so you may as well lock any surface that you plan on doing a lot of drawing to.'''__

===== Blitting =====

__The method of surface objects that you will probably use most often is `blit`, which is an acronym for ''bit block transfer''. Blitting simply means copying image data from one surface to another.__ You will use it for drawing backgrounds, fonts, characters, and just about everything else in a game!

__To blit a surface, you call `blit` from the destination surface object (often the display) and give it the source surface (your sprite, background, and so forth), followed by the coordinate you want to blit it to. You can also blit just a portion of the surface by adding a Rect-style object to the parameter that defines the ''source region''.__ Here are two ways you use the blit method:

 {{{
screen.blit(background, (0,0))
 }}}

which blits a surface called `background` to the top-left corner of screen. If `background` has the same dimensions as screen, we won’t need to fill screen with a solid color. The other way is

 {{{
screen.blit(ogre, (300, 200), (100 * frame_no, 0, 100, 100))
 }}}

__If we have an image containing several frames of an ogre(怪物) walking, we could use something like this to blit it to the screen. By changing the value of `frame_no`, we can blit from a different area of the source surface. (這個概念很類似於上面的 Subsurfaces)__

=== Drawing with Pygame ===

We have used a few functions from the `pygame.draw` module in the preceding examples. The purpose of this module is to draw lines, circles, and other geometric shapes to the screen. You could use it to create an entire game without loading any images. The classic Atari game http://en.wikipedia.org/wiki/Asteroids_(computer_game)[Asteroids] is an example of a great game that just uses shapes drawn with lines. __Even if you don’t use the `pygame.draw` module to create a complete game, you will find it useful for experimenting when you don’t want to go to the trouble of creating images. '''You could also use it to draw a ''debug overlay'' on top of your game when you need to visualize what is happening in your code.'''__

The first two parameters for functions in `pygame.draw` are the surface you want to render to—which could be the screen (display surface) or a plain surface—followed by the color you want to draw in. __Each draw function will also take at least one point, and possibly a list of points. A point should be given as a tuple containing the x and y coordinates, where (0, 0) is the top left of the screen.__

__The return value for these draw functions is a `Rect` object that gives the area of the screen that has been drawn to, which can be useful if we only want to refresh parts of the screen that have been changed.__ Table 4-2 lists the functions in the `pygame.draw` module, which we will cover in this chapter.

Table 4-2. The `pygame.draw` Module

|| Function || Purpose ||
|| `rect` || Draws a rectangle ||
|| `polygon` || Draws a polygon (shape with three or more sides) ||
|| `circle` || Draws a circle ||
|| `ellipse` || Draws an ellipse ||
|| `arc` || Draws an arc ||
|| `line` || Draws a line ||
|| `lines` || Draws several lines ||
|| `aaline` || Draws an antialiased (smooth) line ||
|| `aalines` || Draws several antialiased lines ||

==== pygame.draw.rect ====

This function draws a rectangle onto a surface. In addition to the destination surface and color, `pygame.rect` takes the dimensions of the rectangle you want to draw and the width of the line. __If you set width to 0 or omit it, the rectangle will be filled with solid color; otherwise, just the edges will be drawn.__

Let’s write a script to test Pygame’s rectangle-drawing capabilities. Listing 4-9 draws ten randomly filled rectangles in random positions and colors. It produces a strangely pretty, modern art–like effect.

Listing 4-9. Rectangle Test (`colrects.py`)

 {{{
import pygame
from pygame.locals import *
from sys import exit
from random import *

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    screen.lock()
    for count in range(10):
        random_color = (randint(0,255), randint(0,255), randint(0,255))
        random_pos = (randint(0,639), randint(0,479))
        random_size = (639 - randint(random_pos[0], 639), 479 - randint(random_pos[1], 479))
        pygame.draw.rect(screen, random_color, Rect(random_pos, random_size))

    screen.unlock()
    pygame.display.update()
 }}}

There is another way to draw filled rectangles on a surface. The `fill` method of surface objects takes a `Rect`-style object that defines what part of the surface to fill—and will draw a perfect filled rectangle! __In fact, `fill` can be faster than `pygame.draw.rect`; it can potentially be hardware accelerated (in other words, performed by the graphics card and not the main processor).__

==== pygame.draw.polygon ====

A polygon is a many-sided shape, that is, anything from a triangle to a myriagon (10,000 sides— I looked it up) and beyond. A call to pygame.draw.polygon takes a list of points and will draw the shape between them. Like pygame.rect, it also takes an optional width value. If width is omitted or set to 0, the polygon will be filled; otherwise, only the edges will be drawn.

We will test Pygame’s polygon-drawing capabilities with a simple script. Listing 4-10 keeps a list of points. Every time it gets a MOUSEBUTTONDOWN event, it adds the position of the mouse to the list of points. When it has at least three points, it will draw a polygon.

Try adding a width parameter to the call to pygame.draw.polygon to use nonfilled polygons.

Listing 4-10. Drawing Polygons with Pygame

 {{{
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

points = []

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()
        if event.type == MOUSEBUTTONDOWN:
            points.append(event.pos)

    screen.fill((255,255,255))
    if len(points) >= 3:
        pygame.draw.polygon(screen, (0,255,0), points)
    for point in points:
        pygame.draw.circle(screen, (0,0,255), point, 5)

    pygame.display.update()
 }}}

==== pygame.draw.circle ====

The circle function draws a circle on a surface. It takes the center point and the radius of the circle (the radius is the distance from the center to the edge). Like the other draw functions, it also takes a value for the width of the line. If width is 0 or omitted, the circle will be drawn with a line; otherwise, it will be a solid circle. Listing 4.11 draws randomly filled circles on the screen, in a random color.

Listing 4-11. Random Circles

 {{{
import pygame
from pygame.locals import *
from sys import exit
from random import *

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    random_color = (randint(0,255), randint(0,255), randint(0,255))
    random_pos = (randint(0,639), randint(0,479))
    random_radius = randint(1,200)
    pygame.draw.circle(screen, random_color, random_pos, random_radius)

    pygame.display.update()
 }}}

==== pygame.draw.ellipse ====

You can think of an ellipse as being a squashed circle. If you were to take a circle and stretch it to fit it into a rectangle, it would become an ellipse. In addition to surface and color, the ellipse function takes a Rect-style object that the ellipse should fit in to. It also takes a width parameter, which is used just like rect and circle. Listing 4-12 draws an ellipse that fits in a rectangle stretching from the top-left corner of the screen to the current mouse position.

Listing 4-12. Drawing an Ellipse

 {{{
import pygame
from pygame.locals import *
from sys import exit
from random import *

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    x, y = pygame.mouse.get_pos()
    screen.fill((255,255,255))
    pygame.draw.ellipse(screen, (0,255,0), (0,0,x,y))

    pygame.display.update()
 }}}

==== pygame.draw.arc ====

The arc function draws just a section of an ellipse, but only the edge; there is no fill option for arc. Like the ellipse function, it takes a Rect-style object that the arc would fit into (if it covered the entire ellipse). It also takes two angles in radians. The first angle is where the arc should start drawing, and the second is where it should stop. It also takes a width parameter for the line, which defaults to 1, but you can set it to greater values for a thicker line. Listing 4-13 draws a single arc that fits into the entire screen. The end angle is taken from the x coordinate of the mouse, so if you move the mouse left and right it will change the length of the arc.

Listing 4-13. Arc Test

 {{{
import pygame
from pygame.locals import *
from sys import exit
from random import *
from math import pi

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    x, y = pygame.mouse.get_pos()
    angle = (x/639.)*pi*2.
    screen.fill((255,255,255))
    pygame.draw.arc(screen, (0,0,0), (0,0,639,479), 0, angle)

    pygame.display.update()
 }}}

==== pygame.draw.line ====

A call to pygame.draw.line will draw a line between two points. After the surface and color, it takes two points: the start point and the end point of the line you want to draw. There is also the optional width parameter, which works the same way as rect and circle. Listing 4-14 draws several lines from the edges of the screen to the current mouse position.

Listing 4-14. Line Drawing (drawinglines.py)

 {{{
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    screen.fill((255, 255, 255))
    mouse_pos = pygame.mouse.get_pos()

    for x in xrange(0,640,20):
        pygame.draw.line(screen, (0, 0, 0), (x, 0), mouse_pos)
        pygame.draw.line(screen, (0, 0, 0), (x, 479), mouse_pos)

    for y in xrange(0,480,20):
      pygame.draw.line(screen, (0, 0, 0), (0, y), mouse_pos)
      pygame.draw.line(screen, (0, 0, 0), (639, y), mouse_pos)

    pygame.display.update()
 }}}

==== pgame.draw.lines ====

Often lines are drawn in sequence, so that each line begins where the previous one left off. The first parameter to pygame.draw.lines is a boolean that indicates whether the line is closed. If set to True an additional line will be drawn between the last point in the list and the first; otherwise, it will be left open. Following this value is a list of points to draw lines between and the usual width parameter.

Listing 4-15 uses pygame.draw.lines to draw a line from a list of points, which it gets from the mouse position. When there are more than 100 points in the list, it deletes the first one, so the line miraculously starts to “undraw” itself! This might be a good starting point for a worm game.

Listing 4-15. Drawing Multiple Lines (multiplelines.py)

 {{{
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

points = []

while True:

    for event in pygame.event.get():
        if event.type == QUIT:
            exit()
        if event.type == MOUSEMOTION:
            points.append(event.pos)
            if len(points)>100:
                del points[0]

    screen.fill((255, 255, 255))

    if len(points)>1:
        pygame.draw.lines(screen, (0,255,0), False, points, 2)

    pygame.display.update()
 }}}

==== pygame.draw.aaline ====

You may have noticed from the previous line drawing functions that the lines have a jagged appearance. This is because a pixel can only be drawn at a coordinate on a grid, which may not lie directly underneath a line if it is not horizontal or vertical. This effect is called aliasing, something which computer scientists have put a lot of work into avoiding. Any technique that attempts to avoid or reduce aliasing is called antialiasing.

Pygame can draw antialiased lines that appear significantly smoother than the lines drawn by pygame.draw.line. The function pygame.draw.aaline has the same parameters as pygame.draw.line but draws smooth lines. The downside of antialiased lines is that they are slower to draw than regular lines, but only marginally so. Use aaline whenever visual quality is important.

To see the difference, replace the call to pygame.draw.line in the previous example code with the aaline version.

==== pygame.draw.aalines ====

Just like pygame.draw.line, there is an antialiased version of pygame.draw.lines. A call to pygame.draw.aalines uses the same parameters as pygame.draw.lines but draws smooth lines, so it is easy to switch between the two in code.

=== Summary ===

Colors are the most fundamental things in creating computer graphics. All images in a game are ultimately created by manipulating colors in some form or another. We’ve seen how Pygame stores colors and how to make new colors by combining existing ones. In the process of learning about color manipulation, we introduced lerping (linear interpolation), which we will use for various game tasks.

Surface objects are Pygame’s canvases, and can store all kinds of images. Fortunately we don’t have to worry about the details of how they are stored, because when you manipulate images through a surface they all appear to be the same type.

We covered the draw module in some detail, because it is handy for visually depicting additional information in your game. For instance, you could use it to draw a little arrow over your enemy character indicating which way they are headed.

This chapter has covered all the ways that you can create visuals with Pygame. Armed with this information, you can create images of dungeons, alien worlds, and other game environments.

In the next chapter you will learn how to animate graphics over time.

== Chapter 5. Making Things Move ==

[[|:]]

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==
