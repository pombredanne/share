= Python / Learning Python, Fourth Edition - Part IV. Functions =
<<TableOfContents>>

= Chapter 16. Function Basics =

In Part III, we looked at basic procedural statements in Python. Here, we’ll move on to explore a set of additional statements that we can use to create functions of our own.

In simple terms, a function is a device that groups a set of statements so they can be run more than once in a program. Functions also can compute a result value and let us specify parameters that serve as function inputs, which may differ each time the code is run. Coding an operation as a function makes it a generally useful tool, which we can use in a variety of contexts.

More fundamentally, functions are the alternative to programming by cutting and pasting—rather than having multiple redundant copies of an operation’s code, we can factor it into a single function. In so doing, we reduce our future work radically: if the operation must be changed later, we only have one copy to update, not many.

Functions are the most basic program structure Python provides for maximizing code reuse and minimizing code redundancy. As we’ll see, functions are also a design tool that lets us split complex systems into manageable parts. Table 16-1 summarizes the primary function-related tools we’ll study in this part of the book.

Table 16-1. Function-related statements and expressions (Statement / Examples)

'''Calls'''

 {{{
myfunc('spam', 'eggs', meat=ham)
 }}}

'''`def`, `return`'''

 {{{
def adder(a, b=1, *c):
    return a + b + c[0]
 }}}

'''`global`'''

 {{{
def changer():
    global x; x = 'new'
 }}}

'''`nonlocal`'''

 {{{
def changer():
    nonlocal x; x = 'new'
 }}}

'''`yield`'''

 {{{
def squares(x):
    for i in range(x): yield i ** 2
 }}}

'''`lambda`'''

 {{{
funcs = [lambda x: x**2, lambda x: x*3]
 }}}

== Why Use Functions? ==

Before we get into the details, let’s establish a clear picture of what functions are all about. Functions are a nearly universal program-structuring device. You may have come across them before in other languages, where they may have been called subroutines or procedures. As a brief introduction, functions serve two primary development roles:

 * Maximizing code reuse and minimizing redundancy - As in most programming languages, Python functions are the simplest way to package logic you may wish to use in more than one place and more than one time. Up until now, all the code we’ve been writing has run immediately. Functions allow us to group and generalize code to be used arbitrarily many times later. Because they allow us to code an operation in a single place and use it in many places, Python functions are the most basic factoring tool in the language: they allow us to reduce code redundancy in our programs, and thereby reduce maintenance effort.

 * Procedural decomposition - Functions also provide a tool for splitting systems into pieces that have well-defined roles. For instance, to make a pizza from scratch, you would start by mixing the dough, rolling it out, adding toppings, baking it, and so on. If you were programming a pizza-making robot, functions would help you divide the overall “make pizza” task into chunks—one function for each subtask in the process. __It’s easier to implement the smaller tasks in isolation than it is to implement the entire process at once.__ In general, functions are about procedure—how to do something, rather than what you’re doing it to. We’ll see why this distinction matters in Part VI, when we start making new object with classes.

In this part of the book, we’ll explore the tools used to code functions in Python: function basics, ''scope rules'', and argument passing, along with a few related concepts such as ''generators'' and functional tools. Because its importance begins to become more apparent at this level of coding, we’ll also revisit the notion of polymorphism introduced earlier in the book. As you’ll see, functions don’t imply much new syntax, but they do lead us to some bigger programming ideas.

== Coding Functions ==

Although it wasn’t made very formal, we’ve already used some functions in earlier chapters. For instance, to make a file object, we called the built-in `open` function; similarly, we used the `len` built-in function to ask for the number of items in a collection object.

In this chapter, we will explore how to write new functions in Python. __Functions we write behave the same way as the built-ins we’ve already seen: they are called in expressions, are passed values, and return results.__ But writing new functions requires the application of a few additional ideas that haven’t yet been introduced. Moreover, functions behave very differently in Python than they do in compiled languages like C. Here is a brief introduction to the main concepts behind Python functions, all of which we will study in this part of the book:

 * `def` is executable code. Python functions are written with a new statement, the `def`. __'''Unlike functions in compiled languages such as C, `def` is an executable statement— your function does not exist until Python reaches and runs the `def`.''' In fact, it’s legal (and even occasionally useful) to nest `def` statements inside `if` statements, `while` loops, and even other `def`s. In typical operation, `def` statements are coded in module files and are naturally run to generate functions when a module file is first imported.__

 * `def` creates an object and assigns it to a name. __When Python reaches and runs a `def` statement, it generates a new ''function object'' and assigns it to the function’s name. As with all assignments, the function name becomes a reference to the function object. '''There’s nothing magic about the name of a function'''—as you’ll see, the function object can be assigned to other names, stored in a list, and so on.__ Function objects may also have arbitrary user-defined attributes attached to them to record data.

 * __`lambda` creates an object but returns it as a result. Functions may also be created with the `lambda` expression, a feature that allows us to '''in-line function definitions in places where a `def` statement won’t work syntactically (跟 Closure 的概念有點像)'''__ (this is a more advanced concept that we’ll defer until Chapter 19).

 * `return` sends a result object back to the caller. When a function is called, the caller stops until the function finishes its work and returns control to the caller. Functions that compute a value send it back to the caller with a `return` statement; the returned value becomes the result of the ''function call''.

 * __`yield` sends a result object back to the caller, but remembers where it left off. (保有狀態而言) Functions known as ''generators'' may also use the `yield` statement to send back a value and suspend their state such that they may be resumed later, to produce a series of results ''over time''.__ This is another advanced topic covered later in this part of the book.

 * __`global` declares ''module-level variables'' that are to be assigned. '''By default, all names assigned in a function are local to that function and exist only while the function runs.''' To assign a name in the ''enclosing module'', functions need to list it in a `global` statement.__ More generally, names are always looked up in scopes— places where variables are stored—and assignments bind names to scopes.

 * `nonlocal` declares ''enclosing function variables'' that are to be assigned. Similarly, the `nonlocal` statement added in Python 3.0 allows a function to assign a name that exists in the scope of a syntactically enclosing `def` statement. This allows enclosing functions to serve as a place to retain state—information remembered when a function is called—without using ''shared global names''. (跟 `yield` 有點像[?])

 * __Arguments are passed by ''assignment (object reference)''.__ In Python, arguments are passed to functions by assignment (which, as we’ve learned, means by object reference). As you’ll see, in Python’s model the caller and function share objects by references, but there is no ''name aliasing''. Changing an argument name within a function does not also change the corresponding name in the caller, but changing passed-in mutable objects can change objects shared by the caller.

 * Arguments, return values, and variables are not declared. As with everything in Python, there are no type constraints on functions. __In fact, nothing about a function needs to be declared ahead of time: you can pass in arguments of any type, return any kind of object, and so on. As one consequence, a single function can often be applied to a variety of object types—'''any objects that sport a compatible interface (methods and expressions) will do, regardless of their specific types. (這就是 Python 獨特之處, 只要執行期叫用得到, 就可以視為相容於某個 Interface; 對某個物件不同存取的組合, 就形成了所謂的 Interface, 有時也稱做 Protocol)'''__

If some of the preceding words didn’t sink in, don’t worry—we’ll explore all of these concepts with real code in this part of the book. Let’s get started by expanding on some of these ideas and looking at a few examples.

=== def Statements ===

The `def` statement creates a function object and assigns it to a name. Its general format is as follows:

 {{{
def <name>(arg1, arg2,... argN):
    <statements>
 }}}

As with all compound Python statements, `def` consists of a header line followed by a block of statements, usually indented (or a simple statement after the colon). The statement block becomes the function’s body—that is, the code Python executes each time the function is called.

The `def` header line specifies a function name that is assigned the function object, along with a list of zero or more arguments (sometimes called parameters) in parentheses. __The argument names in the header are ''assigned'' to the objects passed in parentheses at the point of call.__

Function bodies often contain a `return` statement:

 {{{
def <name>(arg1, arg2,... argN):
    ...
    return <value>
 }}}

The Python `return` statement can show up anywhere in a function body; it ends the function call and sends a result back to the caller. The `return` statement consists of an object expression that gives the function’s result. The `return` statement is optional; if it’s not present, the function exits when the control flow falls off the end of the function body. __Technically, a function without a `return` statement returns the `None` object automatically, but this return value is usually ignored.__

Functions may also contain `yield` statements, which are designed to produce a series of values over time, but we’ll defer discussion of these until we survey generator topics in Chapter 20.

=== def Executes at Runtime ===

The Python `def` is a true executable statement: when it runs, it creates a new function object and assigns it to a name. (Remember, all we have in Python is runtime; there is no such thing as a separate compile time.) Because it’s a statement, a `def` can appear anywhere a statement can—even nested in other statements. For instance, although `def`s normally are run when the module enclosing them is imported, __it’s also completely legal to nest a function `def` inside an `if` statement to select between alternative definitions: (為什麼不是進入 Function 後再做分支?)__

 {{{
if test:
    def func(): # Define func this way
        ...
else:
    def func(): # Or else this way
        ...
...
func() # Call the version selected and built
 }}}

__One way to understand this code is to realize that the `def` is much like an `=` statement: it simply assigns a name at runtime. Unlike in compiled languages such as C, Python functions do not need to be fully defined before the program runs. More generally, `def`s are not evaluated until they are reached and run, '''and the code inside `def`s is not evaluated until the functions are later called.'''__

__Because function definition happens at runtime, there’s nothing special about the function name. '''What’s important is the object to which it refers:'''__

 {{{
othername = func # Assign function object
othername() # Call func again
 }}}

__Here, the function was assigned to a different name and called through the new name.__ Like everything else in Python, functions are just objects; they are recorded explicitly in memory at program execution time. In fact, besides calls, functions allow arbitrary attributes to be attached to record information for later use: (應用在什麼地方[?])

 {{{
def func(): ... # Create function object
func() # Call object
func.attr = value # Attach attributes
 }}}

== A First Example: Definitions and Calls ==

Apart from such runtime concepts (which tend to seem most unique to programmers with backgrounds in traditional compiled languages), Python functions are straightforward to use. Let’s code a first real example to demonstrate the basics. As you’ll see, there are two sides to the function picture: a definition (the `def` that creates a function) and a call (an expression that tells Python to run the function’s body).

=== Definition ===

Here’s a definition typed interactively that defines a function called `times`, which returns the product of its two arguments:

 {{{
>>> def times(x, y): # Create and assign function
...     return x * y # Body executed when called
...
 }}}

When Python reaches and runs this `def`, it creates a new function object that packages the function’s code and assigns the object to the name `times`. Typically, such a statement is coded in a module file and runs when the enclosing file is imported; for something this small, though, the interactive prompt suffices.

=== Calls ===

After the `def` has run, you can call (run) the function in your program by adding parentheses after the function’s name. The parentheses may optionally contain one or more object arguments, to be passed (assigned) to the names in the function’s header:

 {{{
>>> times(2, 4) # Arguments in parentheses
8
 }}}

This expression passes two arguments to `times`. As mentioned previously, arguments are passed by assignment, so in this case the name `x` in the function header is assigned the value `2`, `y` is assigned the value `4`, and the function’s body is run. For this function, the body is just a `return` statement that sends back the result as the value of the call expression. The returned object was printed here interactively (as in most languages, 2 * 4 is 8 in Python), but if we needed to use it later we could instead assign it to a variable. For example:

 {{{
>>> x = times(3.14, 4) # Save the result object
>>> x
12.56
 }}}

Now, watch what happens when the function is called a third time, with very different kinds of objects passed in:

 {{{
>>> times('Ni', 4) # Functions are "typeless"
'NiNiNiNi'
 }}}

This time, our function means something completely different (Monty Python reference again intended). In this third call, a string and an integer are passed to `x` and `y`, instead of two numbers. Recall that `*` works on both numbers and sequences; because we never declare the types of variables, arguments, or return values in Python, we can use `times` to either multiply numbers or repeat sequences.

In other words, what our `times` function means and does depends on what we pass into it. This is a core idea in Python (and perhaps the key to using the language well[?]), which we’ll explore in the next section.

=== Polymorphism in Python ===

As we just saw, the very meaning of the expression `x * y` in our simple `times` function depends completely upon the kinds of objects that `x` and `y` are—thus, the same function can perform multiplication in one instance and repetition in another. Python leaves it up to the objects to do something reasonable for the syntax. __Really, `*` is just a dispatch mechanism that routes control to the objects being processed.__

__This sort of type-dependent behavior is known as ''polymorphism'', a term we first met in Chapter 4 that essentially means that the meaning of an operation depends on the objects being operated upon. Because it’s a dynamically typed language, polymorphism runs rampant in Python. In fact, every operation is a polymorphic operation in Python:__ printing, indexing, the `*` operator, and much more.

This is deliberate, and it accounts for much of the language’s conciseness and flexibility. A single function, for instance, can generally be applied to a whole category of object types automatically. __As long as those objects support the expected interface (a.k.a. ''protocol''), the function can process them. '''That is, if the objects passed into a function have the expected methods and expression operators, they are plug-and-play compatible with the function’s logic.'''__

Even in our simple times function, this means that any two objects that support a `*` will work, no matter what they may be, and no matter when they are coded. This function will work on two numbers (performing multiplication), or a string and a number (performing repetition), or any other combination of objects supporting the expected interface—even class-based objects we have not even coded yet.

Moreover, if the objects passed in do not support this expected interface, Python will detect the error when the `*` expression is run and raise an exception automatically. __It’s therefore pointless to code error checking ourselves. In fact, doing so would limit our function’s utility, as it would be restricted to work only on objects whose types we test for.__

__This turns out to be a crucial philosophical difference between Python and statically typed languages like C++ and Java: in Python, your code is not supposed to care about specific data types. If it does, it will be limited to working on just the types you anticipated when you wrote it, and it will not support other compatible object types that may be coded in the future. Although it is possible to test for types with tools like the `type` built-in function, doing so breaks your code’s flexibility. By and large, '''we code to object interfaces in Python, not data types.'''__

__Of course, this polymorphic model of programming means we have to test our code to detect errors, rather than providing type declarations a compiler can use to detect some types of errors for us ahead of time. In exchange for an initial bit of testing, though, we radically reduce the amount of code we have to write and radically increase our code’s flexibility. As you’ll learn, it’s a net win in practice. (不是很清楚這一段的意思[?])__

== A Second Example: Intersecting Sequences ==

Let’s look at a second function example that does something a bit more useful than multiplying arguments and further illustrates function basics.

In Chapter 13, we coded a `for` loop that collected items held in common in two strings. We noted there that the code wasn’t as useful as it could be because it was set up to work only on specific variables and could not be rerun later. Of course, we could copy the code and paste it into each place where it needs to be run, but this solution is neither good nor general—we’d still have to edit each copy to support different sequence names, and changing the algorithm would then require changing multiple copies.

=== Definition ===

By now, you can probably guess that the solution to this dilemma is to package the `for` loop inside a function. Doing so offers a number of advantages:

 * Putting the code in a function makes it a tool that you can run as many times as you like.

 * Because callers can pass in arbitrary arguments, functions are general enough to work on any two sequences (or other iterables) you wish to intersect.

 * When the logic is packaged in a function, you only have to change code in one place if you ever need to change the way the intersection works.

 * Coding the function in a module file means it can be imported and reused by any program run on your machine.

In effect, wrapping the code in a function makes it a general intersection utility:

 {{{
def intersect(seq1, seq2):
    res = [] # Start empty
    for x in seq1: # Scan seq1
        if x in seq2: # Common item?
            res.append(x) # Add to end
    return res
 }}}

The transformation from the simple code of Chapter 13 to this function is straightforward; we’ve just nested the original logic under a `def` header and made the objects on which it operates passed-in parameter names. Because this function computes a result, we’ve also added a `return` statement to send a result object back to the caller.

=== Calls ===

Before you can call a function, you have to make it. To do this, run its `def` statement, either by typing it interactively or by coding it in a module file and importing the file. Once you’ve run the `def`, you can call the function by passing any two sequence objects in parentheses:

 {{{
>>> s1 = "SPAM"
>>> s2 = "SCAM"
>>> intersect(s1, s2) # Strings
['S', 'A', 'M']
 }}}

Here, we’ve passed in two strings, and we get back a list containing the characters in common. The algorithm the function uses is simple: “for every item in the first argument, if that item is also in the second argument, append the item to the result.” It’s a little shorter to say that in Python than in English, but it works out the same.

To be fair, our `intersect` function is fairly slow (it executes nested loops), isn’t really mathematical intersection (there may be duplicates in the result), and isn’t required at all (as we’ve seen, Python’s `set` data type provides a built-in intersection operation). Indeed, the function could be replaced with a single list comprehension expression, as it exhibits the classic loop collector code pattern:

 {{{
>>> [x for x in s1 if x in s2]
['S', 'A', 'M']
 }}}

As a function basics example, though, it does the job—this single piece of code can apply to an entire range of object types, as the next section explains.

=== Polymorphism Revisited ===

Like all functions in Python, `intersect` is polymorphic. That is, it works on arbitrary types, as long as they support the expected object interface:

 {{{
>>> x = intersect([1, 2, 3], (1, 4)) # Mixed types
>>> x # Saved result object
[1]
 }}}

This time, we passed in different types of objects to our function—a `list` and a `tuple` (mixed types)—and it still picked out the common items. Because you don’t have to specify the types of arguments ahead of time, the `intersect` function happily iterates through any kind of sequence objects you send it, as long as they support the expected interfaces.

__For `intersect`, this means that the first argument has to support the `for` loop, and the second has to support the `in` membership test. Any two such objects will work, regardless of their specific types__—that includes physically stored sequences like strings and lists; all the iterable objects we met in Chapter 14, including files and dictionaries; and even any class-based objects we code that apply operator overloading techniques (we’ll discuss these later in the book).

This code will always work if we `intersect` files’ contents obtained with `file.readlines()`. It may not work to intersect lines in open input files directly, though, depending on the file object’s implementation of the `in` operator or general iteration. Files must generally be rewound (e.g., with a `file.seek(0)` or another open) after they have been read to end-of-file once. As we’ll see in Chapter 29 when we study operator overloading, classes implement the `in` operator either by providing the specific `__contains__` method or by supporting the general iteration protocol with the `__iter__` or older `__getitem__` methods; if coded, classes can define what iteration means for their data.

__Here again, if we pass in objects that do not support these interfaces (e.g., numbers), Python will automatically detect the mismatch and raise an exception for us—which is exactly what we want, and the best we could do on our own if we coded explicit type tests. '''By not coding type tests and allowing Python to detect the mismatches for us, we both reduce the amount of code we need to write and increase our code’s flexibility. (從其他語言轉過來, 心態上要做調適)'''__

=== Local Variables ===

Probably the most interesting part of this example is its names. It turns out that the variable `res` inside `intersect` is what in Python is called __a ''local variable''—a name that is visible only to code inside the function `def` and that exists only while the function runs.__ In fact, because all names assigned in any way inside a function are classified as local variables by default, nearly all the names in `intersect` are local variables:

 * `res` is obviously assigned, so it is a local variable.
 * Arguments are passed by assignment, so `seq1` and `seq2` are, too.
 * The `for` loop assigns items to a variable, so the name `x` is also local.

All these local variables appear when the function is called and disappear when the function exits—the `return` statement at the end of `intersect` sends back the result object, but the name `res` goes away. To fully explore the notion of locals, though, we need to move on to Chapter 17.

== Chapter Summary ==

This chapter introduced the core ideas behind function definition—the syntax and operation of the `def` and `return` statements, the behavior of function call expressions, and the notion and benefits of polymorphism in Python functions. As we saw, a `def` statement is executable code that creates a function object at runtime; when the function is later called, objects are passed into it by assignment (recall that assignment means object reference in Python, which, as we learned in Chapter 6, really means pointer internally), and computed values are sent back by `return`. We also began exploring the concepts of local variables and scopes in this chapter, but we’ll save all the details on those topics for Chapter 17. First, though, a quick quiz.

= Chapter 17. Scopes =

Chapter 16 introduced basic function definitions and calls. As we saw, Python’s basic function model is simple to use, but even simple function examples quickly led us to questions about the meaning of variables in our code. This chapter moves on to present the details behind Python’s scopes—the places where variables are defined and looked up. As we’ll see, the place where a name is assigned in our code is crucial to determining what the name means. __We’ll also find that scope usage can have a major impact on program maintenance effort; overuse of globals, for example, is a generally bad thing.__

== Python Scope Basics ==

Now that you’re ready to start writing your own functions, we need to get more formal about what names mean in Python. When you use a name in a program, Python creates, changes, or looks up the name in what is known as a namespace—a place where names live. When we talk about the search for a name’s value in relation to code, the term scope refers to a namespace: that is, the location of a name’s assignment in your code determines the scope of the name’s visibility to your code.

Just about everything related to names, including scope classification, happens at assignment time in Python. As we’ve seen, names in Python spring into existence when they are first assigned values, and they must be assigned before they are used. Because names are not declared ahead of time, Python uses the location of the assignment of a name to associate it with (i.e., bind it to) a particular namespace. In other words, the place where you assign a name in your source code determines the namespace it will live in, and hence its scope of visibility.

Besides packaging code, functions add an extra namespace layer to your programs— by default, all names assigned inside a function are associated with that function’s namespace, and no other. This means that:

 * Names defined inside a def can only be seen by the code within that def. You cannot even refer to such names from outside the function.

 * Names defined inside a def do not clash with variables outside the def, even if the same names are used elsewhere. A name X assigned outside a given def (i.e., in a different def or at the top level of a module file) is a completely different variable from a name X assigned inside that def.

In all cases, the scope of a variable (where it can be used) is always determined by where it is assigned in your source code and has nothing to do with which functions call which. In fact, as we’ll learn in this chapter, variables may be assigned in three different places, corresponding to three different scopes:

 * If a variable is assigned inside a def, it is local to that function.
 * If a variable is assigned in an enclosing def, it is nonlocal to nested functions.
 * If a variable is assigned outside all defs, it is global to the entire file.

We call this lexical scoping because variable scopes are determined entirely by the locations of the variables in the source code of your program files, not by function calls.

For example, in the following module file, the X = 99 assignment creates a global variable named X (visible everywhere in this file), but the X = 88 assignment creates a local variable X (visible only within the def statement):

 {{{
X = 99
def func():
X = 88
 }}}

Even though both variables are named X, their scopes make them different. The net effect is that function scopes help to avoid name clashes in your programs and help to make functions more self-contained program units.

=== Scope Rules ===

Before we started writing functions, all the code we wrote was at the top level of a module (i.e., not nested in a def), so the names we used either lived in the module itself or were built-ins predefined by Python (e.g., open). Functions provide nested namespaces (scopes) that localize the names they use, such that names inside a function won’t clash with those outside it (in a module or another function). Again, functions define a local scope, and modules define a global scope. The two scopes are related as follows:

 * The enclosing module is a global scope. Each module is a global scope—that is, a namespace in which variables created (assigned) at the top level of the module file live. Global variables become attributes of a module object to the outside world but can be used as simple variables within a module file.

 * The global scope spans a single file only. Don’t be fooled by the word “global” here—names at the top level of a file are only global to code within that single file. There is really no notion of a single, all-encompassing global file-based scope in Python. Instead, names are partitioned into modules, and you must always import a module explicitly if you want to be able to use the names its file defines. When you hear “global” in Python, think “module.”

 * Each call to a function creates a new local scope. Every time you call a function, you create a new local scope—that is, a namespace in which the names created inside that function will usually live. You can think of each def statement (and lambda expression) as defining a new local scope, but because Python allows functions to call themselves to loop (an advanced technique known as recursion), the local scope in fact technically corresponds to a function call—in other words, each call creates a new local namespace. Recursion is useful when processing structures whose shapes can’t be predicted ahead of time.

 * Assigned names are local unless declared global or nonlocal. By default, all the names assigned inside a function definition are put in the local scope (the namespace associated with the function call). If you need to assign a name that lives at the top level of the module enclosing the function, you can do so by declaring it in a global statement inside the function. If you need to assign a name that lives in an enclosing def, as of Python 3.0 you can do so by declaring it in a nonlocal statement.

 * All other names are enclosing function locals, globals, or built-ins. Names not assigned a value in the function definition are assumed to be enclosing scope locals (in an enclosing def), globals (in the enclosing module’s namespace), or builtins (in the predefined __builtin__ module Python provides).

There are a few subtleties to note here. First, keep in mind that code typed at the interactive command prompt follows these same rules. You may not know it yet, but code run interactively is really entered into a built-in module called __main__; this module works just like a module file, but results are echoed as you go. Because of this, interactively created names live in a module, too, and thus follow the normal scope rules: they are global to the interactive session. You’ll learn more about modules in the next part of this book.

Also note that any type of assignment within a function classifies a name as local. This includes = statements, module names in import, function names in def, function argument names, and so on. If you assign a name in any way within a def, it will become a local to that function.

Conversely, in-place changes to objects do not classify names as locals; only actual name assignments do. For instance, if the name L is assigned to a list at the top level of a module, a statement L = X within a function will classify L as a local, but L.append(X) will not. In the latter case, we are changing the list object that L references, not L itself— L is found in the global scope as usual, and Python happily modifies it without requiring a global (or nonlocal) declaration. As usual, it helps to keep the distinction between names and objects clear: changing an object is not an assignment to a name.

=== Name Resolution: The LEGB Rule ===

If the prior section sounds confusing, it really boils down to three simple rules. With a def statement:

 * Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in.

 * Name assignments create or change local names by default.

 * global and nonlocal declarations map assigned names to enclosing module and function scopes.

In other words, all names assigned inside a function def statement (or a lambda, an expression we’ll meet later) are locals by default. Functions can freely use names assigned in syntactically enclosing functions and the global scope, but they must declare such nonlocals and globals in order to change them.

Python’s name-resolution scheme is sometimes called the LEGB rule, after the scope names:

 * When you use an unqualified name inside a function, Python searches up to four scopes—the local (L) scope, then the local scopes of any enclosing (E) defs and lambdas, then the global (G) scope, and then the built-in (B) scope—and stops at the first place the name is found. If the name is not found during this search, Python reports an error. As we learned in Chapter 6, names must be assigned before they can be used.

 * When you assign a name in a function (instead of just referring to it in an expression), Python always creates or changes the name in the local scope, unless it’s declared to be global or nonlocal in that function.

 * When you assign a name outside any function (i.e., at the top level of a module file, or at the interactive prompt), the local scope is the same as the global scope— the module’s namespace.

Figure 17-1 illustrates Python’s four scopes. Note that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup layer. This case only comes into play when you nest functions within functions, and it is addressed by the nonlocal statement.

{{attachment:figure_17-1.png}} <<BR>> Figure 17-1. The LEGB scope lookup rule. When a variable is referenced, Python searches for it in this order: in the local scope, in any enclosing functions’ local scopes, in the global scope, and finally in the built-in scope. The first occurrence wins. The place in your code where a variable is assigned usually determines its scope. In Python 3, nonlocal declarations can also force names to be mapped to enclosing function scopes, whether assigned or not.

The scope lookup rule was called the “LGB rule” in the first edition of this book. The enclosing def “E” layer was added later in Python to obviate the task of passing in enclosing scope names explicitly with default arguments—a topic usually of marginal interest to Python beginners that we’ll defer until later in this chapter. Since this scope is addressed by the nonlocal statement in Python 3.0, I suppose the lookup rule might now be better named “LNGB,” but backward compatibility matters in books, too!

Also keep in mind that these rules apply only to simple variable names (e.g., spam). In Parts V and VI, we’ll see that qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here. References to attribute names following periods (.) search one or more objects, not scopes, and may invoke something called “inheritance”; more on this in Part VI of this book.

=== Scope Example ===

Let’s look at a larger example that demonstrates scope ideas. Suppose we wrote the following code in a module file:

 {{{
# Global scope
X = 99 # X and func assigned in module: global

def func(Y): # Y and Z assigned in function: locals
    # Local scope
    Z = X + Y # X is a global
    return Z

func(1) # func in module: result=100
 }}}

This module and the function it contains use a number of names to do their business. Using Python’s scope rules, we can classify the names as follows:

 * Global names: X, func - X is global because it’s assigned at the top level of the module file; it can be referenced inside the function without being declared global. func is global for the same reason; the def statement assigns a function object to the name func at the top level of the module.

 * Local names: Y, Z - Y and Z are local to the function (and exist only while the function runs) because they are both assigned values in the function definition: Z by virtue of the = statement, and Y because arguments are always passed by assignment.

The whole point behind this name-segregation scheme is that local variables serve as temporary names that you need only while a function is running. For instance, in the preceding example, the argument Y and the addition result Z exist only inside the function; these names don’t interfere with the enclosing module’s namespace (or any other function, for that matter).

The local/global distinction also makes functions easier to understand, as most of the names a function uses appear in the function itself, not at some arbitrary place in a module. Also, because you can be sure that local names will not be changed by some remote function in your program, they tend to make programs easier to debug and modify.

=== The Built-in Scope ===

We’ve been talking about the built-in scope in the abstract, but it’s a bit simpler than you may think. Really, the built-in scope is just a built-in module called builtins, but you have to import builtins to query built-ins because the name builtins is not itself built-in....

No, I’m serious! The built-in scope is implemented as a standard library module named builtins, but that name itself is not placed in the built-in scope, so you have to import it in order to inspect it. Once you do, you can run a dir call to see which names are predefined. In Python 3.0:

 {{{
>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis',
    ...many more names omitted...
'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set',
'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple',
'type', 'vars', 'zip']
 }}}

The names in this list constitute the built-in scope in Python; roughly the first half are built-in exceptions, and the second half are built-in functions. Also in this list are the special names None, True, and False, though they are treated as reserved words. Because Python automatically searches this module last in its LEGB lookup, you get all the names in this list “for free;” that is, you can use them without importing any modules. Thus, there are really two ways to refer to a built-in function—by taking advantage of the LEGB rule, or by manually importing the builtins module:

 {{{
>>> zip # The normal way
<class 'zip'>
>>> import builtins # The hard way
>>> builtins.zip
<class 'zip'>
 }}}

The second of these approaches is sometimes useful in advanced work. The careful reader might also notice that because the LEGB lookup procedure takes the first occurrence of a name that it finds, names in the local scope may override variables of the same name in both the global and built-in scopes, and global names may override builtins. A function can, for instance, create a local variable called open by assigning to it:

 {{{
def hider():
    open = 'spam' # Local variable, hides built-in
    ...
    open('data.txt') # This won't open a file now in this scope!
 }}}

However, this will hide the built-in function called open that lives in the built-in (outer) scope. It’s also usually a bug, and a nasty one at that, because Python will not issue a warning message about it (there are times in advanced programming where you may really want to replace a built-in name by redefining it in your code).

Functions can similarly hide global variables of the same name with locals:

 {{{
X = 88 # Global X

def func():
    X = 99 # Local X: hides global

func()
print(X) # Prints 88: unchanged
 }}}

Here, the assignment within the function creates a local X that is a completely different variable from the global X in the module outside the function. Because of this, there is no way to change a name outside a function without adding a global (or nonlocal) declaration to the def, as described in the next section.

 Version skew note: Actually, the tongue twisting gets a bit worse. The Python 3.0 builtins module used here is named __builtin__ in Python 2.6. And just for fun, the name __builtins__ (with the “s”) is preset in most global scopes, including the interactive session, to reference the module known as builtins (a.k.a. __builtin__ in 2.6).

 That is, after importing builtins, __builtins__ is builtins is True in 3.0, and __builtins__ is __builtin__ is True in 2.6. The net effect is that we can inspect the built-in scope by simply running dir(__builtins__) with no import in both 3.0 and 2.6, but we are advised to use builtins for real work in 3.0. Who said documenting this stuff was easy?

==== Breaking the Universe in Python 2.6 ====

Here’s another thing you can do in Python that you probably shouldn’t—because the names True and False in 2.6 are just variables in the built-in scope and are not reserved, it’s possible to reassign them with a statement like True = False. Don’t worry, you won’t actually break the logical consistency of the universe in so doing! This statement merely redefines the word True for the single scope in which it appears. All other scopes still find the originals in the built-in scope.

For more fun, though, in Python 2.6 you could say __builtin__.True = False, to reset True to False for the entire Python process. Alas, this type of assignment has been disallowed in Python 3.0, because True and False are treated as actual reserved words, just like None. In 2.6, though, it sends IDLE into a strange panic state that resets the user code process.

This technique can be useful, however, both to illustrate the underlying namespace model and for tool writers who must change built-ins such as open to customized functions. Also, note that third-party tools such as PyChecker will warn about common programming mistakes, including accidental assignment to built-in names (this is known as “shadowing” a built-in in PyChecker).

== The global Statement ==

:::

= Chapter 19. Advanced Function Topics =

:::

== Anonymous Functions: lambda ==

__Besides the `def` statement, Python also provides an expression form that ''generates function objects''. Because of its similarity to a tool in the Lisp language, it’s called `lambda`.* Like `def`, this expression creates a function to be called later, but it returns the function instead of assigning it to a name. This is why `lambda`s are sometimes known as ''anonymous (i.e., unnamed) functions''. In practice, they are often used as a way to ''inline a function definition'', or to ''defer execution of a piece of code''.__

FOOTNOTE: The `lambda` tends to intimidate people more than it should. This reaction seems to stem from the name “lambda” itself—a name that comes from the Lisp language, which got it from lambda calculus, which is a form of symbolic logic. __In Python, though, it’s really just a keyword that introduces the expression syntactically.__ Obscure mathematical heritage aside, `lambda` is simpler to use than you may think.

=== lambda Basics ===

__The `lambda`’s general form is the keyword `lambda`, followed by one or more arguments (exactly like the arguments list you enclose in parentheses in a `def` header), followed by an expression after a colon:__

 {{{
lambda argument1, argument2,... argumentN :expression using arguments
 }}}

__Function objects returned by running `lambda` expressions work exactly the same as those created and assigned by `def`s, but there are a few differences that make `lambda`s useful in specialized roles:__

 * __`lambda` is an expression, not a statement. Because of this, a `lambda` can appear in places a `def` is not allowed by Python’s syntax—inside a list literal or a function call’s arguments, for example. As an expression, `lambda` returns a value (a new function) that can ''optionally'' be assigned a name. In contrast, the `def` statement always assigns the new function to the name in the header, instead of returning it as a result.__

 * __`lambda`’s body is a single expression, not a block of statements. The `lambda`’s body is similar to what you’d put in a `def` body’s `return` statement; you simply type the result as a ''naked expression'', instead of explicitly returning it. Because it is limited to an expression, a `lambda` is less general than a `def`—you can only squeeze so much logic into a `lambda` body without using statements such as `if`. This is by design, to limit program nesting: `lambda` is designed for coding simple functions, and `def` handles larger tasks.__

Apart from those distinctions, `def`s and `lambda`s do the same sort of work. For instance, we’ve seen how to make a function with a `def` statement:

 {{{
>>> def func(x, y, z): return x + y + z
...
>>> func(2, 3, 4)
9
 }}}

__But you can achieve the same effect with a `lambda` expression by explicitly assigning its result to a name through which you can later call the function:__

 {{{
>>> f = lambda x, y, z: x + y + z
>>> f(2, 3, 4)
9
 }}}

Here, `f` is assigned the function object the `lambda` expression creates; this is how `def` works, too, but its assignment is automatic.

__Defaults work on `lambda` arguments, just like in a `def`:__

 {{{
>>> x = (lambda a="fee", b="fie", c="foe": a + b + c)
>>> x("wee")
'weefiefoe'
 }}}

__The code in a `lambda` body also follows the same ''scope lookup rules'' as code inside a `def`. `lambda` expressions introduce a ''local scope'' much like a nested `def`, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule):__

 {{{
>>> def knights():
... title = 'Sir'
... action = (lambda x: title + ' ' + x) # Title in enclosing def
... return action # Return a function
...
>>> act = knights()
>>> act('robin')
'Sir robin'
 }}}

In this example, prior to Release 2.2, the value for the name `title` would typically have been passed in as a default argument value instead; flip back to the scopes coverage in Chapter 17 if you’ve forgotten why.

:::

== Mapping Functions over Sequences: map ==

__One of the more common things programs do with lists and other sequences is apply an operation to each item and collect the results.__ For instance, updating all the counters in a list can be done easily with a `for` loop:

 {{{
>>> counters = [1, 2, 3, 4]
>>>
>>> updated = []
>>> for x in counters:
... updated.append(x + 10) # Add 10 to each item
...
>>> updated
[11, 12, 13, 14]
 }}}

__But because this is such a common operation, Python actually provides a built-in that does most of the work for you. The `map` function applies a passed-in function to each item in an iterable object and returns a list containing all the function call results.__ For example:

 {{{
>>> def inc(x): return x + 10 # Function to be run
...
>>> list(map(inc, counters)) # Collect results
[11, 12, 13, 14]
 }}}

We met `map` briefly in Chapters 13 and 14, as a way to apply a built-in function to items in an iterable. Here, we make better use of it by passing in a user-defined function to be applied to each item in the list—map calls `inc` on each list item and collects all the return values into a new list. __Remember that `map` is an iterable in Python 3.0, so a `list` call is used to force it to produce all its results for display here; this isn’t necessary in 2.6. (不然是幾版之前需要這麼做？)__

__Because `map` expects a function to be passed in, it also happens to be one of the places where `lambda` commonly appears:__

 {{{
>>> list(map((lambda x: x + 3), counters)) # Function expression
[4, 5, 6, 7]
 }}}

Here, the function adds 3 to each item in the counters list; as this little function isn’t needed elsewhere, it was written inline as a `lambda`. Because such uses of `map` are equivalent to for loops, with a little extra code you can always code a general mapping utility yourself:

 {{{
>>> def mymap(func, seq):
... res = []
... for x in seq: res.append(func(x))
... return res
 }}}

Assuming the function `inc` is still as it was when it was shown previously, we can map it across a sequence with the built-in or our equivalent:

 {{{
>>> list(map(inc, [1, 2, 3])) # Built-in is an iterator
[11, 12, 13]
>>> mymap(inc, [1, 2, 3]) # Ours builds a list (see generators)
[11, 12, 13]
 }}}

__However, as `map` is a built-in, it’s always available, always works the same way, and has some performance benefits (as we’ll prove in the next chapter, it’s usually faster than a manually coded `for` loop).__ Moreover, `map` can be used in more advanced ways than shown here. For instance, given multiple sequence arguments, it sends items taken from sequences in parallel as distinct arguments to the function:

>>> pow(3, 4) # 3**4
81
>>> list(map(pow, [1, 2, 3], [2, 3, 4])) # 1**2, 2**3, 3**4
[1, 8, 81]

With multiple sequences, map expects an N-argument function for N sequences. Here, the pow function takes two arguments on each call—one from each sequence passed to map. It’s not much extra work to simulate this multiple-sequence generality in code, too, but we’ll postpone doing so until later in the next chapter, after we’ve met some additional iteration tools.

The map call is similar to the list comprehension expressions we studied in Chapter 14 and will meet again in the next chapter, but map applies a function call to each item instead of an arbitrary expression. Because of this limitation, it is a somewhat less general tool. However, in some cases map may be faster to run than a list comprehension (e.g., when mapping a built-in function), and it may also require less coding.

