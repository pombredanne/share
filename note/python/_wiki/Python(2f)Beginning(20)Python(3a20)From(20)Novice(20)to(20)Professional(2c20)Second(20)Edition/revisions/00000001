= Beginning Python: From Novice to Professional, Second Edition =
http://www.apress.com/book/view/1590599829
<<TableOfContents>>

= About the Author =

MAGNUS LIE HETLAND is an associate professor(副教授) of algorithms at the Norwegian University of Science and Technology (NTNU). Even though he loves learning new programming languages—even quite obscure(難解的) ones—Magnus has been a devoted Python fan and an active member of the Python community for many years, and is the author of the popular online tutorials “Instant Python” and “Instant Hacking.” His publications include the forerunner(前身) to this book, http://hetland.org/writing/practical-python/[Practical Python] (Apress, 2002), as well as several scientific papers(科學著作). When he isn’t busy staring(注視) at a computer screen, he may be found reading (even while bicycling), acting (演戲; in a local theater group), or gaming (mostly role-playing games).

= About the Technical Reviewer =

RICHARD TAYLOR is a senior analyst at QinetiQ Ltd in the UK, where he specializes in open systems architectures for command and control systems. He has been developing in Python since about 1994, and has used Python to build many large-scale commercial and research applications. When not working, Richard indulges(縱情) his keen(熱切的) interest in genealogy(族譜) and open source software, and is a regular contributor to the http://gramps-project.org/[GRAMPS] (Genealogical Research and Analysis Management Programming System) project.

= Preface =

:::

= Introduction =

 * A C program is like a fast dance on a newly waxed(打蠟的) dance floor by people carrying razors(剃刀). —Waldi Ravens
 * C++: Hard to learn and built to stay that way. —Anonymous
 * Java is, in many ways, C++--. —Michael Feldman
 * And now for something completely different . . . —Monty Python’s Flying Circus

I’ve started this introduction with a few quotes to set the tone(定調) for the book, which is rather informal. In the hope of making it an easy read, I’ve tried to approach the topic of Python programming with a healthy dose(劑量) of humor, and true to the traditions of the Python community, much of this humor is related to http://en.wikipedia.org/wiki/Monty_Python[Monty Python] sketches(短劇). As a consequence, some of my examples may seem a bit silly; I hope you will bear with(容忍) me. (And, yes, the name Python is derived from Monty Python, not from snakes belonging to the family Pythonidae(蟒科).)

In this introduction, I give you a quick look at what Python is, why you should use it, who uses it, who this book’s intended audience is, and how the book is organized.

So, what is Python, and why should you use it? To quote an official blurb (誇張的介紹詞; available from [[http://python.org/doc/essays/blurb.html]]), it is “an interpreted, object-oriented, high-level programming language with dynamic semantics.” Many of these terms will become clear as you read this book, but the gist(要點) is that __Python is a programming language that knows how to stay out of(不插手) your way when you write your programs. '''It enables you to implement the functionality you want without any hassle(爭論),''' and lets you write programs that are clear and readable (much more so than programs in most other currently popular programming languages).__

__Even though Python might not be as fast as compiled languages such as C or C++, '''what you save in programming time will probably be worth using it, and in most programs, the speed difference won’t be noticeable anyway.''' If you are a C programmer, you can easily implement the critical parts of your program in C at a later date, and have them interoperate with the Python parts. (跟 Java JIT 的概念很類似)__ If you haven’t done any programming before (and perhaps are a bit confused by my references to C and C++), Python’s combination of simplicity and power makes it an ideal choice as a place to start.

So, who uses Python? Since http://en.wikipedia.org/wiki/Guido_van_Rossum[Guido van Rossum] created the language in the early 1990s, its following has grown steadily(不斷地), and interest has increased markedly(明顯地) in the past few years. __Python is used extensively for system administration tasks (it is, for example, a vital(不可缺少的) component of several Linux distributions), '''but it is also used to teach programming to complete beginners.'''__ The US National Aeronautics and Space Administration (NASA) uses Python both for development and as a scripting language in several of its systems. http://www.ilm.com/[Industrial Light & Magic] uses Python in its production of special effects for large-budget feature films. Yahoo! uses it (among other things) to manage its discussion groups. Google has used it to implement many components of its web crawler and search engine. Python is being used in such diverse(各種不同的) areas as computer games and http://en.wikipedia.org/wiki/Bioinformatics[bioinformatics(生物訊息學)]. Soon one might as well ask, “Who isn’t using Python?”

This book is for those of you who want to learn how to program in Python. It is intended to suit a wide audience, from neophyte(初學者) programmer to advanced computer wiz(天才). __If you have never programmed before, you should start by reading Chapter 1 and continue until you find that things get too advanced for you (if, indeed, they do). '''Then you should start practicing and write some programs of your own.''' When the time is right, you can return to the book and proceed with the more intricate(複雜難懂的) stuff.__

If you already know how to program, some of the introductory material might not be new to you (although there will probably be some surprising details here and there). You could skim through the early chapters to get an idea of how Python works, or perhaps read through __Appendix A, which is based on my online Python tutorial “Instant Python.” It will get you up to speed on the most important Python concepts. After getting the big picture, you could jump straight to Chapter 10 (which describes the Python standard libraries; 從 Appendix 直接跳到 Chapter 10, 還真是速成!!).__

The last ten chapters present ten programming projects, which show off various capabilities of the Python language. These projects should be of interest to beginners and experts alike. Although some of the material in the later projects may be a bit difficult for an inexperienced programmer, following the projects in order (after reading the material in the first part of the book) should be possible.

The projects touch upon a wide range of topics, most of which will be very useful to you when writing programs of your own. You will learn how to do things that may seem completely out of reach(力所不及的) to you at this point, such as creating a chat server, a peer-to-peer file sharing system, or a full-fledged graphical computer game. Although much of the material may seem hard at first glance, I think you will be surprised by how easy most of it really is. If you would like to download the source code, it’s available from the Source Code/Download section of the Apress web site ([[http://www.apress.com]]).

Well, that’s it. I always find long introductions boring myself, so I’ll let you continue with your ''Pythoneering'', either in Chapter 1 or in Appendix A. Good luck, and happy hacking.

= Chapter 1. Instant Hacking: The Basics =

It’s time to start hacking. (Hacking is not the same as cracking, which is a term describing computer crime. The two are often confused. Hacking basically means “having fun while programming.” For more information, see Eric Raymond’s article “How to Become a Hacker” at [[http://www.catb.org/~esr/faqs/hacker-howto.html]]) In this chapter, you learn how to take control of your computer by speaking a language it understands: Python. Nothing here is particularly difficult, so if you know the basic principles of how your computer works, you should be able to follow the examples and try them out yourself. I’ll go through the basics, starting with the excruciatingly(極其地) simple, but because Python is such a powerful language, you’ll soon be able to do pretty advanced things.

First, I show you how to get the software you need. Then I tell you a bit about algorithms and their main components. Throughout these sections, there are numerous small examples (most of them using only simple arithmetic) that you can try out in the Python ''interactive interpreter'' (covered in the section “The Interactive Interpreter” in this chapter). You learn about variables, functions, and modules, and after handling these topics, I show you how to write and run larger programs. Finally, I deal with strings, an important aspect of almost any Python program.

== Installing Python ==

Before you can start programming, you need some new software. What follows is a short description of how to download and install Python. If you want to jump into the installation process without detailed guidance, you can simply visit http://www.python.org/download to get the most recent version of Python.

=== Windows ===

To install Python on a Windows machine, follow these steps:

 1. Open a web browser and go to [[http://www.python.org]].

 2. Click the Download link.

 3. You should see several links here, with names such as Python 2.5.x and Python 2.5.x Windows installer. Click the Windows installer link to download the installer file. (If you’re running on an Itanium or AMD machine, you need to choose the appropriate installer; 因為是 64 位元的架構, 所以要下載不同的檔案) <<BR>> Note: If you can’t find the link mentioned in step 3, click the link with the highest version among those with names like Python 2.5.x. For Python 2.5, you could simply go to [[http://www.python.org/2.5]]. Follow the instructions for Windows users. This will entail downloading a file called `python-2.5.x.msi` (or something similar), where 2.5.x should be the version number of the newest release.

 4. Store the Windows Installer file somewhere on your computer, such as `C:\download\python-2.5.x.msi`. (Just create a directory where you can find it later.)

 5. Run the downloaded file by double-clicking it in Windows Explorer. This brings up the Python install wizard, which is really easy to use. Just accept the default settings, wait until the installation is finished, and you’re ready to roll!

Assuming that the installation went well, you now have a new program in your Windows Start menu. Run the Python Integrated Development Environment (IDLE) by selecting Start ➤ Programs ➤ Python (This menu option will probably include your version number, as in Python 2.5) ➤ IDLE (Python GUI).

You should now see a window that looks like the one shown in Figure 1-1. If you feel a bit lost, simply select Help ➤ IDLE Help from the menu to get a simple description of the various menu items and basic usage. For more documentation on IDLE, check out [[http://www.python.org/idle]]. (Here you will also find more information on running IDLE on platforms other than Windows.) If you press F1, or select Help ➤ Python Docs from the menu, you will get the full Python documentation. (The document there of most use to you will probably be the Library Reference.) All the documentation is searchable.

attachment:figure_1-1.png <<BR>> Figure 1-1. The IDLE interactive Python shell

Once you have the IDLE interactive Python shell running, you can continue with the section “The Interactive Interpreter,” later in this chapter.

{{{#!wiki note
'''WINDOWS INSTALLER'''

Python for Microsoft Windows is distributed as a ''Windows Installer'' file, and requires that your Windows version supports Windows Installer 2.0 (or later). If you don’t have Windows Installer, it can be downloaded freely for Windows 95, 98, ME, NT 4.0, and 2000. __Windows XP and later versions of Windows already have Windows Installer, and many older machines will, too.__ There are download instructions for the Installer on the Python download page.

Alternatively, you could go to the Microsoft download site, [[http://www.microsoft.com/downloads]], and search for “Windows Installer” (or simply select it from the download menu). Choose the most recent version for your platform and follow the download and installation instructions.

If you’re uncertain about whether you have Windows Installer, simply try executing step 5 of the previous installation instructions: double-click the MSI file. If you get the install wizard, everything is okay. See http://www.python.org/2.5/msi.html for advanced features of the Windows Installer related to Python installation.
}}}

=== Linux and UNIX ===

In most Linux and UNIX installations (including Mac OS X), a Python interpreter will already be present. You can check whether this is the case for you by running the python command at the prompt, as follows:

 {{{
$ python
 }}}

Running this command should start the interactive Python interpreter, with output similar to the following:

 {{{
Python 2.5.1 (r251:54869, Apr 18 2007, 22:08:04)
[GCC 4.0.1 (Apple Computer, Inc. build 5367)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>>
 }}}

Note: __To exit the interactive interpreter, use Ctrl-D (press the Ctrl key and while keeping that depressed, press D).__

If there is no Python interpreter installed, you will probably get an error message similar to the following:

 {{{
bash: python: command not found
 }}}

In that case, you need to install Python yourself, as described in the following sections.

==== Using a Package Manager ====

Several package systems and installation mechanisms exist for Linux. If you’re running a Linux system with some form of package manager, chances are you can get Python through it.

Note: You will probably need to have administrator privileges (a root account) in order to install Python using a package manager in Linux.

For example, if you’re running Debian Linux, you should be able to install Python with the following command:

 {{{
$ apt-get install python
 }}}

If you’re running Gentoo Linux, you should be able to use Portage, like this:

 {{{
$ emerge python
 }}}

In both cases, `$` is, of course, the bash prompt.

Note: Many other package managers out there have automatic download capabilities, including Yum, Synaptic (specific to Ubuntu Linux), and other Debian-style managers. You should probably be able to get recent versions of Python through these.

==== Compiling from Sources ====

If you don’t have a package manager, or would rather not use it, you can compile Python yourself. __This may be the method of choice if you are on a UNIX box but you don’t have root access (installation privileges). This method is very flexible, and enables you to install Python wherever you want, including in your own home directory.__ To compile and install Python, follow these steps:

 1. Go to the download page (refer to steps 1 and 2 in the instructions for installing Python on a Windows system).

 2. Follow the instructions for downloading the sources.

 3. Download the file with the extension `.tgz`. Store it in a temporary location. Assuming that you want to install Python in your home directory, you may want to put it in a directory such as `~/python`. Enter this directory (e.g., using `cd ~/python`).

 4. Unpack the archive with the command `tar -xzvf Python-2.5.tgz` (where 2.5 is the version number of the downloaded source code). If your version of `tar` doesn’t support the `z` option, you may want to uncompress the archive with `gunzip` first, and then use `tar -xvf` afterward. If there is something wrong with the archive, try downloading it again. Sometimes errors occur during download.

 5. Enter the unpacked directory:

 {{{
$ cd Python-2.5
 }}}

Now you should be able to execute the following commands:

 {{{
./configure --prefix=$(pwd)
make
make install
 }}}

You should end up with an executable file called `python` in the current directory. (If this doesn’t work, consult the `README` file included in the distribution.) Put the current directory in your `PATH` environment variable, and you’re ready to rock.

To find out about the other configuration directives, execute this command:

 {{{
./configure --help
 }}}

=== Macintosh ===

If you’re using a Macintosh with a recent version of Mac OS X, you’ll have a version of Python installed already. Just open the Terminal application and enter the command python to start it. Even if you would like to install a newer version of Python, you should leave this one alone, as it is used in several parts of the operating system. You could use either MacPorts (http:// macports.org) or Fink (http://finkproject.org), or you could use the distribution from the Python web site, by following these steps:

 1. Go to the standard download page (see steps 1 and 2 from the Windows instructions earlier in this chapter).

 2. Follow the link for the Mac OS X installer. There should also be a link to the !MacPython download page, which has more information. The !MacPython page also has versions of Python for older versions of the Mac OS.

 3. Once you’ve downloaded the installer `.dmg` file, it will probably mount automatically. If not, simply double-click it. In the mounted disk image, you’ll find an installer package (`.mpkg`) file. If you double-click this, the installation wizard will open, which will take you through the necessary steps.

=== Other Distributions ===

You now have the ''standard Python'' distribution installed. Unless you have a particular interest in alternative solutions, that should be all you need. If you are curious (and, perhaps, feeling a bit courageous), read on.

Several Python distributions are available in addition to the official one. The most wellknown of these is probably !ActivePython, which is available for Linux, Windows, Mac OS X, and several UNIX varieties. A slightly less well-known but quite interesting distribution is Stackless Python. These distributions are based on the standard implementation of Python, written in the C programming language. Two distributions that take a different approach are Jython and !IronPython. If you’re interested in development environments other than IDLE, Table 1-1 lists some options.

Table 1-1. Some Integrated Development Environments (IDEs) for Python

|| Environment || Description || Web Site ||
|| IDLE || The standard Python environment || http://www.python.org/idle ||
|| Pythonwin || Windows-oriented environment || http://www.python.org/download/windows ||
|| !ActivePython || Feature-packed; contains Pythonwin IDE || http://www.activestate.com/activepython/ ||
|| Komodo || Commercial IDE (Komodo has been made open source, so free versions are also available) || http://www.activestate.com ||
|| Wingware || Commercial IDE || http://www.wingware.com ||
|| !BlackAdder || Commercial IDE and (Qt) GUI builder || http://www.thekompany.com ||
|| Boa Constructor || Free IDE and GUI builder || http://boa-constructor.sf.net ||
|| Anjuta || Versatile(多用途的) IDE for Linux/UNIX || http://anjuta.sf.net ||
|| Arachno Python || Commercial IDE || http://www.python-ide.com ||
|| Code Crusader || Commercial IDE || http://www.newplanetsoftware.com ||
|| Code Forge || Commercial IDE http://www.codeforge.com ||
|| Eclipse || Popular, flexible, open source IDE || http://www.eclipse.org ||
|| eric || Free IDE using Qt || http://eric-ide.sf.net ||
|| KDevelop || Cross-language IDE for KDE || http://www.kdevelop.org ||
|| !VisualWx || Free GUI builder || http://visualwx.altervista.org ||
|| wxDesigner || Commercial GUI builder || http://www.roebling.de ||
|| wxGlade || Free GUI builder || http://wxglade.sf.net ||

!ActivePython is a Python distribution from !ActiveState ([[http://www.activestate.com]]). At its core, it’s the same as the standard Python distribution for Windows. __The main difference is that it includes a lot of extra goodies (modules) that are available separately.__ It’s definitely worth a look if you are running Windows.

Stackless Python is a reimplementation of Python, based on the original code, but with some important internal changes. To a beginning user, these differences won’t matter much, and one of the more standard distributions would probably be more useful. __The main advantages of Stackless Python are that it allows deeper levels of recursion and more efficient multithreading.__ As mentioned, both of these are rather advanced features, not needed by the average user. You can get Stackless Python from [[http://www.stackless.com]].

Jython ([[http://www.jython.org]]) and !IronPython ([[http://www.codeplex.com/IronPython]]) are different—they’re versions of Python implemented in other languages. __Jython is implemented in Java, targeting the Java Virtual Machine, and !IronPython is implemented in C#, targeting the .NET and MONO implementations of the common language runtime (CLR). At the time of writing, Jython is ''quite stable'', but lagging behind Python—the current Jython version is 2.2, while Python is at 2.5. There are significant differences in these two versions of the language. !IronPython is still rather young, but it is quite usable, and it is '''reported to be faster than standard Python on some benchmarks.'''__

=== Keeping in Touch and Up-to-Date ===

The Python language evolves continuously. To find out more about recent releases and relevant tools, the python.org web site is an invaluable asset. To find out what’s new in a given release, go to the page for the given release, such as http://python.org/2.5 for release 2.5. There you will also find a link to Andrew Kuchling’s in-depth description of what’s new for the release, with a URL such as http://python.org/doc/2.5/whatsnew for release 2.5. If there have been new releases since this book went to press, you can use these web pages to check out any new features.

Tip: For a summary of what’s changed in the more radically new release 3.0, see [[http://docs.python.org/dev/3.0/whatsnew/3.0.html]]. (原來早從 2008 年就開始在談 Python 3.x 了)

If you want to keep up with newly released third-party modules or software for Python, check out the Python email list `python-announce-list`; for general discussions about Python, try `python-list`, but be warned: this list gets a lot of traffic. Both of these lists are available at [[http://mail.python.org]]. If you’re a Usenet user, these two lists are also available as the newsgroups `comp.lang.python.announce` and `comp.lang.python`, respectively. If you’re totally lost, you could try the `python-help` list (available from the same place as the two other lists) or simply email `help@python.org`. Before you do, you really ought to see if your question is a frequently asked one, by consulting the Python FAQ, at [[http://python.org/doc/faq]], or by performing a quick Web search.

== The Interactive Interpreter ==

When you start up Python, you get a prompt similar to the following:

 {{{
Python 2.5.1 (r251:54869, Apr 18 2007, 22:08:04)
[GCC 4.0.1 (Apple Computer, Inc. build 5367)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>>
 }}}

Note: The exact appearance of the interpreter and its error messages will depend on which version you are using.

This might not seem very interesting, but believe me—it is. This is your gateway to hackerdom— your first step in taking control of your computer. In more pragmatic terms, it’s an interactive Python interpreter. Just to see if it’s working, try the following:

 {{{
>>> print "Hello, world!"
 }}}

When you press the Enter key, the following output appears:

 {{{
Hello, world!
>>>
 }}}

Note: If you are familiar with other computer languages, you may be used to terminating every line with a semicolon. __There is no need to do so in Python. '''A line is a line, more or less.''' You may add a semicolon if you like, but it won’t have any effect (unless more code follows on the same line), and it is not a common thing to do.__

What happened here? The `>>>` thingy is the prompt. You can write something in this space, like `print "Hello, world!"`. If you press Enter, the Python interpreter prints out the string “Hello, world!” and you get a new prompt below that.

Note: The term “printing” in this context refers to writing text to the screen, not producing hard copies with a printer.

What if you write something completely different? Try it out:

 {{{
>>> The Spanish Inquisition
SyntaxError: invalid syntax
>>>
 }}}

Obviously, the interpreter didn’t understand that. (After all, no one expects the Spanish Inquisition(天主教鎮壓異教徒的裁判所)... If you are running an interpreter other than IDLE, such as the command-line version for Linux, the error message will be slightly dfferent.) The interpreter also indicates what’s wrong: it will emphasize the word Spanish by giving it a red background (or, in the command-line version, by using a caret, `^`).

If you feel like it, play around with the interpreter some more. __For some guidance, try entering the command `help` at the prompt and pressing Enter. As mentioned, you can press F1 for help about IDLE.__ Otherwise, let’s press on. After all, the interpreter isn’t much fun when you don’t know what to tell it, is it?

== Algo . . . What? ==

Before you start programming in earnest, I’ll try to give you an idea of what computer programming is. Simply put, it’s telling a computer what to do. Computers can do a lot of things, but they aren’t very good at ''thinking for themselves''. They really need to be spoon-fed(用湯匙餵食的) the details. You need to feed the computer an algorithm in some language it understands. Algorithm is just a fancy word for a procedure or recipe—a detailed description of how to do something. Consider the following:

 {{{
SPAM with SPAM, SPAM, Eggs, and SPAM:
First, take some SPAM.
Then add some SPAM, SPAM, and eggs.
If a particularly spicy SPAM is desired, add some SPAM.
Cook until done - Check every 10 minutes.
 }}}

This recipe may not be very interesting, but how it’s constructed is. It consists of a series of instructions to be followed in order. Some of the instructions may be done directly (“take some SPAM”), while some require some deliberation (考慮; “If a particularly spicy SPAM is desired”), and others must be repeated several times (“Check every 10 minutes.”)

Recipes and algorithms consist of ingredients (objects, things), and instructions (statements). In this example, SPAM and eggs were the ingredients(原料), while the instructions consisted of adding SPAM, cooking for a given length of time, and so on. Let’s start with some reasonably simple Python ingredients and see what you can do with them.

== Numbers and Expressions ==

The interactive Python interpreter can be used as a powerful calculator. Try the following:

 {{{
>>> 2 + 2
 }}}

This should give you the answer 4. That wasn’t too hard. Well, what about this:

 {{{
>>> 53672 + 235253
288925
 }}}

Still not impressed? Admittedly(不可否認地), this is pretty standard stuff. (I’ll assume that you’ve used a calculator enough to know the difference between `1+2*3` and `(1+2)*3.)` All the usual arithmetic operators work as expected—almost. __There is one potential trap here, and that is ''integer division'' (in Python versions prior to 3.0):__

 {{{
>>> 1/2
0
 }}}

__What happened here? One integer (a nonfractional number) was divided by another, and the result was ''rounded down'' to give an integer result. This behavior can be useful at times, but often (if not most of the time), you need ''ordinary division''. What do you do to get that? There are two possible solutions: use ''real numbers'' (numbers with decimal points) rather than integers, or tell Python to change how division works.__

Real numbers are called ''floats'' (or floating-point numbers) in Python. If ''either one'' of the numbers in a division is a float, the result will be, too:

 {{{
>>> 1.0 / 2.0
0.5
>>> 1/2.0
0.5
>>> 1.0/2
0.5
>>> 1/2. # 整數後面加個 "." 就變成 Float 了
0.5
 }}}

If you would rather have Python do proper division, you could add the following statement to the beginning of your program (writing full programs is described later) or simply execute it in the interactive interpreter:

 {{{
>>> from __future__ import division
 }}}

Note: In case it’s not entirely clear, the future in the instruction is surrounded by two underscores on both sides: `__future__`.

Another alternative, if you’re running Python from the command line (e.g., on a Linux machine), is to supply the command-line switch `-Qnew`. In either case, division will suddenly make a bit more sense:

 {{{
>>> 1 / 2
0.5
 }}}

Of course, the single slash can no longer be used for the kind of integer division shown earlier. A separate operator will do this for you—the double slash:

 {{{
>>> 1 // 2
0
 }}}

The double slash consistently performs integer division, even with floats:

 {{{
>>> 1.0 // 2.0
0.0
 }}}

There is a more thorough explanation of the `__future__` stuff in the section “Back to the `__future__`,” later in this chapter.

Now you’ve seen the basic arithmetic operators (addition, subtraction, multiplication, and division), but one more operator is quite useful at times:

 {{{
>>> 1 % 2
1
 }}}

This is the remainder (modulus) operator. `x % y` gives the remainder of `x` divided by `y`. Here are a few more examples:

 {{{
>>> 10 / 3
3
>>> 10 % 3
1
>>> 9 / 3
3
>>> 9 % 3
0
>>> 2.75 % 0.5
0.25
 }}}

Here `10 / 3` is 3 because the result is rounded down. But `3 x 3` is 9, so you get a remainder of 1. When you divide 9 by 3, the result is exactly 3, with no rounding. Therefore, the remainder is 0. This may be useful if you want to check something “every 10 minutes” as in the recipe earlier in the chapter. You can simply check whether `minute % 10` is 0. (For a description on how to do this, see the sidebar “Sneak Peek: The if Statement,” later in this chapter.) __As you can see from the final example, the remainder operator works just fine with floats as well.__

The last operator is the exponentiation (or power) operator:

 {{{
>>> 2 ** 3
8
>>> -3 ** 2
-9
>>> (-3) ** 2
9
 }}}

Note that the exponentiation operator ''binds tighter than'' the negation (unary minus), so `-3 ** 2` is in fact the same as `-(3 ** 2)`. If you want to calculate `(-3) ** 2`, you must say so explicitly.

=== Large Integers ===

Python can handle really large integers:

 {{{
>>> 1000000000000000000
1000000000000000000L
 }}}

What happened here? The number suddenly got an `L` tacked onto the end.

{{{{#!wiki note
If you’re using a version of Python older than 2.2, you get the following behavior:

 {{{
>>> 1000000000000000000
OverflowError: integer literal too large
 }}}

The newer versions of Python are more flexible when dealing with big numbers.
}}}}

Ordinary integers can’t be larger than 2147483647 (or smaller than -2147483648). __If you want really big numbers, you must use longs. A long (or long integer) is written just like an ordinary integer but with an `L` at the end.__ (You can, in theory, use a lowercase `l` as well, but that looks all too much like the digit 1, so I’d advise against it.)

__In the previous example, Python converted the integer to a long, but you can do that yourself, too.__ Let’s try that big number again:

 {{{
>>> 1000000000000000000L
1000000000000000000L
 }}}

__'''Of course, this is only useful in old versions of Python that aren’t capable of figuring this stuff out. (如果不考量 Python 2.2 之前的執行環境, 建議不要明確去加 "L" 或 "l")'''__

Well, can you do math with these monster numbers, too? Sure thing. Consider the following:

 {{{
>>> 1987163987163981639186L * 198763981726391826L + 23
394976626432005567613000143784791693659L
 }}}

__As you can see, you can mix long integers and plain integers as you like. In all likelihood, you won’t have to worry about the difference between longs and ints unless you’re doing type checking, as described in Chapter 7—and '''that’s something you should almost never do.'''__

=== Hexadecimals and Octals ===

To conclude this section, I should mention that hexadecimal numbers are written like this:

 {{{
>>> 0xAF
175
 }}}

and octal numbers like this:

 {{{
>>> 010
8
 }}}

The first digit in both of these is zero. (If you don’t know what this is all about, just close your eyes and skip to the next section—you’re not missing anything important.)

Note: For a summary of Python’s numeric types and operators, see Appendix B.

== Variables ==

Another concept that might be familiar to you is variables. If math makes you queasy(不安的), don’t worry: variables in Python are easy to understand. __A variable is basically a name that represents (or refers to) some ''value''.__ For example, you might want the name `x` to represent 3. To make it so, simply execute the following:

 {{{
>>> x = 3
 }}}

__This is called an ''assignment''. We assign the value 3 to the variable `x`. Another way of putting(表達) this is to say that we ''bind'' the variable `x` to the value (or object) 3.__ After you’ve assigned a value to a variable, you can use the variable in expressions:

 {{{
>>> x * 2
6
 }}}

__Note that you need to assign a value to a variable before you use it. After all, it doesn’t make any sense to use a variable if it doesn’t represent a value, does it?__

Note: Variable names can consist of letters, digits, and underscore characters (`_`). A variable can’t begin with a digit, so `Plan9` is a valid variable name, whereas `9Plan` is not.

== Statements ==

Until now we’ve been working (almost) exclusively with ''expressions'', the ingredients of the recipe. But what about statements—the instructions?

In fact, I’ve cheated. I’ve introduced two types of statements already: the `print` statement, and assignments. So, what’s the difference between a statement and an expression? __Well, an expression is ''something'', while a statement ''does something'' (or, rather, tells the computer to do something).__ For example, `2 * 2` is 4, whereas `print 2 * 2` prints 4. What’s the difference? After all, they behave very similarly. Consider the following:

 {{{
>>> 2*2
4
>>> print 2*2
4
 }}}

__As long as you execute this in the interactive interpreter, the results are similar, but that is only because '''the interpreter always prints out the values of all expressions''' (using the same representation as `repr`—see the section “String Representations, str and repr” later in this chapter). That is not true of Python in general.__ Later in this chapter, you’ll see how to make programs that run without this interactive prompt, and simply putting an expression such as `2*2` in your program won’t do anything interesting. (In case you’re wondering—yes, it does do something. It calculates the product of 2 and 2. However, the result isn’t kept anywhere or shown to the user; it has no ''side effects'', beyond the calculation itself.) Putting `print 2*2` in there, on the other hand, will print out 4.

Note: __In Python 3.0, `print` is a function, which means you need to write `print(42)` instead of `print 42`,__ for example. Other than that, it works more or less like the statement, as described here.

The difference between statements and expressions may be more obvious when dealing with assignments. __Because they are not expressions, they have ''no values'' that can be printed out by the interactive interpreter:__

 {{{
>>> x = 3
>>>
 }}}

As you can see, you get a new prompt immediately. Something has changed, however; `x` is now bound to the value 3.

__This is a defining quality of statements in general: '''they change things.''' For example, assignments change variables, and `print` statements change how your screen looks.__

__Assignments are, perhaps, the most important type of statement in any programming language, although it may be difficult to grasp their importance right now. Variables may just seem like temporary “storage” (like the pots and pans of a cooking recipe), but '''the real power of variables is that you don’t need to know what values they hold in order to manipulate them.'''__ (Note the quotes around storage. Values aren’t stored in variables—they’re stored in some murky(黑暗的) depths of computer memory, and are referred to by variables. As will become abundantly clear as you read on, more than one variable can refer to the same value.) For example, you know that `x * y` evaluates to the product of `x` and `y`, even though you may have no knowledge of what `x` and `y` are. So, you may write programs that use variables in various ways without knowing the values they will eventually hold (or refer to) when the program is run.

== Getting Input from the User ==

You’ve seen that you can write programs with variables without knowing their values. Of course, the interpreter must know the values eventually. So how can it be that we don’t? The interpreter knows only what we tell it, right? Not necessarily.

You may have written a program, and someone else may use it. You cannot predict what values users will supply to the program. Let’s take a look at the useful function `input`. (I’ll have more to say about functions in a minute.)

 {{{
>>> input("The meaning of life: ")
The meaning of life: 42
42
 }}}

What happens here is that the first line (`input(...)`) is executed in the interactive interpreter. It prints out the string "The meaning of life: " as a new prompt. I type 42 and press Enter. The resulting value of input is that very(正如所陳述的) number, which is automatically printed out in the last line. That may not seem very useful, but look at the following:

 {{{
>>> x = input("x: ")
x: 34
>>> y = input("y: ")
y: 42
>>> print x * y
1428
 }}}

Here, the statements at the Python prompts (`>>>`) could be part of a finished program, and the values entered (34 and 42) would be supplied by some user. Your program would then print out the value 1428, which is the product of the two. And you didn’t have to know these values when you wrote the program, right?

Note: This is much more useful when you save your programs in a separate file so other users can execute them. You learn to do that later in this chapter, in the section “Saving and Executing Your Programs.”

{{{{#!wiki note
'''SNEAK PEEK: THE IF STATEMENT'''

To make things a bit more fun, I’ll give you a sneak peek of something you aren’t really supposed to learn about until Chapter 5: the `if` statement. The `if` statement lets you perform an action (another statement) if a given condition is true. One type of condition is an equality test, using the equality operator `==`. Yes, it’s a double equality sign. The single one is used for assignments, remember?

You simply put this condition after the word `if` and then separate it from the following statement with a colon:

 {{{
>>> if 1 == 2: print 'One equals two'
...
>>> if 1 == 1: print 'One equals one'
...
One equals one
>>>
 }}}
}}}}

As you can see, nothing happens when the condition is false. When it is true, however, the following statement (in this case, a `print` statement) is executed. __Note also that when using `if` statements in the interactive interpreter, you need to press Enter twice before it is executed.__ (The reason for this will become clear in Chapter 5—don’t worry about it for now.)

So, if the variable `time` is bound to the current time in minutes, you could check whether you’re “on the hour” with the following statement:

 {{{
if time % 60 == 0: print 'On the hour!'
 }}}
 }}}}

== Functions ==

In the section on numbers and expressions, I used the exponentiation operator (`**`) to calculate powers. The fact is that you can use a function instead, called `pow`:

 {{{
>>> 2**3
8
>>> pow(2,3)
8
 }}}

A function is like a little program that you can use to perform a specific action. Python has a lot of functions that can do many wonderful things. In fact, you can make your own functions, too (more about that later); therefore, we often refer to standard functions such as `pow` as ''built-in functions''.

__Using a function as I did in the preceding example is called ''calling'' the function. You supply it with parameters (in this case, 2 and 3) and it returns a value to you. '''Because it returns a value, a function call is simply another type of expression, like the arithmetic expressions discussed earlier in this chapter.''' (Function calls can also be used as statements if you simply ignore the return value.) In fact, you can combine function calls and operators to create more complicated expressions:__

 {{{
>>> 10 + pow(2, 3*5)/3.0
10932.666666666666
 }}}

Note: The exact number of decimals may vary depending on which version of Python you are using.

Several built-in functions can be used in numeric expressions like this. For example, `abs` gives the absolute value of a number, and `round` rounds floating-point numbers to the nearest integer:

 {{{
>>> abs(-10)
10
>>> 1/2
0
>>> round(1.0/2.0)
1.0
 }}}

Notice the difference between the two last expressions. Integer division always rounds down, whereas `round` rounds to the nearest integer. But what if you want to round a given number down? For example, you might know that a person is 32.9 years old, but you would like to round that down to 32 because she isn’t really 33 yet. Python has a function for this (called `floor`)—it just isn’t available directly. As is the case with many useful functions, it is found in a ''module''.

== Modules ==

__You may think of modules as ''extensions'' that can be imported into Python to extend its capabilities.__ You import modules with a special command called (naturally enough) `import`. The function mentioned in the previous section, `floor`, is in a module called `math`:

 {{{
>>> import math
>>> math.floor(32.9)
32.0
 }}}

Notice how this works: __we import a module with `import`, and then use the functions from that module by writing `module.function`.__

If you want the age to be an integer (32) and not a float (32.0), you can use the function `int`: (The `int` function/type will actually round down while converting to an integer, so when converting to an integer, using `math.floor` is superfluous(多餘的); you could simply use `int(32.9)`.)

 {{{
>>> int(math.floor(32.9))
32
 }}}

Note: __Similar functions exist to convert to other types (for example, `long` and `float`). In fact, these aren’t completely normal functions—they’re ''type objects''. I’ll have more to say about types later. The opposite of `floor` is `ceil` (short for “ceiling”), which finds the smallest integral value larger than or equal to the given number.__

__'''If you are sure that you won’t import more than one function with a given name (from different modules)''', you might not want to write the module name each time you call the function. Then you can use a variant of the `import` command:__

 {{{
>>> from math import sqrt
>>> sqrt(9)
3.0
 }}}

__After using `from module import function`, you can use the function without its module prefix.__

Tip: __'''You may, in fact, use variables to refer to functions (and most other things in Python).''' For example, by performing the assignment `foo = math.sqrt`, you can start using `foo` to calculate square roots; for example, `foo(4)` yields 2.0.__

=== cmath and Complex Numbers ===

The `sqrt` function is used to calculate the square root of a number. Let’s see what happens if we supply it with a negative number:

 {{{
>>> from math import sqrt
>>> sqrt(-1)
Traceback (most recent call last):
  File "<pyshell#23>", line 1, in ?
    sqrt(-1)
ValueError: math domain error
 }}}

or, on some platforms:

 {{{
>>> sqrt(-1)
nan
 }}}

Note: __`nan` is simply a special value meaning “not a number.”__

Well, that’s reasonable. You can’t take the square root of a negative number—or can you? Indeed you can. The square root of a negative number is an imaginary number(虛數). (This is a standard mathematical concept—if you find it a bit too mind-bending, feel free to skip ahead.) So why couldn’t `sqrt` deal with it? Because it deals only with floats, and imaginary numbers (and complex numbers(複數), the sum of real and imaginary numbers) are something completely different— which is why they are covered by a different module, `cmath` (for complex math):

 {{{
>>> import cmath
>>> cmath.sqrt(-1)
1j
 }}}

Notice that I didn’t use `from ... import ...` here. If I had, I would have lost my ordinary `sqrt`. __Name clashes(衝突) like these can be sneaky(狡猾的), so unless you really want to use the `from` version, you should probably stick with a plain `import`.__

The value `1j` is an imaginary number. These numbers are written with a trailing `j` (or `J`), just like longs use `L`. Without delving into the theory of complex numbers, let me just show a final example of how you can use them:

 {{{
>>> (1+3j) * (9+4j)
(-3+31j)
 }}}

__As you can see, the support for complex numbers is built into the language.__

Note: __There is no separate type for imaginary numbers in Python. They are treated as complex numbers whose real component is zero.__

=== Back to the __future__ ===

__It has been rumored(傳說) that Guido van Rossum (Python’s creator) has a time machine, because quite often '''when people request features in the language, the features have already been implemented.'''__ Of course, we aren’t all allowed into this time machine, but Guido has been kind enough to build a part of it into Python, in the form of the magic module `__future__`. __From it, we can import features that will be standard in Python in the future but that aren’t part of the language yet.__ You saw this in the section about numbers and expressions, and you’ll be bumping into it from time to time throughout this book.

== Saving and Executing Your Programs ==

The interactive interpreter is one of Python’s great strengths. It makes it possible to test solutions and to experiment with the language in real time. If you want to know how something works, just try it! However, everything you write in the interactive interpreter is lost when you quit. What you really want to do is write programs that both you and other people can run. In this section, you learn how to do just that.

First of all, you need a text editor, preferably one intended for programming. (If you use something like Microsoft Word, which I don’t really recommend, be sure to save your code as plain text.) If you are already using IDLE, you’re in luck. With IDLE, you can simply create a new editor window with File ➤ New Window. Another window appears, without an interactive prompt. Whew!

Start by entering the following:

 {{{
print "Hello, world!"
 }}}

Now select File ➤ Save to save your program (which is, in fact, a plain text file). Be sure to put it somewhere where you can find it later. You might want to create a directory where you put all your Python projects, such as `C:\python` in Windows. In a UNIX environment, you might use a directory like `~/python`. Give your file any reasonable name, such as `hello.py.` The `.py` ending is important.

Note: If you followed the installation instructions earlier in this chapter, you may have put your Python installation in `~/python` already, but because that has a subdirectory of its own (such as `~/python/Python-2.5/`), this shouldn’t cause any problems. If you would rather put your own programs somewhere else, feel free to use a directory such as `~/my_python_programs`.

Got that? Don’t close the window with your program in it. If you did, just open it again (File ➤ Open). Now you can run it with Edit ➤ Run script, or by pressing Ctrl+F5. (If you aren’t using IDLE, see the next section about running your programs from the command prompt.)

What happens? Hello, world! is printed in the interpreter window, which is exactly what we wanted. The interpreter prompt may be gone (depending on the version you’re using), but you can get it back by pressing Enter (in the interpreter window).

Let’s extend our script to the following:

 {{{
name = raw_input("What is your name? ")
print "Hello, " + name + "!"
 }}}

Note: Don’t worry about the difference between `input` and `raw_input`—I’ll get to that.

If you run this (remember to save it first), you should see the following prompt in the interpreter window:

 {{{
What is your name?
 }}}

Enter your name (for example, Gumby) and press Enter. You should get something like this:

 {{{
Hello, Gumby!
 }}}

Fun, isn’t it?

=== Running Your Python Scripts from a Command Prompt ===

Actually, there are several ways to run your programs. First, let’s assume that you have a DOS window or a UNIX shell prompt before you, and that the directory containing the Python executable (called `python.exe` in Windows, and `python` in UNIX) or the directory containing the executable (in Windows) has been put in your `PATH` environment variable. (If you don’t understand this sentence, you should perhaps skip the section. You don’t really need it.) Also, let’s assume that your script from the previous section (`hello.py`) is in the current directory. Then you can execute your script with the following command in Windows:

 {{{
C:\>python hello.py
 }}}

or UNIX:

 {{{
$ python hello.py
 }}}

As you can see, the command is the same. Only the system prompt changes.

Note: If you don’t want to mess with environment variables, you can simply specify the full path of the Python interpreter. In Windows, you might do something like this:

 {{{
C:\>C:\Python25\python hello.py
 }}}

=== Making Your Scripts Behave Like Normal Programs ===

Sometimes you want to execute a Python program (also called a script) the same way you execute other programs (such as your web browser or text editor), rather than explicitly using the Python interpreter. __In UNIX, there is a standard way of doing this: have the first line of your script begin with the character sequence `#!` (called pound bang or shebang) followed by the absolute path to the program that interprets the script (in our case Python). Even if you didn’t quite understand that, just put the following in the first line of your script if you want it to run easily on UNIX:__

 {{{
#!/usr/bin/env python
 }}}

This should run the script, regardless of where the Python binary is located.

{{{{#!wiki note
In some operating systems if you install a recent version of Python (e.g., 2.5) you will still have an old one lying around (e.g.,1.5.2), which is needed by some system programs (so you can’t uninstall it). In such cases, the `/usr/bin/env` trick is not a good idea, as you will probably end up with your programs being executed by the old Python. Instead, you should find the exact location of your new Python executable (probably called python or python2) and use the full path in the pound bang line, like this:

 {{{
#!/usr/bin/python2
 }}}

The exact path may vary from system to system.
}}}}

Before you can actually run your script, you must make it executable:

 {{{
$ chmod a+x hello.py
 }}}

Now it can be run like this (assuming that you have the current directory in your path):

 {{{
$ hello.py
 }}}

If this doesn’t work, try using `./hello.py` instead, which will work even if the current directory (`.`) is not part of your execution path.

__If you like, you can rename your file and remove the `py` suffix to make it look more like a normal program.__

==== What About Double-Clicking? ====

__In Windows, the suffix (`.py`) is the key to making your script behave like a program.__ Try doubleclicking the file `hello.py` you saved in the previous section. If Python was installed correctly, a DOS window appears with the prompt “What is your name?” Cool, huh? (This behavior depends on your operating system and the installed Python interpreter. If you’ve saved the file using IDLE in Mac OS X, for example, double-clicking the file will simply open it in the IDLE code editor. You’ll see how to make your programs look better, with buttons, menus, and so on, later.)

There is one problem with running your program like this, however. Once you’ve entered your name, the program window closes before you can read the result. __The window closes when the program is finished.__ Try changing the script by adding the following line at the end:

 {{{
raw_input("Press <enter>")
 }}}

Now, after running the program and entering your name, you should have a DOS window with the following contents:

 {{{
What is your name? Gumby
Hello, Gumby!
Press <enter>
 }}}

Once you press the Enter key, the window closes (because the program is finished). Just as a teaser, rename your file `hello.pyw`. (This is Windows-specific.) Double-click it as before. What happens? Nothing! How can that be? I will tell you later in the book—I promise.

=== Comments ===

The hash sign (`#`) is a bit special in Python. When you put it in your code, everything to the right of it is ignored (which is why the Python interpreter didn’t choke on the `/usr/bin/env` stuff used earlier). Here is an example:

 {{{
# Print the circumference of the circle:
print 2 * pi * radius
 }}}

The first line here is called a comment, which can be useful in making programs easier to understand—both for other people and for yourself when you come back to old code. __It has been said that the first commandment(命令) of programmers is “Thou Shalt Comment” (although some less charitable(仁慈的) programmers swear by the motto(箴言) '''“If it was hard to write, it should be hard to read”).''' Make sure your comments say significant things and don’t simply restate what is already obvious from the code. Useless, redundant comments may be worse than none.__ For example, in the following, a comment isn’t really called for:

 {{{
# Get the user's name:
user_name = raw_input("What is your name?")
 }}}

__It’s always a good idea to '''make your code readable on its own as well, even without the comments.''' Luckily, Python is an excellent language for writing readable programs.__

== String ==

Now what was all that `raw_input` and `"Hello, " + name + "!"` stuff about? Let’s tackle the `"Hello"` part first and leave `raw_input` for later.

The first program in this chapter was simply

 {{{
print "Hello, world!"
 }}}

It is customary(慣常的) to begin with a program like this in programming tutorials. The problem is that I haven’t really explained how it works yet. You know the basics of the `print` statement (I’ll have more to say about that later), but what is `"Hello, world!"`? It’s called a string (as in “a string of characters”). Strings are found in almost every useful, real-world Python program and have many uses. Their main use is to represent bits of text, such as the exclamation “Hello, world!”

=== Single-Quoted Strings and Escaping Quotes ===

Strings are ''values'', just as numbers are:

 {{{
>>> "Hello, world!"
'Hello, world!'
 }}}

There is one thing that may be a bit surprising about this example, though: __when Python printed out our string, it used single quotes, whereas we used double quotes.__ What’s the difference? Actually, there is no difference:

 {{{
>>> 'Hello, world!'
'Hello, world!'
 }}}

Here, we use single quotes, and the result is the same. So why allow both? Because in some cases it may be useful:

 {{{
>>> "Let's go!"
"Let's go!"
>>> '"Hello, world!" she said'
'"Hello, world!" she said'
 }}}

In the preceding code, the first string contains a single quote (or an apostrophe, as we should perhaps call it in this context), and therefore we can’t use single quotes to enclose the string. If we did, the interpreter would complain (and rightly so):

 {{{
>>> 'Let's go!'
SyntaxError: invalid syntax
 }}}

Here, the string is `'Let'`, and Python doesn’t quite know what to do with the following s (or the rest of the line, for that matter).

In the second string, we use double quotes as part of our sentence. Therefore, we have to use single quotes to enclose our string, for the same reasons as stated previously. Or, actually we don’t have to. It’s just convenient. __An alternative is to use the backslash character (`\`) to escape the quotes in the string,__ like this:

 {{{
>>> 'Let\'s go!'
"Let's go!"
 }}}

Python understands that the middle single quote is a character in the string and not the end of the string. __(Even so, Python chooses to use double quotes when printing out the string.)__ The same works with double quotes, as you might expect:

 {{{
>>> "\"Hello, world!\" she said"
'"Hello, world!" she said'
 }}}

Escaping quotes like this can be useful, and sometimes necessary. For example, what would you do without the backslash if your string contained both single and double quotes, as in the string `'Let\'s say "Hello, world!"'`?

Note: Tired of backslashes? As you will see later in this chapter, you can avoid most of them by using ''long strings'' and ''raw strings'' (which can be combined).

=== Concatenating Strings ===

Just to keep whipping this slightly tortured(痛苦的) example, let me show you another way of writing the same string:

 {{{
>>> "Let's say " '"Hello, world!"'
'Let\'s say "Hello, world!"'
 }}}

__I’ve simply written two strings, one after the other, and Python automatically concatenates them (makes them into one string). This mechanism isn’t used very often, but it can be useful at times.__ However, it works only when you actually write both strings at the same time, directly following one another:

 {{{
>>> x = "Hello, "
>>> y = "world!"
>>> x y
SyntaxError: invalid syntax
 }}}

__In other words, this is just a special way of writing strings, not a general method of concatenating them.__ How, then, do you concatenate strings? Just like you add numbers:

 {{{
>>> "Hello, " + "world!"
'Hello, world!'
>>> x = "Hello, "
>>> y = "world!"
>>> x + y
'Hello, world!'
 }}}

=== String Representations, str and repr ===

Throughout these examples, you have probably noticed that all the strings printed out by Python are still ''quoted''. __That’s because it prints out the value '''as it might be written in Python code''', not how you would like it to look for the user.__ If you use `print`, however, the result is different:

 {{{
>>> "Hello, world!"
'Hello, world!'
>>> 10000L
10000L
>>> print "Hello, world!"
Hello, world!
>>> print 10000L
10000
 }}}

As you can see, the long integer `10000L` is simply the number 10000 and should be written that way when presented to the user. But when you want to know what value a variable refers to, you may be interested in whether it’s a normal integer or a long, for example.

__What is actually going on here is that values are converted to strings through two different mechanisms. You can use both mechanisms yourself, through the functions `str` and `repr`. `str` simply converts a value into a string in some reasonable fashion that will probably be understood by a user, for example. (Actually, `str` is a type, just like `int` and `long`. `repr`, however, is simply a function.) `repr` creates a string that is a representation of the value as a legal Python expression.__ Here are a few examples:

 {{{
>>> print repr("Hello, world!")
'Hello, world!'
>>> print repr(10000L)
10000L
>>> print str("Hello, world!")
Hello, world!
>>> print str(10000L)
10000
 }}}

A synonym for `repr(x)` is {{{`x`}}} (here, you use backticks, not single quotes). This can be useful when you want to print out a sentence containing a number:

 {{{
>>> temp = 42
>>> print "The temperature is " + temp
Traceback (most recent call last):
  File "<pyshell#61>", line 1, in ?
    print "The temperature is " + temp
TypeError: cannot add type "int" to string
>>> print "The temperature is " + `temp`
The temperature is 42
 }}}

Note: __Backticks are removed in Python 3.0, so even though you may find backticks in old code, you should probably stick with `repr` yourself.__

The first `print` statement doesn’t work because you can’t add a string to a number. The second one, however, works because I have converted temp to the string `"42"` by using the backticks. (I could have just as well used `repr`, which means the same thing, but may be a bit clearer. Actually, in this case, I could also have used `str`. Don’t worry too much about this right now.)

__In short, `str`, `repr`, and backticks are three ways of converting a Python value to a string. The function `str` makes it ''look good'', while `repr` (and the backticks) tries to make the resulting string a legal Python expression.__

=== input vs. raw_input ===

Now you know what `"Hello, " + name + "!"` means. But what about `raw_input`? Isn’t `input` good enough? Let’s try it. Enter the following in a separate script file:

 {{{
name = input("What is your name? ")
print "Hello, " + name + "!"
 }}}

This is a perfectly valid program, but as you will soon see, it’s a bit impractical. Let’s try to run it:

 {{{
What is your name? Gumby
Traceback (most recent call last):
  File "C:/python/test.py", line 2, in ?
    name = input("What is your name? ")
  File "<string>", line 0, in ?
NameError: name 'Gumby' is not defined
 }}}

__The problem is that `input` assumes that what you enter is a valid Python expression (it’s more or less the inverse of `repr`).__ If you write your name as a string, that’s no problem:

 {{{
What is your name? "Gumby"
Hello, Gumby!
 }}}

However, it’s just a bit too much to ask that users write their name in quotes like this. Therefore, we use `raw_input`, which treats all input as raw data and puts it into a string:

 {{{
>>> input("Enter a number: ")
Enter a number: 3
3
>>> raw_input("Enter a number: ")
Enter a number: 3
'3'
 }}}

__Unless you have a special need for `input`, you should probably use `raw_input`.__

=== Long Strings, Raw Strings, and Unicode ===

Before ending this chapter, I want to tell you about a few other ways of writing strings. These alternate string syntaxes can be useful when you have strings that span several lines or contain various special characters.

==== Long Strings ====

If you want to write a really long string, one that spans several lines, you can use triple quotes instead of ordinary quotes:

 {{{
print '''This is a very long string.
It continues here.
And it's not over yet.
"Hello, world!"
Still here.'''
 }}}

You can also use triple double quotes, `"""like this"""`. __Note that because of the distinctive(特殊的) enclosing quotes, both single and double quotes are allowed inside, without being backslash-escaped.__

{{{{#!wiki tip
__Ordinary strings can also span several lines. If the last character on a line is a backslash, the line break itself is “escaped” and ignored.__ For example:

 {{{
print "Hello, \
world!"
 }}}

would print out `Hello, world!`. The same goes for expressions and statements in general:

 {{{
>>> 1 + 2 + \
       4 + 5
12
>>> print \
      'Hello, world'
Hello, world
 }}}
}}}}

==== Raw Strings ====

Raw strings aren’t too picky(過份講究的) about backslashes, which can be very useful sometimes. (Raw strings can be especially useful when writing regular expressions. More about those in Chapter 10.) __In ordinary strings, the backslash has a special role: it escapes things, letting you put things into your string that you couldn’t normally write directly.__ For example, a new line is written `\n`, and can be put into a string like this:

 {{{
>>> print 'Hello,\nworld!'
Hello,
world!
 }}}

This is normally just dandy(極好的), but in some cases, it’s not what you want. What if you wanted the string to include a backslash followed by an `n`? You might want to put the DOS pathname `C:\nowhere` into a string:

 {{{
>>> path = 'C:\nowhere'
>>> path
'C:\nowhere'
 }}}

This looks correct, until you print it and discover the flaw:

 {{{
>>> print path
C:
owhere
 }}}

Not exactly what we were after, is it? So what do we do? We can escape the backslash itself:

 {{{
>>> print 'C:\\nowhere'
C:\nowhere
 }}}

This is just fine. But for long paths, you wind up with a lot of backslashes:

 {{{
path = 'C:\\Program Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'
 }}}

Raw strings are useful in such cases. __They don’t treat the backslash as a special character at all. Every character you put into a raw string stays the way you wrote it:__

 {{{
>>> print r'C:\nowhere'
C:\nowhere
>>> print r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz'
C:\Program Files\fnord\foo\bar\baz\frozz\bozz
 }}}

As you can see, raw strings are prefixed with an `r`. It would seem that you can put anything inside a raw string, and that is almost true. __'''Quotes must be escaped as usual (但並沒有 Escaping 的效果), although that means that you get a backslash in your final string, too:'''__

 {{{
>>> print r'Let\'s go!'
Let\'s go!
 }}}

__The one thing you can’t have in a raw string is a lone, final backslash. In other words, the last character in a raw string cannot be a backslash unless you escape it (and then the backslash you use to escape it will be part of the string, too).__ Given the previous example, that ought to be obvious. If the last character (before the final quote) is an unescaped backslash, Python won’t know whether or not to end the string:

 {{{
>>> print r"This is illegal\"
SyntaxError: invalid token
 }}}

Okay, so it’s reasonable, but what if you want the last character in your raw string to be a backslash? (Perhaps it’s the end of a DOS path, for example.) __Well, I’ve given you a whole bag of tricks in this section that should help you solve that problem, but basically you need to put the backslash in a separate string.__ A simple way of doing that is the following:

 {{{
>>> print r'C:\Program Files\foo\bar' '\\' # Ordinary String 也有類似的問題
C:\Program Files\foo\bar\
 }}}

__Note that you can use both single and double quotes with raw strings. Even triple-quoted strings can be raw.__

==== Unicode Strings ====

__The final type of string constant is the Unicode string (or Unicode object—'''they don’t really belong to the same type as strings''').__ If you don’t know what Unicode is, you probably don’t need to know about this. (If you want to find out more about it, you can go to the Unicode web site, www.unicode.org.) __''Normal strings'' in Python are stored internally as 8-bit ASCII, while Unicode strings are stored as 16-bit Unicode.__ This allows for a more varied set of characters, including special characters from most languages in the world. I’ll restrict my treatment of Unicode strings to the following:

 {{{
>>> u'Hello, world!'
u'Hello, world!'
 }}}

As you can see, Unicode strings use the prefix `u`, just as raw strings use the prefix `r`.

Note: __In Python 3.0, all strings will be Unicode strings.__

== A Quick Summary ==

This chapter covered quite a bit of material. Let’s take a look at what you’ve learned before moving on.

Algorithms: An algorithm is a recipe telling you exactly how to perform a task. When you program a computer, you are essentially describing an algorithm in a language the computer can understand, such as Python. Such a ''machine-friendly description'' is called a program, and it mainly consists of expressions and statements.

Expressions: __An expression is a part of a computer program that represents a value.__ For example, `2 + 2` is an expression, representing the value 4. Simple expressions are built from literal values (such as 2 or `"Hello"`) by using operators (such as `+` or `%`) and functions (such as `pow`). More complicated expressions can be created by combining simpler expressions (e.g., `(2+2)*(3-1))`. Expressions may also contain variables.

Variables: A variable is a name that represents a value. New values may be assigned to variables through assignments such as `x = 2`. An assignment is a kind of statement.

Statements: A statement is an instruction that tells the computer to do something. That may involve changing variables (through assignments), printing things to the screen (such as `print "Hello, world!"`), importing modules, or a host of other stuff.

Functions: Functions in Python work just like functions in mathematics: they may take some arguments, and they return a result. (They may actually do lots of interesting stuff before returning, as you will find out when you learn to write your own functions in Chapter 6.)

Modules: Modules are extensions that can be imported into Python to extend its capabilities. For example, several useful mathematical functions are available in the `math` module.

Programs: You have looked at the practicalities of writing, saving, and running Python programs.

Strings: Strings are really simple—they are just pieces of text. And yet there is a lot to know about them. In this chapter, you’ve seen many ways to write them, and in Chapter 3 you learn many ways of using them.

=== New Functions in This Chapter ===

|| Function || Description ||
|| `abs(number)` || Returns the absolute value of a number ||
|| `cmath.sqrt(number)` || Returns the square root; works with negative numbers ||
|| `float(object)` || Converts a string or number to a floating-point number ||
|| `help()` || Offers interactive help ||
|| `input(prompt)` || Gets input from the user ||
|| `int(object)` || Converts a string or number to an integer ||
|| `long(object)` || Converts a string or number to a long integer ||
|| `math.ceil(number)` || Returns the ceiling of a number as a float ||
|| `math.floor(number)` || Returns the floor of a number as a float ||
|| `math.sqrt(number)` || Returns the square root; doesn’t work with negative numbers ||
|| `pow(x, y[, z])` Returns x to the power of y (modulo z) ||
|| `raw_input(prompt)` || Gets input from the user, as a string ||
|| `repr(object)` || Returns a string representation of a value ||
|| `round(number[, ndigits])` || Rounds a number to a given precision ||
|| `str(object)` || Converts a value to a string ||

=== What Now? ===

Now that you know the basics of expressions, let’s move on to something a bit more advanced: data structures. Instead of dealing with simple values (such as numbers), you’ll see how to bunch them together in more complex structures, such as lists and dictionaries. In addition, you’ll take another close look at strings. In Chapter 5, you learn more about statements, and after that you’ll be ready to write some really nifty programs.

= Chapter 2. Lists and Tuples =

This chapter introduces a new concept: data structures. A data structure is a collection of data elements (such as numbers or characters, or even other data structures) that is structured in some way, such as by numbering the elements. __The most basic data structure in Python is the ''sequence'' (又細分為 List 與 Tuple). Each element of a sequence is assigned a number—its position, or index. The first index is zero, the second index is one, and so forth.__

Note: When you count or number things in your daily life, you probably start counting from 1. The numbering scheme used in Python may seem odd, but it is actually quite natural. __One of the reasons for this, as you see later in the chapter, is that you can also count from the end: the last item of a sequence is numbered -1, the next-to-last -2, and so forth. '''That means you can count forward or backward from the first element, which lies at the beginning, or 0.'''__ Trust me, you get used to it.

This chapter begins with an overview of sequences, and then covers some operations that are common to all sequences, including lists and tuples. These operations will also work with strings, which will be used in some of the examples, although for a full treatment of string operations, you have to wait until the next chapter.

After dealing with these basics, we start working with lists and see what’s special about them. After lists, we come to tuples, which are very similar to lists, except that you can’t change them.

== Sequence Overview ==

Python has six built-in types of sequences. This chapter concentrates on two of the most common ones: lists and tuples. The other built-in sequence types are strings (which I revisit in the next chapter), Unicode strings, buffer objects, and `xrange` objects.

__The main difference between lists and tuples is that you can change a list, but you can’t change a tuple. This means a list might be useful if you need to add elements as you go along, while a tuple can be useful if, for some reason, you can’t allow the sequence to change.__ Reasons for the latter are usually rather technical, having to do with(與...有關) how things work internally in Python. That’s why you may see built-in functions returning tuples. __For your own programs, chances are you can use lists instead of tuples in almost all circumstances.__ (One notable exception, as described in Chapter 4, is using tuples as dictionary keys. There lists aren’t allowed, because you aren’t allowed to modify keys.)

Sequences are useful when you want to work with a collection of values. You might have a sequence representing a person in a database, with the first element being their name, and the second their age. Written as a list (the items of a list are separated by commas and enclosed in square brackets), that would look like this:

 {{{
>>> edward = ['Edward Gumby', 42]
 }}}

But sequences can contain other sequences, too, so you could make a list of such persons, which would be your database:

 {{{
>>> edward = ['Edward Gumby', 42]
>>> john = ['John Smith', 50]
>>> database = [edward, john]
>>> database
[['Edward Gumby', 42], ['John Smith', 50]]
 }}}

Note: __Python has a basic notion of a kind of data structure called a ''container'', which is basically any object that can contain other objects. The two main kinds of containers are sequences (such as lists and tuples) and mappings (such as dictionaries). While the elements of a sequence are numbered, each element in a mapping has a ''name'' (also called a ''key'').__ You learn more about mappings in Chapter 4. For an example of a container type that is neither a sequence nor a mapping, see the discussion of sets in Chapter 10.

== Common Sequence Operations ==

There are certain things you can do with all sequence types. These operations include indexing, slicing, adding, ''multiplying'', and checking for ''membership''. In addition, Python has built-in functions for finding the length of a sequence, and for finding its largest and smallest elements.

Note: One important operation not covered here is ''iteration''. To iterate over a sequence means to perform certain actions repeatedly, once per element in the sequence. To learn more about this, see the section “Loops” in Chapter 5.

=== Indexing ===

All elements in a sequence are numbered—from zero and upwards. You can access them individually with a number, like this:

 {{{
>>> greeting = 'Hello'
>>> greeting[0]
'H'
 }}}

Note: __A string is just a sequence of characters.__ The index 0 refers to the first element, in this case the letter `H`.

This is called indexing. You use an index to fetch an element. All sequences can be indexed in this way. __When you use a negative index, Python counts from the right; that is, from the last element. The last element is at position -1__ (not -0, as that would be the same as the first element):

 {{{
>>> greeting[-1]
'o'
 }}}

String literals (and other sequence literals, for that matter) may be indexed directly, without using a variable to refer to them. The effect is exactly the same:

 {{{
>>> 'Hello'[1]
'e'
 }}}

If a function call returns a sequence, you can index it directly. For instance, if you are simply interested in the fourth digit in a year entered by the user, you could do something like this:

 {{{
>>> fourth = raw_input('Year: ')[3]
Year: 2005
>>> fourth
'5'
 }}}

Listing 2-1 contains a sample program that asks you for a year, a month (as a number from 1 to 12), and a day (1 to 31), and then prints out the date with the proper month name and so on.

Listing 2-1. Indexing Example

 {{{
# Print out a date, given year, month, and day as numbers

months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
]

# A list with one ending for each number from 1 to 31
endings = ['st', 'nd', 'rd'] + 17 * ['th'] \
        + ['st', 'nd', 'rd'] + 7 * ['th'] \ # 這種對齊方式還滿好看的
        + ['st']

year    = raw_input('Year: ')
month   = raw_input('Month (1-12): ')
day     = raw_input('Day (1-31): ')

month_number = int(month)
day_number = int(day)

# Remember to subtract 1 from month and day to get a correct index
month_name = months[month_number-1]
ordinal = day + endings[day_number-1]

print month_name + ' ' + ordinal + ', ' + year
 }}}

An example of a session with this program might be as follows:

 {{{
Year: 1974
Month (1-12): 8
Day (1-31): 16
August 16th, 1974
 }}}

The last line is the output from the program.

=== Slicing ===

__Just as you use indexing to access individual elements, you can use slicing to access ranges of elements.__ You do this by using two indices, separated by a colon:

 {{{
>>> tag = '<a href="http://www.python.org">Python web site</a>'
>>> tag[9:30]
'http://www.python.org'
>>> tag[32:-4] # Positive/Negative Index 可以混用
'Python web site'
 }}}

As you can see, slicing is very useful for extracting parts of a sequence. The numbering here is very important. The first index is the number of the first element you want to include. However, the last index is the number of the first element ''after'' your slice. Consider the following:

 {{{
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[3:6]
[4, 5, 6]
>>> numbers[0:1]
[1]
 }}}

__In short, you supply two indices as limits for your slice, where the first is inclusive and the second is exclusive.__

==== A Nifty(巧妙的) Shortcut ====

Let’s say you want to access the last three elements of numbers (from the previous example). You could do it explicitly, of course:

 {{{
>>> numbers[7:10]
[8, 9, 10]
 }}}

Now, the index 10 refers to element 11—which does not exist, but is one step after the last element you want. Got it?

This is fine, but what if you want to count from the end?

 {{{
>>> numbers[-3:-1]
[8, 9]
 }}}

It seems you cannot access the last element this way. How about using 0 as the element “one step beyond” the end?

 {{{
>>> numbers[-3:0]
[]
 }}}

Not exactly the desired result. __In fact, any time the leftmost index in a slice comes later in the sequence than the second one (in this case, the third-to-last coming later than the first), the result is always an ''empty sequence''. Luckily, you can use a shortcut: if the slice continues to the end of the sequence, you may simply leave out the last index:__

 {{{
>>> numbers[-3:]
[8, 9, 10]
 }}}

The same thing works from the beginning:

 {{{
>>> numbers[:3]
[1, 2, 3]
 }}}

In fact, if you want to copy the entire sequence, you may leave out both indices:

 {{{
>>> numbers[:]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 }}}

Listing 2-2 contains a small program that prompts you for a URL, and (assuming it is of the form [[http://www.somedomainname.com]]) extracts the domain name.

Listing 2-2. Slicing Example

 {{{
# Split up a URL of the form http://www.something.com

url = raw_input('Please enter the URL: ')
domain = url[11:-4]

print "Domain name: " + domain
 }}}

Here is a sample run of the program:

 {{{
Please enter the URL: http://www.python.org
Domain name: python
 }}}

==== Longer Steps ====

When slicing, you specify (either explicitly or implicitly) the start and end points of the slice. __Another parameter (added to the built-in types in Python 2.3), which normally is left implicit, is the ''step length''. In a regular slice, the step length is one, which means that the slice “moves” from one element to the next, returning all the elements between the start and end:__

 {{{
>>> numbers[0:10:1]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 }}}

In this example, you can see that the slice includes another number. This is, as you may have guessed, the ''step size'', made explicit. __If the step size is set to a number greater than one, elements will be skipped.__ For example, a step size of two will include only every other element of the interval between the start and the end:

 {{{
>>> numbers[0:10:2]
[1, 3, 5, 7, 9]
numbers[3:6:3]
[4]
 }}}

You can still use the shortcuts mentioned earlier. For example, if you want every fourth element of a sequence, you need to supply only a step size of four:

 {{{
>>> numbers[::4]
[1, 5, 9]
 }}}

__Naturally, the step size can’t be zero—that wouldn’t get you anywhere—but it can be negative, which means extracting the elements from right to left:__

 {{{
>>> numbers[8:3:-1]
[9, 8, 7, 6, 5]
>>> numbers[10:0:-2]
[10, 8, 6, 4, 2]
>>> numbers[0:10:-2]
[]
>>> numbers[::-2]
[10, 8, 6, 4, 2]
>>> numbers[5::-2]
[6, 4, 2]
>>> numbers[:5:-2]
[10, 8]
 }}}

Getting things right here can involve a bit of thinking. As you can see, the first limit (the leftmost) is still inclusive, while the second (the rightmost) is exclusive. __When using a negative step size, '''you need to have a first limit (start index) that is higher than the second one. (正確地說, 第一個 Index 對應位置必須第二個 Index 右側)''' What may be a bit confusing is that when you leave the start and end indices implicit, Python does the “right thing”—for a positive step size, it moves from the beginning toward the end, and for a negative step size, it moves from the end toward the beginning.__

=== Adding Sequences ===

Sequences can be concatenated with the addition (plus) operator:

 {{{
>>> [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
>>> 'Hello, ' + 'world!'
'Hello, world!'
>>> [1, 2, 3] + 'world!'
Traceback (innermost last):
  File "<pyshell#2>", line 1, in ?
    [1, 2, 3] + 'world!'
TypeError: can only concatenate list (not "string") to list
 }}}

__As you can see from the error message, you can’t concatenate a list and a string, although both are sequences. In general, you cannot concatenate sequences of different types.__

=== Multiplication ===

Multiplying a sequence by a number `x` creates a new sequence where the original sequence is repeated `x` times:

 {{{
>>> 'python' * 5
'pythonpythonpythonpythonpython'
>>> [42] * 10
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
 }}}

==== None, Empty Lists, and Initialization ====

An empty list is simply written as two brackets (`[]`)—there’s nothing in it. But what if you want to have a list with room for ten elements but with nothing useful in it? You could use `[42]*10`, as before, or perhaps more realistically `[0]*10`. You now have a list with ten zeros in it. Sometimes, however, you would like a value that somehow means “nothing,” as in “we haven’t put anything here yet.” That’s when you use `None`. __`None` is a Python value and means exactly that— “nothing here.”__ So if you want to initialize a list of length 10, you could do the following:

 {{{
>>> sequence = [None] * 10
>>> sequence
[None, None, None, None, None, None, None, None, None, None]
 }}}

Listing 2-3 contains a program that prints (to the screen) a “box” made up of characters, which is centered on the screen and adapted to the size of a sentence supplied by the user. The code may look complicated, but it’s basically just arithmetic—figuring out how many spaces, dashes, and so on you need in order to place things correctly.

Listing 2-3. Sequence (String) Multiplication Example

 {{{
# Prints a sentence in a centered "box" of correct width

# Note that the integer division operator (//) only works in Python
# 2.2 and newer. In earlier versions, simply use plain division (/)

sentence = raw_input("Sentence: ")

screen_width = 80
text_width   = len(sentence)
box_width    = text_width + 6 // 應該是加 4 才封; 外加左側的 '| ' 與右側的 ' |'
left_margin  = (screen_width - box_width) // 2

print
print ' ' * left_margin + '+'  + '-' * (box_width-2) + '+'
print ' ' * left_margin + '| ' + ' ' * text_width    + ' |'
print ' ' * left_margin + '| ' +       sentence      + ' |'
print ' ' * left_margin + '| ' + ' ' * text_width    + ' |'
print ' ' * left_margin + '+'  + '-' * (box_width-2) + '+'
print
 }}}

The following is a sample run:

 {{{
Sentence: He's a very naughty boy!

                         +——————————————————————————+
                         |                          |
                         | He's a very naughty boy! |
                         |                          |
                         +——————————————————————————+
 }}}

=== Membership ===

__To check whether a value can be found in a sequence, you use the `in` operator. This operator is a bit different from the ones discussed so far (such as multiplication or addition). It checks whether something is true and returns a value accordingly: `True` for true and `False` for false.__ Such operators are called Boolean operators, and the truth values are called Boolean values. You learn more about Boolean expressions in the section on conditional statements in Chapter 5.

Here are some examples that use the in operator:

 {{{
>>> permissions = 'rw'
>>> 'w' in permissions
True
>>> 'x' in permissions
False
>>> users = ['mlh', 'foo', 'bar']
>>> raw_input('Enter your user name: ') in users
Enter your user name: mlh
True
>>> subject = '$$$ Get rich now!!! $$$'
>>> '$$$' in subject
True
 }}}

The first two examples use the membership test to check whether `'w'` and `'x'`, respectively, are found in the string `permissions`. This could be a script on a UNIX machine checking for writing and execution permissions on a file. The next example checks whether a supplied user name (`mlh`) is found in a list of users. This could be useful if your program enforces some security policy. (In that case, you would probably want to use passwords as well.) The last example checks whether the string `subject` contains the string `'$$$'`. This might be used as part of a spam filter, for example.

{{{{#!wiki note
The example that checks whether a string contains `'$$$'` is a bit different from the others. In general,
the in operator checks whether an object is a member (that is, an element) of a sequence (or some other collection).
__However, the only members or elements of a string are its characters.__ So, the following makes perfect sense:

 {{{
>>> 'P' in 'Python'
True
 }}}

In fact, in earlier versions of Python this was the only membership check that worked with strings—finding out whether a character is in a string. Trying to check for a longer substring, such as `'$$$'`, would give you an error message (it would raise a `TypeError`), and you’d have to use a string method. You learn more about those in Chapter 3. __In Python 2.3 and later, however, you can use the `in` operator to check whether any string is a substring of another.__
}}}}

Listing 2-4 shows a program that reads in a user name and checks the entered PIN code against a database (a list, actually) that contains pairs (more lists) of names and PIN codes. If the name/PIN pair is found in the database, the string 'Access granted' is printed. (The `if` statement was mentioned in Chapter 1 and will be fully explained in Chapter 5.)

Listing 2-4. Sequence Membership Example

 {{{
# Check a user name and PIN code
database = [
    ['albert', '1234'],
    ['dilbert', '4242'],
    ['smith', '7524'],
    ['jones', '9843']
]

username = raw_input('User name: ')
pin = raw_input('PIN code: ')

if [username, pin] in database: print 'Access granted'
 }}}

=== Length, Minimum, and Maximum ===

The built-in functions `len`, `min`, and `max` can be quite useful. The function `len` returns the number of elements a sequence contains. `min` and `max` return the smallest and largest element of the sequence, respectively. (You learn more about comparing objects in Chapter 5, in the section “Comparison Operators.”)

 {{{
>>> numbers = [100, 34, 678]
>>> len(numbers)
3
>>> max(numbers)
678
>>> min(numbers)
34
>>> max(2, 3)
3
>>> min(9, 3, 2, 5)
2
 }}}

How this works should be clear from the previous explanation, except possibly the last two expressions. __In those, `max` and `min` are not called with a sequence argument; the numbers are supplied directly as arguments.__

== Lists: Python’s Workhorse ==

In the previous examples, I’ve used lists quite a bit. You’ve seen how useful they are, but this section deals with what makes them different from tuples and strings: lists are mutable—that is, you can change their contents—and they have many useful specialized methods.

=== The list Function ===

Because strings can’t be modified in the same way as lists, sometimes it can be useful to create a list from a string. __You can do this with the `list` function: (It’s actually a type, not a function, but the difference isn’t important right now.)__

 {{{
>>> list('Hello')
['H', 'e', 'l', 'l', 'o']
 }}}

Note that list works with all kinds of sequences, not just strings.

{{{{#!wiki tip
Tip To convert a list of characters such as the preceding code back to a string, you would use the following expression:

 {{{
''.join(somelist)
 }}}

where `somelist` is your list. For an explanation of what this really means, see the section about join in Chapter 3.
}}}}

=== Basic List Operations ===

You can perform all the standard sequence operations on lists, such as indexing, slicing, concatenating, and multiplying. But the interesting thing about lists is that they can be modified. In this section, you see some of the ways you can change a list: item assignments, item deletion, slice assignments, and list methods. (Note that not all list methods actually change their list.)

==== Changing Lists: Item Assignments ====

Changing a list is easy. You just use ordinary assignment as explained in Chapter 1. However, instead of writing something like `x = 2`, you use the indexing notation to assign to a specific, existing position, such as `x[1] = 2`.

 {{{
>>> x = [1, 1, 1]
>>> x[1] = 2
>>> x
[1, 2, 1]
 }}}

Note: __You cannot assign to a position that doesn’t exist; if your list is of length 2, you cannot assign a value to index 100. To do that, you would have to make a list of length 101 (or more).__ See the section “None, Empty Lists, and Initialization,” earlier in this chapter.

==== Deleting Elements ====

Deleting elements from a list is easy, too. You can simply use the `del` statement:

 {{{
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
>>> del names[2]
>>> names
['Alice', 'Beth', 'Dee-Dee', 'Earl']
 }}}

Notice how Cecil is completely gone, and the length of the list has shrunk from five to four.

__The `del` statement may be used to delete things other than list elements. It can be used with dictionaries (see Chapter 4) or even variables.__ For more information, see Chapter 5.

==== Assigning to Slices ====

Slicing is a very powerful feature, and it is made even more powerful by the fact that you can assign to slices:

 {{{
>>> name = list('Perl')
>>> name
['P', 'e', 'r', 'l']
>>> name[2:] = list('ar')
>>> name
['P', 'e', 'a', 'r']
 }}}

__'''So you can assign to several positions at once. (搭配 Step, 還可以做到非連續 Elements 的置換)''' You may wonder what the big deal is. Couldn’t you just have assigned to them one at a time? Sure, but when you use slice assignments, you may also replace the slice with a sequence whose length is different from that of the original:__

 {{{
>>> name = list('Perl')
>>> name[1:] = list('ython')
>>> name
['P', 'y', 't', 'h', 'o', 'n']
 }}}

__Slice assignments can even be used to insert elements without replacing any of the original ones:__

 {{{
>>> numbers = [1, 5]
>>> numbers[1:1] = [2, 3, 4]
>>> numbers
[1, 2, 3, 4, 5]
 }}}

__Here, I basically “replaced” an empty slice, thereby really inserting a sequence. You can do the reverse to delete a slice:__

 {{{
>>> numbers
[1, 2, 3, 4, 5]
>>> numbers[1:4] = []
>>> numbers
[1, 5]
 }}}

As you may have guessed, this last example is equivalent to `del numbers[1:4]`. __(Now why don’t you try a slice assignment with a step size different from 1? Perhaps even a negative one?)__

=== List Methods ===

You’ve encountered functions already, but now it’s time to meet a close relative: methods.

A method is a function that is tightly coupled to some object, be it a list, a number, a string, or whatever. In general, a method is called like this:

 {{{
object.method(arguments)
 }}}

As you can see, a method call looks just like a function call, except that the object is put before the method name, with a dot separating them. (You get a much more detailed explanation of what methods really are in Chapter 7.)

Lists have several methods that allow you to examine or modify their contents.

==== append ====

The `append` method is used to append an object to the end of a list:

 {{{
>>> lst = [1, 2, 3]
>>> lst.append(4)
>>> lst
[1, 2, 3, 4]
 }}}

You might wonder why I have chosen such an ugly name as `lst` for my list. Why not call it list? I could do that, but as you might remember, `list` is a built-in function. (Actually, from version 2.2 of Python, `list` is a type, not a function. (This is the case with `tuple` and `str` as well.) For the full story on this, see the section “Subclassing list, dict, and str” in Chapter 9.) __If I use the name for a list instead, I won’t be able to call the function anymore. You can generally find better names for a given application.__ A name such as `lst` really doesn’t tell you anything. So if your list is a list of prices, for instance, you probably ought to call it something like `prices`, `prices_of_eggs`, or `pricesOfEggs`.

__It’s also important to note that `append`, like several similar methods, changes the list ''in place''. This means that it does not simply return a new, modified list; instead, it modifies the old one directly. This is usually what you want, but it may sometimes cause trouble.__ I’ll return to this discussion when I describe sort later in the chapter.

==== count ====

The `count` method counts the occurrences of an element in a list:

 {{{
>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to')
2
>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
>>> x.count(1)
2
>>> x.count([1, 2])
1
 }}}

==== extend ====

__The `extend` method allows you to append several values at once by supplying a sequence of the values you want to append.__ In other words, your original list has been extended by the other one:

 {{{
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a.extend(b)
>>> a
[1, 2, 3, 4, 5, 6]
 }}}

__This may seem similar to concatenation, but the important difference is that the extended sequence (in this case, `a`) is modified. This is not the case in ordinary concatenation, in which a completely new sequence is returned:__

 {{{
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3]
 }}}

As you can see, the concatenated list looks exactly the same as the extended one in the previous example, yet a hasn’t changed this time. __Because ordinary concatenation must make a new list that contains copies of `a` and `b`, it isn’t quite as efficient as using `extend` if what you want is something like this:__

 {{{
>>> a = a + b
 }}}

__Also, this isn’t an in-place operation—it won’t modify the original.__

The effect of `extend` can be achieved by assigning to slices, as follows:

 {{{
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a[len(a):] = b
>>> a
[1, 2, 3, 4, 5, 6]
 }}}

While this works, it isn’t quite as readable.

==== index ====

The `index` method is used for searching lists to find the index of the first occurrence of a value:

 {{{
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
>>> knights.index('who')
4
>>> knights.index('herring')
Traceback (innermost last):
  File "<pyshell#76>", line 1, in ?
    knights.index('herring')
ValueError: list.index(x): x not in list
 }}}

When you search for the word `'who'`, you find that it’s located at index 4:

 {{{
>>> knights[4]
'who'
 }}}

However, when you search for `'herring'`, you get an exception because the word is not found at all. (丟出例外的成本也太高了吧?)

==== insert ====

The `insert` method is used to insert an object into a list:

 {{{
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers.insert(3, 'four')
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
 }}}

As with `extend`, you can implement `insert` with slice assignments:

 {{{
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers[3:3] = ['four']
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
 }}}

This may be fancy, but it is hardly as readable as using `insert`.

==== pop ====

The `pop` method removes an element (by default, the last one) from the list and returns it:

 {{{
>>> x = [1, 2, 3]
>>> x.pop()
3
>>> x
[1, 2]
>>> x.pop(0)
1
>>> x
[2]
 }}}

Note: The `pop` method is the only `list` method that both modifies the list and returns a value (other than `None`).

__Using `pop`, you can implement a common data structure called a ''stack''. A stack like this works just like a stack of plates(盤子). You can put plates on top, and you can remove plates from the top. The last one you put into the stack is the first one to be removed. (This principle is called last-in, first-out, or LIFO.)__

__The generally accepted names for the two stack operations (putting things in and taking them out) are ''push'' and ''pop''. Python doesn’t have push, but you can use `append` instead.__ The `pop` and `append` methods reverse each other’s results, so if you push (or `append`) the value you just popped, you end up with the same stack:

 {{{
>>> x = [1, 2, 3]
>>> x.append(x.pop())
>>> x
[1, 2, 3]
 }}}

Tip: __If you want a first-in, first-out (FIFO) queue, you can use `insert(0, ...)` instead of `append`. Alternatively, you could keep using `append` but substitute `pop(0)` for `pop()`.__ An even better solution would be to use a `deque` from the `collections` module. See Chapter 10 for more information.

==== remove ====

The `remove` method is used to remove the first occurrence of a value:

 {{{
>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
>>> x.remove('be')
>>> x
['to', 'or', 'not', 'to', 'be']
>>> x.remove('bee')
  Traceback (innermost last):
    File "<pyshell#3>", line 1, in ?
x.remove('bee')
ValueError: list.remove(x): x not in list
 }}}

As you can see, only the first occurrence is removed, and you cannot remove something (in this case, the string `'bee'`) if it isn’t in the list to begin with.

It’s important to note that this is one of the “nonreturning in-place changing” methods. It modifies the list, but returns nothing (as opposed to `pop`).

==== reverse ====

The `reverse` method reverses the elements in the list. (Not very surprising, I guess.)

 {{{
>>> x = [1, 2, 3]
>>> x.reverse()
>>> x
[3, 2, 1]
 }}}

Note that `reverse` changes the list and does not return anything (just like `remove` and `sort`, for example).

{{{{#!wiki tip
Tip: __If you want to iterate over a sequence in reverse, you can use the `reversed` function. This function doesn’t return a list, though; it returns an iterator. (You learn more about iterators in Chapter 9.) You can convert the returned object with `list`:__

 {{{
>>> x = [1, 2, 3]
>>> list(reversed(x))
[3, 2, 1]
 }}}
}}}}

==== sort ====

The `sort` method is used to sort lists in place. (In case you’re interested: from Python 2.3 on, the `sort` method uses a stable sorting algorithm.) Sorting “in place” means changing the original list so its elements are in sorted order, rather than simply returning a sorted copy of the list:

 {{{
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort()
>>> x
[1, 2, 4, 6, 7, 9]
 }}}

You’ve encountered several methods already that modify the list without returning anything, and in most cases that behavior is quite natural (as with `append`, for example). But I want to emphasize this behavior in the case of `sort` because so many people seem to be confused by it. The confusion usually occurs when users want a sorted copy of a list while leaving the original alone. An intuitive (but wrong) way of doing this is as follows:

 {{{
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.sort() # Don't do this!
>>> print y
None
 }}}

__Because `sort` modifies `x` but returns nothing, you end up with a sorted `x` and a `y` containing `None`.__ One correct way of doing this would be to first bind `y` to a copy of `x`, and then sort `y`, as follows:

 {{{
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x[:]
>>> y.sort()
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]
 }}}

Recall that `x[:]` is a slice containing all the elements of `x`, effectively a copy of the entire list. Simply assigning `x` to `y` wouldn’t work because both `x` and `y` would refer to the same list:

 {{{
>>> y = x
>>> y.sort()
>>> x
[1, 2, 4, 6, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]
 }}}

Another way of getting a sorted copy of a list is using the `sorted` function:

 {{{
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = sorted(x)
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]
 }}}

__This function can actually be used on any sequence, but will always return a list: (The `sorted` function can, in fact, be used on any iterable object.__ You learn more about iterable objects in Chapter 9.)

 {{{
>>> sorted('Python')
['P', 'h', 'n', 'o', 't', 'y']
 }}}

__If you want to sort the elements in reverse order, you can use `sort` (or `sorted`), followed by a call to the `reverse` method, or you could use the `reverse` argument, described in the following section.__

==== Advanced Sorting ====

If you want to have your elements sorted in a specific manner (other than `sort`’s default behavior, which is to sort elements in ascending order, according to Python’s ''default comparison rules'', as explained in Chapter 5), __you can define your own comparison function, of the form `compare(x,y)`, which returns a negative number when x < y, a positive number when x > y, and zero when x == y (according to your definition).__ You can then supply this as a parameter to `sort`. The built-in function `cmp` provides the default behavior:

 {{{
>>> cmp(42, 32)
1
>>> cmp(99, 100)
-1
>>> cmp(10, 10)
0
>>> numbers = [5, 2, 9, 7]
>>> numbers.sort(cmp)
>>> numbers
[2, 5, 7, 9]
 }}}

The `sort` method has two other optional arguments: `key` and `reverse`. If you want to use them, you normally specify them by name (so-called ''keyword arguments''; you learn more about those in Chapter 6). __The `key` argument is similar to the `cmp` argument: you supply a function and it’s used in the sorting process. However, instead of being used directly for determining whether one element is smaller than another, the function is used to create a key for each element, and the elements are sorted according to these keys.__ So, for example, if you want to sort the elements according to their lengths, you use `len` as the key function:

 {{{
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
>>> x.sort(key=len)
>>> x
['add', 'acme', 'aerate', 'abalone', 'aardvark']
 }}}

The other keyword argument, `reverse`, is simply a truth value (`True` or `False`; you learn more about these in Chapter 5) indicating whether the list should be sorted in reverse:

 {{{
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort(reverse=True)
>>> x
[9, 7, 6, 4, 2, 1]
 }}}

__The `cmp`, `key`, and `reverse` arguments are available in the `sorted` function as well.__ In many cases, using custom functions for `cmp` or `key` will be useful. You learn how to define your own functions in Chapter 6.

Tip: If you would like to read more about sorting, you may want to check out Andrew Dalke’s “Sorting Mini-HOWTO,” found at [[http://wiki.python.org/moin/HowTo/Sorting]].

== Tuples: Immutable Sequences ==

Tuples are sequences, just like lists. The only difference is that tuples can’t be changed. (There are some technical differences in the way tuples and lists work behind the scenes, but you probably won’t notice it in any practical way. And tuples don’t have methods the way lists do. Don’t ask me why. As you may have noticed, this is also true of strings.) __The tuple syntax is simple—if you separate some values with commas, you automatically have a tuple:__

 {{{
>>> 1, 2, 3
(1, 2, 3)
 }}}

As you can see, tuples may also be (and often are) enclosed in parentheses:

 {{{
>>> (1, 2, 3)
(1, 2, 3)
 }}}

The empty tuple is written as two parentheses containing nothing:

 {{{
>>> ()
()
 }}}

__So, you may wonder how to write a tuple containing a single value. This is a bit peculiar— '''you have to include a comma, even though there is only one value:'''__

 {{{
>>> 42
42
>>> 42,
(42,)
>>> (42,)
(42,)
 }}}

The last two examples produce tuples of length one, while the first is not a tuple at all. __The comma is crucial(關係重大的). Simply adding parentheses won’t help: `(42)` is exactly the same as 42. One lonely comma, however, can change the value of an expression completely:__

 {{{
>>> 3*(40+2)
126
>>> 3*(40+2,)
(42, 42, 42)
 }}}

=== The tuple Function ===

The `tuple` function works in pretty much the same way as `list`: it takes one sequence argument and converts it to a `tuple`. (Like `list`, `tuple` isn’t really a function—it’s a type. And, as with `list`, you can safely ignore this for now.) __If the argument is already a tuple, it is returned unchanged:__

 {{{
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> tuple('abc')
('a', 'b', 'c')
>>> tuple((1, 2, 3))
(1, 2, 3)
 }}}

=== Basic Tuple Operations ===

As you may have gathered, tuples aren’t very complicated—and there isn’t really much you can do with them except create them and access their elements, and you do this the same as with other sequences:

 {{{
>>> x = 1, 2, 3
>>> x[1]
2
>>> x[0:2]
(1, 2)
 }}}

__As you can see, slices of a tuple are also tuples, just as list slices are themselves lists.__

=== So What’s the Point? ===

By now you are probably wondering why anyone would ever want such a thing as an ''immutable (unchangeable) sequence''. Can’t you just stick to lists and leave them alone when you don’t want them to change? Basically, yes. However, there are two important reasons why you need to know about tuples:

 * __They can be used as keys in mappings (and members of sets); lists can’t be used this way.__ You’ll learn more mappings in Chapter 4.

 * They are returned by some built-in functions and methods, which means that you have to deal with them. __As long as you don’t try to change them, “dealing” with them most often means treating them just like lists (unless you need methods such as `index` and `count`, which `tuples` don’t have).__

In general, lists will probably be adequate(足夠的) for all your sequencing needs.

== A Quick Summary ==

Let’s review some of the most important concepts covered in this chapter:

 * Sequences: A sequence is a data structure in which the elements are numbered (starting with zero). Examples of sequence types are lists, strings, and tuples. Of these, lists are mutable (you can change them), whereas tuples and strings are immutable (once they’re created, they’re fixed). Parts of a sequence can be accessed through slicing, supplying two indices, indicating the starting and ending position of the slice. To change a list, you assign new values to its positions, or use assignment to overwrite entire slices.

 * Membership: Whether a value can be found in a sequence (or other container) is checked with the operator `in`. __Using `in` with strings is a special case—it will let you look for substrings.__

 * Methods: Some of the built-in types (such as lists and strings, but not tuples) have many useful methods ''attached'' to them. (有點像 Groovy JDK 的說法) These are a bit like functions, except that they are tied closely to a specific value. Methods are an important aspect of object-oriented programming, which we look at in Chapter 7.

=== New Functions in This Chapter ===

|| Function || Description ||
|| `cmp(x, y)` || Compares two values ||
|| `len(seq)` || Returns the length of a sequence ||
|| `list(seq)` || Converts a sequence to a list ||
|| `max(args)` || Returns the maximum of a sequence or set of arguments ||
|| `min(args)` || Returns the minimum of a sequence or set of arguments ||
|| `reversed(seq)` || Lets you iterate over a sequence in reverse ||
|| `sorted(seq)` || Returns a sorted list of the elements of seq ||
|| `tuple(seq)` || Converts a sequence to a tuple ||

=== What Now? ===

Now that you’re acquainted with sequences, let’s move on to character sequences, also known as strings.

= Chapter 3. Working with Strings =

You’ve seen strings before, and know how to make them. You’ve also looked at how to access their individual characters by indexing and slicing. In this chapter, you see how to use them to format other values (for printing, for example), and take a quick look at the useful things you can do with string methods, such as splitting, joining, searching, and more.

== Basic String Operations ==

All the standard sequence operations (indexing, slicing, multiplication, membership, length, minimum, and maximum) work with strings, as you saw in the previous chapter. Remember, however, that strings are immutable, so all kinds of item or slice assignments are illegal:

 {{{
>>> website = 'http://www.python.org'
>>> website[-3:] = 'com'
Traceback (most recent call last):
  File "<pyshell#19>", line 1, in ?
    website[-3:] = 'com'
TypeError: object doesn't support slice assignment
 }}}

== String Formatting: The Short Version ==

If you are new to Python programming, chances are you won’t need all the options that are available in Python string formatting, so I’ll give you the short version here. If you are interested in the details, take a look at the section “String Formatting: The Long Version,” which follows. Otherwise, just read this and skip down to the section “String Methods.”

String formatting uses the (aptly(適當地) named) ''string formatting operator'', the percent (`%`) sign.

Note: As you may remember, `%` is also used as a modulus (remainder) operator.

__To the left of the `%`, you place a string (the format string); to the right of it, you place the value you want to format. You can use a single value such as a string or a number, you can use a tuple of values (if you want to format more than one),__ or, as I discuss in the next chapter, you can use a dictionary. The most common case is the tuple:

 {{{
>>> format = "Hello, %s. %s enough for ya?"
>>> values = ('world', 'Hot')
>>> print format % values
Hello, world. Hot enough for ya?
 }}}

Note: __If you use a list or some other sequence instead of a tuple, the sequence will be interpreted as a single value. Only tuples and dictionaries (discussed in Chapter 4) will allow you to format more than one value.__

The `%s` parts of the format string are called ''conversion specifiers''. They mark the places where the values are to be inserted. __The `s` means that the values should be formatted as if they were strings; if they aren’t, they’ll be converted with `str`.__ This works with most values. For a list of other specifier types, see Table 3-1 later in the chapter.

Note: __To actually include a percent sign in the format string, you must write `%%` so Python doesn’t mistake it for the beginning of a conversion specifier.__

__If you are formatting real numbers (floats), you can use the `f` specifier type and supply the precision as a `.` (dot), followed by the number of decimals you want to keep. The format specifier always ends with a ''type character'', so you must put the precision before that:__

 {{{
>>> format = "Pi with three decimals: %.3f"
>>> from math import pi
>>> print format % pi
Pi with three decimals: 3.142
 }}}

{{{{#wiki note
'''TEMPLATE STRINGS'''

__The `string` module offers another way of formatting values: ''template strings''. They work more like variable substitution in many UNIX shells, with `$foo` being replaced by a ''keyword argument'' called `foo` (for more about keyword arguments, see Chapter 6), which is passed to the template method `substitute`:__

 {{{
>>> from string import Template
>>> s = Template('$x, glorious $x!')
>>> s.substitute(x='slurm')
'slurm, glorious slurm!'
 }}}

If the ''replacement field'' is part of a word, the name must be enclosed in braces, in order to clearly indicate where it ends:

 {{{
>>> s = Template("It's ${x}tastic!")
>>> s.substitute(x='slurm')
"It's slurmtastic!"
 }}}

In order to insert a dollar sign, use `$$`:

 {{{
>>> s = Template("Make $$ selling $x!")
>>> s.substitute(x='slurm')
'Make $ selling slurm!'
 }}}

Instead of using keyword arguments, you can supply the value-name pairs in a dictionary (see Chapter 4):

 {{{
>>> s = Template('A $thing must never $action.')
>>> d = {}
>>> d['thing'] = 'gentleman'
>>> d['action'] = 'show his socks'
>>> s.substitute(d)
'A gentleman must never show his socks.'
 }}}

__There is also a method called `safe_substitute` that will not complain about missing values or incorrect uses of the `$` character.__ For more information, see Section 4.1.2, “Template strings,” of the Python Library Reference ([[http://python.org/doc/lib/node40.html]]).
}}}}

== String Formatting: The Long Version ==

The right operand of the formatting operator may be anything; if it is either a tuple or a mapping (like a dictionary), it is given special treatment. We haven’t looked at mappings (such as dictionaries) yet, so let’s focus on tuples here. We’ll use mappings in formatting in Chapter 4, where they’re discussed in greater detail.

__If the right operand is a tuple, each of its elements is formatted separately, and you need a conversion specifier for each of the values.__

{{{{#!wiki note
__If you write the tuple to be converted as part of the ''conversion expression'', you must enclose it in parentheses to avoid confusing Python:__

 {{{
>>> '%s plus %s equals %s' % (1, 1, 2)
'1 plus 1 equals 2'
>>> '%s plus %s equals %s' % 1, 1, 2 # Lacks parentheses!
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: not enough arguments for format string
 }}}

A ''basic conversion specifier'' (as opposed to a ''full conversion specifier'', which may contain a mapping key as well; see Chapter 4 for more information) consists of the items that follow.

Note that the order of these items is crucial.

 * The `%` character: This marks the beginning of the conversion specifier.

 * Conversion flags: __These are optional and may be `-`, indicating left alignment; `+`, indicating that a sign should precede the converted value; “ ” (a space character), indicating that a space should precede positive numbers; or 0, indicating that the conversion should be zero-padded.__

 * The minimum field width: This is also optional and specifies that the converted string will be at least this wide. __If this is an `*` (asterisk), the width will be read from the value tuple.__

 * A `.` (dot) followed by the precision: This is also optional. If a real number is converted, this many decimals should be shown. If a string is converted, this number is the maximum field width. If this is an `*` (asterisk), the precision will be read from the value tuple.

 * The conversion type: This can be any of the types listed in Table 3-1.

Table 3-1. String Formatting Conversion Types

|| Conversion Type || Meaning ||
|| `d`, `i` || Signed integer decimal ||
|| `o` || Unsigned octal ||
|| `u` || Unsigned decimal ||
|| `x` || Unsigned hexadecimal (lowercase) ||
|| `X` || Unsigned hexadecimal (uppercase) ||
|| `e` || Floating-point exponential format (lowercase) ||
|| `E` || Floating-point exponential format (uppercase) ||
|| `f`, `F` || Floating-point decimal format ||
|| `g` || Same as `e` if exponent is greater than -4 or less than precision; `f` otherwise ||
|| `G` || Same as `E` if exponent is greater than -4 or less than precision; `F` otherwise ||
|| `c` || Single character (accepts an integer or a single character string) ||
|| `r` || String (converts any Python object using `repr`) ||
|| `s` || String (converts any Python object using `str`) ||

The following sections discuss the various elements of the conversion specifiers in more detail.

=== Simple Conversion ===

The simple conversion, with only a conversion type, is really easy to use:

 {{{
>>> 'Price of eggs: $%d' % 42
'Price of eggs: $42'
>>> 'Hexadecimal price of eggs: %x' % 42
'Hexadecimal price of eggs: 2a'
>>> from math import pi
>>> 'Pi: %f...' % pi
'Pi: 3.141593...'
>>> 'Very inexact estimate of pi: %i' % pi
'Very inexact estimate of pi: 3'
>>> 'Using str: %s' % 42L
'Using str: 42'
>>> 'Using repr: %r' % 42L
'Using repr: 42L'
 }}}

=== Width and Precision ===

A conversion specifier may include a field width and a precision. The width is the minimum number of characters reserved for a formatted value. The precision is (for a numeric conversion) the number of decimals that will be included in the result or (for a string conversion) the maximum number of characters the formatted value may have.

These two parameters are supplied as two integer numbers (width first, then precision), separated by a . (dot). __Both are optional, but if you want to supply only the precision, you must also include the dot:__

 {{{
>>> '%10f' % pi # Field width 10
' 3.141593'
>>> '%10.2f' % pi # Field width 10, precision 2
'      3.14'
>>> '%.2f' % pi # Precision 2
'3.14'
>>> '%.5s' % 'Guido van Rossum'
'Guido'
 }}}

You can use an `*` (asterisk) as the width or precision (or both). In that case, the number will be read from the tuple argument:

 {{{
>>> '%.*s' % (5, 'Guido van Rossum')
'Guido'
 }}}

=== Signs, Alignment, and Zero-Padding ===

Before the width and precision numbers, you may put a “flag,” which may be either zero, plus, minus, or blank. A zero means that the number will be zero-padded:

 {{{
>>> '%010.2f' % pi
'0000003.14'
 }}}

It’s important to note here that the leading zero in 010 in the preceding code does not mean that the width specifier is an octal number, as it would in a normal Python number. When you use 010 as the width specifier, it means that the width should be 10 and that the number should be zero-padded, not that the width should be 8:

 {{{
>>> 010
8
 }}}

A minus sign (`-`) left-aligns the value:

 {{{
>>> '%-10.2f' % pi
'3.14      '
 }}}

As you can see, any extra space is put on the right-hand side of the number.

A blank (“ ”) means that a blank should be put in front of positive numbers. This may be useful for aligning positive and negative numbers:

 {{{
>>> print ('% 5d' % 10) + '\n' + ('% 5d' % -10)F
   10
  -10
 }}}

Finally, a plus (`+`) means that a sign (either plus or minus) should precede both positive and negative numbers (again, useful for aligning):

 {{{
>>> print ('%+5d' % 10) + '\n' + ('%+5d' % -10)
  +10
  -10
 }}}

In the example shown in Listing 3-1, I use the asterisk width specifier to format a table of fruit prices, where the user enters the total width of the table. Because this information is supplied by the user, I can’t hard-code the field widths in my conversion specifiers. By using the asterisk, I can have the field width read from the converted tuple.

Listing 3-1. String Formatting Example

 {{{
# Print a formatted price list with a given width

width = input('Please enter width: ')

price_width = 10
item_width = width - price_width

header_format = '%-*s%*s'
format        = '%-*s%*.2f'

print '=' * width

print header_format % (item_width, 'Item', price_width, 'Price')

print '-' * width

print format % (item_width, 'Apples', price_width, 0.4)
print format % (item_width, 'Pears', price_width, 0.5)
print format % (item_width, 'Cantaloupes', price_width, 1.92)
print format % (item_width, 'Dried Apricots (16 oz.)', price_width, 8)
print format % (item_width, 'Prunes (4 lbs.)', price_width, 12)
print '=' * width
 }}}

The following is a sample run of the program:

 {{{
Please enter width: 35
===================================
Item                          Price
———————————————————————————————————
Apples                         0.40
Pears                          0.50
Cantaloupes                    1.92
Dried Apricots (16 oz.)        8.00
Prunes (4 lbs.)               12.00
===================================
 }}}

== String Methods ==

You have already encountered methods in lists. __Strings have a much richer set of methods, in part(在某種程度上) because strings have “inherited” many of their methods from the `string` module where they resided as functions in earlier versions of Python__ (and where you may still find them, if you feel the need).

Because there are so many string methods, only some of the most useful ones are described here. For a full reference, see Appendix B. In the description of the string methods, you will find references to other, related string methods in this chapter (marked “See also”) or in Appendix B.

{{{#!wiki note
'''BUT STRING ISN’T DEAD'''

Even though string methods have completely upstaged(搶風頭) the `string` module, the module still includes a few constants and functions that aren’t available as string methods. The `maketrans` function is one example and will be discussed together with the `translate` method in the material that follows. The following are some useful constants available from `string`. (For a more thorough description of the module, check out Section 4.1 of the Python Library Reference ([[http://python.org/doc/lib/module-string.html]]).)

 * `string.digits`: A string containing the digits 0-9
 * `string.letters`: A string containing all letters (uppercase and lowercase)
 * `string.lowercase`: A string containing all lowercase letters
 * `string.printable`: A string containing all printable characters
 * `string.punctuation`: A string containing all punctuation characters
 * `string.uppercase`: A string containing all uppercase letters

__Note that the string constant letters (such as `string.letters`) are ''locale-dependent'' (that is, their exact values depend on the language for which Python is configured). (In Python 3.0, `string.letters` and friends will be removed. You will need to use constants like `string.ascii_letters` instead.)__ If you want to make sure you’re using ASCII, you can use the variants with `ascii_` in their names, such as `string.ascii_letters`.
}}}

=== find ===

The `find` method finds a substring within a larger string. It returns the leftmost index where the substring is found. __If it is not found, `-1` is returned:__

 {{{
>>> 'With a moo-moo here, and a moo-moo there'.find('moo')
7
>>> title = "Monty Python's Flying Circus"
>>> title.find('Monty')
0
>>> title.find('Python')
6
>>> title.find('Flying')
15
>>> title.find('Zirquss')
-1
 }}}

In our first encounter with membership in Chapter 2, we created part of a spam filter by using the expression `'$$$'` in subject. We could also have used `find` (which would also have worked prior to Python 2.3, when in could be used only when checking for single character membership in strings):

 {{{
>>> subject = '$$$ Get rich now!!! $$$'
>>> subject.find('$$$')
0
 }}}

Note: The string method `find` does not return a Boolean value. If find returns 0, as it did here, it means that it has found the substring, at index zero.

You may also supply a starting point for your search and, optionally, an ending point:

 {{{
>>> subject = '$$$ Get rich now!!! $$$'
>>> subject.find('$$$')
0
>>> subject.find('$$$', 1) # Only supplying the start
20
>>> subject.find('!!!')
16
>>> subject.find('!!!', 0, 16) # Supplying start and end
-1
 }}}

__Note that the range specified by the start and stop values (second and third parameters) includes the first index but not the second. This is ''common practice'' in Python.__

In Appendix B: `rfind`, `index`, `rindex`, `count`, `startswith`, `endswith`.

=== join ===

__A very important string method, `join` is the inverse of `split`. It is used to join the elements of a sequence:__

 {{{
>>> seq = [1, 2, 3, 4, 5]
>>> sep = '+'
>>> sep.join(seq) # Trying to join a list of numbers
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: sequence item 0: expected string, int found
>>> seq = ['1', '2', '3', '4', '5']
>>> sep.join(seq) # Joining a list of strings
'1+2+3+4+5'
>>> dirs = '', 'usr', 'bin', 'env'
>>> '/'.join(dirs)
'/usr/bin/env'
>>> print 'C:' + '\\'.join(dirs)
C:\usr\bin\env
 }}}

__As you can see, the sequence elements that are to be joined must all be strings.__ Note how in the last two examples I use a list of directories and format them according to the conventions of UNIX and DOS/Windows simply by using a different separator (and adding a drive name in the DOS version).

See also: `split`.

==== lower ====

The `lower` method returns a lowercase version of the string:

 {{{
>>> 'Trondheim Hammer Dance'.lower()
'trondheim hammer dance'
 }}}

This can be useful if you want to write code that is case insensitive—that is, code that ignores the difference between uppercase and lowercase letters. For instance, suppose you want to check whether a user name is found in a list. If your list contains the string `'gumby'` and the user enters his name as 'Gumby', you won’t find it:

 {{{
>>> if 'Gumby' in ['gumby', 'smith', 'jones']: print 'Found it!'
...
>>>
 }}}

Of course, the same thing will happen if you have stored `'Gumby'` and the user writes `'gumby'`, or even `'GUMBY'`. A solution to this is to convert all names to lowercase both when storing and searching. The code would look something like this:

 {{{
>>> name = 'Gumby'
>>> names = ['gumby', 'smith', 'jones']
>>> if name.lower() in names: print 'Found it!'
...
Found it!
>>>
 }}}

See also: `translate`.

In Appendix B: `islower`, `capitalize`, `swapcase`, `title`, `istitle`, `upper`, `isupper`.

{{{{#!wiki note
'''TITLE CASING'''

One relative of `lower` is the `title` method (see Appendix B), which title cases a string—that is, all words start with uppercase characters, and all other characters are lowercased. However, the word boundaries are defined in a way that may give some unnatural results:

 {{{
>>> "that's all folks".title()
"That'S All, Folks"
 }}}

An alternative is the `capwords` function from the `string` module:

 {{{
>>> import string
>>> string.capwords("that's all, folks")
"That's All, Folks"
 }}}

Of course, if you want a truly correctly capitalized title (which depends on the style you’re using—possibly lowercasing articles, coordinating conjunctions, prepositions(介系詞) with fewer than five letters, and so forth), you’re basically on your own(靠自己?).
}}}}

==== replace ====

__The `replace` method returns a string where ''all'' the occurrences of one string have been replaced by another:__

 {{{
>>> 'This is a test'.replace('is', 'eez')
'Theez eez a test'
 }}}

If you have ever used the “search and replace” feature of a word processing program, you will no doubt see the usefulness of this method.

See also: `translate`.

In Appendix B: `expandtabs`.

==== split ====

__A very important string method, `split` is the inverse of `join`, and is used to split a string into a sequence:__

 {{{
>>> '1+2+3+4+5'.split('+')
['1', '2', '3', '4', '5']
>>> '/usr/bin/env'.split('/')
['', 'usr', 'bin', 'env']
>>> 'Using the default'.split()
['Using', 'the', 'default']
 }}}

__Note that if no separator is supplied, the default is to split on all runs of consecutive(連續的) whitespace characters (spaces, tabs, newlines, and so on).__

See also: `join`.

In Appendix B: `rsplit`, `splitlines`.

==== strip ====

__The `strip` method returns a string where whitespace on the left and right (but not internally) has been stripped (removed):__

 {{{
>>> '      internal whitespace is kept      '.strip()
'internal whitespace is kept'
 }}}

As with `lower`, `strip` can be useful when comparing input to stored values. Let’s return to the user name example from the section on `lower`, and let’s say that the user inadvertently types a space after his name:

 {{{
>>> names = ['gumby', 'smith', 'jones']
>>> name = 'gumby '
>>> if name in names: print 'Found it!'
...
>>> if name.strip() in names: print 'Found it!'
...
Found it!
>>>
 }}}

__You can also specify which characters are to be stripped, by listing them all in a string parameter:__

 {{{
>>> '*** SPAM * for * everyone!!! ***'.strip(' *!')
'SPAM * for * everyone'
 }}}

Stripping is performed only at the ends, so the internal asterisks are not removed.

In Appendix B: `lstrip`, `rstrip`.

==== translate ====

Similar to `replace`, `translate` replaces parts of a string, but unlike `replace`, `translate` works only with single characters. __Its strength lies in that it can perform several replacements simultaneously, and can do so more efficiently than `replace`.__

__There are quite a few rather technical uses for this method (such as translating newline characters or other platform-dependent special characters),__ but let’s consider a simpler (although slightly more silly) example. Let’s say you want to translate a plain English text into one with a German accent. To do this, you must replace the character `c` with `k`, and `s` with `z`.

__Before you can use `translate`, however, you must make a ''translation table''. This translation table is a full listing of which characters should be replaced by which. Because this table (which is actually just a string) has 256 entries, you won’t write it out yourself. Instead, you’ll use the function `maketrans` from the `string` module.__

The `maketrans` function takes two arguments: two strings of equal length, indicating that each character in the first string should be replaced by the character in the same position in the second string. Got that? In the case of our simple example, the code would look like the following:

 {{{
>>> from string import maketrans
>>> table = maketrans('cs', 'kz')
 }}}

{{{{#!wiki note
'''WHAT’S IN A TRANSLATION TABLE?'''

A translation table is a string containing one replacement letter for each of the 256 characters in the ASCII character set:

 {{{
>>> table = maketrans('cs', 'kz')
>>> len(table)
256
>>> table[97:123]
'abkdefghijklmnopqrztuvwxyz'
>>> maketrans('', '')[97:123]
'abcdefghijklmnopqrstuvwxyz'
 }}}

As you can see, I’ve sliced out the part of the table that corresponds to the lowercase letters. Take a look at the alphabet in the table and that in the empty translation (which doesn’t change anything). The empty translation has a normal alphabet, while in the preceding code, the letter `c` has been replaced by `k`, and `s` has been replaced by `z`.
}}}}

Once you have this table, you can use it as an argument to the `translate` method, thereby translating your string:

 {{{
>>> 'this is an incredible test'.translate(table)
'thiz iz an inkredible tezt'
 }}}

An optional second argument can be supplied to `translate`, specifying letters that should be deleted. If you wanted to emulate a really fast-talking German, for instance, you could delete all the spaces:

 {{{
>>> 'this is an incredible test'.translate(table, ' ')
'thizizaninkredibletezt'
 }}}

See also: `replace`, `lower`.

{{{{#!wiki note
'''PROBLEMS WITH NON-ENGLISH STRINGS'''

Sometimes string methods such as `lower` won’t work quite the way you want them to—for instance, if you happen to use a non-English alphabet. Let’s say you want to convert the uppercase Norwegian word BØLLEFRØ to its lowercase equivalent:

 {{{
>>> print 'BØLLEFRØ'.lower()
bØllefrØ
 }}}

As you can see, this didn’t really work because Python doesn’t consider Ø a real letter. In this case, you can use `translate` to do the translation:

 {{{
>>> table = maketrans('ÆØÅ', 'æøå')
>>> word = 'KÅPESØM'
>>> print word.lower()
kÅpesØm
>>> print word.translate(table)
KåPESøM
>>> print word.translate(table).lower()
kåpesøm
 }}}

__Then again, simply using Unicode might solve your problems:__

 {{{
>>> print u'ærnæringslære'.upper()
ÆRNÆRINGSLÆRE
 }}}

You might also want to check out the `locale` module for some internationalization functionality.
}}}}

== A Quick Summary ==

In this chapter, you have seen two important ways of working with strings:

 * String formatting: The modulo operator (`%`) can be used to splice(接合) values into a string that contains conversion flags, such as `%s`. You can use this to format values in many ways, including right or left justification, setting a specific field width and precision, adding a sign (plus or minus), or left-padding with zeros.

 * String methods: __Strings have a plethora(過多) of methods. Some of them are extremely useful (such as `split` and `join`), while others are used less often (such as `istitle` or `capitalize`).__

=== New Functions in This Chapter ===


|| Function || Description ||
|| `string.capwords(s[, sep])` || Splits `s` with `split` (using `sep`), capitalize items, and join with a single space ||
|| `string.maketrans(from, to)` || Makes a translation table for `translate` ||

=== What Now? ===

Lists, strings, and dictionaries are three of the most important data types in Python. You’ve seen lists and strings, so guess what’s next? In the next chapter, you see how dictionaries not only support indices, but other kinds of keys (such as strings or tuples) as well. Dictionaries also support a few methods, although not as many as strings.

= Chapter 4. Dictionaries: When Indices Won’t Do =

You’ve seen that lists are useful when you want to ''group values into a structure'' and refer to each value by number. In this chapter, you learn about a data structure in which you can refer to each value by name. This type of structure is called a mapping. __The only built-in mapping type in Python is the dictionary. The values in a dictionary don’t have any particular order but are stored under a key, which may be a number, a string, or even a tuple.__

== Dictionary Uses ==

The name dictionary should give you a clue about the purpose of this structure. An ordinary book is made for reading from start to finish. If you like, you can quickly open it to any given page. This is a bit like a Python list. On the other hand, dictionaries—both real ones and their Python equivalent—are constructed so that you can look up a specific word (key) easily, to find its definition (value).

A dictionary is more appropriate than a list in many situations. Here are some examples of uses of Python dictionaries:

 * Representing the state of a game board, with each key being a tuple of coordinates
 * Storing file modification times, with file names as keys
 * A digital telephone/address book

Let’s say you have a list of people:

 {{{
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
 }}}

What if you wanted to create a ''little database'' where you could store the telephone numbers of these people—how would you do that? One way would be to make another list. Let’s say you’re storing only their four-digit extensions. Then you would get something like this:

 {{{
>>> numbers = ['2341', '9102', '3158', '0142', '5551']
 }}}

Once you’ve created these lists, you can look up Cecil’s telephone number as follows:

 {{{
>>> numbers[names.index('Cecil')]
3158
 }}}

{{{{#!wiki note
'''INTEGERS VS. STRINGS OF DIGITS'''

You might wonder why I have used strings to represent the telephone numbers—why not integers? Consider what would happen to Dee-Dee’s number then:

 {{{
>>> 0142
98
 }}}

Not exactly what we wanted, is it? As mentioned briefly in Chapter 1, octal numbers are written with an initial zero. It is impossible to write decimal numbers like that.

 {{{
>>> 0912
   File "<stdin>", line 1
       0912
         ^
SyntaxError: invalid syntax
 }}}

The lesson is this: telephone numbers (and other numbers that may contain leading zeros) should be represented as strings of digits—not integers.
}}}}

It works, but it’s a bit impractical. What you really would want to do is something like the following:

 {{{
>>> phonebook['Cecil']
3158
 }}}

Guess what? If phonebook is a dictionary, you can do just that.

== Creating and Using Dictionaries ==

Dictionaries are written like this:

 {{{
phonebook = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
 }}}

Dictionaries consist of pairs (called ''items'') of keys and their corresponding values. In this example, the names are the keys and the telephone numbers are the values. Each key is separated from its value by a colon (`:`), the items are separated by commas, and the whole thing is enclosed in curly braces. __An empty dictionary (without any items) is written with just two curly braces, like this: `{}`.__

Note: __Keys are unique within a dictionary (and any other kind of mapping). Values do not need to be unique within a dictionary.__

=== The dict Function ===

__You can use the `dict` function (The `dict` function isn’t really a function at all. It is a type, just like `list`, `tuple`, and `str`.) to construct dictionaries from other mappings (for example, other dictionaries) or from sequences of `(key, value)` pairs:__

 {{{
>>> items = [('name', 'Gumby'), ('age', 42)]
>>> d = dict(items)
>>> d
{'age': 42, 'name': 'Gumby'}
>>> d['name']
'Gumby'
 }}}

It can also be used with keyword arguments, as follows:

 {{{
>>> d = dict(name='Gumby', age=42)
>>> d
{'age': 42, 'name': 'Gumby'}
 }}}

__Although this is probably the most useful application of `dict`, you can also use it with a mapping argument to create a dictionary with the same items as the mapping. (If used without any arguments, it returns a new empty dictionary, just like other similar functions such as `list`, `tuple`, and `str`.) If the other mapping is a dictionary (which is, after all, the only built-in mapping type), you can use the dictionary method `copy` instead, as described later in this chapter.__

 {{{
>>> d1 = {1: 'a', 2: 'b'}; d2 = dict(d1)
>>> print d1 is d2, d1 == d2 # 好像不需要用到 copy()?
False True
 }}}

=== Basic Dictionary Operations ===

The basic behavior of a dictionary in many ways mirrors that of a sequence:

 * `len(d)` returns the number of items (key-value pairs) in `d`.
 * `d[k]` returns the value associated with the key `k`.
 * `d[k] = v` associates the value `v` with the key `k`.
 * `del d[k]` deletes the item with key `k`.
 * `k in d` checks whether there is an item in `d` that has the key `k`.

Although dictionaries and lists share several common characteristics, there are some important distinctions:

 * Key types: Dictionary keys don’t have to be integers (though they may be). __They may be any ''immutable type'', such as floating-point (real) numbers, strings, or tuples.__

 * Automatic addition: __You can assign a value to a key, even if that key isn’t in the dictionary to begin with; in that case, a new item will be created.__ You cannot assign a value to an index outside the list’s range (without using `append` or something like that).

 * Membership: The expression `k in d` (where `d` is a dictionary) looks for a key, not a value. The expression `v in l`, on the other hand (where `l` is a list) looks for a value, not an index.

This may seem a bit inconsistent, but it is actually quite natural when you get used to it.

After all, if the dictionary has the given key, checking the corresponding value is easy.

Tip: __Checking for ''key membership'' in a dictionary is much more efficient than checking for membership in a list. The difference is greater the larger the data structures are.__

The first point—that the keys may be of any immutable type—is the main strength of dictionaries. The second point is important, too. Just look at the difference here:

 {{{
>>> x = []
>>> x[42] = 'Foobar'
Traceback (most recent call last):
   File "<stdin>", line 1, in ?
IndexError: list assignment index out of range
>>> x = {}
>>> x[42] = 'Foobar'
>>> x
{42: 'Foobar'}
 }}}

First, I try to assign the string `'Foobar'` to position 42 in an empty list—clearly impossible because that position does not exist. To make this possible, I would have to initialize `x` with `[None]*43` or something, rather than simply `[]`. The next attempt, however, works perfectly. Here I assign `'Foobar'` to the key 42 of an empty dictionary. You can see there’s no problem here. A new item is simply added to the dictionary, and I’m in business.

Listing 4-1 shows the code for the telephone book example.

Listing 4-1. Dictionary Example

 {{{
# A simple database

# A dictionary with person names as keys. Each person is represented as
# another dictionary with the keys 'phone' and 'addr' referring to their phone
# number and address, respectively.

people = {

    'Alice': {
        'phone': '2341',
        'addr': 'Foo drive 23'
    },

    'Beth': {
        'phone': '9102',
        'addr': 'Bar street 42'
    },

    'Cecil': {
        'phone': '3158',
        'addr': 'Baz avenue 90'
    }

}

# Descriptive labels for the phone number and address. These will be used
# when printing the output.

labels = {
    'phone': 'phone number',
    'addr': 'address'
}

name = raw_input('Name: ')

# Are we looking for a phone number or an address?
request = raw_input('Phone number (p) or address (a)? ')

# Use the correct key:
if request == 'p': key = 'phone'
if request == 'a': key = 'addr'

# Only try to print information if the name is a valid key in
# our dictionary:
if name in people: print "%s's %s is %s." % \
    (name, labels[key], people[name][key])
 }}}

Here is a sample run of the program:

 {{{
Name: Beth
Phone number (p) or address (a)? p
Beth's phone number is 9102.
 }}}

=== String Formatting with Dictionaries ===

In Chapter 3, you saw how you could use string formatting to format all the values in a tuple. __If you use a dictionary (with only strings as keys) instead of a tuple, you can make the string formatting even snazzier(入時的). After the `%` character in each conversion specifier, you add a key (enclosed in parentheses), which is followed by the other specifier elements:__

 {{{
>>> phonebook
{'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'}
>>> "Cecil's phone number is %(Cecil)s." % phonebook
"Cecil's phone number is 3258."
 }}}

__Except for the added string key, the conversion specifiers work as before. '''When using dictionaries like this, you may have any number of conversion specifiers, as long as all the given keys are found in the dictionary.''' This sort of string formatting can be very useful in template systems (in this case using HTML):__

 {{{
>>> template = '''<html>
    <head><title>%(title)s</title></head>
    <body>
    <h1>%(title)s</h1>
    <p>%(text)s</p>
    </body>'''
>>> data = {'title': 'My Home Page', 'text': 'Welcome to my home page!'}
>>> print template % data
<html>
<head><title>My Home Page</title></head>
<body>
<h1>My Home Page</h1>
<p>Welcome to my home page!</p>
</body>
 }}}

Note: The `string.Template` class (mentioned in Chapter 3) is also quite useful for this kind of application.

=== Dictionary Methods ===

Just like the other built-in types, dictionaries have methods. While these methods can be very useful, you probably will not need them as often as the list and string methods. You might want to skim this section first to get an idea of which methods are available, and then come back later if you need to find out exactly how a given method works.

==== clear ====

The `clear` method removes all items from the dictionary. This is an in-place operation (like `list.sort`), so it returns nothing (or, rather, `None`):

 {{{
>>> d = {}
>>> d['name'] = 'Gumby'
>>> d['age'] = 42
>>> d
{'age': 42, 'name': 'Gumby'}
>>> returned_value = d.clear()
>>> d
{}
>>> print returned_value
None
 }}}

Why is this useful? Let’s consider two scenarios. Here’s the first one:

 {{{
>>> x = {}
>>> y = x
>>> x['key'] = 'value'
>>> y
{'key': 'value'}
>>> x = {} # Rebind
>>> y
{'key': 'value'}
 }}}

And here’s the second scenario:

 {{{
>>> x = {}
>>> y = x
>>> x['key'] = 'value'
>>> y
{'key': 'value'}
>>> x.clear()
>>> y
{}
 }}}

In both scenarios, `x` and `y` originally refer to the same dictionary. In the first scenario, I “blank out” `x` by assigning a new, empty dictionary to it. That doesn’t affect `y` at all, which still refers to the original dictionary. This may be the behavior you want, but if you really want to remove all the elements of the original dictionary, you must use `clear`. As you can see in the second scenario, `y` is then also empty afterward.

==== copy ====

__The `copy` method returns a new dictionary with the same key-value pairs (a ''shallow copy'', since the values themselves are the same, not copies):__

 {{{
>>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']}
>>> y = x.copy()
>>> y['username'] = 'mlh'
>>> y['machines'].remove('bar')
>>> y
{'username': 'mlh', 'machines': ['foo', 'baz']}
>>> x
{'username': 'admin', 'machines': ['foo', 'baz']}
 }}}

As you can see, when you replace a value in the copy, the original is unaffected. However, if you modify a value (in place, without replacing it), the original is changed as well because the same value is stored there (like the 'machines' list in this example).

__One way to avoid that problem is to make a ''deep copy'', copying the values, any values they contain, and so forth as well. You accomplish this using the function `deepcopy` from the `copy` module:__

 {{{
>>> from copy import deepcopy
>>> d = {}
>>> d['names'] = ['Alfred', 'Bertrand']
>>> c = d.copy()
>>> dc = deepcopy(d)
>>> d['names'].append('Clive')
>>> c
{'names': ['Alfred', 'Bertrand', 'Clive']}
>>> dc
{'names': ['Alfred', 'Bertrand']}
 }}}

==== fromkeys ====

__The `fromkeys` method creates a new dictionary with the given keys, each with a default corresponding value of `None`:__

 {{{
>>> {}.fromkeys(['name', 'age'])
{'age': None, 'name': None}
 }}}

__This example first constructs an empty dictionary and then calls the `fromkeys` method on that, in order to create another dictionary—a somewhat redundant strategy. Instead, you can call the method directly on `dict`, which (as mentioned before) is the type of all dictionaries.__ (The concept of types and classes is discussed more thoroughly in Chapter 7.)

 {{{
>>> dict.fromkeys(['name', 'age'])
{'age': None, 'name': None}
      If you don’t want to use None as the default value, you can supply your own default:
>>> dict.fromkeys(['name', 'age'], '(unknown)')
{'age': '(unknown)', 'name': '(unknown)'}
 }}}

==== get ====

__The `get` method is a forgiving(寬大的) way of accessing dictionary items. Ordinarily, when you try to access an item that is not present in the dictionary, things go very wrong:__

 {{{
>>> d = {}
>>> print d['name']
Traceback (most recent call last):
   File "<stdin>", line 1, in ?
KeyError: 'name'
 }}}

Not so with get:

 {{{
>>> print d.get('name')
None
 }}}

__As you can see, when you use `get` to access a nonexistent key, there is no exception. Instead, you get the value `None`. You may supply your own “default” value, which is then used instead of `None`:__

 {{{
>>> d.get('name', 'N/A')
'N/A'
 }}}

If the key is there, get works like ordinary dictionary lookup:

 {{{
>>> d['name'] = 'Eric'
>>> d.get('name')
'Eric'
 }}}

Listing 4-2 shows a modified version of the program from Listing 4-1, which uses the `get` method to access the “database” entries.

Listing 4-2. Dictionary Method Example

 {{{
# A simple database using get()

# Insert database (people) from Listing 4-1 here.

labels = {
    'phone': 'phone number',
    'addr': 'address'
}

name = raw_input('Name: ')

# Are we looking for a phone number or an address?
request = raw_input('Phone number (p) or address (a)? ')

# Use the correct key:
key = request # In case the request is neither 'p' nor 'a'
if request == 'p': key = 'phone'
if request == 'a': key = 'addr'

# Use get to provide default values:
person = people.get(name, {})
label = labels.get(key, key)
result = person.get(key, 'not available')

print "%s's %s is %s." % (name, label, result)
 }}}

An example run of this program follows. Notice how the added flexibility of `get` allows the program to give a useful response, even though the user enters values we weren’t prepared for:

 {{{
Name: Gumby
Phone number (p) or address (a)? batting average
Gumby's batting average is not available.
 }}}

==== has_key ====

__The `has_key` method checks whether a dictionary has a given key. The expression `d.has_key(k)` is equivalent to `k in d`. The choice of which to use is largely a matter of taste, although `has_key` is on its way out of the language (it will be gone in Python 3.0).__

Here is an example of how you might use `has_key`:

 {{{
>>> d = {}
>>> d.has_key('name')
False
>>> d['name'] = 'Eric'
>>> d.has_key('name')
True
 }}}

==== items and iteritems ====

__The `items` method returns all the items of the dictionary as a list of items in which each item is of the form `(key, value)`. The items are not returned in any particular order:__

 {{{
>>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0}
>>> d.items()
[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
 }}}

The `iteritems` method works in much the same way, but returns an ''iterator'' instead of a list:

 {{{
>>> it = d.iteritems()
>>> it
<dictionary-iterator object at 169050>
>>> list(it) # Convert the iterator to a list
[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
 }}}

__Using `iteritems` may be more efficient in many cases (especially if you want to iterate over the result).__ For more information on iterators, see Chapter 9.

==== keys and iterkeys ====

The `keys` method returns a list of the keys in the dictionary, while `iterkeys` returns an iterator over the keys.

==== pop ====

The `pop` method can be used to get the value corresponding to a given key, and then remove the key-value pair from the dictionary:

 {{{
>>> d = {'x': 1, 'y': 2}
>>> d.pop('x')
1
>>> d
{'y': 2}
 }}}

==== popitem ====

__The `popitem` method is similar to `list.pop`, which pops off the last element of a list. Unlike `list.pop`, however, `popitem` pops off an ''arbitrary'' item because dictionaries don’t have a “last element” or any order whatsoever. This may be very useful if you want to remove and process the items one by one in an efficient way (without retrieving a list of the keys first):__

 {{{
>>> d
{'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'}
>>> d.popitem()
('url', 'http://www.python.org')
>>> d
{'spam': 0, 'title': 'Python Web Site'}
 }}}

Although `popitem` is similar to the list method `pop`, there is no dictionary equivalent of `append` (which adds an element to the end of a list). Because dictionaries have no order, such a method wouldn’t make any sense.

==== setdefault ====

The `setdefault` method is somewhat similar to `get`, in that it retrieves a value associated with a given key. __In addition to the `get` functionality, `setdefault` sets the value corresponding to the given key if it is not already in the dictionary:__

 {{{
>>> d = {}
>>> d.setdefault('name', 'N/A')
'N/A'
>>> d
{'name': 'N/A'}
>>> d['name'] = 'Gumby'
>>> d.setdefault('name', 'N/A')
'Gumby'
>>> d
{'name': 'Gumby'}
 }}}

As you can see, when the key is missing, `setdefault` returns the default and updates the dictionary accordingly. If the key is present, its value is returned and the dictionary is left unchanged. The default is optional, as with `get`; if it is left out, `None` is used:

 {{{
>>> d = {}
>>> print d.setdefault('name')
None
>>> d
{'name': None}
 }}}

==== update ====

__The `update` method updates one dictionary with the items of another:__

 {{{
>>> d = {
        'title': 'Python Web Site',
        'url': 'http://www.python.org',
        'changed': 'Mar 14 22:09:15 MET 2008'
     }
>>> x = {'title': 'Python Language Website'}
>>> d.update(x)
>>> d
{'url': 'http://www.python.org', 'changed':
'Mar 14 22:09:15 MET 2008', 'title': 'Python Language Website'}
 }}}

The items in the supplied dictionary are added to the old one, supplanting any items there with the same keys.

__The `update` method can be called in the same way as the `dict` function (or type constructor), as discussed earlier in this chapter. This means that `update` can be called with a mapping, a sequence (or other iterable object) of `(key, value)` pairs, or keyword arguments.__

==== values and itervalues ====

__The `values` method returns a list of the values in the dictionary (and `itervalues` returns an iterator of the values). Unlike keys, the list returned by values may contain duplicates:__

 {{{
>>>  d = {}
>>>  d[1] = 1
>>>  d[2] = 2
>>>  d[3] = 3
>>>  d[4] = 1
>>>  d.values()
[1, 2, 3, 1]
 }}}

== A Quick Summary ==

In this chapter, you learned about the following:

 * Mappings: __A mapping enables you to ''label its elements with any immutable object'',__ the most usual types being strings and tuples. The only built-in mapping type in Python is the dictionary.

 * String formatting with dictionaries: You can apply the string formatting operation to dictionaries by including names (keys) in the formatting specifiers. __When using tuples in string formatting, you need to have one formatting specifier for each element in the tuple. When using dictionaries, you can have fewer specifiers than you have items in the dictionary.__

 * Dictionary methods: Dictionaries have quite a few methods, which are called in the same way as list and string methods.

=== New Functions in This Chapter ===

|| Function || Description ||
|| `dict(seq)` || Creates dictionary from `(key, value)` pairs (or a mapping or keyword arguments) ||

=== What Now? ===

You now know a lot about Python’s basic data types and how to use them to form expressions. As you may remember from Chapter 1, computer programs have another important ingredient(構成要素)—statements. They’re covered in detail in the next chapter.

= Chapter 5. Conditionals, Loops, and Some Other Statements =

By now, I’m sure you are getting a bit impatient(急切的). All right—all these data types are just dandy(極好的東西), but you can’t really do much with them, can you?

Let’s crank up(加快) the pace a bit. You’ve already encountered a few statement types (`print` statements, `import` statements, and assignments). Let’s first take a look at some more ways of using these before diving into the world of conditionals and loops. Then you’ll see how ''list comprehensions''[?] work almost like conditionals and loops, even though they are expressions, and finally you’ll take a look at `pass`, `del`, and `exec`.

== More About print and import ==

As you learn more about Python, you may notice that some aspects of Python that you thought you knew have hidden features just waiting to pleasantly surprise you. Let’s take a look at a couple of such nice features in `print` (In Python 3.0, `print` is no longer a statement at all—it’s a function (with essentially the same functionality.) and `import`. 

Tip: __For many applications, logging (using the `logging` module) will be more appropriate than using `print`.__ See Chapter 19 for more details.

=== Printing with Commas ===

__You’ve seen how `print` can be used to print an expression, which is either a string or automatically converted to one.__ But you can actually print more than one expression, as long as you separate them with commas:

 {{{
>>> print 'Age:', 42
Age: 42
 }}}

As you can see, a space character is inserted between each argument.

Note: __The arguments of `print` do not form a tuple, as one might expect:__

 {{{
>>> 1, 2, 3
(1, 2, 3)
>>> print 1, 2, 3
1 2 3
>>> print (1, 2, 3)
(1, 2, 3)
 }}}

__This behavior can be very useful if you want to combine text and variable values without using the full power of string formatting:__

 {{{
>>> name = 'Gumby'
>>> salutation = 'Mr.'
>>> greeting = 'Hello,'
>>> print greeting, salutation, name
Hello, Mr. Gumby
 }}}

If the greeting string had no comma, how would you get the comma in the result? You couldn’t just use

 {{{
print greeting, ',', salutation, name
 }}}

because that would introduce a space before the comma. One solution would be the following:

 {{{
print greeting + ',', salutation, name
 }}}

which simply adds the comma to the greeting.

__If you add a comma at the end, your next `print` statement will continue printing on the same line. For example, the statements__

 {{{
print 'Hello,',
print 'world!'
 }}}

print out `Hello, world!`. This will work only in a script, and not in an interactive Python session. In the interactive session, each statement will be executed (and print its contents) separately.

=== Importing Something As Something Else ===

Usually, when you import something from a module, you either use

 {{{
import somemodule
 }}}

or

 {{{
from somemodule import somefunction
 }}}

or

 {{{
from somemodule import somefunction, anotherfunction, yetanotherfunction
 }}}

or

 {{{
from somemodule import *
 }}}

__The fourth version should be used only when you are certain that you want to import everything from the given module.__ But what if you have two modules, each containing a function called `open`, for example—what do you do then? You could simply import the modules using the first form, and then use the functions as follows:

 {{{
module1.open(...)
module2.open(...)
 }}}

__But there is another option: you can add an `as` clause to the end and supply the name you want to use, either for the entire module:__

 {{{
>>> import math as foobar
>>> foobar.sqrt(4)
2.0
 }}}

or for the given function:

 {{{
>>> from math import sqrt as foobar
>>> foobar(4)
2.0
 }}}

For the `open` functions, you might use the following:

 {{{
from module1 import open as open1
from module2 import open as open2
 }}}

Note: __Some modules, such as `os.path`, are ''arranged hierarchically'' (inside each other).__ For more about module structure, see the section on packages in Chapter 10.

== Assignment Magic ==

The humble(簡單的) assignment statement also has a few tricks up its sleeve.

=== Sequence Unpacking ===

You’ve seen quite a few examples of assignments, both for variables and for parts of data structures (such as positions and slices in a list, or ''slots''[?] in a dictionary), but there is more. You can perform several different assignments ''simultaneously'':

 {{{
>>> x, y, z = 1, 2, 3
>>> print x, y, z
1 2 3
 }}}

Doesn’t sound useful? Well, you can use it to switch the contents of two (or more) variables:

 {{{
>>> x, y = y, x
>>> print x, y, z
2 1 3
 }}}

__Actually, what I’m doing here is called ''sequence unpacking'' (or ''iterable unpacking''). I have a sequence (or an arbitrary iterable object) of values, and I unpack it into a sequence of variables.__ Let me be more explicit:

 {{{
>>>  values = 1, 2, 3
>>>  values
(1,  2, 3)
>>>  x, y, z = values
>>>  x
1
 }}}

__This is particularly useful when a function or method returns a tuple (or other sequence or iterable object).__ Let’s say that you want to retrieve (and remove) an arbitrary key-value pair from a dictionary. You can then use the `popitem` method, which does just that, returning the pair as a tuple. Then you can unpack the returned tuple directly into two variables:

 {{{
>>> scoundrel = {'name': 'Robin', 'girlfriend': 'Marion'}
>>> key, value = scoundrel.popitem()
>>> key
'girlfriend'
>>> value
'Marion'
 }}}

__'''This allows functions to return more than one value, packed as a tuple,''' easily accessible through a single assignment.__ The sequence you unpack must have exactly as many items as the targets you list on the left of the `=` sign; otherwise Python raises an exception when the assignment is performed:

 {{{
>>> x, y, z = 1, 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: need more than 2 values to unpack
>>> x, y, z = 1, 2, 3, 4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: too many values to unpack
 }}}

Note: __Python 3.0 has another unpacking feature: you can use the star operator (`*`), just as in function argument lists (see Chapter 6). For example, `a, b, rest* = [1, 2, 3, 4]` will result in `rest` gathering whatever remains after assigning values to `a` and `b`. In this case, `rest` will be `[3, 4]`.__ The starred(用星星裝飾的) variable may also be placed first, and it will always contain a list. The right-hand side of the assignment may be any iterable object.

=== Chained Assignments ===

__Chained assignments are used as a shortcut when you want to bind several variables to the same value.__ This may seem a bit like the ''simultaneous assignments'' in the previous section, except that here you are dealing with only one value:

 {{{
x = y = somefunction()
 }}}

which is the same as

 {{{
y = somefunction()
x = y
 }}}

Note that the preceding statements may not be the same as

 {{{
x = somefunction()
y = somefunction()
 }}}

For more information, see the section about the identity operator (`is`), later in this chapter.

=== Augmented Assignments ===

Instead of writing `x = x + 1`, you can just put the expression operator (in this case `+`) before the assignment operator (`=`) and write `x += 1`. This is called an ''augmented assignment'', and it works with all the standard operators, such as `*`, `/`, `%`, and so on:

 {{{
>>> x = 2
>>> x += 1
>>> x *= 2
>>> x
6
 }}}

It also works with other data types (as long as the binary operator itself works with those data types):

 {{{
>>> fnord = 'foo'
>>> fnord += 'bar'
>>> fnord *= 2
>>> fnord
'foobarfoobar'
 }}}

__Augmented assignments can make your code more compact and concise, and in many cases, more readable.__

== Blocks: The Joy of Indentation ==

A block isn’t really a type of statement but something you’re going to need when you tackle the next two sections.

A block is a group of statements that can be executed if a condition is true (conditional statements), or executed several times (loops), and so on. __A block is created by indenting a part of your code; that is, putting spaces in front of it.__

Note: __You can use tab characters to indent your blocks as well. Python interprets a tab as moving to the next tab stop, with one tab stop every eight spaces, '''but the standard and preferable style is to use spaces only, not tabs, and specifically four spaces per each level of indentation.'''__

Each line in a block must be indented by the same amount. The following is pseudocode (not real Python code) that shows how the indenting works:

 {{{
this is a line
this is another line:
    this is another block
    continuing the same block
    the last line of this block
phew, there we escaped the inner block
 }}}

In many languages, a special word or character (for example, `begin` or `{`) is used to start a block, and another (such as `end` or `}`) is used to end it. __In Python, a colon (`:`) is used to indicate that a block is about to begin, and then every line in that block is indented (by the same amount). '''When you go back to the same amount of indentation as some ''enclosing block'', you know that the current block has ended.'''__ (Many programming editors and IDEs are aware of how this block indenting works, and can help you get it right without much effort.)

Now I’m sure you are curious to know how to use these blocks. So, without further ado, let’s have a look.

== Conditions and Conditional Statements ==

Until now, you’ve written programs in which each statement is executed, one after the other. It’s time to move beyond that and let your program choose whether or not to execute a block of statements.

=== So That’s What Those Boolean Values Are For ===

Now you are finally going to need those truth values (also called Boolean values, after George Boole, who did a lot of smart stuff on truth values) that you’ve been bumping into(偶然遇見) repeatedly.

Note: If you’ve been paying close attention, you noticed the sidebar in Chapter 1, “Sneak Peek: The `if` Statement,” which describes the `if` statement. I haven’t really introduced it formally until now, and as you’ll see, there is a bit more to it than what I’ve told you so far.

__The following values are considered by the interpreter to mean false when evaluated as a Boolean expression__ (for example, as the condition of an `if` statement):

 {{{
False         None        0        ""       ()       []        {}
 }}}

In other words, the standard values `False` and `None`, numeric zero of all types (including float, long, and so on), empty sequences (such as empty strings, tuples, and lists), and empty dictionaries are all considered to be false. Everything else (At least when we’re talking about built-in types—as you see in Chapter 9, you can influence whether objects you construct yourself are interpreted as true or false.) is interpreted as true, including the special value `True`. __(As Python veteran Laura Creighton puts it, '''the distinction is really closer to something vs. nothing, rather than true vs. false.''')__

Got it? This means that every value in Python can be interpreted as a truth value, which can be a bit confusing at first, but it can also be extremely useful. And even though you have all these truth values to choose from, the “standard” truth values are `True` and `False`. __In some languages (such as C and Python prior to version 2.3), the standard truth values are 0 (for false) and 1 (for true). In fact, `True` and `False` aren’t that different—they’re just glorified(美其名的) versions of 0 and 1 that look different but act the same:__
     
 {{{
>>> True
True
>>> False
False
>>> True == 1
True
>>> False == 0
True
>>> True + False + 42
43
 }}}

__So now, if you see a logical expression returning 1 or 0 (probably in an older version of Python), you will know that what is really meant is `True` or `False`.__

The Boolean values `True` and `False` belong to the type `bool`, which can be used (just like, for example, `list`, `str`, and `tuple`) to convert other values:

 {{{
>>> bool('I think, therefore I am')
True
>>> bool(42)
True
>>> bool('')
False
>>> bool(0)
False
 }}}

__Because any value can be used as a Boolean value, you will most likely rarely (if ever) need such an explicit conversion (that is, Python will automatically convert the values for you, so to speak).__

Note: __Although `[]` and `""` are both false (that is, `bool([]) == bool("") == False`), they are not equal (that is, `[] != ""`). The same goes for other false objects of different types (for example, `() != False`).__

=== Conditional Execution and the if Statement ===

Truth values can be combined (which you’ll see in a while), but let’s first see what you can use them for. Try running the following script:

 {{{
name = raw_input('What is your name? ')
if name.endswith('Gumby'):
    print 'Hello, Mr. Gumby'
 }}}

This is the `if` statement, which lets you do conditional execution. That means that if the condition (the expression after `if` but before the colon) evaluates to true (as defined previously), the following block (in this case, a single `print` statement) is executed. If the condition is false, then the block is not executed (but you guessed that, didn’t you?).

Note: __In the sidebar “Sneak Peek: The if Statement” in Chapter 1, the statement was written on a single line. That is equivalent to using a ''single-line block'', as in the preceding example.__

=== else Clauses ===

In the example from the previous section, if you enter a name that ends with “Gumby,” the method `name.endswith` returns `True`, making the `if` statement enter the block, and the greeting is printed. If you want, you can add an alternative, with the `else` clause __(called a clause because it isn’t really a separate statement, just a part of the `if` statement):__

 {{{
name = raw_input('What is your name? ')
if name.endswith('Gumby'):
    print 'Hello, Mr. Gumby'
else:
    print 'Hello, stranger'
 }}}

Here, if the first block isn’t executed (because the condition evaluated to false), you enter the second block instead. This really shows how easy it is to read Python code, doesn’t it? Just read the code aloud (from `if`), and __it sounds just like a normal (or perhaps not quite normal) sentence.__

=== elif Clauses ===

If you want to check for several conditions, you can use `elif`, which is short for “else if.” It is a combination of an `if` clause and an `else` clause—an `else` clause with a condition:

 {{{
num = input('Enter a number: ')
if num > 0:
    print 'The number is positive'
elif num < 0:
    print 'The number is negative'
else:
    print 'The number is zero'
 }}}

Note: __Instead of `input(...)`, you might want to use `int(raw_input(...))`.__ For the difference between `input` and `raw_input`, see Chapter 1.

=== Nesting Blocks ===

Let’s throw in a few bells and whistles. You can have `if` statements inside other `if` statement blocks, as follows:

 {{{
name = raw_input('What is your name? ')
if name.endswith('Gumby'):
    if name.startswith('Mr.'):
        print 'Hello, Mr. Gumby'
    elif name.startswith('Mrs.'):
        print 'Hello, Mrs. Gumby'
    else:
        print 'Hello, Gumby'
else:
    print 'Hello, stranger'
 }}}

Here, if the name ends with “Gumby,” you check the start of the name as well—in a separate `if` statement inside the first block. Note the use of `elif` here. The last alternative (the `else` clause) has no condition—if no other alternative is chosen, you use the last one. If you want to, you can leave out either of the `else` clauses. If you leave out the inner `else` clause, names that don’t start with either “Mr.” or “Mrs.” are ignored (assuming the name was “Gumby”). If you drop the outer `else` clause, strangers are ignored.

=== More Complex Conditions ===

That’s really all there is to know about `if` statements. Now let’s return to the conditions themselves, because they are the really interesting part of conditional execution.

==== Comparison Operators ====

Perhaps the most basic operators used in conditions are the comparison operators. They are used (surprise, surprise) to compare things. The comparison operators are summarized in Table 5-1.

Table 5-1. The Python Comparison Operators

|| Expression || Description ||
|| `x == y` || x equals y. ||
|| `x < y` || x is less than y. ||
|| `x > y` || x is greater than y. ||
|| `x >= y` || x is greater than or equal to y. ||
|| `x <= y` || x is less than or equal to y. ||
|| `x != y` || x is not equal to y. ||
|| `x is y` || x and y are the same object. ||
|| `x is not y` || x and y are different objects. ||
|| `x in y` || x is a member of the container (e.g., sequence) y. ||
|| `x not in y` || x is not a member of the container (e.g., sequence) y. ||

{{{#!wiki note
'''COMPARING INCOMPATIBLE TYPES'''

In theory, you can compare any two objects `x` and `y` for relative size (using operators such as `<` and `<=`) and obtain a truth value. __However, such a comparison makes sense only if `x` and `y` are of the same or closely related types__ (such as two integers or an integer and a floating-point number).

Just as it doesn’t make much sense to add an integer to a string, checking whether an integer is less than a string seems rather pointless. __Oddly, in Python versions prior to 3.0 you are allowed to do this. You really should stay away from such comparisons, as the result is totally arbitrary and may change between each execution of your program. In Python 3.0, comparing incompatible types in this way is no longer allowed.__
}}}

Note: __If you stumble across(偶然發現) the expression `x <> y` somewhere, this means `x != y`. The `<>` operator is deprecated,__ however, and you should avoid using it.

__Comparisons can be chained in Python, just like assignments—you can put several comparison operators in a chain, like this: `0 < age < 100`. (中間用 AND 串接起來)__

Tip: When comparing things, you can also use the built-in function `cmp`, as described in Chapter 2.

Some of these operators deserve(值得) some special attention and will be described in the following sections.

==== The Equality Operator ====

If you want to know if two things are equal, use the equality operator, written as a double equality sign, `==`:

 {{{
>>> "foo" == "foo"
True
>>> "foo" == "bar"
False
 }}}

Double? Why can’t you just use a single equality sign, as they do in mathematics? I’m sure you’re clever enough to figure this out for yourself, but let’s try it:

 {{{
>>> "foo" = "foo"
SyntaxError: can't assign to literal
 }}}

The single equality sign is the assignment operator, which is used to change things, which is not what you want to do when you compare things.

==== is: The Identity Operator ====

The `is` operator is interesting. It seems to work just like `==`, but it doesn’t:

 {{{
>>> x  = y = [1, 2, 3]
>>> z  = [1, 2, 3]
>>> x  == y
True
>>> x  == z
True
>>> x  is y
True
>>> x  is z
False
 }}}

Until the last example, this looks fine, but then you get that strange result: `x is not z`, even though they are equal. Why? __Because is tests for identity, rather than equality.__ The variables `x` and `y` have been bound to the same list, while `z` is simply bound to another list that happens to contain the same values in the same order. They may be equal, but they aren’t the same object.

Does that seem unreasonable? Consider this example:

 {{{
>>> x = [1, 2, 3]
>>> y = [2, 4]
>>> x is not y
True
>>> del x[2]
>>> y[1] = 1
>>> y.reverse()
 }}}

In this example, I start with two different lists, `x` and `y`. As you can see, `x` is not `y` (just the inverse of `x` is `y`), which you already know. I change the lists around a bit, and though they are now equal, they are still two separate lists:

 {{{
>>> x == y
True
>>> x is y
False
 }}}

Here, it is obvious that the two lists are equal but not identical.

__To summarize: use `==` to see if two objects are equal, and use `is` to see if they are identical (the same object).__

__Caution: '''Avoid the use of `is` with basic, immutable values such as numbers and strings. The result is unpredictable because of the way Python handles these objects internally.'''__

==== in: The Membership Operator ====

I have already introduced the `in` operator (in Chapter 2, in the section “Membership”). It can be used in conditions, just like all the other comparison operators:

 {{{
name = raw_input('What is your name? ')
if 's' in name:
    print 'Your name contains the letter "s".'
else:
    print 'Your name does not contain the letter "s".'
 }}}

==== String and Sequence Comparisons ====

Strings are compared according to their ''order'' when sorted alphabetically:

 {{{
>>> "alpha" < "beta"
True
 }}}

Note: __The exact ordering may depend on your locale__ (see the standard library documentation for the `locale` module, for example).

If you throw in capital letters, things get a bit messy. (Actually, characters are sorted by their ''ordinal values''. __The ordinal value of a letter can be found with the `ord` function, whose inverse is `chr`.__) To ignore the difference between uppercase and lowercase letters, use the string methods `upper` and `lower` (see Chapter 3):

 {{{
>>> 'FnOrD'.lower() == 'Fnord'.lower()
True
 }}}

Other sequences are compared in the same manner, except that instead of characters, you may have other types of elements:

 {{{
>>> [1, 2] < [2, 1]
True
 }}}

If the sequences contain other sequences as elements, the same rule applies to these sequence elements:

 {{{
>>> [2, [1, 4]] < [2, [1, 5]]
True
 }}}

==== Boolean Operators ====

Now, you have plenty of things that return truth values. (In fact, given the fact that all values can be interpreted as truth values, all expressions return them.) But you may want to check for more than one condition. For example, let’s say you want to write a program that reads a number and checks whether it’s between 1 and 10 (inclusive). You could do it like this:

 {{{
number = input('Enter a number between 1 and 10: ')
if number <= 10:
    if number >= 1:
        print 'Great!'
    else:
        print 'Wrong!'
else:
    print 'Wrong!'
 }}}

This would work, but it’s clumsy(笨拙的). The fact that you have to write `print 'Wrong!'` in two places should alert you to this clumsiness. Duplication of effort is not a good thing. So what do you do? It’s so simple:

 {{{
number = input('Enter a number between 1 and 10: ')
if number <= 10 and number >= 1:
    print 'Great!'
else:
    print 'Wrong!'
 }}}

Note: __I could (and quite probably should ) have made this example even simpler by using the following chained comparison: `1 <= number <= 10`.__

The `and` operator is a so-called Boolean operator. It takes two truth values, and returns true if both are true, and false otherwise. You have two more of these operators, `or` and `not`. With just these three, you can combine truth values in any way you like: (For a thorough explanation, see Alex Martelli’s recipe on the subject in the Python Cookbook ([[http:// aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52310]])

 {{{
if ((cash > price) or customer_has_good_credit) and not out_of_stock:
    give_goods()
 }}}

{{{{#!wiki note
'''SHORT-CIRCUIT LOGIC AND CONDITIONAL EXPRESSIONS'''

__The Boolean operators have one interesting property: they ''evaluate only what they need to evaluate''.__ For example, the expression `x and y` requires both `x` and `y` to be true; so if `x` is false, the expression returns false immediately, without worrying about y. Actually, if `x` is false, it returns `x`; otherwise, it returns `y`. (Can you see how this gives the expected meaning?) __This behavior is called ''short-circuit logic'' (or ''lazy evaluation''): the Boolean operators are often called logical operators, and as you can see, the second value is sometimes “short-circuited.” This works with `or`, too.__ In the expression `x or y`, if `x` is true, it is returned; otherwise, `y` is returned. (Can you see how this makes sense?) __Note that this means that any code you have (such as a function call) after a Boolean operator may not be executed at all.__

So, how is this useful? Primarily, it avoids executing code uselessly, but it can also be used for some nifty tricks. Let’s say users are supposed to enter their name, but may opt to enter nothing, and in that case, you want to use the default value `'<unknown>'`. You could use an `if` statement, but you could also state things very succinctly(簡潔地):

 {{{
name = raw_input('Please enter your name: ') or '<unknown>'
 }}}

In other words, if the return value from `raw_input` is true (not an empty string), it is assigned to `name` (nothing changes); otherwise, the default `'<unknown>'` is assigned to `name`.

This sort of short-circuit logic can be used to implement the so-called ''ternary(由三個組成的) operator'' (or conditional operator), commonly used in languages such as C and Java. (For a thorough explanation, see Alex Martelli’s recipe on the subject in the Python Cookbook [[http:// aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52310]]) __As of version 2.5, Python has a built-in conditional expression, though, which looks like this:__

 {{{
a if b else c
 }}}

__If `b` is true, `a` is returned; otherwise, `c` is returned. (等同於 Java 的 `b ? a : c`, 不是那麼直覺?)__ (Note that this operator cannot be used directly to get the same result as in the `raw_input` example without introducing a ''temporary variable''.)
}}}}

=== Assertions ===

There is a useful relative of the `if` statement, which works more or less like this (pseudocode):

 {{{
if not condition:
    crash program
 }}}

Now, why on earth would you want something like that? __Simply because it’s better that your program crashes when an error condition emerges(浮現) than at a much later time. Basically, you can require that certain things be true (for example, when checking required properties of parameters to your functions or as an aid during initial testing and debugging).__ The keyword used in the statement is `assert`:

 {{{
>>> age = 10
>>> assert 0 < age < 100
>>> age = -1
>>> assert 0 < age < 100
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
AssertionError
 }}}

It can be useful to put the `assert` statement in your program as a ''checkpoint'', if you know something must be true for your program to work correctly.

__A string may be added after the condition, to explain the assertion:__

 {{{
>>> age = -1
>>> assert 0 < age < 100, 'The age must be realistic'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
AssertionError: The age must be realistic
 }}}

== Loops ==

Now you know how to do something if a condition is true (or false), but how do you do something several times? For example, you might want to create a program that reminds you to pay the rent every month, but with the tools we have looked at until now, you would need to write the program like this (pseudocode):

 {{{
send mail
wait one month
send mail
wait one month
send mail
wait one month
(...and so on)
 }}}

But what if you wanted it to continue doing this until you stopped it? Basically, you want something like this (again, pseudocode):

 {{{
while we aren't stopped:
    send mail
    wait one month
 }}}

Or, let’s take a simpler example. Let’s say that you want to print out all the numbers from 1 to 100. Again, you could do it the stupid way:

 {{{
print  1
print  2
print  3
...
print  99
print  100
 }}}

But you didn’t start using Python because you wanted to do stupid things, right?

=== while Loops ===

In order to avoid the cumbersome code of the preceding example, it would be useful to be able to do something like this:

 {{{
x = 1
while x <= 100:
    print x
    x += 1
 }}}

Now, how do you do that in Python? You guessed it—you do it just like that. Not that complicated, is it? You could also use a loop to ensure that the user enters a name, as follows:

 {{{
name = ''
while not name:
    name = raw_input('Please enter your name: ')
print 'Hello, %s!' % name
 }}}

Try running this, and then just pressing the Enter key when asked to enter your name. You’ll see that the question appears again, because `name` is still an empty string, which evaluates to false.

Tip: __What would happen if you entered just a space character as your name? Try it. It is accepted because a string with one space character is not empty, and therefore not false. This is definitely a flaw in our little program, but easily corrected: just change `while not name` to `while not name or name.isspace()`, or perhaps, `while not name.strip()`.__

=== for Loops ===

__The `while` statement is very flexible. It can be used to repeat a block of code while ''any condition'' is true. While this may be very nice in general, sometimes you may want something tailored to your specific needs.__ One such need is to perform a block of code for each element of a set (or, actually, sequence or other iterable object) of values.

Note: __Basically, an iterable object is any object that you can iterate over (that is, use in a `for` loop).__ You learn more about iterables and iterators in Chapter 9, but for now, you can simply think of them as sequences.

You can do this with the `for` statement:

 {{{
words = ['this', 'is', 'an', 'ex', 'parrot']
for word in words:
    print word
 }}}

or

 {{{
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for number in numbers:
    print number
 }}}

Because iterating (another word for looping) over a range of numbers is a common thing to do, Python has a built-in function to make ranges for you:

 {{{
>>> range(0, 10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 }}}

__Ranges work like slices. They include the first limit (in this case 0), but not the last (in this case 10). Quite often, you want the ranges to start at 0, and this is actually assumed if you supply only one limit (which will then be the last):__

 {{{
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 }}}

The following program writes out the numbers from 1 to 100:

 {{{
for number in range(1,101):
    print number
 }}}

Notice that this is much more compact than the `while` loop I used earlier.

Tip: __If you can use a `for` loop rather than a `while` loop, you should probably do so.__

__The `xrange` function works just like `range` in loops, but where `range` creates the whole sequence at once, `xrange` creates only one number at a time. (In Python 3.0, `range` will be turned into an xrange-style function) This can be useful when iterating over huge sequences more efficiently, but in general, you don’t need to worry about it.__

=== Iterating Over Dictionaries ===

To loop over the keys of a dictionary, you can use a plain `for` statement, just as you can with sequences:

 {{{
d = {'x': 1, 'y': 2, 'z': 3}
for key in d:
    print key, 'corresponds to', d[key]
 }}}

In Python versions before 2.2, you would have used a dictionary method such as `keys` to retrieve the keys (since direct iteration over dictionaries wasn’t allowed). If only the values were of interest, you could have used `d.values` instead of `d.keys`. You may remember that `d.items` returns key-value pairs as tuples. One great thing about `for` loops is that you can use sequence unpacking in them:

 {{{
for key, value in d.items():
    print key, 'corresponds to', value
 }}}

Note: __As always, the order of dictionary elements is undefined. In other words, when iterating over either the keys or the values of a dictionary, you can be sure that you’ll process all of them, but you can’t know in which order. '''If the order is important, you can store the keys or values in a separate list and, for example, sort it before iterating over it.'''__

=== Some Iteration Utilities ===

Python has several functions that can be useful when iterating over a sequence (or other iterable object). Some of these are available in the `itertools` module (mentioned in Chapter 10), but there are some built-in functions that come in quite handy as well.

==== Parallel Iteration ====

Sometimes you want to iterate over two sequences at the same time. Let’s say that you have the following two lists:

 {{{
names = ['anne', 'beth', 'george', 'damon']
ages = [12, 45, 32, 102]
 }}}

If you want to print out names with corresponding ages, you could do the following:

 {{{
for i in range(len(names)):
    print names[i], 'is', ages[i], 'years old'
 }}}

Here, i serves as a standard variable name for loop indices (as these things are called).

A useful tool for ''parallel iteration'' is the built-in function `zip`, which “zips” together the sequences, returning a list of tuples:

 {{{
>>> zip(names, ages)
[('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]
 }}}

Now I can unpack the tuples in my loop:

 {{{
for name, age in zip(names, ages):
    print name, 'is', age, 'years old'
 }}}

The `zip` function works with as many sequences as you want. It’s important to note what `zip` does when the sequences are of different lengths: it stops when the shortest sequence is used up:

 {{{
>>> zip(range(5), xrange(100000000))
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
 }}}

I wouldn’t recommend using `range` instead of `xrange` in the preceding example. Although only the first five numbers are needed, range calculates all the numbers, and that may take a lot of time. With `xrange`, this isn’t a problem because it calculates only those numbers needed.

==== Numbered Iteration ====

In some cases, you want to iterate over a sequence of objects and at the same time have access to the index of the current object. For example, you might want to replace every string that contains the substring 'xxx' in a list of strings. There would certainly be many ways of doing this, but let’s say you want to do something along the following lines:

 {{{
for string in strings:
    if 'xxx' in string:
        index = strings.index(string) # Search for the string in the list of strings
        strings[index] = '[censored]'
 }}}

This would work, but it seems unnecessary to search for the given string before replacing it. Also, if you didn’t replace it, the search might give you the wrong index (that is, the index of some previous occurrence of the same word). A better version would be the following:

 {{{
index = 0
for string in strings:
    if 'xxx' in string:
        strings[index] = '[censored]'
    index += 1
 }}}

This also seems a bit awkward, although acceptable. Another solution is to use the built-in function `enumerate`:

 {{{
for index, string in enumerate(strings):
    if 'xxx' in string:
        strings[index] = '[censored]'
 }}}

This function lets you iterate over ''index-value'' pairs, where the indices are supplied automatically.

==== Reversed and Sorted Iteration ====

Let’s look at another couple of useful functions: reversed and sorted. They’re similar to the list methods reverse and sort (with sorted taking arguments similar to those taken by sort), but they work on any sequence or iterable object, and instead of modifying the object in place, they return reversed and sorted versions:

 {{{
>>> sorted([4, 3, 6, 8, 3])
[3, 3, 4, 6, 8]
>>> sorted('Hello, world!')
[' ', '!', ',', 'H', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
>>> list(reversed('Hello, world!'))
['!', 'd', 'l', 'r', 'o', 'w', ' ', ',', 'o', 'l', 'l', 'e', 'H']
>>> ''.join(reversed('Hello, world!'))
'!dlrow ,olleH'
 }}}

Note that although sorted returns a list, reversed returns a more mysterious iterable object. You don’t need to worry about what this really means; you can use it in for loops or methods such as join without any problems. You just can’t index or slice it, or call list methods on it directly. In order to perform those tasks, you need to convert the returned object, using the list type, as shown in the previous example.

=== Breaking Out of Loops ===

:::

= Chapter 11. Files and Stuff =

So far, we’ve mainly been working with data structures that reside in the interpreter itself. What little interaction our programs have had with the outside world has been through `input`, `raw_input`, and `print`. In this chapter, we go one step further and let our programs catch a glimpse of a larger world: the world of files and streams. The functions and objects described in this chapter will enable you to store data ''between program invocations'' and to process data from other programs.

== Opening Files ==

You can open files with the `open` function, which has the following syntax:

 {{{
open(name[, mode[, buffering]])
 }}}

The `open` function takes a file name as its only mandatory argument, and returns a `file` object. The `mode` and `buffering` arguments are both optional and will be explained in the following sections.

Assuming that you have a text file (created with your text editor, perhaps) called `somefile.txt` stored in the directory `C:\text` (or something like `~/text` in UNIX), you can open it like this:

 {{{
>>> f = open(r'C:\text\somefile.txt')
 }}}

If the file doesn’t exist, you may see an exception traceback like this:

 {{{
Traceback (most recent call last):
File "<pyshell#0>", line 1, in ?
IOError: [Errno 2] No such file or directory: "C:\\text\\somefile.txt"
 }}}

You’ll see what you can do with such file objects in a little while, but first, let’s take a look at the other two arguments of the `open` function.

=== File Modes ===

__If you use `open` with only a file name as a parameter, you get a `file` object you can read from.__ If you want to write to the file, you must state that explicitly, supplying a ''mode''. (Be patient—I get to the actual reading and writing in a little while.) The `mode` argument to the `open` function can have several values, as summarized in Table 11-1.

Table 11-1. Most Common Values for the Mode Argument of the `open` Function

|| Value || Description ||
|| `'r'` || Read mode ||
|| `'w'` || Write mode ||
|| `'a'` || Append mode ||
|| `'b'` || Binary mode (added to other mode) ||
|| `'+'` || Read/write mode (added to other mode) ||

__Explicitly specifying read mode has the same effect as not supplying a ''mode string'' at all.__ The write mode enables you to write to the file.

The `'+'` can be added to any of the other modes to indicate that both reading and writing is allowed. So, for example, `'r+'` can be used when opening a text file for reading and writing. (For this to be useful, you will probably want to use `seek` as well; see the sidebar “Random Access” later in this chapter.)

The `'b'` mode changes the way the file is handled. __Generally, Python assumes that you are dealing with text files (containing characters).__ Typically, this is not a problem. But if you are processing some other kind of file (called a binary file) such as a sound clip or an image, you should add a `'b'` to your mode: for example, `'rb'` to read a binary file.

'''WHY USE BINARY MODE?'''

 If you use binary mode when you read (or write) a file, things won’t be much different. You are still able to read a number of bytes (basically the same as characters), and perform other operations associated with text files. __The main point is that when you use ''binary mode'', Python gives you exactly the contents found in the file— and in ''text mode'', it won’t necessarily do that.__

 __If you find it shocking that Python manipulates your text files, don’t worry. '''The only “trick” it employs is to ''standardize your line endings''.''' Generally, in Python, you end your lines with a newline character (`\n`), as is the norm in UNIX systems. This is not standard in Windows, however. In Windows, a line ending is marked with `\r\n`. To hide this from your program (so it can work seamlessly across different platforms), Python does some automatic conversion here. When you read text from a file in text mode in Windows, it converts `\r\n` to `\n`. Conversely, when you write text to a file in text mode in Windows, it converts `\n` to `\r\n`. (The Macintosh version does the same thing, but converts between `\n` and `\r`.)__

 __The problem occurs when you work with a binary file, such as a sound clip. It may contain bytes that can be interpreted as the line-ending characters mentioned in the previous paragraph, and if you are using text mode, Python performs its automatic conversion. However, that will probably destroy your binary data. So, to avoid that, you simply use binary mode, and no conversions are made.__

 Note that this distinction is not important on platforms (such as UNIX) where the newline character is the standard line terminator, because no conversion is performed there anyway.

 __Note: Files can be opened in ''universal newline support mode'', using the mode character `U` together with, for example, `r`. In this mode, all line-ending characters/strings (`\r\n`, `\r`, or `\n`) are then converted to newline characters (`\n`), regardless of which convention is followed on the ''current platform''.__

=== Buffering ===

The `open` function takes a third (optional) parameter, which controls the buffering of the file. __If the parameter is `0` (or `False`), input/output (I/O) is ''unbuffered'' (all reads and writes go directly from/to the disk); if it is `1` (or `True`), I/O is ''buffered'' (meaning that Python may use memory instead of disk space to make things go faster, and only update when you use `flush` or `close`— see the section “Closing Files,” later in this chapter). Larger numbers indicate the buffer size (in bytes), while `-1` (or any negative number) sets the buffer size to the default.__

== The Basic File Methods ==

Now you know how to open files. The next step is to do something useful with them. In this section, you learn about some basic methods of `file` objects (and some other file-like objects, sometimes called ''streams'').

Note You will probably run into the term ''file-like'' repeatedly in your Python career (I’ve used it a few times already). __A file-like object is simply one supporting a few of the same methods as a `file`, most notably either `read` or `write` or both.__ The objects returned by `urllib.urlopen` (see Chapter 14) are a good example of this. They support methods such as `read`, `readline`, and `readlines`, but not (at the time of writing) methods such as `isatty`, for example.

'''THREE STANDARD STREAMS'''

In Chapter 10, in the section about the `sys` module, I mentioned ''three standard streams''. These are actually files (or file-like objects), and you can apply most of what you learn about files to them.

A standard source of data input is `sys.stdin`. When a program reads from standard input, you can supply text by typing it, or you can link it with the standard output of another program, using a pipe, as demonstrated in the section “Piping Output.” (This is a standard UNIX concept.)

The text you give to `print` appears in `sys.stdout`. The prompts for `input` and `raw_input` also go there. Data written to `sys.stdout` typically appears on your screen, but can be rerouted to the standard input of another program with a pipe, as mentioned.

__Error messages (such as ''stack traces'') are written to `sys.stderr`. In many ways, it is similar to `sys.stdout`.__

=== Reading and Writing ===

The most important capabilities of files (or streams) are supplying and receiving data. If you have a file-like object named `f`, you can write data (in the form of a string) with the method `f.write`, and read data (also as a string) with the method `f.read`.

Each time you call `f.write(string)`, the string you supply is written to the file after those you have written previously:

 {{{
>>> f = open('somefile.txt', 'w')
>>> f.write('Hello, ')
>>> f.write('World!')
>>> f.close()
 }}}

__Notice that I call the `close` method when I’m finished with the file.__ You learn more about it in the section “Closing Your Files” later in this chapter.

Reading is just as simple. Just remember to tell the stream how many characters (bytes; 比較精確的說法是 Bytes, 只是剛好 ASCII 編碼一個 Byte 對應一個 Character 而已) you want to read.

Here’s an example (continuing where I left off):

 {{{
>>> f = open('somefile.txt', 'r')
>>> f.read(4)
'Hell'
>>> f.read()
'o, World!'
 }}}

First, I specify how many characters to read (4), and then __I simply read the ''rest'' of the file (by not supplying a number).__ Note that I could have dropped the mode specification from the call to open because `'r'` is the default.

=== Piping Output ===

In a UNIX shell (such as GNU bash), you can write several commands after one another, linked
together with pipes, as in this example (assuming GNU bash):
$ cat somefile.txt | python somescript.py | sort
■Note GNU bash is also available in Windows. For more information, visit http://www.cygwin.com. In
Mac OS X, the shell is available out of the box, through the Terminal application, for example.

:::

= Appendix A. The Short Version =

This is a minimal introduction to Python, based on my popular web tutorial, “Instant Python” ([[http://hetland.org/writing/instant-python.html]]). It targets programmers who already know a language or two, but who want to get up to speed with Python. For information on downloading and executing the Python interpreter, see Chapter 1.

== The Basics ==

__'''To get a basic feel for the Python language, think of it as ''pseudocode'', because that’s pretty close to the truth.''' Variables don’t have types, so you don’t need to declare them. They appear when you assign to them, and disappear when you don’t use them anymore.__ Assignment is done with the `=` operator, like this:

 {{{
x = 42
 }}}

__Note that equality is tested by the `==` operator.__

You can assign several variables at once, like this:

 {{{
x, y, z = 1, 2, 3
first, second = second, first <-- 調換兩個變數!!
a = b = 123
 }}}

__Blocks are indicated through indentation, and only through indentation.__ (No `begin`/`end` or braces.) The following are some common control structures:

 {{{
if x < 5 or (x > 10 and x < 20):
    print "The value is OK."

if x < 5 or 10 < x < 20: <-- 其中 "10 < x < 20" 的表示法, 真是太直覺了!!
    print "The value is OK."

for i in [1, 2, 3, 4, 5]:
    print "This is iteration number", i

x = 10
while x >= 0:
    print "x is still not negative."
    x = x - 1
 }}}

The first two examples are equivalent.

__The ''index variable'' given in the `for` loop iterates through the elements of a list (Or any other ''iterable'' object, actually; written with brackets, as in the example).__ To make an “ordinary” `for` loop (that is, a ''counting loop''), use the built-in function `range`:

 {{{
# Print out the values from 0 to 99, inclusive
for value in range(100):
    print value
 }}}

__The line beginning with `#` is a comment and is ignored by the interpreter.__

Now you know enough (in theory) to implement any algorithm in Python. Let’s add some basic user interaction. __To get input from the user (from a text prompt), use the built-in function `input`:__

 {{{
x = input("Please enter a number: ")
print "The square of that number is", x * x
 }}}

The `input` function displays the (optional) prompt given and lets the user enter any valid ''Python value''. (採用 literal 的表示法, 例如字串要用引號框起來...) In this case, we were expecting a number. If something else (such as a string) is entered, the program would halt with an error message. To avoid that, you would need to add some ''error checking''. I won’t go into that here; suffice it to say that __if you want the user input returned verbatim(逐字地) as a string (so that anything can be entered), use the function `raw_input` instead.  If you wanted to convert an input string `s` to an integer, you could then use `int(s)`.__

Note: __If you want to input a string with `input`, the user must write the quotes explicitly. In Python, strings can be enclosed in either single or double quotes. '''In Python 3.0, the original `input` disappears, and `raw_input` is renamed `input`.'''__ See Appendix D for more on Python 3.0.

So, you have control structures, input, and output covered—now you need some snazzy(時髦的) data structures. The most important ones are ''lists'' and ''dictionaries''. Lists are written with brackets, and can (naturally) be ''nested'':

 {{{
name = ["Cleese", "John"]
x = [[1, 2, 3], [y, z], [[[]]]]
 }}}

__One of the nice things about lists is that you can access their elements separately or in groups, through ''indexing'' and ''slicing''. Indexing is done (as in many other languages) by writing the index in brackets after the list. (Note that the first element has index 0.)__

 {{{
print name[1], name[0] # Prints "John Cleese"
name[0] = "Smith"
 }}}

__Slicing is almost like indexing, except that you indicate both the start and stop index of the result, with a colon (`:`) separating them: (不含 stop index)__

 {{{
x = ["SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "eggs", "and", "SPAM"]
print x[5:7] # Prints the list ["eggs","and"]
 }}}

__Notice that the end is noninclusive. If one of the indices is dropped, it is assumed that you want everything ''in that direction''.__ In other words, the slice `x[:3]` means “every element from the beginning of x up to element 3, noninclusive” (well, element 3 is actually the fourth element, because the counting starts at 0). The slice `x[3:]` would, on the other hand, mean “every element in x, starting at element 3 (inclusive) up to, and including, the last one.” __For really interesting results, you can use negative numbers, too: `x[-3]` is the third element from the end of the list.__

Now then, what about dictionaries? __To put it simply, they are like lists, except that their contents aren’t ordered. How do you index them then? Well, every element has a ''key'', or a ''name'', which is used to look up the element, just as in a real dictionary.__ The following example demonstrates the syntax used to create dictionaries:

 {{{
phone = { "Alice" : 23452532, "Boris" : 252336,
          "Clarice" : 2352525, "Doris" : 23624643 }
person = { 'first name': "Robin", 'last name': "Hood",
           'occupation': "Scoundrel" }
 }}}

Now, to get person’s occupation(職業), you use the expression `person["occupation"]`. If you wanted to change the person’s last name, you could write this:

 {{{
person['last name'] = "of Locksley" <-- 雖然宣告的時候用 {...}, 但存取時還是要用 [...] 的語法
 }}}

Simple, isn’t it? __Like lists, dictionaries can hold other dictionaries, or lists, for that matter. And naturally, lists can hold dictionaries, too. '''That way, you can easily make some quite advanced data structures.'''__

== Functions ==

Our next step is abstraction. __You want to give a name to a piece of code and call it with a couple of parameters. In other words, you want to define a ''function'' (also called a ''procedure'').__ That’s easy. Use the keyword `def`, as follows:

 {{{
def square(x):
    return x * x

print square(2) # Prints out 4
 }}}

The `return` statement is used to return a value from the function.

__When you pass a parameter to a function, '''you ''bind'' the parameter to the value, thus creating a ''new reference''.''' This means that you can modify the original value (改變 Reference 的內部狀態而言) directly inside the function, but if you make the parameter name ''refer'' to something else (''rebind'' it), that change won’t affect the original. This works just like in Java, for example.__ Let’s take a look at an example:

 {{{
def change(x):
    x[1] = 4

y = [1, 2, 3]
change(y)
print y # Prints out [1, 4, 3]
 }}}

As you can see, the original list is passed in, and if the function modifies it, these modifications carry over(帶出) to the place where the function was called. Note the behavior in the following example, however, where the function body rebinds the parameter:

 {{{
def nochange(x):
  x = 0

y = 1
nochange(y)
print y # Prints out 1
 }}}

__Why doesn’t `y` change now? Because you ''don’t change the value''! The value that is passed in is the number 1, and you can’t change a number in the same way that you change a list. The number 1 is (and will always be) the number 1. (感覺 Python 裡也有 Primitive Types?) '''What the example does change is what the parameter `x` ''refers'' to, and this does not carry over to the ''calling environment''.'''__

__Python has all kinds of nifty things such as ''named arguments'' and ''default arguments'',__ and can handle a variable number of arguments to a single function. For more information about this, see Chapter 6.

If you know how to use functions in general, what I’ve told you so far is basically what you need to know about them in Python.

__It might be useful to know, however, that functions are ''values'' in Python.__ So if you have a function such as `square`, you could do something like the following:

 {{{
queeble = square
print queeble(2) # Prints out 4
 }}}

To call a function without arguments, you must remember to write `doit()` and not `doit`. __'''The latter, as shown, only returns the function itself, as a value. (有點類似 Function Pointer 的概念) This goes for methods in objects, too.'''__ Methods are described in the next section.

== Objects and Stuff . . . ==

I assume you know how object-oriented programming works. Otherwise, this section might not make much sense. No problem—start playing without the objects, or check out Chapter 7.

In Python, you define classes with the (surprise!) `class` keyword, as follows:

 {{{
class Basket:

    # Always remember the *self* argument
    def __init__(self, contents = None):
        self.contents = contents or []

    def add(self, element):
        self.contents.append(element)

    def print_me(self):
        result = ""
        for element in self.contents:
            result = result + " " + repr(element)
        print "Contains:" + result
 }}}

Several things are worth noting in this example:

 * Methods are called like this: `object.method(arg1, arg2)`.

 * Some arguments can be optional and given a default value (as mentioned in the previous section on functions). This is done by writing the definition like this:

 {{{
def spam(age = 32): ...
 }}}

 * Here, `spam` can be called with one or zero parameters. If it’s called without any parameters, `age` will have the default value of 32.

 * `repr` converts an object to its ''string representation''. (So if `element` contains the number 1, then `repr(element)` is the same as "1", whereas '`element`' is a literal string.)

__'''No methods or member variables (''attributes'') are protected (or private or the like) in Python.''' Encapsulation is pretty much a matter of programming style. (If you really need it, there are naming conventions that will allow some privacy, such as prefixing a name with a single or double underscore.)__

Now, about that ''short-circuit logic'' . . .

__All values in Python can be used as ''logic values''. Some of the more empty ones (such as `False`, `[]`, `0`, `""`, and `None`) represent logical falsity; most other values (such as `True`, `[0]`, `1`, and `"Hello, world"`) represent logical truth. '''(下面將 `a and b` 及 `a or b` 的運算結果不一定是 `True`/`False`, 因為它會直接把 `a` 或 `b` 傳回, 這真是一個很特別的設計!!)'''__

Logical expressions such as `a and b` are evaluated like this:

 * Check if `a` is true.
 * If it is not, then simply return it.
 * If it is, then simply return `b` (which will represent the truth value of the expression).

The corresponding logic for `a or b` is this:

 * If `a` is true, then return it.
 * If it isn’t, then return `b`.

__This short-circuit mechanism enables you to use `and` and `or` like the boolean operators they are supposed to implement, '''but it also enables you to write short and sweet little ''conditional expressions''.'''__ For example, this statement:

 {{{
if a:
    print a
else:
    print b
 }}}

could instead be written like this:

 {{{
print a or b
 }}}

__Actually, this is somewhat of a Python idiom(習慣用語), so you might as well get used to it.__

Note: In Python 2.5, ''actual'' conditional expressions were introduced, so you could, in fact, write this: `print a if a else b` (好像變得不直覺了?)

The `Basket` constructor (`Basket.__init__`) in the previous example uses this strategy in handling default parameters. The argument `contents` has a default value of `None` (which is, among other things, false); therefore, to check if it had a value, you could write this:

 {{{
if contents:
    self.contents = contents
else:
    self.contents = []
 }}}

Instead, the constructor uses this simple statement:

 {{{
self.contents = contents or []
 }}}

__Why don’t you give it the default value of `[]` in the first place? '''Because of the way Python works, this would give all the `Basket` instances the same empty list as default contents. (Share 同一個 Instance 而言, 這跟 Tapestry 裡的 `initial-value` 有相同的考量)''' As soon as one of them started to fill up, they all would contain the same elements, and the default would not be empty anymore.__ To learn more about this, see the discussion about the difference between ''identity'' and ''equality'' in Chapter 5.

Note: __When using `None` as a ''placeholder'' as done in the `Basket.__init__` method, '''using `contents is None` as the condition is safer than simply checking the argument’s boolean value.''' This will allow you to pass in a ''false value'' such as an empty list of your own (to which you could keep a reference outside the object).__

If you would like to use an empty list as the default value, you can avoid the problem of sharing this among instances by doing the following:

 {{{
def __init__(self, contents=[]):
    self.contents = contents[:] # 不論傳什麼東西進去, 都會被複製一份出來; 導致 Caller 所持有的 Reference 跟內部存放的那一份不同
 }}}

Can you guess how this works? Instead of using the same empty list everywhere, you use the expression `contents[:]` to make a copy. (You simply slice the entire thing.)

So, to actually make a `Basket` and to use it (to call some methods on it), you would do something like this:

 {{{
b = Basket(['apple','orange'])
b.add("lemon")
b.print_me()
 }}}

This would print out the contents of the Basket: an apple, an orange, and a lemon.

There are ''magic methods'' other than `__init__`. One such method is `__str__`, which defines how the object wants to look if it is treated like a string. You could use this in the basket instead of `print_me`:

 {{{
def __str__(self):
    result = ""
    for element in self.contents:
        result = result + " " + repr(element)
    return "Contains:" + result # 這裡改用 return 而非 print
 }}}

Now, if you wanted to print the basket `b`, you could just use this:

 {{{
print b
 }}}

Cool, huh?

Subclassing works like this:

 {{{
class SpamBasket(Basket):
# ...
 }}}

__Python allows ''multiple inheritance'', so you can have several superclasses in the parentheses, separated by commas.__ Classes are instantiated like this: `x = Basket()`. Constructors are, as I said, made by defining the special member function `__init__`. Let’s say that `SpamBasket` had a constructor `__init__(self, type)`. Then you could make a spam basket like this: `y = SpamBasket("apples")`.

__If in the constructor of `SpamBasket`, you needed to call the constructor of one or more superclasses, you could call it like this: `Basket.__init__(self)`. Note that in addition to supplying the ordinary parameters, '''you must explicitly supply `self`, because the superclass `__init__` doesn’t know which instance it is dealing with.'''__

For more about the wonders of object-oriented programming in Python, see Chapter 7.

== Some Loose Ends ==

__Here, I’ll quickly review a few other useful things before ending this appendix. Most useful functions and classes are put in ''modules'', '''which are really text files with the file name extension `.py` that contain Python code.''' You can import these and use them in your own programs.__ For example, to use the function `sqrt` from the standard module `math`, you can do either this:

 {{{
import math
x = math.sqrt(y)
 }}}

or this:

 {{{
from math import sqrt
x = sqrt(y)
 }}}

For more information on the ''standard library modules'', see Chapter 10.

__'''All the code in the module/script is run when it is imported.''' If you want your program to be both an ''importable module'' and a ''runnable program'', you might want to add something like this at the end of it:__

 {{{
if __name__ == "__main__": main()
 }}}

__This is a magic way of saying that if this module is run as an ''executable script'' (that is, it is not being imported into another script), then the function `main` should be called.__ Of course, you could do anything after the colon there.

And for those of you who want to make an executable script in UNIX, use the following first line to make it run by itself: (還要將 Script 標示為 Executable 即可)

 {{{
#!/usr/bin/env python
 }}}

Finally, a brief mention of an important concept: exceptions. Some operations (such as dividing something by zero or reading from a nonexistent file) produce an error condition or exception. You can even make your own exceptions and raise them at the appropriate times.

__If nothing is done about the exception, your program ends and prints out an error message. You can avoid this with a try/except statement,__ as in this example:

 {{{
def safe_division(a, b):
    try:
        return a/b
    except ZeroDivisionError: pass
 }}}

`ZeroDivisionError` is a standard exception. In this case, you could have checked if `b` was zero, but in many cases, that strategy is not feasible(可行的). And besides, if you removed the `try/except` statement in `safe_division`, thereby making it a risky function to call (called something like `unsafe_division`), you could still do the following: (讓 Caller 也有機會做處理)

 {{{
try:
    unsafe_division(a, b)
except ZeroDivisionError:
    print "Something was divided by zero in unsafe_division"
 }}}

In cases in which you typically would not have a specific problem, but it might occur, using exceptions enables you to avoid costly testing and so forth.

Well, that’s it. Hope you learned something. __Now go and play. And remember the Python motto of learning: '''use the source''' (which basically means read all the code you can get your hands on).__

