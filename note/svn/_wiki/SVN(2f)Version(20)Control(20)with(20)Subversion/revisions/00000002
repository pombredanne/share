= SVN / Version Control With Subversion =
http://svnbook.red-bean.com/en/1.5/svn-book.html @2009/12/29
http://svnbook.red-bean.com/nightly/en/svn-book.html @2010/03/29
<<TableOfContents>>

= Chapter 2. Basic Usage =

== Dealing with Structural Conflicts (1.6) ==

So far, we have only talked about conflicts at the level of ''file content''. When you and your collaborators make overlapping changes within the same file, Subversion forces you to merge those changes before you can commit.

But what happens if your collaborators move or delete a file that you are still working on? Maybe there was a miscommunication, and one person thinks the file should be deleted, while another person still wants to commit changes to the file. __Or maybe your collaborators did some refactoring, renaming files and moving around directories in the process. If you were still working on these files, '''those modifications may need to be applied to the files at their new location.''' Such conflicts manifest(出現) themselves at the ''directory tree structure level'' rather than at the file content level, and are known as ''tree conflicts''. (相對於 Textual Conflicts 的說法)__

 {{{#!wiki note
'''Tree conflicts prior to Subversion 1.6'''

Prior to Subversion 1.6, tree conflicts could yield rather unexpected results. For example, if a file was locally modified, but had been renamed in the repository, running `svn update` would make Subversion carry out the following steps: (位置不同的新舊兩支檔案之間沒有關聯)

 * Check the file to be renamed for local modifications.

 * Delete the file at its old location, and if it had local modifications, keep an on-disk copy of the file at the old location. This on-disk copy now appears as an ''unversioned'' file in the working copy.

 * Add the file, as it exists in the repository, at its new location.

__When this situation arises, there is the possibility that the user makes a commit without realizing that local modifications have been left in a now-unversioned file in the working copy, and have not reached the repository. (更糟的是送交出去, 就會有兩支很像的檔案出現在兩個地方)__ This gets more and more likely (and tedious) if the number of files affected by this problem is large.

Since Subversion 1.6, this and other similar situations are flagged as conflicts in the working copy.
 }}}

__As with ''textual conflicts'', tree conflicts prevent a commit from being made from the conflicted state, giving the user the opportunity to examine the state of the working copy for potential problems arising from the tree conflict, and resolving any such problems before committing.__

=== An example Tree Conflict ===

Suppose a software project you were working on currently looked like this:

 {{{
$ svn ls -Rv svn://svn.example.com/trunk/
      4 harry                 Feb 06 14:34 ./
      4 harry              23 Feb 06 14:34 COPYING
      4 harry              41 Feb 06 14:34 Makefile
      4 harry              33 Feb 06 14:34 README
      4 harry                 Feb 06 14:34 code/
      4 harry              51 Feb 06 14:34 code/bar.c
      4 harry             124 Feb 06 14:34 code/foo.c
 }}}

Your collaborator Harry has renamed the file `bar.c` to `baz.c`. You are still working on `bar.c` in your working copy, but you don't know yet that the file has been renamed in the repository.

The log message to Harry's commit looked like this:

 {{{
$ svn log -r5 svn://svn.example.com/trunk <-- 還要加 -v, 否則看不到 Changed paths 等細節
------------------------------------------------------------------------
r5 | harry | 2009-02-06 14:42:59 +0000 (Fri, 06 Feb 2009) | 2 lines
Changed paths:
   M /trunk/Makefile
   D /trunk/code/bar.c
   A /trunk/code/baz.c (from /trunk/code/bar.c:4) <-- 更名時, 內部會記錄來源

Rename bar.c to baz.c, and adjust Makefile accordingly.
 }}}

The local changes you have made look like this:

 {{{
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c  (revision 4)
+++ code/foo.c  (working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
        printf("I don't like being moved around!\n%s", bar());
-       return 0;
+       return 1;
 }
Index: code/bar.c
===================================================================
--- code/bar.c  (revision 4)
+++ code/bar.c  (working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-       return "Me neither!\n";
+       return "Well, I do like being moved around!\n";
 }
 }}}

Your changes are all based on revision 4. They cannot be committed because Harry has already checked in revision 5:

 {{{
$ svn commit -m "Small fixes"
Sending        code/bar.c
Sending        code/foo.c
Transmitting file data ..
svn: Commit failed (details follow):
svn: File not found: transaction '5-5', path '/trunk/code/bar.c'
 }}}

At this point, you need to run `svn update`. Besides bringing our working copy up to date so that you can see Harry's changes, this also flags a tree conflict so you have the opportunity to evaluate and properly resolve it.

 {{{
$ svn update
   C code/bar.c
A    code/baz.c
U    Makefile
Updated to revision 5.
Summary of conflicts:
  Tree conflicts: 1
 }}}

In its output, `svn update` signifies tree conflicts using a capital `C` in the fourth output column. `svn status` reveals additional details of the conflict:

 {{{
$ svn status
M       code/foo.c
A  +  C code/bar.c
      >   local edit, incoming delete upon update
M       code/baz.c
 }}}

__Note how `bar.c` is automatically scheduled for ''re-addition'' in your working copy, which simplifies things in case you want to keep the file.__

__Because a move in Subversion is implemented as a copy operation followed by a delete operation, and these two operations cannot be easily related to one another during an update, all Subversion can warn you about is an incoming delete operation on a locally modified file. '''This delete operation may be part of a move, or it could be a genuine(真正的) delete operation.''' Talking to your collaborators, or, as a last resort, `svn log`, is a good way to find out what has actually happened.__

Both `foo.c` and `baz.c` are reported as locally modified in the output of `svn status`. You made the changes to `foo.c` yourself, so this should not be surprising. But why is `baz.c` reported as locally modified?

__The answer is that despite the limitations of the move implementation, Subversion was smart enough to transfer your local edits in `bar.c` into `baz.c`:__

 {{{
$ svn diff code/baz.c
Index: code/baz.c
===================================================================
--- code/baz.c  (revision 5)
+++ code/baz.c  (working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-       return "Me neither!\n";
+       return "Well, I do like being moved around!\n";
 }
 }}}

Warning: __Local edits to the file `bar.c`, which is renamed during an update to `baz.c`, will only be applied to `bar.c` if your working copy of `bar.c` is based on the revision in which it was last modified before being moved in the repository.__ Otherwise, Subversion will resort to retreiving `baz.c` from the repository, and will not try to transfer your local modifications to it. You will have to do so manually.

__`svn info` shows the URLs of the items involved in the conflict. The left URL shows the source of the local side of the conflict, while the right URL shows the source of the incoming side of the conflict.__ These URLs indicate where you should start searching the repository's history for the change which conflicts with your local change.

 {{{
$ svn info code/bar.c | tail -n 4 
Tree conflict: local edit, incoming delete upon update
  Source  left: (file) ^/trunk/code/bar.c@4
  Source right: (none) ^/trunk/code/bar.c@5
 }}}

`bar.c` is now said to be the victim(受害者) of a tree conflict. It cannot be committed until the conflict is resolved:

 {{{
$ svn commit -m "Small fixes" 
svn: Commit failed (details follow):
svn: Aborting commit: 'code/bar.c' remains in conflict
 }}}

So how can this conflict be resolved? You can either agree or disagree with the move Harry made. In case you agree, you can delete `bar.c` and mark the tree conflict as resolved:

 {{{
$ svn remove --force code/bar.c
D         code/bar.c
$ svn resolve --accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
M       code/baz.c
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c  (revision 5)
+++ code/foo.c  (working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
        printf("I don't like being moved around!\n%s", bar());
-       return 0;
+       return 1;
 }
Index: code/baz.c
===================================================================
--- code/baz.c  (revision 5)
+++ code/baz.c  (working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-       return "Me neither!\n";
+       return "Well, I do like being moved around!\n";
 }
 }}}

__If you do not agree with the move, you can delete `baz.c` instead, after making sure any changes made to it after it was renamed are either preserved or not worth keeping.__ Do not forget to revert the changes Harry made to the `Makefile`. Since `bar.c` is already scheduled for re-addition, there is nothing else left to do, and the conflict can be marked resolved:

 {{{
$ svn remove --force code/baz.c
D         code/baz.c
$ svn resolve --accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
A  +    code/bar.c
D       code/baz.c
M       Makefile
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c	(revision 5)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
 	printf("I don't like being moved around!\n%s", bar());
-	return 0;
+	return 1;
 }
Index: code/bar.c
===================================================================
--- code/bar.c	(revision 5)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-	return "Me neither!\n";
+	return "Well, I do like being moved around!\n";
 }
Index: code/baz.c
===================================================================
--- code/baz.c	(revision 5)
+++ code/baz.c	(working copy)
@@ -1,4 +0,0 @@
-const char *bar(void)
-{
-	return "Me neither!\n";
-}
Index: Makefile
===================================================================
--- Makefile	(revision 5)
+++ Makefile	(working copy)
@@ -1,2 +1,2 @@
 foo: 
-	$(CC) -o $@ code/foo.c code/baz.c
+	$(CC) -o $@ code/foo.c code/bar.c
 }}}

In either case, you have now resolved your first tree conflict! You can commit your changes and tell Harry during tea break about all the extra work he caused for you.

= Chapter 3. Advanced Topics =

If you've been reading this book chapter by chapter, from start to finish, you should by now have acquired enough knowledge to use the Subversion client to perform the most common version control operations. You understand how to check out a working copy from a Subversion repository. You are comfortable with submitting and receiving changes using the `svn commit` and `svn update` operations. You've probably even developed a reflex(反射作用?) that causes you to run the `svn status` command almost unconsciously(無意中). For all intents and purposes, you are ready to use Subversion in a typical environment.

But the Subversion feature set doesn't stop at “common version control operations.” It has other bits of functionality besides just communicating file and directory changes to and from a central repository.

This chapter highlights some of Subversion's features that, while important, aren't part of the typical user's daily routine. It assumes that you are familiar with Subversion's basic file and directory versioning capabilities. If you aren't, you'll want to first read Chapter 1, Fundamental Concepts and Chapter 2, Basic Usage. Once you've mastered those basics and consumed this chapter, you'll be a Subversion power user!

== Revision Specifiers ==

As we described in the section called “Revisions”, revision numbers in Subversion are pretty straightforward—integers that keep getting larger as you commit more changes to your versioned data. Still, it doesn't take long before you can no longer remember exactly what happened in each and every revision. Fortunately, the typical Subversion workflow doesn't often demand(要求) that you supply arbitrary revisions to the Subversion operations you perform. For operations that do require a revision specifier, you generally supply a revision number that you saw in a ''commit email'' (應用在什麼地方?), in the output of some other Subversion operation, or in some other context that would give meaning to that particular number.

But occasionally, you need to pinpoint(正確指出?) a moment in time for which you don't already have a revision number memorized or handy. So besides the integer revision numbers, svn allows as input some additional forms of revision specifiers: ''revision keywords'' and ''revision dates''.

__Note: The various forms of Subversion revision specifiers can be mixed and matched when used to specify revision ranges. For example, you can use `-r REV1:REV2` where `REV1` is a revision keyword and `REV2` is a revision number, or where `REV1` is a date and `REV2` is a revision keyword, and so on. The individual revision specifiers are independently evaluated, so you can put whatever you want on the opposite sides of that colon.__

=== Revision Keywords ===

The Subversion client understands a number of revision keywords. These keywords can be used instead of integer arguments to the `--revision` (`-r`) option, and are resolved into specific revision numbers by Subversion:

 * `HEAD` - __The latest (or “youngest”) revision in the repository. '''(要注意該 Revision 可能跟所在的路徑無關)'''__

 * `BASE` - The revision number of an item in a working copy. If the item has been locally modified, this refers to the way the item appears without those local modifications.

 * `COMMITTED` - __The most recent revision prior to, or equal to, `BASE`, in which an item changed. '''(搭配事先的 `svn update`, 就等同於 "在某個路徑之下, 最後一次送交的 Revision")'''__

 * `PREV` - The revision immediately before the last revision in which an item changed. Technically, this boils down to `COMMITTED-1`.

As can be derived from their descriptions, __the `PREV`, `BASE`, and `COMMITTED` revision keywords are used only when referring to a working copy path—they don't apply to repository URLs.__ `HEAD`, on the other hand, can be used in conjunction with both of these path types.

Here are some examples of revision keywords in action:

 {{{
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working copy (with all of its local changes) to the
# latest version of that tree in the repository

$ svn diff -r BASE:HEAD foo.c
# compares the unmodified version of foo.c with the latest version of
# foo.c in the repository

$ svn log -r BASE:HEAD
# shows all commit logs for the current versioned directory since you
# last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c, decreasing foo.c's working revision

$ svn diff -r BASE:14 foo.c
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14
 }}}

=== Revision Dates ===

Revision numbers reveal nothing about the world outside the version control system, but sometimes you need to correlate a moment in real time with a moment in version history. To facilitate this, the `--revision` (`-r`) option can also accept as input date specifiers wrapped in curly braces (`{` and `}`). __Subversion accepts the standard ISO-8601 date and time formats, plus a few others. Here are some examples. (Remember to use quotes around any date that contains spaces.)__

 {{{
$ svn checkout -r {2006-02-17}
$ svn checkout -r {15:30}
$ svn checkout -r {15:30:00.200000}
$ svn checkout -r {"2006-02-17 15:30"}
$ svn checkout -r {"2006-02-17 15:30 +0230"}
$ svn checkout -r {2006-02-17T15:30}
$ svn checkout -r {2006-02-17T15:30Z}
$ svn checkout -r {2006-02-17T15:30-04:00}
$ svn checkout -r {20060217T1530}
$ svn checkout -r {20060217T1530Z}
$ svn checkout -r {20060217T1530-0500}
…
 }}}

When you specify a date, Subversion resolves that date to the most recent revision of the repository as of that date, and then continues to operate against that resolved revision number:

 {{{
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
…
 }}}

=== Is Subversion a Day Early? ===

If you specify a single date as a revision without specifying a time of day (for example `2006-11-27`), you may think that Subversion should give you the last revision that took place on the 27th of November. Instead, you'll get back a revision from the 26th, or even earlier. Remember that Subversion will find the most recent revision of the repository as of the date you give. __If you give a date without a timestamp, such as `2006-11-27`, Subversion assumes a time of 00:00:00, so looking for the most recent revision won't return anything on the 27th.__

If you want to include the 27th in your search, you can either specify the 27th with the time (`{"2006-11-27 23:59"}`), or just specify the next day (`{2006-11-28}`).

You can also use a range of dates. Subversion will find all revisions between both dates, inclusive:

 {{{
$ svn log -r {2006-11-20}:{2006-11-29}
…
 }}}

Warning: Since the timestamp of a revision is stored as an ''unversioned'', modifiable property of the revision (see the section called “Properties”), revision timestamps can be changed to represent complete falsifications(變造) of true chronology(年表), or even removed altogether. __Subversion's ability to correctly convert revision dates into real revision numbers depends on revision datestamps maintaining a sequential ordering—the younger the revision, the younger its timestamp.__ If this ordering isn't maintained, you will likely find that trying to use dates to specify revision ranges in your repository doesn't always return the data you might have expected.

== Properties ==

:::

== Keyword Substitution ==

Subversion has the ability to substitute keywords—pieces of useful, dynamic information about a versioned file—into the contents of the file itself. Keywords generally provide information about the last modification made to the file. __Because this information changes each time the file changes, and more importantly, just ''after'' the file changes, it is a hassle(麻煩) for any process except the version control system to keep the data completely up to date. Left to human authors, the information would inevitably(不可避免地) grow stale.__

For example, say you have a document in which you would like to display the last date on which it was modified. You could burden every author of that document to, just before committing their changes, also tweak the part of the document that describes when it was last changed. But sooner or later, someone would forget to do that. Instead, simply ask Subversion to perform keyword substitution on the `LastChangedDate` keyword. __You control where the keyword is inserted into your document by placing a ''keyword anchor'' at the desired location in the file. This anchor is just a string of text formatted as `$KeywordName$`.__

All keywords are case-sensitive where they appear as anchors in files: you must use the correct capitalization for the keyword to be expanded. You should consider the value of the `svn:keywords` property to be case-sensitive, too—certain keyword names will be recognized regardless of case, but this behavior is deprecated.

Subversion defines the list of keywords available for substitution. That list contains the following five keywords, some of which have aliases that you can also use:

 * `Date` - This keyword describes the last time the file was known to have been changed in the repository, and is of the form `$Date: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $`. It may also be specified as `LastChangedDate`. Unlike the `Id` keyword, which uses UTC, the `Date` keyword displays dates using the local time zone.

 * `Revision` - This keyword describes the last known revision in which this file changed in the repository, and looks something like `$Revision: 144 $`. It may also be specified as `LastChangedRevision` or `Rev`.

 * `Author` - This keyword describes the last known user to change this file in the repository, and looks something like `$Author: harry $`. It may also be specified as `LastChangedBy`.

 * `HeadURL` - This keyword describes the full URL to the latest version of the file in the repository, and looks something like `$HeadURL: http://svn.collab.net/repos/trunk/README $`. It may be abbreviated as `URL`.

 * `Id` - This keyword is a compressed combination of the other keywords. Its substitution looks something like `$Id: calc.c 148 2006-07-28 21:30:43Z sally $`, and is interpreted to mean that the file `calc.c` was last changed in revision 148 on the evening of July 28, 2006 by the user sally. The date displayed by this keyword is in UTC, unlike that of the `Date` keyword (which uses the local time zone).

Several of the preceding descriptions use the phrase “last known” or similar wording. Keep in mind that keyword expansion is a ''client-side operation'', and your client “knows” only about changes that have occurred in the repository when you update your working copy to include those changes. If you never update your working copy, your keywords will never expand to different values even if those versioned files are being changed regularly in the repository.

Simply adding keyword anchor text to your file does nothing special. Subversion will never attempt to perform textual substitutions on your file contents unless explicitly asked to do so. After all, you might be writing a document (... or maybe even a section of a book ...) about how to use keywords, and you don't want Subversion to substitute your beautiful examples of unsubstituted keyword anchors!

To tell Subversion whether to substitute keywords on a particular file, we again turn to the property-related subcommands. The `svn:keywords` property, when set on a versioned file, controls which keywords will be substituted on that file. The value is a space-delimited list of keyword names or aliases.

For example, say you have a versioned file named `weather.txt` that looks like this:

 {{{
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
 }}}

With no `svn:keywords` property set on that file, Subversion will do nothing special. Now, let's enable substitution of the `LastChangedDate` keyword.

 {{{
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
 }}}

Now you have made a local property modification on the `weather.txt` file. You will see no changes to the file's contents (unless you made some of your own prior to setting the property). Notice that the file contained a keyword anchor for the `Rev` keyword, yet we did not include that keyword in the property value we set. Subversion will happily ignore requests to substitute keywords that are not present in the file and will not substitute keywords that are not present in the `svn:keywords` property value.

Immediately after you commit this property change, Subversion will update your working file with the new substitute text. Instead of seeing your keyword anchor `$LastChangedDate$`, you'll see its substituted result. That result also contains the name of the keyword and continues to be delimited by the dollar sign (`$`) characters. And as we predicted, the `Rev` keyword was not substituted because we didn't ask for it to be.

Note also that we set the `svn:keywords` property to `Date Author`, yet the keyword anchor used the alias `$LastChangedDate$` and still expanded correctly:

 {{{
Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
 }}}

If someone else now commits a change to `weather.txt`, your copy of that file will continue to display the same substituted keyword value as before—until you update your working copy. At that time, the keywords in your `weather.txt` file will be resubstituted with information that reflects the most recent known commit to that file.

 {{{#!wiki
'''Where's $GlobalRev$?'''

New users are often confused by how the `$Rev$` keyword works. Since the repository has a single, globally increasing revision number, many people assume that it is this number that is reflected by the `$Rev$` keyword's value. But `$Rev$` expands to show the last revision in which the file changed, not the last revision to which it was updated. Understanding this clears the confusion, but frustration often remains—without the support of a Subversion keyword to do so, how can you automatically get the global revision number into your files?

To do this, you need external processing. Subversion ships with a tool called `svnversion`, which was designed for just this purpose. It crawls your working copy and generates as output the revision(s) it finds. You can use this program, plus some additional tooling, to embed that revision information into your files. For more information on svnversion, see the section called “svnversion”.
 }}}

Subversion 1.2 introduced a new variant of the keyword syntax, which brought additional, useful—though perhaps atypical(非典型的)—functionality. You can now tell Subversion to maintain a fixed length (in terms of the number of bytes consumed) for the substituted keyword. By using a double colon (`::`) after the keyword name, followed by a number of space characters, you define that fixed width. When Subversion goes to substitute your keyword for the keyword and its value, it will essentially replace only those space characters, leaving the overall width of the keyword field unchanged. If the substituted value is shorter than the defined field width, there will be extra padding characters (spaces) at the end of the substituted field; if it is too long, it is truncated with a special hash (`#`) character just before the final dollar sign terminator.

For example, say you have a document in which you have some section of ''tabular'' data reflecting the document's Subversion keywords. Using the original Subversion keyword substitution syntax, your file might look something like:

 {{{
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
 }}}

Now, that looks nice and tabular at the start of things. But when you then commit that file (with keyword substitution enabled, of course), you see:

 {{{
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
 }}}

The result is not so beautiful. And you might be tempted to then adjust the file after the substitution so that it again looks tabular. But that holds only as long as the keyword values are the same width. If the last committed revision rolls into a new place value (say, from 99 to 100), or if another person with a longer username commits the file, stuff gets all crooked again. However, if you are using Subversion 1.2 or later, you can use the new fixed-length keyword syntax and define some field widths that seem sane, so your file might look like this:

 {{{
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
 }}}

You commit this change to your file. This time, Subversion notices the new fixed-length keyword syntax and maintains the width of the fields as defined by the padding you placed between the double colon and the trailing dollar sign. After substitution, the width of the fields is completely unchanged—the short values for Rev and Author are padded with spaces, and the long Date field is truncated by a hash character:

 {{{
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
 }}}

The use of fixed-length keywords is especially handy when performing substitutions into complex file formats that themselves use fixed-length fields for data, or for which the stored size of a given data field is overbearingly(專橫的) difficult to modify from outside the format's native application (such as for Microsoft Office documents).

Warning: Be aware that because the width of a keyword field is measured in bytes, the potential for corruption of multibyte values exists. For example, a username that contains some multibyte UTF-8 characters might suffer truncation in the middle of the string of bytes that make up one of those characters. The result will be a mere truncation when viewed at the byte level, but will likely appear as a string with an incorrect or garbled(混淆不清的) final character when viewed as UTF-8 text. It is conceivable(可能的) that certain applications, when asked to load the file, would notice the broken UTF-8 text and deem the entire file corrupt, refusing to operate on the file altogether. So, when limiting keywords to a fixed size, choose a size that allows for this type of byte-wise expansion.

== Sparse(零星的) Directories ==

By default, most Subversion operations on directories act in a recursive manner. For example, `svn checkout` creates a working copy with every file and directory in the specified area of the repository, descending recursively through the repository tree until the entire structure is copied to your local disk. __Subversion 1.5 introduces a feature called ''sparse directories'' (or ''shallow checkouts'') that allows you to easily check out a working copy—or a portion of a working copy—more shallowly(淺薄地) than full recursion, with the freedom to bring in previously ignored files and subdirectories at a later time.__

For example, say we have a repository with a tree of files and directories with names of the members of a human family with pets. (It's an od(古怪的)d example, to be sure, but bear with us.) A regular `svn checkout` operation will give us a working copy of the whole tree:

 {{{
$ svn checkout file:///var/svn/repos mom
A    mom/son
A    mom/son/grandson
A    mom/daughter
A    mom/daughter/granddaughter1
A    mom/daughter/granddaughter1/bunny1.txt
A    mom/daughter/granddaughter1/bunny2.txt
A    mom/daughter/granddaughter2
A    mom/daughter/fishie.txt
A    mom/kitty1.txt
A    mom/doggie1.txt
Checked out revision 1.
$
 }}}

Now, let's check out the same tree again, but this time we'll ask Subversion to give us only the topmost directory with none of its children at all:

 {{{
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1
$
 }}}

Notice that we added to our original `svn checkout` command line a new `--depth` option. __This option is present on many of Subversion's subcommands and is similar to the `--non-recursive` (`-N`) and `--recursive` (`-R`) options. (事實上 `--non-recursive` 已經被標示為 Deprecated, 取而代之的正是 `--depth`)__ In fact, it combines, improves upon, supercedes(取代), and ultimately obsoletes(廢除) these two older options. For starters, it expands the supported degrees of depth specification available to users, adding some previously unsupported (or inconsistently supported) depths. Here are the depth values that you can request for a given Subversion operation:

 * `--depth empty` - Include only the immediate target of the operation, not any of its file or directory children.

 * `--depth files` - Include the immediate target of the operation and any of its immediate file children.

 * `--depth immediates` - Include the immediate target of the operation and any of its immediate file or directory children. __The directory children will themselves be empty. (也就是這些空資料夾的 ambient depth 會被標為 "empty")__

 * `--depth infinity` - Include the immediate target, its file and directory children, its children's children, and so on to full recursion.

Of course, merely combining two existing options into one hardly constitutes a new feature worthy of a whole section in our book. (意指 `--depth` 不單單只是合併 `--non-recursive` 與 `--recursive` 而已, 否則也不值得花一個章節來做說明) Fortunately, there is more to this story. __This idea of depth extends not just to the operations you perform with your Subversion client, but also as a description of a working copy citizen's ''ambient(周遭的) depth'', (這裡 "working copy citizen" 指的正是被簽出到 Working Copy 的成員, 尤其是 "資料夾", 因為實驗發現只有資料夾才會有 "Depth:" 的記錄) which is the depth persistently recorded by the working copy for that item. Its key strength is this very persistence—the fact that it is ''sticky''. '''The working copy remembers the depth you've selected for each item in it until you later change that ''depth selection''; (通常是 `svn update --set-depth`)'''__ by default, Subversion commands operate on the working copy citizens present, regardless of their selected depth settings. (其他指令都是針對已經簽出的檔案在操作, 跟 depth 無關?)

You can check the recorded ambient depth of a working copy using the `svn info` command. If the ambient depth is anything other than infinite recursion, `svn info` will display a line describing that depth value:

 {{{
$ svn info mom-immediates | grep '^Depth:'
Depth: immediates
$
 }}}

Our previous examples demonstrated checkouts of infinite depth (the default for `svn checkout`) and empty depth. Let's look now at examples of the other depth values:

 {{{
$ svn checkout file:///var/svn/repos mom-files --depth files
A    mom-files/kitty1.txt
A    mom-files/doggie1.txt
Checked out revision 1.
$ svn checkout file:///var/svn/repos mom-immediates --depth immediates
A    mom-immediates/son
A    mom-immediates/daughter
A    mom-immediates/kitty1.txt
A    mom-immediates/doggie1.txt
Checked out revision 1.
$
 }}}

As described, each of these depths is something more than only the target, but something less than full recursion.

We've used `svn checkout` as an example here, but you'll find the `--depth` option present on many other Subversion commands, too. __In those other commands, depth specification is a way to limit the scope of an operation to some depth, much like the way the older `--non-recursive` (`-N`) and `--recursive` (`-R`) options behave. This means that when operating on a working copy of some depth, while requesting an operation of a shallower depth, the operation is limited to that shallower depth. (事實上 `svn update` 也支援 `--depth` 參數, 跟這裡有著相同的解釋)__ In fact, we can make an even more general statement: given a working copy of any arbitrary—even mixed—ambient depth, and a Subversion command with some requested operational depth, the command will maintain the ambient depth of the working copy members while still limiting the scope of the operation to the requested (or default) operational depth.[?]

__In addition to the `--depth` option, the `svn update` and `svn switch` subcommands also accept a second depth-related option: `--set-depth`. It is with this option that you can change the ''sticky depth'' (= ambient depth) of a working copy item. Watch what happens as we take our empty-depth checkout and gradually ''telescope(套疊)'' it deeper using `svn update --set-depth NEW-DEPTH TARGET`:__

 {{{
$ svn update --set-depth files mom-empty
A    mom-empty/kittie1.txt
A    mom-empty/doggie1.txt
Updated to revision 1.
$ svn update --set-depth immediates mom-empty
A    mom-empty/son
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty
A    mom-empty/son/grandson
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
A    mom-empty/daughter/granddaughter2
A    mom-empty/daughter/fishie1.txt
Updated to revision 1.
$
 }}}

As we gradually increased our depth selection, the repository gave us more pieces of our tree.

In our example, we operated only on the root of our working copy, changing its ambient depth value. But we can independently change the ambient depth value of any subdirectory inside the working copy, too. __Careful use of this ability allows us to flesh out(充實) only certain portions of the working copy tree, leaving other portions absent(缺乏的) altogether (hence the “sparse” bit of the feature's name).__ Here's an example of how we might build out a portion of one branch of our family's tree, enable full recursion on another branch, and keep still other pieces ''pruned'' (剪除; absent from disk).

 {{{
$ rm -rf mom-empty
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1.
$ svn update --set-depth empty mom-empty/son
A    mom-empty/son
Updated to revision 1.
$ svn update --set-depth empty mom-empty/daughter
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
Updated to revision 1.
$
 }}}

__Fortunately, having a complex collection of ambient depths in a single working copy doesn't complicate the way you interact with that working copy. You can still make, revert, display, and commit local modifications in your working copy without providing any new options (including `--depth` and `--set-depth`) to the relevant subcommands.__ Even `svn update` works as it does elsewhere when no specific depth is provided—it updates the working copy targets that are present while honoring their sticky depths.

You might at this point be wondering, “So what? When would I use this?” One scenario where this feature finds utility is tied to a particular repository layout, specifically where you have many related or codependent projects or software modules living as siblings in a single repository location (`trunk/project1`, `trunk/project2`, `trunk/project3`, etc.). In such scenarios, it might be the case that you personally care about only a handful of those projects—maybe some primary project and a few other modules on which it depends. You can check out individual working copies of all of these things, but those working copies are disjoint(脫節) and, as a result, it can be cumbersome to perform operations across several or all of them at the same time. The alternative is to use the sparse directories feature, building out a single working copy that contains only the modules you care about. You'd start with an empty-depth checkout of the common parent directory of the projects, and then update with infinite depth only the items you wish to have, like we demonstrated in the previous example. Think of it like an opt-in (選擇性加入) system for working copy citizens.

Subversion 1.5's implementation of shallow checkouts is good but does not support a couple of interesting behaviors. __First, you cannot ''de-telescope'' a working copy item.__ Running `svn update --set-depth empty` in an infinite-depth working copy will not have the effect of discarding everything but the topmost directory—it will simply error out. __Second, there is no depth value to indicate that you wish an item to be explicitly excluded. You have to do implicit exclusion of an item by including everything else. (不支援 "黑名單" 而言; 不過還是可以用 {{{svn update `svn list | grep -v '...'`}}} 的技巧做出一點變化...)__

== Locking ==

:::

=== Lock Communication ===

We've seen how `svn lock` and `svn unlock` can be used to create, release, break, and steal locks. This satisfies the goal of ''serializing commit access'' to a file. But what about the larger problem of preventing wasted time?

For example, suppose Harry locks an image file and then begins editing it. Meanwhile, miles away, Sally wants to do the same thing. She doesn't think to run `svn status --show-updates`, so she has no idea that Harry has already locked the file. She spends hours editing the file, and when she tries to commit her change, she discovers that either the file is locked or that she's out of date (如果 Harry 已經送交的話). Regardless, her changes aren't mergeable with Harry's. (通常二進位檔根本無法合併) One of these two people has to throw away his or her work, and a lot of time has been wasted.

__'''Subversion's solution to this problem is to provide a mechanism to remind users that a file ought to be locked before the editing begins.''' The mechanism is a special property: `svn:needs-lock`. If that property is attached to a file (regardless of its value, which is irrelevant), Subversion will try to use filesystem-level permissions to make the file read-only—unless, of course, the user has explicitly locked the file. When a lock token is present (as a result of using `svn lock`), the file becomes read/write. When the lock is released, the file becomes read-only again.__

The theory, then, is that if the image file has this property attached, Sally would immediately notice something is strange when she opens the file for editing: many applications alert users immediately when a read-only file is opened for editing, and nearly all would prevent her from saving changes to the file. This reminds her to lock the file before editing, whereby she discovers the preexisting lock:

 {{{
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
 }}}

__Tip: Users and administrators alike are encouraged to attach the `svn:needs-lock` property to any file that cannot be ''contextually merged''. This is the primary technique for encouraging good locking habits and preventing wasted effort. '''(透過責任區域的劃分, 或許能減少 `svn:needs-lock` 的使用; 畢竟編輯前都要先取得 Lock, 在某些情況下還滿礙手礙腳的?)'''__

__Note that this property is a communication tool that works independently from the locking system. In other words, any file can be locked, whether or not this property is present. And conversely, the presence of this property doesn't make the repository require a lock when committing.__

Unfortunately, the system isn't flawless. It's possible that even when a file has the property, the read-only reminder won't always work. Sometimes applications misbehave and “hijack” the read-only file, silently allowing users to edit and save the file anyway. There's not much that Subversion can do in this situation—at the end of the day, there's simply no substitution for good ''interpersonal communication''.

== Externals Definitions ==

:::

=== Client Credentials Caching ===

Many servers are configured to require authentication on every request. This would be a big annoyance to users if they were forced to type their passwords over and over again. Fortunately, the Subversion client has a remedy(補救) for this—a built-in system for caching authentication credentials on disk. __By default, whenever the command-line client successfully responds to a server's authentication challenge, it saves the credentials in the user's ''private runtime configuration area'' (`~/.subversion/auth/` on Unix-like systems or` %APPDATA%/Subversion/auth/` on Windows;__ see the section called “Runtime Configuration Area” for more details about the runtime configuration system). Successful credentials are cached on disk and keyed on a combination of the server's hostname, port, and authentication realm.

When the client receives an ''authentication challenge'', it first looks for the appropriate credentials in the user's disk cache. If seemingly suitable credentials are not present, or if the cached credentials ultimately fail to authenticate, the client will, by default, fall back to prompting the user for the necessary information.

The security-conscious reader will suspect(懷疑) immediately that there is reason for concern here. “Caching passwords on disk? That's terrible! You should never do that!”

The Subversion developers recognize the legitimacy(合理性) of such concerns, and so Subversion works with available mechanisms provided by the operating system and environment to try to minimize the risk of leaking this information. Here's a breakdown(分析說明) of what this means for users on the most common platforms:

 * On Windows 2000 and later, the Subversion client uses standard Windows cryptography services to encrypt the password on disk. Because the encryption key is managed by Windows and is tied to the user's own login credentials, only the user can decrypt the cached password. __(Note that if the user's Windows account password is reset by an administrator, all of the cached passwords become undecipherable(無法解譯的). The Subversion client will behave as though they don't exist, prompting for passwords when required; 自己改密碼就不會有事嗎?)__

 * Similarly, on Mac OS X, the Subversion client stores all repository passwords in the login keyring (managed by the [[http://en.wikipedia.org/wiki/Keychain|Keychain]] service), which is protected by the user's account password. User preference settings can impose additional policies, such as requiring that the user's account password be entered each time the Subversion password is used.

 * __For other Unix-like operating systems, no standard “keychain” services exist. (選擇太多也不一定是好事...) However, the `auth/` caching area is still permission-protected so that only the user (owner) can read data from it, not the world at large. The operating system's own file permissions protect the passwords. (對照 `~/.subversion/auth/` 的權限, 確實只有 Owner 可以讀寫)__

Of course, for the truly paranoid(多疑的人), none of these mechanisms meets the test of perfection. So for those folks willing to sacrifice(犧牲) convenience for the ultimate in security, Subversion provides various ways of disabling its credentials caching system altogether.

__To disable caching for a single command, pass the `--no-auth-cache` option:__

 {{{
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: <svn://host.example.com:3690> example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: <svn://host.example.com:3690> example realm
Username:  joe
…
 }}}

__Or, if you want to disable credential caching ''permanently'', you can edit the config file (即 `~/.subversion/config`) in your runtime configuration area and set the `store-auth-creds` option to `no`.__ This will prevent the storing of credentials used in any Subversion interactions you perform on the affected computer. This can be extended to cover all users on the computer, too, by modifying the ''system-wide runtime configuration area'' (described in the section called “Configuration Area Layout”).

 {{{
[auth]
store-auth-creds = no
 }}}

__Sometimes users will want to remove specific credentials from the disk cache. To do this, you need to navigate into the `auth/` area and manually delete the appropriate cache file.__ Credentials are cached in individual files; if you look inside each file, you will see keys and values. The `svn:realmstring` key describes the particular server realm that the file is associated with:

 {{{
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
<https://svn.domain.com:443> Joe's repository
END
 }}}

Once you have located the proper cache file, just delete it.

One last word about svn's authentication behavior, specifically regarding the `--username` and `--password` options. Many client subcommands accept these options, but it is important to understand that using these options does not automatically send credentials to the server. __As discussed earlier, the server “pulls” credentials from the client when it deems necessary; the client cannot “push” them at will. If a username and/or password are passed as options, they will be presented to the server only if the server requests them. (參考下面 Note 的例子)__ These options are typically used to authenticate as a different user than Subversion would have chosen by default (such as your system login name) or when trying to avoid interactive prompting (such as when calling `svn` from a script).

Note: A common mistake is to misconfigure a server so that it never issues an authentication challenge. When users pass `--username` and `--password` options to the client, they're surprised to see that they're never used; that is, new revisions still appear to have been committed anonymously! (假設伺服端不需要驗證, 就算明確給定 username/password 也不會被採納)

Here is a final summary that describes how a Subversion client behaves when it receives an authentication challenge.

 1. First, the client checks whether the user specified any credentials as command-line options (`--username` and/or `--password`). If so, the client will try to use those credentials to authenticate against the server.

 2. If no command-line credentials were provided, or the provided ones were invalid, the client looks up the server's hostname, port, and realm in the runtime configuration's `auth/` area, to see whether appropriate credentials are cached there. If so, it attempts to use those credentials to authenticate.

 3. Finally, if the previous mechanisms failed to successfully authenticate the user against the server, the client resorts to(訴諸於...) interactively prompting the user for valid credentials (unless instructed not to do so via the `--non-interactive` option or its client-specific equivalents).

If the client successfully authenticates by any of these methods, it will attempt to cache the credentials on disk (unless the user has disabled this behavior, as mentioned earlier).

== Summary ==

After reading this chapter, you should have a firm grasp on some of Subversion's features that, while perhaps not used every time you interact with your version control system, are certainly handy to know about. But don't stop here! Read on to the following chapter, where you'll learn about branches, tags, and merging. Then you'll have nearly full mastery of the Subversion client. Though our lawyers won't allow us to promise you anything, this additional knowledge could make you measurably(到某種程度) more cool. (No purchase necessary. Certains terms and conditions apply. No guarantee of coolness—implicit or otherwise—exists. Mileage(哩程) may vary.)

= Chapter 4. Branching and Merging =

:::

= Chapter 7. Customizing Your Subversion Experience =

Version control can be a complex subject, as much art as science, that offers myriad(無數的) ways of getting stuff done. Throughout this book, you've read of the various Subversion command-line client subcommands and the options that modify their behavior. In this chapter, we'll look into still more ways to customize the way Subversion works for you—setting up the Subversion ''runtime configuration'', using ''external helper applications'', Subversion's interaction with the operating system's configured locale, and so on.

== Runtime Configuration Area ==

Subversion provides many optional behaviors that the user can control. Many of these options are of the kind that a user would wish to apply to all Subversion operations. So, rather than forcing users to remember command-line arguments for specifying these options and to use them for every operation they perform, Subversion uses configuration files, segregated(分離) into a Subversion ''configuration area''.

__The Subversion configuration area is a ''two-tiered hierarchy'' of option names and their values. Usually, this boils down to a special directory that contains configuration files (the first tier), which are just text files in standard [[http://en.wikipedia.org/wiki/INI_file|INI format]] (with “sections” providing the second tier).__ You can easily edit these files using your favorite text editor (such as Emacs or vi), and they contain directives read by the client to determine which of several optional behaviors the user prefers.

=== Configuration Area Layout ===

__The first time the `svn` command-line client is executed, it creates a ''per-user'' configuration area.__ On Unix-like systems, this area appears as a directory named `.subversion` in the user's home directory. On Win32 systems, Subversion creates a folder named `Subversion`, typically inside the Application Data area of the user's profile directory (which, by the way, is usually a hidden directory). However, on this platform, the exact location differs from system to system and is dictated by the Windows Registry. (The `APPDATA` environment variable points to the Application Data area, so you can always refer to this folder as `%APPDATA%\Subversion`.) We will refer to the per-user configuration area using its Unix name, `.subversion`.

__In addition to the per-user configuration area, Subversion also recognizes (不會自動建立而言) the existence of a ''system-wide'' configuration area. '''This gives system administrators the ability to establish defaults for all users on a given machine.''' Note that the system-wide configuration area alone does not dictate(支配) mandatory(強制的) policy—the settings in the per-user configuration area override those in the system-wide one, and command-line arguments supplied to the `svn` program have the final word on behavior.__ On Unix-like platforms, the system-wide configuration area is expected to be the `/etc/subversion` directory; on Windows machines, it looks for a Subversion directory inside the common Application Data location (again, as specified by the Windows Registry). __Unlike the per-user case, the `svn` program does not attempt to create the system-wide configuration area.__

__The per-user configuration area currently contains three files—two configuration files (`config` and `servers`), and a `README.txt` file, which describes the INI format. At the time of their creation, the files contain default values for each of the supported Subversion options, mostly commented out and grouped with textual descriptions about how the values for the key affect Subversion's behavior.__ To change a certain behavior, you need only to load the appropriate configuration file into a text editor, and to modify the desired option's value. If at any time you wish to have the default configuration settings restored, you can simply remove (or rename) your configuration directory and then run some innocuous(無害的) `svn` command, such as `svn --version`. A new configuration directory with the default contents will be created.

The per-user configuration area also contains a cache of authentication data. The `auth` directory holds a set of subdirectories that contain pieces of cached information used by Subversion's various supported authentication methods. __This directory is created in such a way that only the user herself has permission to read its contents.__

=== Configuration and the Windows Registry ===

In addition to the usual INI-based configuration area, Subversion clients running on Windows platforms may also use the Windows Registry to hold the configuration data. The option names and their values are the same as in the INI files. The “file/section” hierarchy is preserved as well, though addressed in a slightly different fashion—in this schema, files and sections are just levels in the Registry key tree.

::: 把設定寫在 Registry 裡不是個好方法...

=== Configuration Options ===

In this section, we will discuss the specific runtime configuration options that Subversion currently supports.

==== Servers ====

:::

==== Config ====

The config file contains the rest of the currently available Subversion runtime options—those not related to networking. There are only a few options in use as of this writing, but they are again grouped into sections in expectation of future additions.

The `auth` section contains settings related to Subversion's authentication and authorization against the repository. It contains the following:

'''`store-passwords`'''

This instructs Subversion to cache, or not to cache, passwords that are supplied by the user in response to server authentication challenges. The default value is `yes`. Set this to `no` to disable this on-disk password caching. You can override this option for a single instance of the `svn` command using the `--no-auth-cache` command-line parameter (for those subcommands that support it). For more information, see the section called “Client Credentials Caching”.

'''`store-auth-creds`'''

__This setting is the same as `store-passwords`, except that it enables or disables on-disk caching of all authentication information: usernames, passwords, server certificates, and any other types of cacheable credentials. (比 `store-passwords` 更徹底!!)__

The `helpers` section controls which external applications Subversion uses to accomplish its tasks. Valid options in this section are:

:::

= Chapter 9. Subversion Complete Reference =

This chapter is intended to be a complete reference to using Subversion. This includes the command-line client (`svn`) and all its ''subcommands'', as well as the repository administration programs (`svnadmin` and `svnlook`) and their respective subcommands.

== The Subversion Command-Line Client: svn ==

To use the command-line client, type `svn`, the subcommand you wish to use, (Well, you don't need a subcommand to use the `--version` option, but we'll get to that in just a minute.) and any options or targets that you wish to operate on—__the subcommand and the options need not appear in a specific order. (其中 Targets 仍固定擺在最後面; 習慣上會採用 subcommand-options-targets 的順序)__ For example, all of the following are valid ways to use `svn status`:

 {{{
$ svn -v status
$ svn status -v 
$ svn status -v myfile
 }}}

You can find many more examples of how to use most client commands in Chapter 2, Basic Usage and commands for managing properties in the section called “Properties”.

=== svn Options ===

__While Subversion has different options for its subcommands, '''all options exist in a single namespace—that is, each option is guaranteed to mean the same thing regardless of the subcommand you use it with.'''__ For example, `--verbose` (`-v`) always means “verbose output,” regardless of the subcommand you use it with.

The `svn` command-line client usually exits quickly with an error if you pass it an option which does not apply to the specified subcommand. __But as of Subversion 1.5, several of the options which apply to all—or nearly all—of the subcommands have been deemed(視為) acceptable by all subcommands, even if they have no effect on some of them. They appear grouped together in the command-line client's usage messages as ''global options''. (例如 `svn help log` 輸出的最下方有一個 "Global options:" 的區段; 但這為什麼有助於 Scripts 的撰寫?)__ This was done to assist folks who write scripts which wrap the command-line client. These global options are as follows:

'''`--config-dir DIR`'''

Instructs Subversion to read configuration information from the specified directory instead of the default location (`.subversion` in the user's home directory).

'''`--no-auth-cache`'''

Prevents caching of authentication information (e.g., username and password) in the Subversion runtime configuration directories.

'''`--non-interactive`'''

Disables all interactive prompting. Some examples of interactive prompting include requests for authentication credentials and conflict resolution decisions. __This is useful if you're running Subversion inside an automated script and it's more appropriate to have Subversion fail than to prompt for more information. (讓程式報錯, 總比程式卡在那裡等待輸入來得好)__

'''`--password PASSWD`'''

Specifies the password to use when authenticating against a Subversion server. If not provided, or if incorrect, Subversion will prompt you for this information as needed.

'''`--username NAME`'''

Specifies the username to use when authenticating against a Subversion server. If not provided, or if incorrect, Subversion will prompt you for this information as needed.

The rest of the options apply and are accepted by only a subset of the subcommand. They are as follows:

'''`--accept ACTION`'''

Specifies an action for ''automatic conflict resolution''. Possible actions are `postpone`, `base`, `mine-full`, `theirs-full`, `edit`, and `launch`.

'''`--auto-props`'''

Enables ''auto-props'', overriding the `enable-auto-props` directive in the config file.

'''`--change (-c) ARG`'''

__Used as a means to refer to a specific “change” (a.k.a. a revision). '''This option is syntactic sugar for “`-r ARG-1:ARG`”.'''__

'''`--changelist ARG`'''

Instructs Subversion to operate only on members of the ''changelist'' named `ARG`. You can use this option multiple times to specify sets of changelists. (什麼是 changelist[?])

'''`--cl ARG`'''

An alias for the `--changelist` option.

'''`--depth ARG`'''

__Instructs Subversion to limit the scope of an operation to a particular ''tree depth''. `ARG` is one of `empty`, `files`, `immediates`, or `infinity`.__

'''`--diff-cmd CMD`'''

__Specifies an external program to use to show differences between files. When `svn diff` is invoked without this option, it uses Subversion's ''internal diff engine'', which provides ''unified diffs'' by default. If you want to use an external diff program, use `--diff-cmd`. You can pass options to the diff program with the `--extensions` (`-x`) option__ (more on that later in this section).

'''`--diff3-cmd CMD`'''

Specifies an external program to use to merge files.

'''`--dry-run`'''

__Goes through all the motions of running a command, but makes no actual changes—either on disk or in the repository.__

'''`--editor-cmd CMD`'''

Specifies an external program to use to edit a log message or a property value. See the `editor-cmd` section in the section called “Config” for ways to specify a default editor.

'''`--encoding ENC`'''

Tells Subversion that your commit message is encoded in the charset provided. The default is your operating system's native locale, and you should specify the encoding if your commit message is in any other encoding.

'''`--extensions (-x) ARG`'''

Specifies an argument or arguments that Subversion should pass to an external diff command. This option is valid only when used with the `svn diff` or `svn merge` commands, with the `--diff-cmd` option. If you wish to pass multiple arguments, you must enclose all of them in quotes (e.g., `svn diff --diff-cmd /usr/bin/diff -x "-b -E"`).

'''`--file (-F) FILENAME`'''

__Uses the contents of the named file for the specified subcommand, though '''different subcommands do different things with this content.''' For example, `svn commit` uses the content as a commit log, whereas `svn propset` uses it as a property value.__

'''`--force`'''

Forces a particular command or operation to run. Subversion will prevent you from performing some operations in normal usage, but you can pass the `force` option to tell Subversion “I know what I'm doing as well as the possible repercussions(後果) of doing it, so let me at 'em.” This option is the programmatic equivalent of doing your own electrical work with the power on—if you don't know what you're doing, you're likely to get a nasty shock.

'''`--force-log`'''

Forces a suspicious(可疑的?) parameter passed to the `--message` (`-m`) or `--file` (`-F`) option to be accepted as valid. __By default, Subversion will produce an error if parameters to these options look like they might instead be targets of the subcommand.__ For example, if you pass a versioned file's path to the `--file` (`-F`) option, Subversion will assume you've made a mistake, that the path was instead intended as the target of the operation, and that you simply failed to provide some other—unversioned—file as the source of your log message. To assert your intent and override these types of errors, pass the `--force-log` option to subcommands that accept log messages.

'''`--help` (`-h` or `-?`)'''

If used with one or more subcommands, shows the built-in help text for each. If used alone, it displays the general client help text.

'''`--ignore-ancestry`'''

__Tells Subversion to ignore ancestry when calculating differences (rely on path contents alone).__

'''`--ignore-externals`'''

Tells Subversion to ignore externals definitions and the external working copies managed by them.

'''`--incremental`'''

Prints output in a format suitable for ''concatenation''.

'''`--keep-changelists`'''

Tells Subversion not to delete changelists after committing.

'''`--keep-local`'''

Keeps the local copy of a file or directory (used with the `svn delete` command).

'''`--limit (-l) NUM`'''

Shows only the first `NUM` log messages.

'''`--message (-m) MESSAGE`'''

Indicates that you will specify either a log message or a ''lock comment'' on the command line, following this option. For example:

 {{{
$ svn commit -m "They don't make Sunday."
 }}}

'''`--new ARG`'''

Uses `ARG` as the newer target (for use with `svn diff`).

'''`--no-auto-props`'''

Disables auto-props, overriding the `enable-auto-props` directive in the config file.

'''`--no-diff-deleted`'''

__Prevents Subversion from printing differences for deleted files.__ The default behavior when you remove a file is for `svn diff` to print the same differences that you would see if you had left the file but removed all the content.

'''`--no-ignore`'''

Shows files in the status listing that would normally be omitted since they match a pattern in the `global-ignores` configuration option or the `svn:ignore` property. See the section called “Config” and the section called “Ignoring Unversioned Items” for more information.

'''`--no-unlock`'''

Tells Subversion not to automatically unlock files (the default commit behavior is to unlock all files listed as part of the commit). See the section called “Locking” for more information.

'''`--non-recursive (-N)`'''

__Deprecated. Stops a subcommand from recursing into subdirectories. (按照 "Sparse Directories" 一節的說法, 它就要連同 `--recursive` 被 `--depth` 取代)__ Most subcommands recurse by default, but some subcommands—usually those that have the potential to remove or undo your local modifications—do not.

'''`--notice-ancestry`'''

Pays attention to ancestry when calculating differences.

'''`--old ARG`'''

Uses `ARG` as the older target (for use with `svn diff`).

'''`--parents`'''

__Creates and adds nonexistent or nonversioned parent subdirectories to the working copy or repository as part of an operation. This is useful for automatically creating multiple subdirectories where none currently exist. '''If performed on a URL, all the directories will be created in a single commit. (跟 `mkdir` 中 `--parents` 的用法類似)'''__

'''`--quiet (-q)`'''

Requests that the client print only essential information while performing an operation.

'''`--record-only`'''

Marks revisions as merged, for use with `--revision` (`-r`).

'''`--recursive (-R)`'''

Makes a subcommand recurse into subdirectories. Most subcommands recurse by default.

'''`--reintegrate`'''

Used with the `svn merge` subcommand, merges all of the source URL's changes into the working copy. See the section called “Keeping a Branch in Sync” for details.

'''`--relocate FROM TO [PATH...]`'''

Used with the `svn switch` subcommand, changes the location of the repository that your working copy references. This is useful if the location of your repository changes and you have an existing working copy that you'd like to continue to use. See `svn switch` for an example.

'''`--remove ARG`'''

Disassociates `ARG` from a changelist

'''`--revision (-r) REV`'''

__Indicates that you're going to supply a revision (or range of revisions) for a particular operation. You can provide revision numbers, ''keywords'', or dates (in curly braces) as arguments to the `revision` option. If you wish to offer a range of revisions, you can provide two revisions separated by a colon.__ For example:

 {{{
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
 }}}

See the section called “Revision Keywords” for more information.

'''`--revprop`'''

Operates on a ''revision property'' (指 `"svn:"` 開頭的 Properties[?]) instead of a property specific to a file or directory. This option requires that you also pass a revision with the `--revision` (`-r`) option.

'''`--set-depth ARG`'''

__Sets the ''sticky depth'' on a directory in a working copy to one of `empty`, `files`, `immediates`, or `infinity`. (參考上面 Sparse Directories 的說明)__

'''`--show-revs ARG`'''

Used to make `svn mergeinfo` display either merged or eligible(合格的?) revisions.

'''`--show-updates (-u)`'''

__Causes the client to display information about which files in your working copy are ''out of date''. This doesn't actually update any of your files—it just shows you which files will be updated if you then use `svn update`.__

'''`--stop-on-copy`'''

__Causes a Subversion subcommand that traverses the history of a versioned resource to stop harvesting(收割?) that historical information when a copy—that is, a location in history where that resource was copied from another location in the repository—is encountered.__

'''`--strict`'''

Causes Subversion to use ''strict semantics'', a notion that is rather vague(含糊的) unless talking about specific subcommands (namely, `svn propget`).[?]

'''`--targets FILENAME`'''

__Tells Subversion to get the list of files that you wish to operate on from the filename that you provide instead of listing all the files on the command line.__

'''`--use-merge-history (-g)`'''

Uses or displays additional information from ''merge history''.

'''`--verbose (-v)`'''

Requests that the client print out as much information as it can while running any subcommand. This may result in Subversion printing out additional fields, detailed information about every file, or additional information regarding its actions.

'''`--version`'''

Prints the client version info. This information includes not only the version number of the client, but also a listing of all ''repository access modules'' that the client can use to access a Subversion repository. With `--quiet` (`-q`) it prints only the version number in a compact form.

'''`--with-all-revprops`'''

Used with the `--xml` option to `svn log`, will retrieve and display all revision properties in the log output.

'''`--with-revprop ARG`'''

When used with any command that writes to the repository, sets the revision property, using the `NAME=VALUE` format, `NAME` to `VALUE`. When used with `svn log` in `--xml` mode, this displays the value of `ARG` in the log output.

'''`--xml`'''

Prints output in XML format.

:::

==== svn checkout ====

'''Name'''

`svn checkout` — Check out a working copy from a repository.

'''Synopsis'''

 {{{
svn checkout URL[@REV]... [PATH]
 }}}

'''Description'''

__Check out a working copy from a repository. If `PATH` is omitted, the basename of the URL will be used as the destination. If multiple URLs are given, each will be checked out into a subdirectory of `PATH`, with the name of the subdirectory being the basename of the URL. (這裡的 basename 指的是 URL 的最後一個元素, 例如 http://svn.bitstrut.com/bazaar/src/context 中的 "context"; 這與 Commons IO 中 [[http://commons.apache.org/io/api-release/org/apache/commons/io/FilenameUtils.html|FilenameUtils]] 對 base name 的定義相同)__

其中 `URL` 不能指向某個檔案, 必須要指向某個資料夾才行. 否則會丟出 "svn: URL 'xxx' refers to a file, not a directory" 的錯誤.

'''Alternate names'''

 * `co`

'''Changes'''

Creates a working copy

'''Accesses repository'''

Yes

'''Options'''

 * `--depth ARG`
 * `--force`
 * `--ignore-externals`
 * `--quiet (-q)`
 * `--revision (-r) REV`

__'''另外 `--non-recursive (-N)` 可以用來只簽出根目錄, 但後續的 `svn update` 也要記得加上這個選項才行, 否則更新時整個目錄的內容全都會下來...'''__

'''Examples'''

Check out a working copy into a directory called `mine`:

 {{{
$ svn checkout file:///var/svn/repos/test mine
A  mine/a
A  mine/b
A  mine/c
A  mine/d
Checked out revision 20.
$ ls
mine
 }}}

Check out two different directories into two separate working copies:

 {{{
$ svn checkout file:///var/svn/repos/test  file:///var/svn/repos/quiz
A  test/a
A  test/b
A  test/c
A  test/d
Checked out revision 20.
A  quiz/l
A  quiz/m
Checked out revision 13.
$ ls
quiz  test
 }}}

Check out two different directories into two separate working copies, but place both into a directory called `working-copies`:

 {{{
$ svn checkout file:///var/svn/repos/test  file:///var/svn/repos/quiz working-copies
A  working-copies/test/a
A  working-copies/test/b
A  working-copies/test/c
A  working-copies/test/d
Checked out revision 20.
A  working-copies/quiz/l
A  working-copies/quiz/m
Checked out revision 13.
$ ls
working-copies
 }}}

__If you interrupt a checkout (or something else interrupts your checkout, such as loss of connectivity, etc.), you can restart it either by issuing the identical checkout command again or by updating the incomplete working copy:__

 {{{
$ svn checkout file:///var/svn/repos/test mine
A  mine/a
A  mine/b
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn checkout file:///var/svn/repos/test mine
A  mine/c
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn update mine
A  mine/d
Updated to revision 20.
 }}}

If you wish to check out some revision other than the most recent one, you can do so by providing the `--revision (-r)` option to the `svn checkout` command:

 {{{
$ svn checkout -r 2 file:///var/svn/repos/test mine
A  mine/a
Checked out revision 2.
 }}}

==== svn export ====

`svn export` — Export a clean directory tree.

'''Synopsis'''

 {{{
svn export [-r REV] URL[@PEGREV] [PATH]

svn export [-r REV] PATH1[@PEGREV] [PATH2]
 }}}

'''Description'''

The first form exports a clean directory tree from the repository specified by `URL`—at revision `REV` if it is given; otherwise, at `HEAD`, into `PATH`. If `PATH` is omitted, the last component of the URL is used for the local directory name.

__2009-12-16 實驗確認, `URL` 或 `PATH1` 並不一定要指向一個目錄. 如果 `URL` 指向一支檔案, 而且省略 `PATH` 時, 會將該檔案匯出到目前所在的目錄, 並不會建立一個跟檔案同名的資料夾.__

The second form exports a clean directory tree from the working copy specified by `PATH1` into `PATH2`. __All local changes will be preserved, but files not under version control will not be copied. '''(如果要連同未加入版控者一起匯出, 可能就要複製整個資料夾, 再手動將 `.svn` 資料夾去掉吧?)'''__

'''Alternate names'''

None

'''Changes'''

Local disk

'''Accesses repository'''

Only if exporting from a URL

'''Options'''

 * `--depth ARG`
 * `--force`
 * `--ignore-externals`
 * `--native-eol EOL`
 * `--quiet (-q)`
 * `--revision (-r) REV`

'''Examples'''

Export from your working copy (doesn't print every file and directory):

 {{{
$ svn export a-wc my-export
Export complete.
 }}}

Export directly from the repository (prints every file and directory):

 {{{
$ svn export file:///var/svn/repos my-export
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
 }}}

When rolling operating-system-specific release packages, it can be useful to export a tree that uses a specific EOL character for line endings. The `--native-eol` option will do this, but it affects only files that have `svn:eol-style = native` properties attached to them. For example, to export a tree with all CRLF line endings (possibly for a Windows `.zip` file distribution):[?]

 {{{
$ svn export file:///var/svn/repos my-export --native-eol CRLF
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
 }}}

You can specify `LR`, `CR`, or `CRLF` as a line-ending type with the `--native-eol` option.

==== svn diff ====

'''Name'''

`svn diff` — This displays the differences between two revisions or paths.

'''Synopsis'''

 {{{
diff [-c M | -r N[:M]] [TARGET[@REV]...]

diff [-r N[:M]] --old=OLD-TGT[@OLDREV] [--new=NEW-TGT[@NEWREV]] [PATH...]

diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]
 }}}

'''Description'''

Display the differences between two paths. You can use `svn diff` in the following ways:

 * __'''Use just `svn diff` to display ''local modifications'' in a working copy.'''__

 * Display the changes made to `TARGET`s as they are seen in `REV` between two revisions. `TARGET`s may be all working copy paths or all URLs. If `TARGET`s are working copy paths, `N` defaults to `BASE` and `M` to the working copy; if `TARGET`s are `URL`s, `N` must be specified and `M` defaults to `HEAD`. __The `-c M` option is equivalent to `-r N:M` where `N = M-1`. Using `-c -M` does the reverse: `-r M:N` where `N = M-1`.__

 * Display the differences between `OLD-TGT` as it was seen in `OLDREV` and `NEW-TGT` as it was seen in `NEWREV`. `PATH`s, if given, are relative to `OLD-TGT` and `NEW-TGT` and restrict the output to differences for those paths. `OLD-TGT` and `NEW-TGT` may be working copy paths or `URL[@REV]`. `NEW-TGT` defaults to `OLD-TGT` if not specified. `-r N` makes `OLDREV` default to `N`; `-r N:M` makes `OLDREV` default to `N` and `NEWREV` default to `M`.

 {{{
svn diff OLD-URL[@OLDREV] NEW-URL[@NEWREV] is shorthand for svn diff --old=OLD-URL[@OLDREV] --new=NEW-URL[@NEWREV].

svn diff -r N:M URL is shorthand for svn diff -r N:M --old=URL --new=URL.

svn diff [-r N[:M]] URL1[@N] URL2[@M] is shorthand for svn diff [-r N[:M]] --old=URL1 --new=URL2.
 }}}

If TARGET is a URL, then revs N and M can be given either via the --revision (-r) option or by using the “@” notation as described earlier.

If TARGET is a working copy path, the default behavior (when no --revision (-r) option is provided) is to display the differences between the base and working copies of TARGET. If a --revision (-r) option is specified in this scenario, though, it means:

 * `--revision N:M` - The server compares `TARGET@N` and `TARGET@M`.
 * `--revision N` - The client compares `TARGET@N` against the working copy.

If the alternate syntax is used, the server compares `URL1` and `URL2` at revisions `N` and `M`, respectively. If either `N` or `M` is omitted, a value of `HEAD` is assumed.

__'''By default, `svn diff` ignores the ancestry(世系) of files and merely compares the contents of the two files being compared.''' If you use `--notice-ancestry`, the ancestry of the paths in question will be taken into consideration when comparing revisions (i.e., if you run `svn diff` on two files with identical contents but different ancestry, you will see the entire contents of the file as having been ''removed and added again'').__

'''Alternate names'''

 * `di`

'''Changes'''

Nothing

'''Accesses repository'''

For obtaining differences against anything but `BASE` revision in your working copy

'''Options'''

 * `--change (-c) ARG`
 * `--changelist ARG`
 * `--depth ARG`
 * `--diff-cmd CMD`
 * `--extensions (-x) ARG`
 * `--force`
 * `--new ARG`
 * `--no-diff-deleted`
 * `--notice-ancestry`
 * `--old ARG`
 * `--revision (-r) ARG`
 * `--summarize`
 * `--xml`

'''Examples'''

Compare `BASE` and your working copy (one of the most popular uses of `svn diff`):

 {{{
$ svn diff COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
 }}}

See what changed in the file `COMMITTERS` revision 9115:

 {{{
$ svn diff -c 9115 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
 }}}

See how your working copy's modifications compare against an older revision:

 {{{
$ svn diff -r 3900 COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
 }}}

Compare revision 3000 to revision 3500 using “`@`” syntax:

 {{{
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 \
           http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
…
 }}}

Compare revision 3000 to revision 3500 using ''range notation'' (pass only the one URL in this case):

 {{{
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
 }}}

Compare revision 3000 to revision 3500 of all the files in trunk using range notation:

 {{{
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
 }}}       

Compare revision 3000 to revision 3500 of only three files in trunk using range notation:

 {{{
$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk \
           COMMITTERS README HACKING
 }}}

If you have a working copy, you can obtain the differences without typing in the long URLs:

 {{{
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
 }}}

Use `--diff-cmd CMD --extensions (-x)` to pass arguments directly to the external diff program:

 {{{
$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
> This is a test
> 
 }}}

Lastly, you can use the `--xml` option along with the `--summarize` option to view XML describing the changes that occurred between revisions, but not the contents of the diff itself:

 {{{
$ svn diff --summarize --xml http://svn.red-bean.com/repos/test@r2 \
           http://svn.red-bean.com/repos/test
<?xml version="1.0"?>
<diff>
<paths>
<path
   props="none"
   kind="file"
   item="modified">http://svn.red-bean.com/repos/test/sandwich.txt</path>
<path
   props="none"
   kind="file"
   item="deleted">http://svn.red-bean.com/repos/test/burrito.txt</path>
<path
   props="none"
   kind="dir"
   item="added">http://svn.red-bean.com/repos/test/snacks</path>
</paths>
</diff>
 }}}

==== svn list ====

'''Name'''

`svn list` — List directory entries in the repository.

'''Synopsis'''

 {{{
svn list [TARGET[@REV]...]
 }}}

'''Description'''

List each `TARGET` file and the contents of each `TARGET` directory as they exist in the repository. If `TARGET` is a working copy path, the corresponding repository URL will be used.

The default `TARGET` is “`.`”, meaning the repository URL of the current working copy directory.

With `--verbose (-v)`, `svn list` shows the following fields for each item:

 * Revision number of the last commit
 * Author of the last commit
 * If locked, the letter “O” (see the preceding section on svn info for details).
 * Size (in bytes)
 * Date and time of the last commit

With `--xml`, output is in XML format (with a header and an enclosing document element unless `--incremental` is also specified). All of the information is present; the `--verbose (-v)` option is not accepted.

'''Alternate names'''

 * `ls`

'''Changes'''

Nothing

'''Accesses repository'''

Yes

'''Options'''

 * `--depth ARG`
 * `--incremental`
 * `--recursive (-R)`
 * `--revision (-r) REV`
 * `--verbose (-v)`
 * `--xml`

'''Examples'''

`svn list` is most useful if you want to see what files a repository has without downloading a working copy:

 {{{
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
…
 }}}

You can pass the `--verbose (-v)` option for additional information, rather like the Unix command `ls -l`:

 {{{
$ svn list -v file:///var/svn/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
 }}}

You can also get svn list output in XML format with the `--xml` option:

 {{{
$ svn list --xml http://svn.red-bean.com/repos/test
<?xml version="1.0"?>
<lists>
<list
   path="http://svn.red-bean.com/repos/test">
<entry
   kind="dir">
<name>examples</name>
<size>0</size>
<commit
   revision="24">
<author>harry</author>
<date>2008-01-18T06:35:53.048870Z</date>
</commit>
</entry>
...
</list>
</lists>
 }}}

For further details, see the earlier section the section called “`svn list`”.

==== svn log ====

'''Name'''

`svn log` — Display commit log messages.

'''Synopsis'''

 {{{
svn log [PATH]

svn log URL[@REV] [PATH...]
 }}}

'''Description'''

Shows log messages from the repository. If no arguments are supplied, `svn log` shows the log messages for all files and directories inside (and including) the current working directory of your working copy. You can refine the results by specifying a path, one or more revisions, or any combination of the two. The default revision range for a local path is `BASE:1`. (不是 `1:BASE`, 因為 Logs 確實依 "從新到舊" 的順序列出)

If you specify a URL alone, it prints log messages for everything the URL contains. __If you add paths past the URL, only messages for those paths under that URL will be printed.__ The default revision range for a URL is `HEAD:1`.

With `--verbose (-v)`, `svn log` will also print all affected paths with each log message. With `--quiet (-q)`, `svn log` will not print the log message body itself, this is compatible with `--verbose (-v)`).

Each log message is printed just once, even if more than one of the affected paths for that revision were explicitly requested. __Logs follow copy history by default. Use `--stop-on-copy` to disable this behavior, '''which can be useful for determining ''branch points''.'''__

'''Alternate names'''

None

'''Changes'''

Nothing

'''Accesses repository'''

Yes

'''Options'''

 * `--change (-c) ARG`
 * `--incremental`
 * `--limit (-l) NUM`
 * `--quiet (-q)`
 * `--revision (-r) REV`
 * `--stop-on-copy`
 * `--targets FILENAME`
 * `--use-merge-history (-g)`
 * `--verbose (-v)`
 * `--with-all-revprops`
 * `--with-revprop ARG`
 * `--xml`

'''Examples'''

You can see the log messages for all the paths that changed in your working copy by running `svn log` from the top:

 {{{
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
…
 }}}

Examine all log messages for a particular file in your working copy:

 {{{
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
 }}}

If you don't have a working copy handy, you can log a URL:

 {{{
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
 }}}

If you want several distinct paths underneath the same URL, you can use the `URL [PATH...]` syntax:

 {{{
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
 }}}

The `--verbose (-v)` option causes `svn log` to include information about the paths that were changed in each displayed revision. These paths appear, one path per line of output, with action codes that indicate what type of change was made to the path.

 {{{
$ svn log -v http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line
Changed paths:
   M /foo.c

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line
Changed paths:
   A /bar.c

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
 }}}

`svn log` uses just a handful of ''action codes'', and they are similar to the ones the `svn update` command uses:

 * `A` - The item was added.
 * `D` - The item was deleted.
 * `M` - Properties or textual contents on the item were changed.
 * `R` - The item was ''replaced'' by a different one at the same location.

__In addition to the action codes which precede the changed paths, `svn log` with the `--verbose (-v)` option will note '''whether a path was added or replaced as the result of a copy operation. It does so by printing (`from COPY-FROM-PATH:COPY-FROM-REV`) after such paths.'''__

When you're concatenating the results of multiple calls to the `log` command, you may want to use the `--incremental` option. `svn log` normally prints out a dashed line at the beginning of a log message, after each subsequent log message, and following the final log message. If you ran `svn log` on a range of two revisions, you would get this:

 {{{
$ svn log -r 14:15
------------------------------------------------------------------------
r14 | …

------------------------------------------------------------------------
r15 | …

------------------------------------------------------------------------
 }}}

However, if you wanted to gather two nonsequential log messages into a file, you might do something like this:

 {{{
$ svn log -r 14 > mylog
$ svn log -r 19 >> mylog
$ svn log -r 27 >> mylog
$ cat mylog
------------------------------------------------------------------------
r14 | …

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | …

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | …

------------------------------------------------------------------------
 }}}

You can avoid the clutter of the double dashed lines in your output by using the `--incremental` option:

 {{{
$ svn log --incremental -r 14 > mylog
$ svn log --incremental -r 19 >> mylog
$ svn log --incremental -r 27 >> mylog
$ cat mylog
------------------------------------------------------------------------
r14 | …

------------------------------------------------------------------------
r19 | …

------------------------------------------------------------------------
r27 | …
 }}}

The `--incremental` option provides similar output control when using the `--xml` option:

 {{{
$ svn log --xml --incremental -r 1 sandwich.txt
<logentry
   revision="1">
<author>harry</author>
<date>2008-06-03T06:35:53.048870Z</date>
<msg>Initial Import.</msg>
</logentry>
 }}}

Tip: Sometimes when you run `svn log` on a specific path and a specific revision, you see no log information output at all, as in the following:

 {{{
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
 }}}

That just means the path wasn't modified in that revision. To get log information for that revision, either run the log operation against the repository's root URL, or specify a path that you happen to know was changed in that revision:

 {{{
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
 }}}

==== svn propedit ====

'''Name'''

`svn propedit` — Edit the property of one or more items under version control. See `svn propset` later in this chapter.

'''Synopsis'''

 {{{
svn propedit PROPNAME TARGET...

svn propedit PROPNAME --revprop -r REV [TARGET]
 }}}

'''Examples'''

 {{{
svn propedit svn:externals http://svn.simplbug.com/repos/...
 }}}

'''Description'''

Edit one or more properties using your favorite editor. The first form edits versioned properties in your working copy, and the second edits unversioned remote properties on a repository revision (`TARGET` determines only which repository to access; 可以直接修改遠端的 Properties 還滿方便的).

'''Alternate names'''

 * `pedit`
 * `pe`

'''Changes'''

Working copy; repository only if operating on a URL

'''Accesses repository'''

Only if operating on a URL

'''Options'''

 * `--editor-cmd EDITOR`
 * `--encoding ENC`
 * `--file (-F) ARG`
 * `--force`
 * `--force-log`
 * `--message (-m) ARG`
 * `--revision (-r) REV`
 * `--revprop`
 * `--with-revprop ARG`

'''Examples'''

`svn propedit` makes it easy to modify properties that have multiple values:

Set new value for property `'svn:keywords'` on `'foo.c'`

 {{{
$ svn propedit svn:keywords  foo.c 
 }}}

svn will launch your favorite editor here, with a buffer open containing the current contents of the `svn:keywords` property. __You can add multiple values to a property easily here by entering one value per line. (存檔離開後又會開出另一個 Editor 供輸入 Comment)__

==== svn proplist ====

'''Name'''

`svn proplist` — List all properties.

'''Synopsis'''

 {{{
svn proplist [TARGET[@REV]...]

svn proplist --revprop -r REV [TARGET]
 }}}

'''Description'''

List all properties on files, directories, or revisions. The first form lists versioned properties in your working copy, and the second lists ''unversioned'' remote properties on a repository revision (`TARGET` determines only which repository to access).

'''Alternate names'''

`plist`, `pl`

'''Changes'''

Working copy; repository only if operating on a URL

'''Accesses repository'''

Only if operating on a URL

'''Options'''

 * `--changelist ARG`
 * `--depth ARG`
 * `--quiet (-q)`
 * `--recursive (-R)`
 * `--revision (-r) REV`
 * `--revprop`
 * `--verbose (-v)`
 * `--xml`

'''Examples'''

You can use `proplist` to see the properties on an item in your working copy:

 {{{
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
 }}}

__But with the `--verbose` flag, `svn proplist` is extremely handy as it also shows you the values for the properties:__

 {{{
$ svn proplist --verbose foo.c
Properties on 'foo.c':
  svn:mime-type : text/plain
  svn:keywords : Author Date Rev
  owner : sally
 }}}

Lastly, you can get `svn proplist` output in xml format with the `--xml` option:

 {{{
$ svn proplist --xml 
<?xml version="1.0"?>
<properties>
<target
   path=".">
<property
   name="svn:ignore"/>
</target>
</properties>
 }}}

==== svn revert ====

'''Name'''

`svn revert` — Undo all local edits.

'''Synopsis'''

 {{{
svn revert PATH...
 }}}

'''Description'''

Reverts any local changes to a file or directory and resolves any conflicted states. `svn revert` will revert not only the contents of an item in your working copy, but also any property changes. Finally, you can use it to undo any scheduling operations that you may have performed (e.g., files scheduled for addition or deletion can be “unscheduled”).

'''Alternate names'''

None

'''Changes'''

Working copy

'''Accesses repository'''

No

'''Options'''

 * `--changelist ARG`
 * `--depth ARG`
 * `--quiet (-q)`
 * `--recursive (-R)`
 * `--targets FILENAME`

'''Examples'''

Discard changes to a file:

 {{{
$ svn revert foo.c
Reverted foo.c
 }}}

If you want to revert a whole directory of files, use the `--depth=infinity` option:

 {{{
$ svn revert --depth=infinity .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
 }}}

Lastly, you can undo any scheduling operations:

 {{{
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?      mistake.txt
?      whoops
 }}}

'''Warning'''

`svn revert` is inherently dangerous, since its entire purpose is to throw away data—namely, your uncommitted changes. Once you've reverted, Subversion provides no way to get back those uncommitted changes.

__If you provide no targets to `svn revert`, it will do nothing—to protect you from accidentally losing changes in your working copy, `svn revert` requires you to provide at least one target.__

==== svn switch ====

'''Name'''

`svn switch` — Update working copy to a different URL.

'''Synopsis'''

 {{{
svn switch URL[@PEGREV] [PATH]

switch --relocate FROM TO [PATH...]
 }}}

'''Description'''

The first variant of this subcommand (without the `--relocate` option) updates your working copy to point to a new URL—usually a URL that ''shares a common ancestor'' with your working copy, although not necessarily. This is the Subversion way to move a working copy to a new branch. If specified, `PEGREV` determines in which revision the target is first looked up. See the section called “Traversing Branches” for an in-depth look at switching.

If `--force` is used, unversioned obstructing(阻礙) paths in the working copy do not automatically cause a failure if the switch attempts to add the same path. If the obstructing path is the same type (file or directory) as the corresponding path in the repository, it becomes versioned but its contents are left untouched in the working copy. This means that an obstructing directory's unversioned children may also obstruct and become versioned. For files, any content differences between the obstruction and the repository are treated like a local modification to the working copy. All properties from the repository are applied to the obstructing path.[?]

As with most subcommands, you can limit the scope of the switch operation to a particular tree depth using the `--depth` option. Alternatively, you can use the `--set-depth` option to set a new “sticky” working copy depth on the switch target. Currently, the depth of a working copy directory can only be increased (telescoped(套疊) more deeply); you cannot make a directory more shallow.

__The `--relocate` option causes `svn switch` to do something different: it updates your working copy to point to the same repository directory, only at a different URL (typically because an administrator has moved the repository to another server, or to another URL on the same server).__

Alternate names: `sw`

Changes: Working copy

Accesses repository: Yes

'''Options'''

 * `--accept ACTION`
 * `--depth ARG`
 * `--diff3-cmd CMD`
 * `--force`
 * `--ignore-externals`
 * `--quiet (-q)`
 * `--relocate`
 * `--revision (-r) REV`
 * `--set-depth ARG`

'''Examples'''

If you're currently inside the directory `vendors`, which was branched to `vendors-with-fix`, and you'd like to switch your working copy to that branch:

 {{{
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
 }}}

To switch back, just provide the URL to the location in the repository from which you originally checked out your working copy:

 {{{
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
 }}}

Tip: You can switch just part of your working copy to a branch if you don't want to switch your entire working copy.

__Sometimes an administrator might change the location (or apparent(外表的) location) of your repository—in other words, the content of the repository doesn't change, but the repository's ''root URL'' does. For example, the hostname may change, the URL scheme may change, or any part of the URL that leads to the repository itself may change. Rather than check out a new working copy, you can have the `svn switch` command “rewrite” your working copy's ''administrative metadata'' to refer to the new repository location. If you use the `--relocate` option to `svn switch`, Subversion will contact the repository to validate the relocation request (looking for the repository at the new URL, of course), and then do this ''metadata rewriting''. No file contents will be changed as the result of this type of switch operation—this is a metadata-only modification to the working copy.__

 {{{
$ svn checkout file:///var/svn/repos test
A  test/a
A  test/b
…

$ mv repos newlocation
$ cd test/

$ svn update
svn: Unable to open an ra_local session to URL
svn: Unable to open repository 'file:///var/svn/repos'

$ svn switch --relocate file:///var/svn/repos file:///tmp/newlocation .
$ svn update
At revision 3.
 }}}

Warning: Be careful when using the `--relocate` option. If you mistype the argument, you might end up creating nonsensical(沒有意義的) URLs within your working copy that render the whole workspace unusable and tricky to fix. It's also important to understand exactly when one should or shouldn't use `--relocate`. Here's the rule of thumb:

 * If the working copy needs to reflect a new directory ''within the repository'', use just `svn switch`.

 * If the working copy still reflects the same repository directory, but the location of the repository itself has changed, use `svn switch` with the `--relocate` option.

==== svn update ====

'''Name'''

`svn update` — Update your working copy.

'''Synopsis'''

 {{{
svn update [PATH...]
 }}}

'''Description'''

`svn update` brings changes from the repository into your working copy. If no revision is given, it brings your working copy up to date with the `HEAD` revision. Otherwise, it synchronizes the working copy to the revision given by the `--revision` option. As part of the synchronization, `svn update` also removes any ''stale locks'' (see the section called “Sometimes You Just Need to Clean Up”) found in the working copy.

For each updated item, it prints a line that starts with a character reporting the action taken. These characters have the following meaning:

 * `A` - Added
 * `B` - Broken lock (third column only)
 * `D` - Deleted
 * `U` - Updated
 * `C` - Conflicted
 * `G` - Merged
 * `E` - Existed

__A character in the first column signifies an update to the actual file, whereas updates to the file's properties are shown in the second column. Lock information is printed in the third column.__

As with most subcommands, you can limit the scope of the update operation to a particular tree depth using the `--depth` option. Alternatively, you can use the `--set-depth` option to set a new “sticky” working copy depth on the update target. Currently, the depth of a working copy directory can only be increased (telescoped more deeply); you cannot make a directory more shallow.[?]

'''Alternate names'''

 * `up`

'''Changes'''

Working copy

'''Accesses repository'''

Yes

'''Options'''

 * `--accept ARG`
 * `--changelist`
 * `--depth ARG`
 * `--diff3-cmd CMD`
 * `--editor-cmd ARG`
 * `--force`
 * `--ignore-externals`
 * `--quiet (-q)`
 * `--revision (-r) REV`
 * `--set-depth ARG`

'''Examples'''

Pick up repository changes that have happened since your last update:

 {{{
$ svn update
A  newdir/toggle.c
A  newdir/disclose.c
A  newdir/launch.c
D  newdir/README
Updated to revision 32.
 }}}

You can also “update” your working copy to an older revision (Subversion doesn't have the concept of “sticky” files like CVS does; see Appendix B, Subversion for CVS Users):

 {{{
$ svn update -r30
A  newdir/README
D  newdir/toggle.c
D  newdir/disclose.c
D  newdir/launch.c
U  foo.c
Updated to revision 30.
 }}}

__Tip: If you want to examine an older revision of a single file, you may want to use `svn cat` instead—it won't change your working copy.__

:::

== svnadmin ==

`svnadmin` is the administrative tool for monitoring and repairing your Subversion repository. For detailed information on repository administration, see the maintenance section for the section called “svnadmin”.

__Since `svnadmin` works via ''direct repository access'' (and thus can only be used on the machine that holds the repository), it refers to the repository with a path, not a URL.__

=== svnadmin Options ===

Options in svmadin are global, just as they are in `svn`:

'''`--bdb-log-keep`'''

(Berkeley DB-specific.) Disable automatic log removal of database logfiles. Having these logfiles around can be convenient if you need to restore from a catastrophic repository failure.

'''`--bdb-txn-nosync`'''

(Berkeley DB-specific.) Disables fsync when committing database transactions. Used with the `svnadmin create` command to create a Berkeley DB-backed repository with `DB_TXN_NOSYNC` enabled (which improves speed but has some risks associated with it).

'''`--bypass-hooks`'''

Bypass the ''repository hook system''.

'''`--clean-logs`'''

Remove unused Berkeley DB logs.

'''`--force-uuid`'''

By default, when loading data into repository that already contains revisions, `svnadmin` will ignore the UUID from the dump stream. This option will cause the repository's UUID to be set to the UUID from the stream.

'''`--ignore-uuid`'''

By default, when loading an empty repository, `svnadmin` will ignore the UUID from the dump stream. This option will force that UUID to be ignored (useful for overriding your configuration file if it has `--force-uuid` set).

'''`--incremental`'''

Dump a revision only as a diff against the previous revision, instead of the usual fulltext.

'''`--parent-dir DIR`'''

When loading a dump file, root paths at `DIR` instead of `/`.

'''`--pre-1.4-compatible`'''

When creating a new repository, use a format that is compatible with versions of Subversion earlier than Subversion 1.4.

'''`--pre-1.5-compatible`'''

When creating a new repository, use a format that is compatible with versions of Subversion earlier than Subversion 1.5.

'''`--revision (-r) ARG`'''

Specify a particular revision to operate on.

'''`--quiet`'''

Do not show normal progress—show only errors.

'''`--use-post-commit-hook`'''

When loading a dump file, runs the repository's `post-commit` hook after finalizing each newly loaded revision.

'''`--use-post-revprop-change-hook`'''

When changing a revision property, runs the repository's `post-revprop-change` hook after changing the revision property.

'''`--use-pre-commit-hook`'''

When loading a dump file, runs the repository's `pre-commit` hook before finalizing each newly loaded revision. If the hook fails, aborts the commit and terminates the load process.

'''`--use-pre-revprop-change-hook`'''

When changing a revision property, runs the repository's `pre-revprop-change` hook before changing the revision property. If the hook fails, aborts the modification and terminates.

=== svnadmin Subcommands ===

Here are the various subcommands for the `svnadmin` program.

==== svnadmin crashtest ====

'''Name'''

`svnadmin crashtest` — Simulate a process that crashes.

'''Synopsis'''

 {{{
svnadmin crashtest REPOS_PATH
 }}}

'''Description'''

Open the repository at `REPOS_PATH`, then abort, thus simulating a process that crashes while holding an open repository handle. This is used for testing ''automatic repository recovery'' (a new feature in Berkeley DB 4.4). It's unlikely that you'll need to run this command.

'''Options'''

None

'''Examples'''

 {{{
$ svnadmin crashtest /var/svn/repos
Aborted
 }}}

Exciting, isn't it?

==== svnadmin create ====

'''Name'''

`svnadmin create` — Create a new, empty repository.

'''Synopsis'''

 {{{
svnadmin create REPOS_PATH
 }}}

'''Description'''

Create a new, empty repository at the path provided. If the provided directory does not exist, it will be created for you. (Remember, svnadmin works only with local paths, not URLs.) __As of Subversion 1.2, `svnadmin creates` new repositories with the FSFS filesystem backend by default.__

While `svnadmin create` will create the base directory for a new repository, it will not create intermediate directories. For example, if you have an empty directory named `/var/svn`, creating `/var/svn/repos` will work, while attempting to create `/var/svn/subdirectory/repos` will fail with an error.

'''Options'''

 * `--bdb-log-keep`
 * `--bdb-txn-nosync`
 * `--config-dir DIR`
 * `--fs-type TYPE`
 * `--pre-1.4-compatible`
 * `--pre-1.5-compatible`

'''Examples'''

Creating a new repository is this easy:

 {{{
$ svnadmin create /var/svn/repos
 }}}

In Subversion 1.0, a Berkeley DB repository is always created. In Subversion 1.1, a Berkeley DB repository is the default repository type, but an FSFS repository can be created using the `--fs-type` option:

 {{{
$ svnadmin create /var/svn/repos --fs-type fsfs
 }}}

==== svnadmin deltify ====

'''Name'''

`svnadmin deltify` — Deltify changed paths in a revision range.

'''Synopsis'''

 {{{
svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH
 }}}

'''Description'''

`svnadmin deltify` exists in current versions of Subversion only for historical reasons. This command is deprecated and no longer needed.

It dates from a time when Subversion offered administrators greater control over compression strategies in the repository. This turned out to be a lot of complexity for very little gain, and this “feature” was deprecated.

'''Options'''

 * `--quiet (-q)`
 * `--revision (-r) REV`

==== svnadmin dump ====

'''Name'''

`svnadmin dump` — Dump the contents of the filesystem to stdout.

'''Synopsis'''

 {{{
svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]
 }}}

'''Description'''

Dump the contents of the filesystem to stdout in a “dump file” ''portable'' format, sending feedback to stderr. Dump revisions `LOWER` rev through `UPPER` rev. If no revisions are given, dump all revision trees. If only `LOWER` is given, dump that one revision tree. See the section called “Migrating Repository Data Elsewhere” for a practical use.

__By default, the Subversion ''dump stream'' contains a single revision (the first revision in the requested revision range) in which every file and directory in the repository in that revision is presented as though that ''whole tree was added at once'', followed by other revisions (the remainder of the revisions in the requested range), which contain only the files and directories that were modified in those revisions. '''For a modified file, the complete full-text representation of its contents, as well as all of its properties, are presented in the dump file; for a directory, all of its properties are presented.'''__

Two useful options modify the dump file generator's behavior. The first is the `--incremental` option, which simply causes that first revision in the dump stream to contain only the files and directories modified in that revision, instead of being presented as the addition of a new tree, and in exactly the same way that every other revision in the dump file is presented. __This is useful for generating a relatively small dump file to be loaded into another repository that already has the files and directories that exist in the original repository. '''(針對 "first revision" 而言, 後續 Modified Revisions 還是採用 Full-Text Representation; "incremental" 這個名稱會讓人誤以 Revisions 會有類似下面 `--deltas` 的效果)'''__

__The second useful option is `--deltas`. This option causes `svnadmin dump` to, instead of emitting full-text representations of file contents and property lists, emit only deltas of those items against their previous versions. This reduces (in some cases, drastically(大幅度地)) the size of the dump file that `svnadmin dump` creates. There are, however, disadvantages to using this option—deltified dump files are more CPU-intensive to create, '''cannot be operated on by `svndumpfilter`,''' and tend not to compress as well as their nondeltified counterparts when using third-party tools such as `gzip` and `bzip2`.__

'''Options'''

 * `--deltas`
 * `--incremental`
 * `--quiet (-q)`
 * `--revision (-r) REV`

'''Examples'''

Dump your whole repository:

 {{{
$ svnadmin dump /var/svn/repos > full.dump
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
…
 }}}

Incrementally dump a single transaction from your repository:

 {{{
$ svnadmin dump /var/svn/repos -r 21 --incremental > incr.dump
* Dumped revision 21.
 }}}

==== svnadmin help ====

'''Name'''

`svnadmin help` — Help!

'''Synopsis'''

 {{{
svnadmin help [SUBCOMMAND...]
 }}}

'''Description'''

This subcommand is useful when you're trapped(被困的) on a desert island(荒島) with neither a Net connection nor a copy of this book.

'''Alternate names'''

 * `?`
 * `h`

==== svnadmin hotcopy ====

'''Name'''

`svnadmin hotcopy` — Make a hot copy of a repository.

'''Synopsis'''

 {{{
svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH
 }}}

'''Description'''

This subcommand makes a full “hot” backup of your repository, including all hooks, configuration files, and, of course, database files. If you pass the `--clean-logs` option, `svnadmin` will perform a hot copy of your repository, and then remove unused Berkeley DB logs from the original repository. You can run this command at any time and make a safe copy of the repository, regardless of whether other processes are using the repository.

'''Options'''

 * `--clean-logs`

Warning: As described in the section called “Berkeley DB”, __hot-copied Berkeley DB repositories are not portable across operating systems, nor will they work on machines with a different “endianness” than the machine where they were created.__

==== svnadmin list-dblogs ====

:::

==== svnadmin load ====

'''Name'''

`svnadmin load` — Read a repository dump stream from stdin.

'''Synopsis'''

 {{{
svnadmin load REPOS_PATH
 }}}

'''Description'''

__Read a repository dump stream from stdin, ''committing new revisions'' into the repository's filesystem.__ Send progress feedback to stdout.

'''Options'''

 * `--force-uuid`
 * `--ignore-uuid`
 * `--parent-dir`
 * `--quiet (-q)`
 * `--use-post-commit-hook`
 * `--use-pre-commit-hook`

'''Examples'''

This shows the beginning of loading a repository from a backup file (made, of course, with `svnadmin dump`):

 {{{
$ svnadmin load /var/svn/restored < repos-backup
<<< Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
 }}}

Or if you want to load into a subdirectory:

 {{{
$ svnadmin load --parent-dir new/subdir/for/project \
                /var/svn/restored < repos-backup
<<< Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
 }}}

==== svnadmin lslocks ====

:::

==== svnadmin recover ====

'''Name'''

`svnadmin recover` — Bring a repository database back into a consistent state (applies only to repositories using the bdb backend). In addition, if `repos/conf/passwd` does not exist, it will create a default passwordfile.

'''Synopsis'''

 {{{
svnadmin recover REPOS_PATH
 }}}

'''Description'''

Run this command if you get an error indicating that your repository needs to be recovered.

'''Options'''

 * `--wait`

'''Examples'''

Recover a hung repository:

 {{{
$ svnadmin recover /var/svn/repos/ 
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
 }}}

Recovering the database requires an exclusive lock on the repository. (This is a “database lock”; see the sidebar The Three Meanings of “Lock”.) If another process is accessing the repository, then `svnadmin recover` will error:

 {{{
$ svnadmin recover /var/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?

$
 }}}

The `--wait` option, however, will cause `svnadmin recover` to wait indefinitely for other processes to disconnect:

 {{{
$ svnadmin recover /var/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by…

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
 }}}

==== svnadmin rmlocks ====

:::

==== svnadmin setlog ====

'''Name'''

`svnadmin setlog` — Set the log message on a revision.

'''Synopsis'''

 {{{
svnadmin setlog REPOS_PATH -r REVISION FILE
 }}}

'''Description'''

Set the log message on revision `REVISION` to the contents of `FILE`.

This is similar to using `svn propset` with the `--revprop` option to set the `svn:log` property on a revision, except that you can also use the option `--bypass-hooks` to avoid running any `pre-` or `post-commit` hooks, which is useful if the modification of revision properties has not been enabled in the `pre-revprop-change` hook.[?]

__Warning: Revision properties are not under version control, so this command will permanently overwrite the previous log message.__

'''Options'''

 * `--bypass-hooks`
 * `--revision (-r) REV`

'''Examples'''

Set the log message for revision 19 to the contents of the file `msg`:

 {{{
$ svnadmin setlog /var/svn/repos/ -r 19 msg
 }}}

==== svnadmin setrevprop ====

'''Name'''

`svnadmin setrevprop` — Set a property on a revision.

'''Synopsis'''

 {{{
svnadmin setrevprop REPOS_PATH -r REVISION NAME FILE
 }}}

'''Description'''

Set the property `NAME` on revision `REVISION` to the contents of `FILE`. Use `--use-pre-revprop-change-hook` or `--use-post-revprop-change-hook` to trigger the revision property-related hooks (e.g., if you want an email notification sent from your `post-revprop-change-hook`).

'''Options'''

 * `--revision (-r) ARG`
 * `--use-post-revprop-change-hook`
 * `--use-pre-revprop-change-hook`

'''Examples'''

The following sets the revision property `repository-photo` to the contents of the file `sandwich.png`:

 {{{
$svnadmin setrevprop /var/svn/repos -r 0 repository-photo sandwich.png
 }}}

As you can see, `svnadmin setrevprop` has no output upon success.

==== svnadmin setuuid ====

'''Name'''

`svnadmin setuuid` — Reset the repository UUID.

'''Synopsis'''

 {{{
svnadmin setuuid REPOS_PATH [NEW_UUID]
 }}}

'''Description'''

Reset the repository UUID for the repository located at `REPOS_PATH`. If `NEW_UUID` is provided, use that as the new repository UUID; otherwise, generate a brand-new UUID for the repository.

'''Options'''

None

'''Examples'''

If you've svnsynced `/var/svn/repos` to `/var/svn/repos-new` and intend to use `repos-new` as your canonical repository, you may want to change the UUID for `repos-new` to the UUID of `repos` so that your users don't have to check out a new working copy to accommodate the change:

 {{{
$ svnadmin setuuid /var/svn/repos-new 2109a8dd-854f-0410-ad31-d604008985ab
 }}}

As you can see, `svnadmin setuuid` has no output upon success.

==== svnadmin upgrade ====

'''Name'''

`svnadmin upgrade` — Upgrade a repository to the latest supported schema version.

'''Synopsis'''

 {{{
svnadmin upgrade REPOS_PATH
 }}}

'''Description'''

Upgrade the repository located at `REPOS_PATH` to the latest supported schema version.

This functionality is provided as a convenience for repository administrators who wish to make use of new Subversion functionality without having to undertake(承擔) a potentially costly full repository dump and load operation. As such, the upgrade performs only the minimum amount of work needed to accomplish this while still maintaining the integrity of the repository. __While a dump and subsequent load guarantee the most optimized repository state, `svnadmin upgrade` does not. (還是乖乖用 `svnadmin dump` 加上 `svnadmin load` 好了...)__

Warning: You should always back up your repository before upgrading.

'''Options'''

None

'''Examples'''

Upgrade the repository at path `/var/repos/svn`:

 {{{
$ svnadmin upgrade /var/repos/svn
Repository lock acquired.
Please wait; upgrading the repository may take some time...

Upgrade completed.
 }}}

==== svnadmin verify ====

'''Name'''

`svnadmin verify` — Verify the data stored in the repository.

'''Synopsis'''

 {{{
svnadmin verify REPOS_PATH
 }}}

'''Description'''

__Run this command if you wish to verify the integrity of your repository. This basically iterates through all revisions in the repository by internally dumping all revisions and discarding the output—'''it's a good idea to run this on a regular basis to guard against latent(潛在的) hard disk failures and “[[http://en.wikipedia.org/wiki/Bitrot|bitrot]]. (位元衰減)”''' If this command fails—which it will do at the first sign of a problem—that means your repository has at least one corrupted revision, and you should restore the corrupted revision from a backup (you did make a backup, didn't you? 如果只修復特定 Revision?).__

'''Options'''

 * `--quiet (-q)`
 * `--revision (-r) ARG`

'''Examples'''

Verify a hung repository:

 {{{
$ svnadmin verify /var/svn/repos/ 
* Verified revision 1729.
 }}}

= Appendix C. WebDAV and Autoversioning =

__WebDAV is an extension to HTTP, and it is growing more and more popular as a standard for ''file sharing''. Today's operating systems are becoming extremely web-aware, and many now have built-in support for ''mounting'' “shares” exported by WebDAV servers. (可以用來實作 file server, 也可以用來取代 FTP [...])__

If you use Apache as your Subversion network server, to some extent(在某種程度上) you are also running a WebDAV server. This appendix gives some background on the nature of this protocol, how Subversion uses it, and how well Subversion interoperates with other software that is ''WebDAV-aware''.

== What Is WebDAV? ==

__DAV stands for “Distributed Authoring and Versioning.” RFC 2518 defines a set of concepts and accompanying(伴隨的) extension methods to HTTP 1.1 that make the Web a more universal(通用的) read/write medium. '''The basic idea is that a WebDAV-compliant web server can act like a ''generic file server''; clients can “mount” shared folders over HTTP that behave much like other network filesystems (such as NFS or SMB).'''__

__The tragedy(不幸), though, is that despite the acronym(字首縮寫字), the RFC specification doesn't actually describe any sort of version control. '''Basic WebDAV clients and servers assume that ''only one version'' of each file or directory exists, and that it can be ''repeatedly overwritten''.'''__

__Because RFC 2518 left out versioning concepts, another committee(委員) was left with the responsibility of writing RFC 3253 a few years later. '''The new RFC adds versioning concepts to WebDAV, placing the “V” back in “DAV”—hence the term “DeltaV.” WebDAV/DeltaV clients and servers are often called just “DeltaV” programs, since DeltaV implies the existence of basic WebDAV.'''__

The original WebDAV standard has been widely successful. Every modern computer operating system has a general WebDAV client built in (details to follow), and a number of popular standalone applications are also able to speak WebDAV—Microsoft Office, Dreamweaver, and Photoshop, to name a few. __On the server end, Apache HTTP Server has been able to provide WebDAV services since 1998 and is considered the de facto open source standard. Several other commercial WebDAV servers are available, including Microsoft's own IIS.__

DeltaV, unfortunately, has not been so successful. It's very difficult to find any DeltaV clients or servers. The few that do exist are relatively unknown commercial products, and thus it's very difficult to test interoperability. __It's not entirely clear as to why DeltaV has remained stagnant(停滯的). Some opine(認爲) that the specification is just too complex. Others argue that while WebDAV's features have mass appeal (even the least technical users appreciate network file sharing), its version control features just aren't interesting or necessary for most users. '''Finally, some believe that DeltaV remains unpopular because there's still no open source server product that implements it well. (沒有 server, 哪來的 client!!)'''__

__When Subversion was still in its design phase, it seemed like a great idea to use Apache as a network server. It already had a module to provide WebDAV services. DeltaV was a relatively new specification. The hope was that the Subversion server module (`mod_dav_svn`) would eventually evolve into an open source DeltaV reference implementation. '''Unfortunately, DeltaV has a very specific versioning model that doesn't quite line up with Subversion's model. Some concepts were mappable; others were not.'''__

What does this mean, then?

First, the Subversion client is not a fully implemented DeltaV client. It needs certain types of things from the server that DeltaV itself cannot provide, and thus is largely dependent on a number of Subversion-specific HTTP REPORT requests that only `mod_dav_svn` understands.

Second, `mod_dav_svn` is not a fully realized DeltaV server. Many portions of the DeltaV specification were irrelevant to Subversion, and thus were left unimplemented.

There is still some debate(爭論) in the developer community as to whether or not it's worthwhile to remedy(補救) either of these situations. __It's fairly unrealistic to change Subversion's design to match DeltaV, so there's probably no way the client can ever learn to get everything it needs from a general DeltaV server. On the other hand, `mod_dav_svn` could be further developed to implement all of DeltaV, but it's hard to find motivation to do so—there are almost no DeltaV clients to interoperate with. (互相矛盾的兩個面向, 唯一的出路就是修改 SVN 的設計, 以符合 DeltaV 的要求 - 如此皆大歡喜?)__

== Autoversioning ==

While the Subversion client is not a full DeltaV client, and the Subversion server is not a full DeltaV server, there's still a glimmer(微光) of WebDAV interoperability to be happy about: autoversioning.

Autoversioning is an optional feature defined in the DeltaV standard. A typical DeltaV server will reject an ignorant(不知情的) WebDAV client attempting to do a PUT to a file that's under version control. To change a version-controlled file, the server expects a series of proper ''versioning requests'': something like `MKACTIVITY`, `CHECKOUT`, `PUT`, `CHECKIN`. __But if the DeltaV server supports autoversioning, write requests from basic WebDAV clients are accepted. The server behaves as though the client had issued the proper series of versioning requests, performing a commit under the hood. In other words, it allows a DeltaV server to interoperate with ordinary WebDAV clients that don't understand versioning.__

__Because so many operating systems already have integrated WebDAV clients, the use case for this feature can be incredibly appealing to administrators working with ''nontechnical users''. Imagine an office of ordinary users running Microsoft Windows or Mac OS. Each user “mounts” the Subversion repository, which appears to be an ordinary network folder. '''They use the shared folder as they always do: open files, edit them, and save them. Meanwhile, the server is automatically versioning everything. Any administrator (or knowledgeable user) can still use a Subversion client to search history and retrieve older versions of data. (如果有檔案遭刪除、衝突要解決時怎麼辦[?])'''__

This scenario isn't fiction(捏造)—it's real and it works, as of Subversion 1.2 and later. To activate autoversioning in `mod_dav_svn`, use the `SVNAutoversioning` directive within the `httpd.conf` `Location` block, like so:

 {{{
<Location /repos>
  DAV svn
  SVNPath /var/svn/repository
  SVNAutoversioning on
</Location>
 }}}

__When Subversion autoversioning is active, write requests from WebDAV clients result in ''automatic commits''. A generic log message is automatically generated and attached to each revision.__

__'''很適合用在辦公室環境, 因為非技術人員通常 "不願去瞭解" 或 "很難去理解" 版控的念... 但不適合用在共同開發的環境下. 因為沒有機會撰寫 comment, 將會使版控的效益或團隊成員間的溝通工作大打折扣, 或許 TortoiseSVN 目前還是非技術人員配合版本控制的最佳途徑. 另外 autorevisioning 或許也可以拿來補足不支援 attachment revision 的 Wiki, 或者做為線上編輯時選取外部檔案的來源 (雖然使用者不想做版控, 但至少有機會求回誤刪或改錯的檔案) [...] @2008/12/14'''__

__Before activating this feature, however, understand what you're getting into. '''WebDAV clients tend to do many write requests, resulting in a huge number of automatically committed revisions.''' For example, when saving data, many clients will do a PUT of a 0-byte file (as a way of reserving a name; 這種狀況應該只會出現在新建立檔案時?) followed by another PUT with the real file data. The single file-write results in two separate commits. '''Also consider that many applications auto-save every few minutes, resulting in even more commits. (對於只儲存 "最後一個版本" 的 auto-save, 搭配 autorevisioning 時可以延伸它的效益, 為編輯中的資料提供多層次的安全網!!)'''__

If you have a `post-commit` hook program that sends email, you may want to disable email generation either altogether or on certain sections of the repository; it depends on whether you think the influx(湧入) of emails will still prove to be valuable notifications or not. __Also, a smart `post-commit` hook program can distinguish between a transaction created via autoversioning and one created through a normal Subversion commit operation. The trick is to look for a revision property named `svn:autoversioned`. If present, the commit was made by a generic WebDAV client.__

Another feature that may be a useful complement for Subversion's autoversioning comes from Apache's `mod_mime` module. __If a WebDAV client adds a new file to the repository, there's no opportunity for the user to set the the `svn:mime-type` property. This might cause the file to appear as a ''generic icon'' when viewed within a WebDAV shared folder, not having an association with any application.__ One remedy(補救方法) is to have a sysadmin (or other Subversion-knowledgeable person) check out a working copy and manually set the `svn:mime-type` property on necessary files. But there's potentially no end to such cleanup tasks. Instead, you can use the `ModMimeUsePathInfo` directive in your Subversion `<Location>` block:

 {{{
<Location /repos>
  DAV svn
  SVNPath /var/svn/repository
  SVNAutoversioning on

  ModMimeUsePathInfo on
</Location>
 }}}

__This directive allows `mod_mime` to attempt automatic deduction(推論) of the MIME type on new files that enter the repository via autoversioning. The module looks at the file's named extension and possibly the contents as well; if the file matches some common patterns, the file's `svn:mime-type` property will be set automatically.__

== Client Interoperability ==

__All WebDAV clients fall into one of three categories—standalone applications, file-explorer extensions, or filesystem implementations. These categories broadly define the types of WebDAV functionality available to users.__ Table C.1, “Common WebDAV clients” gives our categorization as well as a quick description of some common pieces of WebDAV-enabled software. You can find more details about these software offerings, as well as their general category, in the sections that follow.

Table C.1. Common WebDAV clients

|| Software || Type || Windows || Mac || Linux || Description ||
|| Adobe Photoshop || Standalone WebDAV application || X || || || Image editing software, allowing direct opening from, and writing to, WebDAV URLs ||
|| cadaver || Standalone WebDAV application || || X || X || Commandline WebDAV client supporting file transfer, tree, and locking operations ||
|| DAV Explorer || Standalone WebDAV application || X || X || X || Java GUI tool for exploring WebDAV shares ||
|| Adobe Dreamweaver || Standalone WebDAV application || X || || || Web production software able to directly read from and write to Web-DAV URLs ||
|| Microsoft Office || Standalone WebDAV application || X || || || Office productivity suite with several components able to directly read from and write to Web-DAV URLs ||
|| Microsoft Web Folders || File-explorer WebDAV extension || X || || || GUI file explorer program able to perform ''tree operations'' on a WebDAV share ||
|| GNOME Nautilus || File-explorer WebDAV extension || || || X || GUI file explorer able to perform tree operations on a WebDAV share ||
|| KDE Konqueror || File-explorer WebDAV extension || || || X || GUI file explorer able to perform tree operations on a WebDAV share ||
|| Mac OS X WebDAV || filesystem implementation || || X || || Operating system that has built-in support for mounting WebDAV shares. ||
|| Novell Net-Drive || WebDAV filesystem implementation || X || || || Drivemapping program for assigning Windows drive letters to a mounted remote Web-DAV share ||
|| SRT Web-Drive || WebDAV filesystem implementation || X || || || File transfer software, which, among other things, allows the assignment of Windows drive letters to a mounted remote Web-DAV share ||
|| davfs2 || WebDAV filesystem implementation || || || X || Linux filesystem driver that allows you to mount a WebDAV share ||

=== Standalone WebDAV Applications ===

A WebDAV application is a program that speaks WebDAV protocols with a WebDAV server. We'll cover some of the most popular programs with this kind of WebDAV support.

==== Microsoft Office, Dreamweaver, Photoshop ====

On Windows, several well-known applications contain integrated WebDAV client functionality, such as Microsoft's Office (WebDAV support was removed from Microsoft Access for some reason, but it exists in the rest of the Office suite.), Adobe's Photoshop and Dreamweaver programs. They're able to directly open and save to URLs, and tend to make heavy use of WebDAV locks when editing a file. (Gedit 裡的 File > Open Location... 該不會可以直接操作 WebDAV 吧[?])

Note that while many of these programs also exist for Mac OS X, they do not appear to support WebDAV directly on that platform. In fact, on Mac OS X, the File > Open dialog box doesn't allow one to type a path or URL at all. __It's likely that the WebDAV features were deliberately(故意地) left out of Macintosh versions of these programs, since OS X already provides such excellent low-level filesystem support for WebDAV.__

==== cadaver, DAV Explorer ====

__`cadaver` is a bare-bones Unix command-line program for browsing and changing WebDAV shares.__ Like the Subversion client, it uses the `neon` HTTP library—not surprisingly, since both `neon` and `cadaver` are written by the same author. `cadaver` is free software (GPL license) and is available at http://www.webdav.org/cadaver/.

__'''Using `cadaver` is similar to using a command-line FTP program, and thus it's extremely useful for basic ''WebDAV debugging''.''' It can be used to upload or download files in a pinch(在緊要關頭), to examine properties, and to copy, move, lock, or unlock files:__

 {{{
$ cadaver http://host/repos
dav:/repos/> ls
Listing collection `/repos/': succeeded.
Coll: > foobar                              0 May 10 16:19
      > playwright.el                    2864 May 4 16:18
      > proofbypoem.txt                  1461 May 5 15:09
      > westcoast.jpg                   66737 May 5 15:09

dav:/repos/> put README
Uploading README to `/repos/README':
Progress: [=============================>] 100.0% of 357 bytes succeeded.

dav:/repos/> get proofbypoem.txt
Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:
Progress: [=============================>] 100.0% of 1461 bytes succeeded.
 }}}

DAV Explorer is another standalone WebDAV client, written in Java. It's under a free Apache-like license and is available at http://www.ics.uci.edu/~webdav/. __It does everything `cadaver` does, but has the advantages of being portable and being a more user-friendly GUI application. It's also one of the first clients to support the new WebDAV Access Control Protocol (RFC 3744).__

Of course, DAV Explorer's ACL support is useless in this case, since `mod_dav_svn` doesn't support it. The fact that both `cadaver` and DAV Explorer support some limited DeltaV commands isn't particularly useful either, since they don't allow `MKACTIVITY` requests. But it's not relevant anyway; __we're assuming all of these clients are operating against an ''autoversioning repository''.__

=== File-Explorer WebDAV Extensions ===

__Some popular file explorer GUI programs support WebDAV extensions that allow a user to browse a DAV share as though it was just another directory on the local computer, and to perform basic tree editing operations on the items in that share. For example, Windows Explorer is able to browse a WebDAV server as a “network place.” '''Users can drag files to and from the desktop, or can rename, copy, or delete files in the usual way. But because it's only a feature of the file explorer, the DAV share isn't visible to ordinary applications. All DAV interaction must happen through the explorer interface. (操作起來像是 FTP 一樣; 如果要檢視或修改檔案內容, 就必須要 "下載" 之後才能檢視, 修改後再 "上傳"...)'''__

==== Microsoft Web Folders ====

__Microsoft was one of the original backers(支持者) of the WebDAV specification, and first started shipping a client in Windows 98, which was known as ''Web Folders''. This client was also shipped in Windows NT 4.0 and Windows 2000.__

The original Web Folders client was an extension to Explorer, the main GUI program used to browse filesystems. It works well enough. In Windows 98, the feature might need to be explicitly installed if Web Folders aren't already visible inside My Computer. In Windows 2000, simply add a new “network place,” enter the URL, and the WebDAV share will pop up for browsing.

__With the release of Windows XP, Microsoft started shipping a new implementation of Web Folders, known as the ''WebDAV Mini-Redirector''. '''The new implementation is a ''filesystem-level client'', allowing WebDAV shares to be mounted as drive letters. (透過 My Computer > Map Network Drive 的功能. 注意不能輸入埠號, 否則連帳號/密碼都不會問)'''__ Unfortunately, this implementation is incredibly(難以置信地) buggy. The client usually tries to convert HTTP URLs (`http://host/repos`) into UNC share notation (`\\host\repos`); it also often tries to use Windows Domain authentication to respond to basic-auth HTTP challenges, sending usernames as `HOST\username`. These interoperability problems are severe(嚴重的) and are documented in numerous places around the Web, to the frustration(挫折) of many users. Even Greg Stein, the original author of Apache's WebDAV module, bluntly(坦率地) states that XP Web Folders simply can't operate against an Apache server.

Windows Vista's initial implementation of Web Folders seems to be almost the same as XP's, so it has the same sort of problems. With luck, Microsoft will remedy(補救) these issues in a Vista Service Pack. (問題是 XP 的使用者仍然佔多數)

However, there seem to be workarounds for both XP and Vista that allow Web Folders to work against Apache. Users have mostly reported success with these techniques, so we'll relay them here.

__On Windows XP, you have two options. First, search Microsoft's web site for update [[http://www.microsoft.com/downloads/details.aspx?FamilyID=17c36612-632e-4c04-9382-987622ed1d64&DisplayLang=en|KB907306]], “Software Update for Web Folders.” This may fix all your problems. If it doesn't, it seems that the original pre-XP Web Folders implementation is still buried(埋入) within the system. You can unearth(發現) it by going to Network Places and adding a new network place. When prompted, enter the URL of the repository, but include a port number in the URL. '''For example, you should enter http://host/repos as http://host:80/repos instead. (@2008/12/15 在一台 Windows XP SP2 上裝設 KB907306 之後, 發現沒有任何改善, 但加了埠號之後就可以了!!)''' Respond to any authentication prompts with your Subversion credentials.__

On Windows Vista, the same KB90730 update may clear everything up. But there may still be other issues. Some users have reported that Vista considers all `http://` connections insecure, and thus will always fail any authentication challenges from Apache unless the connection happens over `https://`. If you're unable to connect to the Subversion repository via SSL, you can tweak the system registry to turn off this behavior. Just change the value of the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Para meters\BasicAuthLevel` key from `1` to `2`. A final warning: be sure to set up the Web Folder to point to the repository's root directory (/), rather than some subdirectory such as `/trunk`. Vista Web Folders seems to work only against repository roots.

__In general, while these workarounds may function for you, you might get a better overall experience using a third-party WebDAV client such as WebDrive or NetDrive.__

==== Nautilus, Konqueror ====

Nautilus is the official file manager/browser for the GNOME desktop (http://www.gnome.org), and Konqueror is the manager/browser for the KDE desktop (http:// www.kde.org). Both of these applications have an explorer-level WebDAV client built in, and they operate just fine against an autoversioning repository.

In GNOME's Nautilus, select the File > Open location menu item and enter the URL in the dialog box presented. The repository should then be displayed like any other filesystem.

In KDE's Konqueror, you need to use the `webdav://` scheme when entering the URL in the location bar. If you enter an `http://` URL, Konqueror will behave like an ordinary web browser. You'll likely see the generic HTML directory listing produced by `mod_dav_svn`. When you enter `webdav://host/repos` instead of `http://host/repos`, Konqueror becomes a WebDAV client and displays the repository as a filesystem.

=== WebDAV Filesystem Implementation ===

__The WebDAV filesystem implementation is arguably(可論證的) the best sort of WebDAV client. It's implemented as a low-level filesystem module, typically within the operating system's kernel. '''This means that the DAV share is ''mounted like any other network filesystem'', similar to mounting an NFS share on Unix or attaching an SMB share as a drive letter in Windows. As a result, this sort of client provides completely transparent read/write WebDAV access to all programs. Applications aren't even aware that WebDAV requests are happening.'''__

==== WebDrive, NetDrive ====

Both WebDrive and NetDrive are excellent commercial products that allow a WebDAV share to be attached as drive letters in Windows. As a result, you can operate on the contents of these WebDAV-backed pseudodrives as easily as you can against real local hard drives, and in the same ways. You can purchase WebDrive from South River Technologies (http://www.southrivertech.com). Novell's NetDrive is freely available online, but requires users to have a NetWare license.

==== Mac OS X ====

Apple's OS X operating system has an integrated filesystem-level WebDAV client. From the Finder, select the Go > Connect to Server menu item. Enter a WebDAV URL, and it appears as a disk on the desktop, just like any other mounted volume. You can also mount a WebDAV share from the Darwin terminal by using the webdav filesystem type with the mount command:

 {{{
$ mount -t webdav http://svn.example.com/repos/project /some/mountpoint
$
 }}}

Note that if your mod_dav_svn is older than version 1.2, OS X will refuse to mount the share as read/write; it will appear as read-only. This is because OS X insists on locking support for read/write shares, and the ability to lock files first appeared in Subversion 1.2.

Also, OS X's WebDAV client can sometimes be overly sensitive to HTTP redirects. If OS X is unable to mount the repository at all, you may need to enable the `BrowserMatch` directive in the Apache server's `httpd.conf`:

 {{{
BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
 }}}

==== Linux davfs2 ====

Linux `davfs2` is a filesystem module for the Linux kernel, whose development is organized at http://dav.sourceforge.net/. Once you install `davfs2`, you can mount a WebDAV network share using the usual Linux `mount` command:

 {{{
$ mount.davfs http://host/repos /mnt/dav <-- 會詢問帳號/密碼
 }}}










= Version Control with Subversion 1.4 =
http://svnbook.red-bean.com/en/1.4/index.html
[[TableOfContents]]

== Foreword ==

[~~~]

== Chapter 1. Fundamental Concepts ==

This chapter is a short, casual introduction to Subversion. If you're new to version control, this chapter is definitely for you. We begin with a discussion of general version control concepts, work our way into the specific ideas behind Subversion, and show some simple examples of Subversion in use.

__Even though the examples in this chapter show people sharing collections of program source code, '''keep in mind that Subversion can manage any sort of file collection—it's not limited to helping computer programmers.'''__

=== The Repository ===

__'''Subversion is a ''centralized'' system for sharing information. At its core is a ''repository'', which is a central store of data.''' The repository stores information in the form of a ''filesystem tree''—a typical hierarchy of files and directories. Any number of clients connect to the repository, and then read or write to these files. By writing data, a client makes the information available to others; by reading data, the client receives information from others.__

Figure 1.1, “A typical client/server system” illustrates this. [[BR]] attachment:ch02dia1.png

__So why is this interesting? So far, this sounds like the definition of a typical file server. And indeed, the repository is a kind of ''file server'', but it's not your usual breed(類型). '''What makes the Subversion repository special is that it remembers every change ever written to it: every change to every file, and even changes to the ''directory tree itself'', such as the addition, deletion, and rearrangement of files and directories.'''__

When a client reads data from the repository, it normally sees only the latest version of the filesystem tree. But the client also has the ability to view previous states of the filesystem. For example, a client can ask historical questions like, “What did this directory contain last Wednesday?” or “Who was the last person to change this file, and what changes did he make?” __These are the sorts of questions that are at the heart of any version control system: '''systems that are designed to ''track changes to data over time''.'''__

=== Versioning Models ===

The core mission of a version control system is to enable collaborative editing and sharing of data. But different systems use different strategies to achieve this. It's important to understand these different strategies for a couple of reasons. First, it will help you compare and contrast(對照) existing version control systems, in case you encounter other systems similar to Subversion. __Beyond that, it will also help you make more effective use of Subversion, since Subversion itself supports a couple of different ways of working. __

==== The Problem of File-Sharing ====

All version control systems have to solve the same fundamental problem: how will the system allow users to share information, but prevent them from accidentally stepping on each other's feet? It's all too easy for users to accidentally overwrite each other's changes in the repository.

Consider the scenario shown in Figure 1.2, “The problem to avoid”. Suppose we have two co-workers, Harry and Sally. They each decide to edit the same repository file at the same time. If Harry saves his changes to the repository first, then it's possible that (a few moments later) Sally could accidentally overwrite them with her own new version of the file. __While Harry's version of the file won't be lost forever (because the system remembers every change), any changes Harry made won't be present in Sally's newer version of the file, because she never saw Harry's changes to begin with. '''Harry's work is still effectively lost—or at least missing from the latest version of the file—and probably by accident.''' This is definitely a situation we want to avoid!__

Figure 1.2. The problem to avoid [[BR]] attachment:ch02dia2.png

==== The Lock-Modify-Unlock Solution ====

__Many version control systems use a ''lock-modify-unlock'' model to address the problem of many authors clobbering(使挫敗) each other's work. In this model, the repository allows only one person to change a file at a time. This exclusivity(獨佔) policy is managed using ''locks''.__ Harry must “lock” a file before he can begin making changes to it. If Harry has locked a file, then Sally cannot also lock it, and therefore cannot make any changes to that file. (問題是 Sally 怎麼知道檔案被 lock 了? 有辦法強制 client 要修改就要取得 lock 嗎[?]) All she can do is read the file, and wait for Harry to finish his changes and release his lock. After Harry unlocks the file, Sally can take her turn(輪流) by locking and editing the file. Figure 1.3, “The lock-modify-unlock solution” demonstrates this simple solution.

Figure 1.3. The lock-modify-unlock solution [[BR]] attachment:ch02dia3.png

The problem with the lock-modify-unlock model is that it's a bit restrictive(受限的), and often becomes a roadblock(障礙) for users:

 * Locking may cause administrative problems. Sometimes Harry will lock a file and then forget about it. Meanwhile(在這期間), because Sally is still waiting to edit the file, her hands are tied. And then Harry goes on vacation. __Now Sally has to get an administrator to release Harry's lock. The situation ends up causing a lot of unnecessary delay and wasted time. (設計成 zappy 一樣可以強制取得鎖定就好了 ^^)__
 * __Locking may cause unnecessary ''serialization''(沒有辦法同時做事情而言).__ What if Harry is editing the beginning of a text file, and Sally simply wants to edit the end of the same file? These changes don't overlap at all. They could easily edit the file simultaneously, and no great harm would come, assuming the changes were properly merged together. There's no need for them to take turns(輪流) in this situation.
 * __Locking may create a false sense(錯覺) of security. Suppose Harry locks and edits file A, while Sally simultaneously locks and edits file B. But what if A and B depend on one another, and the changes made to each are ''semantically incompatible''? Suddenly A and B don't work together anymore. The locking system was powerless to prevent the problem—yet it somehow provided a false sense of security. '''It's easy for Harry and Sally to imagine that by locking files, each is beginning a safe, insulated(隔離的) task, and thus not bother(操心) discussing their incompatible changes early on. Locking often becomes a substitute(取代) for real communication. (這有點像是 XP 裡的 user story, 如果寫得太細時, 就會產生消極溝通的心理...)'''__

==== The Copy-Modify-Merge Solution ====

__Subversion, CVS, and many other version control systems use a ''copy-modify-merge'' model as an alternative to locking. (但 lock-modify-unlock model 也不是那麼一無是處, 有些情況下還是適用, 因此 Subversion 還是支援 locking...) In this model, each user's client contacts the project repository and creates a ''personal working copy''—a ''local reflection'' of the repository's files and directories. Users then work simultaneously and independently, modifying their ''private copies''. '''Finally, the private copies are ''merged together'' into a new, final version. The version control system often assists with the merging, but ultimately a human being is responsible for making it happen correctly. (可能有 semantic conflicts, 所以人為的介入是少不了的)'''__

Here's an example. Say that Harry and Sally each create working copies of the same project, copied from the repository. They work concurrently, and make changes to the same file A within their copies. Sally saves her changes to the repository first. __When Harry attempts to save his changes later, the repository informs him that his file A is ''out-of-date''. '''In other words, that file A in the repository has somehow changed since he last copied it. (據以編輯的版本已經遭到異動)''' So Harry asks his client to merge any new changes from the repository into his working copy of file A. Chances are that Sally's changes don't overlap with his own; so once he has both sets of changes integrated, he saves his working copy back to the repository.__ Figure 1.4, “The copy-modify-merge solution” and Figure 1.5, “The copy-modify-merge solution (continued)” show this process.

Figure 1.4. The copy-modify-merge solution [[BR]] attachment:ch02dia4.png

Figure 1.5. The copy-modify-merge solution (continued) [[BR]] attachment:ch02dia5.png

__But what if Sally's changes do overlap with Harry's changes? What then? This situation is called a ''conflict'', and it's usually not much of a problem. When Harry asks his client to merge the latest repository changes into his working copy, his copy of file A is somehow flagged as being in a state of ''conflict'': he'll be able to see both sets of conflicting changes, and ''manually'' choose between them. '''Note that software can't automatically resolve conflicts; only humans are capable of understanding and making the necessary intelligent choices.''' Once Harry has manually resolved the overlapping changes—perhaps after a discussion with Sally—he can safely save the merged file back to the repository.__

__The copy-modify-merge model may sound a bit chaotic(混亂的), but in practice, it runs extremely smoothly. Users can work in parallel, never waiting for one another. When they work on the same files, it turns out that most of their concurrent changes don't overlap at all; conflicts are infrequent. '''And the amount of time it takes to resolve conflicts is usually far less than the time lost by a locking system.'''__

__'''In the end, it all comes down to one critical factor(關鍵因素): ''user communication''. When users communicate poorly, both ''syntactic(語法的) and semantic conflicts'' increase. No system can force users to communicate perfectly, and no system can detect semantic conflicts.''' So there's no point in being lulled(哄騙) into a false sense of security that a locking system will somehow prevent conflicts; in practice, locking seems to inhibit(抑制) productivity more than anything else.__

==== When Locking is Necessary ====

While the lock-modify-unlock model is considered generally harmful to collaboration, there are still times when locking is appropriate.

__The copy-modify-merge model is based on the assumption that files are ''contextually mergeable'': that is, that the majority of the files in the repository are ''line-based'' text files (such as program source code). But for files with binary formats, such as artwork(圖片) or sound, it's often impossible to merge conflicting changes. '''In these situations, it really is necessary to users to take strict turns when changing the file. Without serialized access, somebody ends up wasting time on changes that are ultimately discarded. (這意謂著, 儘可能以純文字格式來儲存您的創作, 儘管不太可能同時創作, 至少可以方便比對出版本間的差異...)'''__ (系統可以僅要求時用者要編輯二進位檔時才要取得 lock 嗎? 還是要靠自律[?])

While Subversion is still primarily a copy-modify-merge system, it still recognizes the need to lock an occasional(偶然的) file and thus provide mechanisms for this. This feature is discussed later in this book, in the section called “Locking”.

=== Subversion in Action ===

[~~~]

== Chapter 4. Branching and Merging ==

 ''“君子务本 (It is upon the Trunk that a gentleman works.)” --Confucius''

''Branching'', ''tagging'', and ''merging'' are concepts common to almost all version control systems. If you're not familiar with these ideas, we provide a good introduction in this chapter. If you are familiar, then hopefully you'll find it interesting to see how Subversion implements these ideas.

Branching is a fundamental part of version control. If you're going to allow Subversion to manage your data, then this is a feature you'll eventually come to depend on. This chapter assumes that you're already familiar with Subversion's basic concepts (Chapter 1, Fundamental Concepts).

=== What's a Branch? ===

Suppose it's your job to maintain a document for a division(部門) in your company, a handbook of some sort. One day a different division asks you for the same handbook, but with a few parts “tweaked” for them, since they do things slightly differently.

What do you do in this situation? You do the obvious thing: you make a second copy of your document, and begin maintaining the two copies separately. As each department asks you to make small changes, you incorporate them into one copy or the other.

__You often want to make the same change to both copies. For example, if you discover a typo in the first copy, it's very likely that the same typo exists in the second copy. The two documents are almost the same, '''after all; they only differ in small, specific ways.'''__

__This is the basic concept of a branch—namely, '''a ''line of development'' that exists independently of another line, yet still shares a ''common history'' if you look far enough back in time. A branch always begins life as a ''copy of something'', and moves on from there, generating its own history''' (see Figure 4.1, “Branches of development”).__

Figure 4.1. Branches of development [[BR]] attachment:ch04dia1.png

__Subversion has commands to help you maintain parallel branches of your files and directories. '''It allows you to create branches by copying your data, and remembers that the copies are related to one another. It also helps you ''duplicate changes'' from one branch to another.''' Finally, it can make portions of your working copy reflect different branches, so that you can “mix and match”(混搭) different lines of development in your daily work.__

=== Using Branches ===

At this point, you should understand how each commit creates an entire new filesystem tree (called a “revision”) in the repository. If not, go back and read about revisions in the section called “Revisions”.

For this chapter, we'll go back to the same example from Chapter 1, Fundamental Concepts. Remember that you and your collaborator, Sally, are sharing a repository that contains two projects, “paint” and “calc”. Notice that in Figure 4.2, “Starting repository layout”, however, each project directory now contains subdirectories named `trunk` and `branches`. The reason for this will soon become clear.

Figure 4.2. Starting repository layout [[BR]] attachment:ch04dia2.png

As before, assume that Sally and you both have working copies of the “calc” project. Specifically, you each have a working copy of `/calc/trunk`. __All the files for the project are in this subdirectory rather than in `/calc` itself, because your team has decided that `/calc/trunk` is where the “main line” of development is going to take place. '''(這裡的 "main line" 是人為認定的, 並不是因為它在 trunk, 所以就是 "main line". 包括 trunk 是否就是 always usable, 這些都是 project policy 的議題...)'''__

Let's say that you've been given the task of implementing radical(徹底的) new project feature. It will take a long time to write, and will affect all the files in the project. The problem here is that you don't want to interfere with(妨礙) Sally, who is in the process of fixing small bugs here and there. She's depending on the fact that the latest version of the project (in `/calc/trunk`) is always usable. If you start committing your changes bit-by-bit, you'll surely break things for Sally.

One strategy is to crawl into a hole: you and Sally can stop sharing information for a week or two. That is, start gutting(破壞) and reorganizing all the files in your working copy, but don't commit or update until you're completely finished with the task. There are a number of problems with this, though. First, it's not very safe. Most people like to save their work to the repository frequently, should something bad accidentally happen to their working copy. Second, it's not very flexible. If you do your work on different computers (perhaps you have a working copy of `/calc/trunk` on two different machines), you'll need to manually copy your changes back and forth, or just do all the work on a single computer. __By that same token, it's difficult to share your changes-in-progress with anyone else. '''A common software development “best practice” is to allow your peers to review your work as you go. If nobody sees your intermediate commits, you lose potential ''feedback''. (這就是所謂的 code reviewing)''' Finally, when you're finished with all your changes, you might find it very difficult to re-merge your final work with the rest of the company's main body of code. (即使分出 branch, 最後還是可能產生難以合併的問題)__ Sally (or others) may have made many other changes in the repository that are difficult to incorporate into your working copy—especially if you run `svn update` after weeks of isolation.

__The better solution is to create your own branch (= private branch), or line of development, in the repository. This allows you to save your ''half-broken work'' frequently without interfering with others, yet you can still selectively share information with your collaborators.__ You'll see exactly how this works later on.

==== Creating a Branch ====

Creating a branch is very simple—you make a copy of the project in the repository using the `svn copy` command. Subversion is not only able to copy single files, but whole directories as well. In this case, you want to make a copy of the `/calc/trunk` directory. __Where should the new copy live? Wherever you wish—it's a matter of ''project policy''. (一再強調 project policy 的重要性, 因此撰寫一份這樣的文件是有必要的) Let's say that your team has a policy of creating branches in the `/calc/branches` area of the repository,__ and you want to name your branch `my-calc-branch`. You'll want to create a new directory, `/calc/branches/my-calc-branch`, which begins its life as a copy of `/calc/trunk`.

There are two different ways to make a copy. We'll demonstrate the messy(麻煩的) way first, just to make the concept clear. To begin, check out a working copy of the project's root directory, `/calc`:

 {{{
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
 }}}

Making a copy is now simply a matter of passing two working-copy paths to the `svn copy` command:

 {{{
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
 }}}

In this case, the `svn copy` command recursively copies the `trunk` working directory to a new working directory, `branches/my-calc-branch`. As you can see from the `svn status` command, the new directory is now scheduled for addition to the repository. But also notice the “+” sign next to the letter A. __This indicates that the scheduled addition is a copy of something, not something new. When you commit your changes, Subversion will create `/calc/branches/my-calc-branch` in the repository by copying `/calc/trunk`, rather than resending all of the working copy data over the network:__

 {{{
$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
 }}}

And now here's the easier method of creating a branch, which we should have told you about in the first place: `svn copy` is able to operate directly on two URLs.

 {{{
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
 }}}

From the repository's point of view, there's really no difference between these two methods. Both procedures create a new directory in revision 341, and the new directory is a copy of `/calc/trunk`. This is shown in Figure 4.3, “Repository with new copy”. __Notice that the second method, however, performs an immediate commit in constant time(同時). '''(Subversion does not support copying between different repositories. When using URLs with `svn copy` or `svn move`, you can only copy items within the same repository.)'''__ It's an easier procedure, because it doesn't require you to check out a large portion of the repository. In fact, this technique doesn't even require you to have a working copy at all. This is the way most users create branches.

Figure 4.3. Repository with new copy [[BR]] attachment:ch04dia3.png

==== Cheap Copies ====

__Subversion's repository has a special design. When you copy a directory, you don't need to worry about the repository growing huge—Subversion doesn't actually duplicate any data. Instead, it creates a new directory entry that points to an existing tree. If you're a Unix user, this is the same concept as a ''hard-link''. '''As further changes are made to files and directories beneath the copied directory, Subversion continues to employ this hard-link concept where it can. It only duplicates data when it is necessary to disambiguate(分清楚) different versions of objects.'''__

__This is why you'll often hear Subversion users talk about “cheap copies”. It doesn't matter how large the directory is—it takes a very tiny, constant amount of time to make a copy of it. In fact, this feature is the basis of how commits work in Subversion: '''each revision is a “cheap copy” of the previous revision, with a few items ''lazily'' changed within.'''__ (To read more about this, visit Subversion's website and read about the “bubble up” method in Subversion's design documents.)

__Of course, these internal mechanics of copying and sharing data are hidden from the user, who simply sees copies of trees. The main point here is that copies are cheap, both in time and space. If you create a branch entirely within the repository (by running `svn copy URL1 URL2`), it's a quick, constant-time operation. '''Make branches as often as you want. (為數眾多的 branch 要如何管理? 總該訂出命名慣例吧[?])'''__

==== Working with Your Branch ====

Now that you've created a branch of the project, you can check out a new working copy to start using it:

 {{{
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
 }}}

There's nothing special about this working copy; it simply mirrors a different directory in the repository. When you commit changes, however, Sally won't see them when she updates, because her working copy is of `/calc/trunk`. (Be sure to read the section called “Traversing Branches” later in this chapter: the `svn switch` command is an alternate way of creating a working copy of a branch.)

Let's pretend(假裝) that a week goes by, and the following commits happen:

 * You make a change to `/calc/branches/my-calc-branch/button.c`, which creates revision 342.
 * You make a change to `/calc/branches/my-calc-branch/integer.c`, which creates revision 343.
 * Sally makes a change to `/calc/trunk/integer.c`, which creates revision 344.

There are now two independent lines of development, shown in Figure 4.4, “The branching of one file's history”, happening on `integer.c`.

Figure 4.4. The branching of one file's history [[BR]] attachment:ch04dia4.png

Things get interesting when you look at the history of changes made to your copy of `integer.c`: (注意下面的 "`-v`", 才會顯示出異動的細節, 否則只會印出 comment 而已)

 {{{
$ pwd
/home/user/my-calc-branch

$ svn log -v integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
 }}}

__'''Notice that Subversion is tracing the history of your branch's `integer.c` all the way back through time, even traversing(橫越) the point where it was copied.''' It shows the creation of the branch as an ''event'' in the history, because `integer.c` was ''implicitly'' copied when all of `/calc/trunk/` was copied.__ Now look what happens when Sally runs the same command on her copy of the file:

 {{{
$ pwd
/home/sally/calc

$ svn log -v integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
 }}}

__Sally sees her own revision 344 change, but not the change you made in revision 343. As far as Subversion is concerned, '''these two commits affected different files in different repository locations. However, Subversion does show that the two files share a ''common history''. Before the branch-copy was made in revision 341, they used to be the same file.''' That's why you and Sally both see the changes made in revisions 303 and 98.__

==== The Key Concepts Behind Branches ====

There are two important lessons that you should remember from this section. First, __'''Subversion has no internal concept of a branch—it only knows how to make copies. When you copy a directory, the resulting directory is only a “branch” because you ''attach that meaning'' to it.''' You may think of the directory differently, or treat it differently, but to Subversion it's just an ordinary directory that happens to carry some extra ''historical information''.__ Second, because of this copy mechanism, Subversion's branches exist as normal filesystem directories in the repository. This is different from other version control systems, where branches are typically defined by adding extra-dimensional “labels” to collections of files.

=== Copying Changes Between Branches ===

Now you and Sally are working on parallel branches of the project: you're working on a ''private branch'', and Sally is working on the trunk, or main line of development.

__For projects that have a large number of contributors, it's common for most people to have working copies of the trunk. '''Whenever someone needs to make a ''long-running change'' that is likely to disrupt(破壞) the trunk, a standard procedure is to create a ''private branch'' (屬於 feature branch 的一種, 有別於因不同發行版本而拆出的 release branch) and commit changes there until all the work is complete.'''__

So, the good news is that you and Sally aren't interfering with each other. The bad news is that it's very easy to drift(漂流) too far apart. __Remember that one of the problems with the “crawl into a hole” strategy is that by the time you're finished with your branch, it may be near-impossible to merge your changes back into the trunk without a huge number of conflicts. '''(這個問題跟有沒有拆出 branch 沒有關係, 只要太久沒有 update 或 merge 都會有這個問題...)'''__

__'''Instead, you and Sally might continue to share changes as you work. (這裡的 "share" 應該是具方向性的, 是由 trunk 往 branch 的方向, 持續讓 branch 不要與 trunk 差距太大, 最後才能由 branch 往 trunk 合併; 如果變動幅度很大, 這樣的做法並不可行[...])''' It's up to you to decide which changes are worth sharing; Subversion gives you the ability to ''selectively'' “copy” changes between branches. And when you're completely finished with your branch, your entire set of branch changes can be copied back into the trunk.__

==== Copying Specific Changes ====

In the previous section, we mentioned that both you and Sally made changes to `integer.c` on different branches. If you look at Sally's ''log message'' for revision 344, you can see that she fixed some spelling errors. No doubt, your copy of the same file still has the same spelling errors. It's likely that your future changes to this file will be affecting the same areas that have the spelling errors, so you're in for some potential conflicts when you merge your branch someday. __'''It's better, then, to receive Sally's change now, before you start working too heavily in the ''same places''. (方向上是由 trunk 往 branch; 因此 private branch 的開發者必須持續關注 trunk 的異動, 儘早將異動合併進來. 這也突顯了 "小量異動" 與 log message 的重要性, 也有助於 code review 工作的進行)'''__

It's time to use the `svn merge` command. This command, it turns out, is a very close cousin(近親) to the `svn diff` command (which you read about in Chapter 2, Basic Usage). __Both commands are able to compare any two objects in the repository and describe the ''differences''. (其中 `svn diff` 單純做比對, 但 `svn merge` 則直接套用成 local modifications)__ For example, you can ask `svn diff` to show you the exact change made by Sally in revision 344:

 {{{
$ svn diff -c 344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c (revision 343)
+++ integer.c (revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info->operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info->operating_system, "Macintosh"); break;
     case 8:  sprintf(info->operating_system, "Z-System"); break;
-    case 9:  sprintf(info->operating_system, "CPM"); break;
+    case 9:  sprintf(info->operating_system, "CP/M"); break;
     case 10:  sprintf(info->operating_system, "TOPS-20"); break;
     case 11:  sprintf(info->operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info->operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high << 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */

     info->extra_header = (unsigned char *) my_malloc(total);
     fread(info->extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */

   if ((info->data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }

@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info->data_offset);
   #endif

-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */

   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
 }}}

__The `svn merge` command is almost exactly the same. Instead of printing the differences to your terminal, however, it applies them directly to your working copy as ''local modifications'':__

 {{{
$ svn merge -c 344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
 }}}

__The output of `svn merge` shows that your copy of `integer.c` was ''patched''. It now contains Sally's change—the change has been “copied” from the trunk to your working copy of your private branch, and now exists as a local modification. At this point, it's ''up to you'' to review the local modification and make sure it works correctly. (尤其是 semantic conflicts 的識別)__

In another scenario, it's possible that things may not have gone so well, and that `integer.c` may have entered a conflicted state. __You might need to resolve the conflict using standard procedures (see Chapter 2, Basic Usage), or if you decide that the merge was a bad idea altogether, simply give up and `svn revert` the local change. '''(也因此在做 merge 之前, 要先確認沒有未確認的 local change, 否則想做 revert 時就分不清哪些是 merge 而來的異動...)'''__

__But assuming that you've reviewed the merged change, you can `svn commit` the change ''as usual''. At that point, the change has been merged into your repository branch. '''In version control terminology, this act of copying changes between branches is commonly called ''porting changes''. (若要強調 merging 與 porting 的差別, merging 多用在 branch 開發成果往 trunk, 而 porting 多用在 trunk 往 branch 的同步; merge 是帶有歷史記錄的, 而 porting 則是沒有的)'''__

__'''When you commit the local modification, make sure your log message mentions that you're porting a specific change from one branch to another. (因為 merge 的動作並不會被記錄, 那只是 local modifications)'''__ For example:

 {{{
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
 }}}

As you'll see in the next sections, this is a very important “best practice” to follow.

 '''Why Not Use Patches Instead?'''

 A question may be on your mind, especially if you're a Unix user: why bother to use `svn merge` at all? Why not simply use the operating system's `patch` command to accomplish the same job? For example:

 {{{
$ svn diff -c 344 http://svn.example.com/repos/calc/trunk > patchfile
$ patch -p0  < patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
 }}}

 In this particular case, yes, there really is no difference. __But `svn merge` has special abilities that surpass(勝過) the `patch` program. The file format used by patch is quite limited; it's only able to tweak ''file contents.'' There's no way to represent changes to ''trees'', such as the addition, removal, or renaming of files and directories.__ Nor can the patch program notice changes to ''properties''. If Sally's change had, say, added a new directory, the output of `svn diff` wouldn't have mentioned it at all. `svn diff` only outputs the limited patch-format (跟 `patch` 有相同的問題), so there are some ideas it simply can't express. The `svn merge` command, however, can express changes in tree structure and properties by directly applying them to your working copy.

A word of warning: while `svn diff` and `svn merge` are very similar in concept, they do have different syntax in many cases. Be sure to read about them in Chapter 9, Subversion Complete Reference for details, or ask `svn help`. For example, `svn merge` requires a working-copy path as a target, i.e. a place where it should apply the tree-changes. If the target isn't specified, it assumes you are trying to perform one of the following common operations:

 1. You want to merge directory changes into your current working directory.
 2. You want to merge the changes in a specific file into a file by the same name which exists in your current working directory.

If you are merging a directory and haven't specified a target path, `svn merge` assumes the first case above and tries to apply the changes into your current directory. If you are merging a file, and that file (or a file by the same name) exists in your current working directory, `svn merge` assumes the second case and tries to apply the changes to a local file with the same name.

If you want changes applied somewhere else, you'll need to say so. For example, if you're sitting in the parent directory of your working copy, you'll have to specify the target directory to receive the changes:

 {{{
$ svn merge -c 344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
 }}}

==== The Key Concept Behind Merging ====

You've now seen an example of the `svn merge` command, and you're about to see several more. If you're feeling confused about exactly how merging works, you're not alone. Many users (especially those new to version control) are initially perplexed(困惑的) about the proper syntax of the command, and about how and when the feature should be used. But fear not, this command is actually much simpler than you think! There's a very easy technique for understanding exactly how `svn merge` behaves.

__The main source of confusion is the name of the command. The term “merge” somehow denotes(意味) that branches are combined together, or that there's some sort of mysterious(難解的) blending(混合) of data going on. That's not the case. '''A better name for the command might have been `svn diff-and-apply`, because that's all that happens: two repository trees are compared, and the ''differences'' are applied to a working copy. (因此瞭解 diff 的輸出結果, 有助於瞭解 merge 的內部運作; 上述的 "differences" 會被轉換成一連串加加減減的動作, 有點像是 database schema migration 的 script 一樣, 只要在來源 revision 上跑這一段 script, 就會變成跟目的 revision 一樣)'''__

The command takes three arguments:

 1. An initial repository tree (often called the left side of the comparison),
 2. A final repository tree (often called the right side of the comparison),
 3. A working copy to accept the differences as local changes (often called the target of the merge).

__Once these three arguments are specified, the two trees are compared, and the resulting differences are applied to the target working copy as local modifications. When the command is done, '''the results are no different than if you had hand-edited the files, or run various `svn add` or `svn delete` commands yourself. (有點像是錄製下來的動作, 然後重新套用一樣)''' If you like the results, you can commit them. If you don't like the results, you can simply `svn revert` all of the changes.__

The syntax of `svn merge` allows you to specify the three necessary arguments rather flexibly. Here are some examples:

 {{{
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
 }}}

The first syntax lays out all three arguments explicitly, naming each tree in the form `URL@REV` and naming the working copy target. The second syntax can be used as a shorthand for situations when you're comparing two different revisions of the same URL. The last syntax shows how the working-copy argument is optional; if omitted, it defaults to the current directory.

==== Best Practices for Merging ====

===== Tracking Merges Manually =====

__Merging changes sounds simple enough, but in practice it can become a headache. '''The problem is that if you repeatedly merge changes from one branch to another (廣義地來說, trunk 也是 branch 的一種), you might accidentally merge the same change twice.''' When this happens, sometimes things will work fine. When patching a file, Subversion typically notices if the file already has the change, and does nothing. '''But if the already-existing change has been modified in any way (改到相同的地方, 或者是修改的基礎不一致? 因為 diff 的套用不單單只是行對行的取代而已, 它還會比對修改的上下文是否一致[?]), you'll get a conflict.'''__

Ideally, your version control system should prevent the double-application of changes to a branch. It should automatically remember which changes a branch has already received, and be able to list them for you. It should use this information to help automate merges as much as possible.

__Unfortunately, Subversion is not such a system; (未來會支援; However, at the time of writing, this feature is being worked on!) it does not yet record any information about merge operations. '''When you commit local modifications, the repository has no idea whether those changes came from running `svn merge`, or from just hand-editing the files.'''__

__What does this mean to you, the user? It means that until the day Subversion grows this feature, you'll have to track merge information yourself. The best place to do this is in the commit log-message. As demonstrated in prior examples, '''it's recommended that your log-message mention a specific revision number (or range of revisions; 要注意 revision rN-1:N 與 changeset #N 之間的不同) that are being merged into your branch. Later on, you can run `svn log` to review which changes your branch already contains. (如果由 trunk porting 到 branch 的過程中做了一些調整, 那這些調整要如何從 branch 套回 trunk? 這一點可以在 "Feature Branches" 一節最後面得到解答)''' This will allow you to carefully construct a subsequent `svn merge` command that won't be redundant with previously ported changes.__

為了避開 revision 與 changeset 容易混淆的問題, 使用 specifica changeset or range of changeset 的表示法, 例如 #343 或 #500-502 會不會比較好? 不過下面許多例子仍採用 revision 的寫法, 或許是因為 changeset 這個東西很難定義清楚的關係吧 (Everyone seems to have a slightly different definition of “changeset”, or at least a different expectation of what it means for a version control system to have “changeset features”), 因此在實務上目前就暫時採用 revision 的寫法 (@2008/04/14)

 {{{
$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
$ svn commit -m "Undoing change committed in r303."
$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
}}}
 
In the next section, we'll show some examples of this technique in action.

===== Previewing Merges =====

__'''First, always remember to do your merge into a working copy that has no local edits and has been recently updated. If your working copy isn't “clean” in these ways, you can run into some headaches.'''__

Assuming your working copy is tidy(有條不紊的), merging isn't a particularly high-risk operation. If you get the merge wrong the first time, simply `svn revert` the changes and try again.

If you've merged into a working copy that already has local modifications, the changes applied by a merge will be mixed with your pre-existing ones, and running `svn revert` is no longer an option. The two sets of changes may be impossible to separate.

In cases like this, people take comfort in being able to predict or examine merges before they happen. One simple way to do that is to run `svn diff` with the same arguments you plan to pass to `svn merge`, as we already showed in our first example of merging. Another method of previewing is to pass the `--dry-run` option to the merge command:

 {{{
$ svn merge --dry-run -c 344 http://svn.example.com/repos/calc/trunk
U integer.c
$ svn status
# nothing printed, working copy is still unchanged.
 }}}
 
__The `--dry-run` option doesn't actually apply any local changes to the working copy. '''It only shows status codes that would be printed in a real merge. It's useful for getting a “high level” preview of the potential merge,''' for those times when running `svn diff` gives too much detail.__

===== Merge Conflicts =====

Just like the `svn update` command, `svn merge` applies changes to your working copy. And therefore it's also capable of creating conflicts. The conflicts produced by `svn merge`, however, are sometimes different, and this section explains those differences.

To begin with, assume that your working copy has no local edits. __When you `svn update` to a particular revision, the changes sent by the server will always apply “cleanly” to your working copy. The server produces the ''delta'' by comparing two trees: a virtual snapshot of your working copy, and the revision tree you're interested in. Because the left-hand side of the comparison is exactly equal to what you already have, the delta is guaranteed to correctly convert your working copy into the right-hand tree.__

__But `svn merge` has no such guarantees and can be much more chaotic(混亂的): the user can ask the server to compare any two trees at all, even ones that are unrelated to the working copy! '''This means there's large potential for human error. Users will sometimes compare the wrong two trees, creating a delta that doesn't ''apply cleanly''.''' `svn merge` will do its best to apply as much of the delta as possible, but some parts may be impossible. Just as the Unix `patch` command sometimes complains about “failed hunks”, `svn merge` will complain about “skipped targets”:__

 {{{
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U foo.c
U bar.c
Skipped missing target: 'baz.c'
U glub.c
C glorb.h
$ 
 }}}
 
In the previous example it might be the case that `baz.c` exists in both snapshots of the branch being compared, and the resulting delta wants to change the file's contents, but the file doesn't exist in the working copy. (呼應前面 `svn diff-and-apply` 的說法) __'''Whatever the case, the “skipped” message means that the user is most likely comparing the wrong two trees; they're the classic sign of user error. (要異動的檔案不存在、要新增的檔案已經存在, 要刪除的檔案不存在而言)'''__ When this happens, it's easy to recursively revert all the changes created by the merge (`svn revert -recursive`), delete any unversioned files or directories left behind after the revert, and re-run `svn merge` with different arguments.

__'''看到 "Skipped" 固然是個警訊, 但如果使用者很清楚自己在重複套用異動 (例如有一個 delta 混合有從自己及別人那裡抽出的異動, 而想要套用別人的異動時), 就沒什麼問題 [...]'''__

__Also notice that the previous example shows a conflict happening on `glorb.h`. We already stated that the working copy has no local edits: how can a conflict possibly happen? '''Again, because the user can use `svn merge` to define and apply any ''old delta'' to the working copy, that delta may contain textual changes that don't cleanly apply to a working file, even if the file has no local modifications.'''__

__Another small difference between `svn update` and `svn merge` are the names of the full-text files created when a conflict happens. In the section called “Resolve Conflicts (Merging Others' Changes)”, we saw that an update produces files named `filename.mine`, `filename.rOLDREV`, and `filename.rNEWREV`. When `svn merge` produces a conflict, though, it creates three files named `filename.working`, `filename.left`, and `filename.right`. In this case, the terms “left” and “right” are describing which side of the double-tree comparison the file came from. In any case, these differing names will help you distinguish between conflicts that happened as a result of an update versus ones that happened as a result of a merge.__

===== Noticing or Ignoring Ancestry =====

__When conversing with a Subversion developer, you might very likely hear reference to the term ''ancestry''. This word is used to describe the relationship between two objects in a repository: if they're related to each other, then one object is said to be an ancestor of the other.__

__For example, suppose you commit revision 100, which includes a change to a file `foo.c`. Then `foo.c@99` is an “ancestor” of `foo.c@100`. On the other hand, suppose you commit the deletion of `foo.c` in revision 101, and then add a new file by the same name in revision 102. '''In this case, `foo.c@99` and `foo.c@102` may appear to be ''related'' (they have the same path), but in fact are completely different objects in the repository. They share no history or “ancestry”.'''__

__The reason for bringing this up is to point out an important difference between `svn diff` and `svn merge`. The former command ignores ancestry, while the latter command is quite sensitive to it. For example, if you asked `svn diff` to compare revisions 99 and 102 of `foo.c`, you would see line-based diffs; the `diff` command is ''blindly'' comparing two paths. '''But if you asked `svn merge` to compare the same two objects, it would notice that they're unrelated and first attempt to delete the old file, then add the new file;''' the output would indicate a deletion followed by an add:__

 {{{
D foo.c
A foo.c
 }}}
 
Most merges involve comparing trees that are ''ancestrally related'' to one another, and therefore `svn merge` defaults to this behavior. Occasionally, however, you may want the merge command to compare two unrelated trees. For example, you may have imported two source-code trees representing different vendor releases of a software project (see the section called “Vendor branches”). __If you asked `svn merge` to compare the two trees, you'd see the entire first tree being deleted, followed by an add of the entire second tree! In these situations, you'll want `svn merge` to do a path-based comparison only, ignoring any relations between files and directories. Add the `--ignore-ancestry` option to your merge command, and it will behave just like `svn diff`. (And conversely, the `--notice-ancestry` option will cause `svn diff` to behave like the `merge` command.)__

===== Merges and Moves =====

A common desire is to refactor source code, especially in Java-based software projects. Files and directories are shuffled around and renamed, often causing great disruption(混亂) to everyone working on the project. Sounds like a perfect case to use a branch, doesn't it? Just create a branch, shuffle things around, then merge the branch back to the trunk, right?

__Alas(哎呀!), this scenario doesn't work so well right now, and is considered one of Subversion's current weak spots(弱點). '''The problem is that Subversion's `update` command isn't as robust as it should be (最大的問題在於它將 rename 解釋成 copy + delete, 最後 client update 時就會變成 delete + add), particularly when dealing with copy and move operations.'''__

When you use `svn copy` to duplicate a file, the repository remembers where the new file came from, but it fails to transmit that information to the client which is running `svn update` or `svn merge`. Instead of telling the client, “Copy that file you already have to this new location”, it instead sends down an entirely new file. __This can lead to problems, especially because the same thing happens with renamed files. '''A lesser-known fact about Subversion is that it lacks “true renames”—the `svn move` command is nothing more than an aggregation of `svn copy` and `svn delete`. (撇開下面 delete + add 的問題, 至少 `svn copy` 可以保有 history)'''__

For example, suppose that while working on your private branch, you rename `integer.c` to `whole.c`. Effectively you've created a new file in your branch that is a copy of the original file, and deleted the original file. Meanwhile, back on trunk, Sally has committed some improvements to `integer.c`. Now you decide to merge your branch to the trunk: (其中 r341 是發生在 branch 身上)

 {{{
$ cd calc/trunk

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
D   integer.c
A   whole.c
 }}}

This doesn't look so bad at first glance, but it's also probably not what you or Sally expected. The merge operation has deleted the latest version of `integer.c` file (the one containing Sally's latest changes), and blindly(盲目地) added your new `whole.c` file—which is a duplicate of the older version of `integer.c`. The net effect is that merging your “rename” to the branch has removed Sally's recent changes from the latest revision!

__This isn't true data-loss; Sally's changes are still in the repository's history, but it may not be immediately obvious that this has happened. The moral(寓意) of this story is that until Subversion improves, be very careful about merging copies and renames from one branch to another.__

__目前要注意的就是別在 branch / trunk 間產生 rename 的差異, 別在 branch 做 refactoring 的動作 (包括上下移動檔案內容). 例如 `.classpath` 這個檔案透過 UI 做調整時, 哪怕只是調整版號, 順序可能會被調整過 (可能是我們習慣 "先刪再加" 的動作所造成, 但畫面上也沒有提供 Move Up/Down 的功能), 因此在做 porting 時, 如果 `.classpath` 產生衝突, '''順序上應該要以 "最後要 merge 回去的位置" 為主, 否則將來做 merge 是又會因位置對調的問題而產生衝突.'''__

=== Common Use-Cases ===

There are many different uses for branching and `svn merge`, and this section describes the most common ones you're likely to run into.

==== Merging a Whole Branch to Another ====

To complete our running example, we'll move forward in time. Suppose several days have passed, and many changes have happened on both the trunk and your private branch. Suppose that you've finished working on your private branch; the ''feature'' or ''bug fix'' (兩者都適合用 branch 來實作) is finally complete, and now you want to merge all of your branch changes back into the trunk for others to enjoy.

So how do we use `svn merge` in this scenario? Remember that this command compares two trees, and applies the differences to a working copy. So to receive the changes, you need to have a working copy of the trunk. We'll assume that either you still have your original one lying around (fully updated), or that you recently checked out a fresh working copy of `/calc/trunk`.

__But which two trees should be compared? At first glance, the answer may seem obvious: just compare the latest trunk tree with your latest branch tree. But beware—this assumption is wrong, and has burned(打擊) many a new user! Since `svn merge` operates like `svn diff`, comparing the latest trunk and branch trees will not merely describe the set of changes you made to your branch. '''Such a comparison shows too many changes: it would not only show the addition of your branch changes, but also the removal(轉移) of trunk changes that never happened on your branch. (前題是過程中沒有從 trunk 往 branch 做 porting, 否則後續由 branch 往 trunk 做 merging 時, 必定會產生 "merge the same change twice" 的問題, 正確的做法應該參考 "Feature Branches" 一節)'''__

__'''To express only the changes that happened on your branch, you need to compare the ''initial state'' of your branch to its ''final state''.''' Using `svn log` on your branch, you can see that your branch was created in revision 341. And the final state of your branch is simply a matter of using the HEAD revision. That means you want to compare revisions 341 and HEAD of your branch directory, and apply those differences to a working copy of the trunk.__

__'''A nice way of finding the revision in which a branch was created (the “base” of the branch) is to use the `--stop-on-copy` option to `svn log`. (在 Subclipse 的 History View 底下也有 Stop on Copy/Rename 的選項)''' The `log` subcommand will normally show every change ever made to the branch, including tracing back through the copy which created the branch. So normally, you'll see history from the trunk as well. The `--stop-on-copy` will halt log output as soon as `svn log` detects that its target was copied or renamed (= copy + delete).__

So in our continuing example,

 {{{
$ svn log -v --stop-on-copy \
http://svn.example.com/repos/calc/branches/my-calc-branch
...
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
A /calc/branches/my-calc-branch (from /calc/trunk:340)
$
As expected, the final revision printed by this command is the revision in which
my-calc-branch was created by copying.
 }}}
 
Here's the final merging procedure, then:

 {{{
$ cd calc/trunk
$ svn update
At revision 405.
$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U integer.c
U button.c
U Makefile
$ svn status
M integer.c
M button.c
M Makefile
# ...examine the diffs, compile, test, etc...
$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending integer.c
Sending button.c
Sending Makefile
Transmitting file data ...
Committed revision 406.
 }}}
 
__Again, notice that the commit log message very specifically mentions the range of changes that was merged into the trunk. Always remember to do this, because it's critical information you'll need later on.__

For example, suppose you decide to keep working on your branch for another week, in order to complete an enhancement to your original feature or bug fix. The ''repository's HEAD'' revision is now 480, and you're ready to do another merge from your private branch to the trunk. __But as discussed in the section called “Best Practices for Merging”, you don't want to merge the changes you've already merged before; you only want to merge everything “new” on your branch since the last time you merged. The ''trick'' is to figure out what's ''new''. (相對於 old delta 的說法)__

The first step is to run `svn log` on the trunk, and look for a log message about the last time you merged from the branch:

 {{{
$ cd calc/trunk
$ svn log
...
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line
Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
...
 }}}
 
__'''因應上面 "look for log message" 的做法, 最好養成習慣在 log message 做 `[merge]` 的 tagging, 例如 "`[merge] porting /trunk r305:307`" 或 "`[merge] porting /branches/MG-bz-08-002@348`" (要一併提及 path 及 revision, 否則事後無法定位特定的資源, 尤其是短命的 feature branch 可能早就已經被刪除), 那麼日後就可以用 `svn log --stop-on-copy | grep -B2 '\[merge\]'` 找出所有的 merging/porting 的動作 (但用 `[branch]` 來標示分出支線, 效益並不明顯[...])'''__
 
Aha! Since all branch-changes that happened between revisions 341 and 405 were previously merged to the trunk as revision 406, you now know that you want to merge only the branch changes after that—by comparing revisions 406 and HEAD.

 {{{
$ cd calc/trunk
$ svn update
At revision 480.
# We notice that HEAD is currently 480, so we use it to do the merge:
$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U integer.c
U button.c
U Makefile
$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending integer.c
Sending button.c
Sending Makefile
Transmitting file data ...
Committed revision 481.
 }}}
 
__Now the trunk contains the complete ''second wave'' of changes made to the branch. At this point, you can either ''delete'' your branch (we'll discuss this later on), or continue working on your branch and repeat this procedure for subsequent merges.__

==== Undoing Changes ====

__Another common use for `svn merge` is to ''roll back'' a change that has already been committed. Suppose you're working away(一個勁地幹下去) happily on a working copy of `/calc/trunk`, and you discover that the change made way back in revision 303, which changed `integer.c`, is completely wrong. It never should have been committed. '''You can use `svn merge` to “undo” the change in your working copy, and then commit the local modification to the repository. (概念上相當簡單直覺!!)''' All you need to do is to specify a ''reverse difference''. (You can do this by specifying `--revision 303:302` (順序對調), or by an equivalent `--change -303`.)__

 {{{
$ svn merge -c -303 http://svn.example.com/repos/calc/trunk
U integer.c
$ svn status
M integer.c
$ svn diff
...#
verify that the change is removed
...
$ svn commit -m "Undoing change committed in r303."
Sending integer.c
Transmitting file data .
Committed revision 350.
 }}}

__One way to think about a repository revision is as a specific group of changes (some version control systems call these ''changesets''; 差異 delta 而言).__ By using the `-r` option, you can ask `svn merge` to apply a changeset, or whole range of changesets, to your working copy. In our case of undoing a change, we're asking `svn merge` to apply changeset #303 to our working copy backwards.

 '''Subversion and Changesets'''
 
 Everyone seems to have a slightly different definition of “changeset”, or at least a different expectation of what it means for a version control system to have “changeset features”. __'''For our purpose, let's say that a changeset is just a collection of changes with a unique name.''' The changes might include textual edits to file contents, modifications to tree structure, or tweaks to metadata. In more common speak, a changeset is just a patch with a name you can refer to.__
 
 __'''In Subversion, a global revision number N names a tree in the repository: it's the way the repository looked ''after'' the Nth commit. It's also the name of an ''implicit changeset'': if you compare tree N with tree N-1, you can derive the exact patch that was committed. (也就是說 revision N-1:N 就等同於 changeset N 的表示法) For this reason, it's easy to think of “revision N” as not just a tree, but a changeset as well.'''__ If you use an issue tracker to manage bugs, you can use the revision numbers to refer to particular patches that fix bugs—for example, “this issue was fixed by revision 9238.”. Somebody can then run `svn log -r9238` to read about the exact changeset which fixed the bug, and run `svn diff -c 9238` to see the patch itself. And Subversion's `merge` command also uses revision numbers. You can merge specific changesets from one branch to another by naming them in the merge arguments: `svn merge -r9237:9238` would merge changeset #9238 into your working copy.

Keep in mind that rolling back a change like this is just like any other `svn merge` operation, so you should use `svn status` and `svn diff` to confirm that your work is in the state you want it to be in, and then use `svn commit` to send the final version to the repository. After committing, this particular changeset is no longer ''reflected'' in the HEAD revision.

Again, you may be thinking: well, that really didn't undo the commit, did it? The change still exists in revision 303. If somebody checks out a version of the calc project between revisions 303 and 349, they'll still see the bad change, right?

__Yes, that's true. When we talk about “removing” a change, we're really talking about removing it from HEAD. The original change still exists in the repository's history. For most situations, this is good enough. Most people are only interested in tracking the HEAD of a project anyway. There are special cases, however, where you really might want to destroy all evidence(證據) of the commit. (Perhaps somebody accidentally committed a confidential document.) This isn't so easy, it turns out, '''because Subversion was deliberately(故意地) designed to never lose information. Revisions are immutable trees which build upon one another.''' Removing a revision from history would cause a domino effect(骨牌效應), creating chaos(大混亂) in all subsequent revisions and possibly invalidating all working copies. The Subversion project has plans, however, to someday implement a command that would accomplish the task of permanently deleting information. In the meantime, see the section called “svndumpfilter” for a possible workaround.__

==== Resurrecting(復活) Deleted Items ====

The great thing about version control systems is that information is never lost. Even when you delete a file or directory, it may be gone from the HEAD revision, but the object still exists in earlier revisions. One of the most common questions new users ask is, “How do I get my old file or directory back?”.

The first step is to define exactly which item you're trying to resurrect. Here's a useful metaphor(比喻): __'''you can think of every object in the repository as existing in a sort of two-dimensional coordinate system. The first coordinate is a particular revision tree, and the second coordinate is a path within that tree. So every version of your file or directory can be defined by a specific coordinate pair.''' (Remember the “peg revision” syntax—`foo.c@224` —mentioned back in the section called “Peg and Operative Revisions”.)__

First, you might need to use `svn log` to discover the exact coordinate pair you wish to resurrect. A good strategy is to run `svn log --verbose` in a directory which used to contain your deleted item. The `--verbose` (`-v`) option shows a list of all changed items in each revision; all you need to do is find the revision in which you deleted the file or directory. You can do this visually, or by using another tool to examine the log output (via `grep`, or perhaps via an incremental search in an editor).

 {{{
$ cd parent-dir
$ svn log -v
...
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
D /calc/trunk/real.c
M /calc/trunk/integer.c
Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
...
 }}}
 
In the example, we're assuming that you're looking for a deleted file `real.c`. By looking through the logs of a parent directory, you've spotted that this file was deleted in revision 808. Therefore, the last version of the file to exist was in the revision right before that. Conclusion: you want to resurrect the path `/calc/trunk/real.c` from revision 807. That was the hard part—the ''research''. Now that you know what you want to restore, you have two different choices.

One option is to use `svn merge` to apply revision 808 “in reverse”. (We've already discussed how to undo changes, see the section called “Undoing Changes”.) This would have the effect of re-adding `real.c` as a local modification. The file would be scheduled for addition, and after a commit, the file would again exist in HEAD.

In this particular example, however, this is probably not the best strategy. Reverse-applying revision 808 would not only schedule `real.c` for addition, but the log message indicates that it would also undo certain changes to `integer.c`, which you don't want. Certainly, you could reverse merge revision 808 and then `svn revert` the local modifications to `integer.c`, but this technique doesn't scale well. What if there were 90 files changed in revision 808?

A second, more targeted strategy is not to use `svn merge` at all, but rather the `svn copy` command. Simply copy the exact revision and path “coordinate pair” from the repository to your working copy:

 {{{
$ svn copy -r 807 \
http://svn.example.com/repos/calc/trunk/real.c ./real.c
$ svn status
A + real.c
$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding real.c
Transmitting file data .
Committed revision 1390.
 }}}

__The plus sign in the status output indicates that the item isn't merely scheduled for addition, but scheduled for addition “with history”. Subversion remembers where it was copied from. In the future, running `svn log` on this file will traverse back through the file's resurrection and through all the history it had prior to revision 807. In other words, '''this new `real.c` isn't really new; it's a direct descendant of the original, deleted file.'''__

Although our example shows us resurrecting a file, note that these same techniques work just as well for resurrecting deleted directories.

==== Common Branching Patterns ====

Version control is most often used for software development, so here's a quick peek at(窺視) two of the most common ''branching/merging patterns'' used by teams of programmers. If you're not using Subversion for software development, feel free to skip this section. If you're a software developer using version control for the first time, pay close attention, as these patterns are often considered best practices by experienced folk(人們). These processes aren't specific to Subversion; they're applicable to any version control system. Still, it may help to see them described in Subversion terms.

 {{{
|- branches
|  |- 1.6
|  |  |- 1.6.1
|  |  \- 1.6.2
|  |
|  |- 1.7
|  |  \- 1.7.1
|  |
|  |- 1.8
|  |  \- 1.8.1
|  |
|  \- FEATURE-0002
|  
\- turnk (併回 FEATURE-0001 後釋出 1.7)
 }}}

__'''只有 feature branches 才能 merge 回 trunk, 其餘的 release branches 都必須用 porting 的方式把異動分享出來.''' 按上面的例子, 假設 1.6.1 修正了一個重大瑕疵, 希望 1.7.x 及 1.8.x 也都能排除這個問題:__
 及 latest release branch
 * __由於 TRUNK 已經包含 FEATURE-0001 的新功能, 如果要將 1.6.1 的修正 merge 回 TRUNK 的話, 勢必要讓 1.6.1 同步到 trunk 最新的版本才行, 但如此一來 1.6.x 就會多出了 "新功能", 這與 release branches "不增加新功能" 的定位是有衝突的, '''而且如果 FEATURE-0001 對相依性做了很大的調整, 那麼後續改用 1.6.2 的人就會發生嚴重的版本衝突, 這對使用 1.6.x 的人是難以理解的, 因為版次第 3 碼的變動不應該產生不相容的結果. (這也難怪下面只有在 feature branches 的章節才提到 synchronized merge 的概念)'''__
 * __'''release branches 不會再跟 trunk 做 synchronized (不需要改變或增加新功能); 但 release branches 的異動還是會 porting 回 trunk (當然只 porting 分支內主動修改的部份, 否則會產生重複修改的衝突; 可以在 comment 加註 "[bugfix]" 來識別; 回 trunk 最好的時機就是釋出修正版次時), 供後續分出的其他 feature branches 使用.'''__
 * 由於 release branches 的修正都會回到 trunk, 因此其他 feature branches 都會藉由 synchoinzed 的動作, 得到這些修正.
 * __'''除非這個問題只有特定 release branches 才有, 否則 bug fix 應該做在 TRUNK, 再 porting 到其他分支; 如果某 release branche 需要其他特定 release branches 才有 bug fix, 直接在 branches 間做 porting 即可.'''__

===== Release Branches =====

__Most software has a typical lifecycle: code, test, release, repeat. There are two problems with this process. '''First, developers need to keep writing new features while quality-assurance teams take time to test supposedly(被認為是)-stable versions of the software.''' New work cannot halt while the software is tested. Second, the team almost always needs to support older, released versions of software; if a bug is discovered in the latest code, it most likely exists in released versions as well, and customers will want to get that bugfix without having to wait for a major new release.__

__'''因此 feature branch 開發告一段落之後, 就可以併回 trunk (真正要釋出給客戶之前才做, 否則中間如果插件進來就會造成本來還沒有準備要交貨的部份也被迫釋出的問題), 然後再分出 release branch 著手準備版本釋出的工作.'''__

Here's where version control can help. The typical procedure looks like this:

 * Developers commit all new work to the trunk. Day-to-day changes are committed to `/trunk`: new features, bugfixes, and so on. 
 
 * The trunk is copied to a “release” branch. When the team thinks the software is ready for release (say, a 1.0 release), then `/trunk` might be copied to `/branches/1.0`.
 
 * Teams continue to work in parallel. One team begins rigorous(嚴格的) testing of the release branch, while another team continues new work (say, for version 2.0) on `/trunk`. __'''If bugs are discovered in either location, fixes are ported ''back and forth'' as necessary. At some point, however, even that process stops. The branch is “frozen” for final testing right before a release.'''__
   
   .__'''測試期間發現的錯誤, 直接改在 release branch 即可, 釋出之前再統一 porting 回 TRUNK. 但釋出之後, 就不應該直接在 release branch 內做修改 (包括 buf fix 的部份), 而是應該先改在 TRUNK, 然後再 porting 到 release branch.'''__
   
 * __The branch is tagged and released. When testing is complete, `/branches/1.0` is copied to `/tags/1.0.0` (注意後面多了個 ".0", 雖然感覺有點多餘, 但 0 所強調的正是 release 後未修正過的版本) as a ''reference snapshot''. The tag is packaged and released to customers.__
 
 * __The branch is maintained over time. While work continues on `/trunk` for version 2.0, '''bugfixes continue to be ported from `/trunk` to `/branches/1.0`.''' When enough bugfixes have accumulated, management may decide to do a 1.0.1 release: `/branches/1.0` is copied to `/tags/1.0.1`, and the tag is packaged and released.__
 
   .__'''這麼說來, release branches 在做完測試做第一次的釋出之後, 就不會再發生往 TRUNK 的 porting, 只剩 TRUNK 往 release branch 的 porting. 而且 "通常" 只針對 "被要求修正的部份" (尤其是 bugfix) 做 porting 而已, 因為 release brances 要求的是穩定性, 即便只是 refactoring 也不值得做 porting...'''__
 
This entire process repeats as the software matures: when the 2.0 work is complete, a new 2.0 release branch is created, tested, tagged, and eventually released. __After some years, the repository ends up with a number of release branches in “maintenance” mode, and a number of tags representing final shipped versions.__

__這裡的 "maintenance mode" 很難界定, 尤其是 library 一旦發行之後, 就會被其他專案使用, 要如何知道別人不會再對這個版本有修改的需求? 若不好好管理這為數眾多的 release branches, 後續會很難分清楚那些是開發中的, 哪些是很久沒有動過的... '''目前 @2008/09/10 建議除了 private/personal branches 在開發完成後可直接刪除以外, 其餘 feature/release branches 都應該保留下來, 否則日後要找舊版本的資料時不是很好找 (至少 subclipse 就會出現 "path not found" 的錯誤, 想要選取己刪除的分支也選不到, 只能回到 `svn` command 下做才行), 如果 `branches` 下的分支太多的話, 可以建立 `branches/.archives` 的分支, 把這些過時的分支移到下面去即可. (`tags` 下也可以採用同樣的做法; 其中 ".archives" 以 "." 開頭是為了讓有機會出現在清單的最上面)'''__

===== Feature Branches =====

__A feature branch is the sort of branch that's been the dominant(支配的) example in this chapter, the one you've been working on while Sally continues to work on `/trunk`. '''It's a temporary branch created to work on a complex change without interfering with the stability of `/trunk`. Unlike release branches (which may need to be supported forever), feature branches are born, used for a while, merged back to the trunk, then ultimately ''deleted'' (由後續的 relese branch 接手). They have a finite span of usefulness.'''__

Again, project policies vary widely concerning exactly when it's appropriate to create a feature branch. Some projects never use feature branches at all: commits to `/trunk` are a free-for-all. The advantage to this system is that it's simple—nobody needs to learn about branching or merging. The disadvantage is that the trunk code is often unstable or unusable. __Other projects use branches to an extreme: '''no change is ever committed to the trunk directly. Even the most trivial changes are created on a short-lived branch, carefully reviewed and merged to the trunk. Then the branch is deleted.''' This system guarantees an exceptionally(非常地) stable and usable trunk at all times, but at the cost of tremendous(驚人的) process overhead. (其實只要按照下面的方法維持 synchronized feature branch, 合併的工作就不困難...)__

__Most projects take a middle-of-the-road(中庸的) approach. They commonly insist(堅持) that `/trunk` compile and pass regression tests at all times. '''A feature branch is only required when a change requires a large number of destabilizing(不穩定的) commits.''' A good rule of thumb(單憑經驗的方法) is to ask this question: if the developer worked for days in isolation and then committed the large change ''all at once'' (so that `/trunk` were never destabilized), '''would it be too large a change to review? (一直強調 code reviewing 的重要性)''' If the answer to that question is “yes”, then the change should be developed on a feature branch. As the developer commits incremental changes to the branch, they can be easily reviewed by peers.__

__Finally, there's the issue of how to best keep a feature branch in “sync” with the trunk as work progresses. As we mentioned earlier, there's a great risk to working on a branch for weeks or months; '''trunk changes may continue to pour in(大量湧入; 尤其是指其他 feature branches 的完工), to the point where the two lines of development differ so greatly that it may become a nightmare trying to merge the branch back to the trunk.'''__

__'''This situation is best avoided by regularly merging trunk changes to the branch. (嚴格來說應該是 "porting")''' Make up a policy: once a week, merge the last week's worth of trunk changes to the branch. Take care when doing this; the merging needs to be hand-tracked to avoid the problem of repeated merges__ (as described in the section called “Tracking Merges Manually”). You'll need to write careful log messages detailing exactly which revision ranges have been merged already (as demonstrated in the section called “Merging a Whole Branch to Another”). It may sound intimidating(嚇人的), but it's actually pretty easy to do.

__'''At some point, you'll be ready to merge the ''“synchronized” feature branch'' back to the trunk. To do this, begin by doing a ''final merge'' of the latest trunk changes to the branch. When that's done, the latest versions of branch and trunk will be ''absolutely identical except for your branch changes''. So in this ''special case'', you would merge by comparing the branch with the trunk: (注意 trunk 要寫在 branch 前面, @2008/04/15 實驗確認位置對調會產生 undo 的效果; 此時的 comment 要怎麼寫[?])'''__

 {{{
$ cd trunk-working-copy
$ svn update
At revision 1910.
$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
http://svn.example.com/repos/calc/branches/mybranch@1910
U real.c
U integer.c
A newdirectory
A newdirectory/newfile
...
 }}}
 
__'''By comparing the HEAD revision of the trunk with the HEAD revision of the branch, you're defining a delta that describes only the changes you made to the branch; both lines of development already have all of the trunk changes. (如果能接受 merge 其實只是 diff-and-apply 的概念, 就不難理解比對兩個 HEAD 跟比對 initial state 與 final state 的結果是不同的)'''__

Another way of thinking about this pattern is that your weekly sync of trunk to branch is analogous to running `svn update` in a working copy, while the final merge step is analogous to running `svn commit` from a working copy. After all, what else is a working copy but a very shallow(淺薄的) private branch? It's a branch that's only capable of storing one change at a time.[?]

=== Traversing Branches ===

The `svn switch` command transforms an existing working copy to reflect a different branch. While this command isn't strictly necessary for working with branches, it provides a nice shortcut. In our earlier example, after creating your private branch, you checked out a fresh working copy of the new repository directory. Instead, you can simply ask Subversion to change your working copy of `/calc/trunk` to mirror the new branch location:

 {{{
$ cd calc
$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk
$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U integer.c
U button.c
U Makefile
Updated to revision 341.
$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
 }}}
 
After “switching” to the branch, your working copy is no different than what you would get from doing a fresh checkout of the directory. And it's usually more efficient to use this command, because often branches only differ by a small degree. The server sends only the minimal set of changes necessary to make your working copy reflect the branch directory. The `svn switch` command also takes a `--revision` (`-r`) option, so you need not always move your working copy to the HEAD of the branch.

Of course, most projects are more complicated than our calc example, containing multiple subdirectories. Subversion users often follow a specific algorithm when using branches:

 1. Copy the project's entire “trunk” to a new branch directory.
 2. Switch only ''part of'' the trunk working copy to mirror the branch.
 
__In other words, if a user knows that the branch-work only needs to happen on a specific subdirectory, they use `svn switch` to move only that subdirectory to the branch. (Or sometimes users will switch just a single working file to the branch!) '''That way, they can continue to receive normal “trunk” updates to most of their working copy, but the switched ''portions'' will remain immune (免疫的; unless someone commits a change to their branch. 下面提到 "single, atomic change" 的行為, 如果不將 trunk 與 branch 的異動拆開來的話, 後續的維護會變得很困難).''' This feature adds a whole new dimension to the concept of a “mixed working copy”—not only can working copies contain a mixture of working revisions, but a mixture of repository locations as well.__

__If your working copy contains a number of switched subtrees from different repository locations, it continues to function as normal. When you update, you'll receive patches to each subtree as appropriate. '''When you commit, your local changes will still be applied as a single, atomic change to the repository. (對 Subversion 而言只是同時改了不同路徑下的檔案而已)'''__

Note that while it's okay for your working copy to reflect a mixture of repository locations, these locations must all be within the same repository. Subversion repositories aren't yet able to communicate with one another; that's a feature planned for the future. (You can, however, use `svn switch` with the `--relocate` option if the URL of your server changes and you don't want to abandon an existing working copy. See `svn switch` for more information and an example)

 '''Switches and Updates'''
 
 __Have you noticed that the output of `svn switch` and `svn update` look the same? The switch command is actually a ''superset'' of the `update` command.__
 
 When you run `svn update`, you're asking the repository to compare two trees. The repository does so, and then sends a description of the differences back to the client. The only difference between `svn switch` and `svn update` is that the `update` command always compares two ''identical paths''.

 That is, if your working copy is a mirror of `/calc/trunk`, then `svn update` will automatically compare your working copy of `/calc/trunk` to `/calc/trunk` in the HEAD revision.

 If you're switching your working copy to a branch, then `svn switch` will compare your working copy of `/calc/trunk` to some other branch-directory in the HEAD revision. __In other words, an update moves your working copy through time. A switch moves your working copy through time and ''space''.__
 
Because `svn switch` is essentially a variant of `svn update`, it shares the same behaviors; any local modifications in your working copy are preserved when new data arrives from the repository. This allows you to perform all sorts of ''clever tricks''.

__For example, suppose you have a working copy of `/calc/trunk` and make a number of changes to it. Then you suddenly realize that you meant to make the changes to a branch instead. No problem! When you `svn switch` your working copy to the branch, the local changes will remain. You can then test and commit them to the branch. (這種狀況還滿常出現的)__

=== Tags ===

__Another common version control concept is a tag. A tag is just a “snapshot” of a project in time. In Subversion, this idea already seems to be everywhere. '''Each repository revision is exactly that—a snapshot of the filesystem after each commit.'''__

However, people often want to give more human-friendly names to tags, like release-1.0. And they want to make snapshots of smaller subdirectories of the filesystem. After all, it's not so easy to remember that release-1.0 of a piece of software is a particular subdirectory of revision 4822.

==== Creating a Simple Tag ====

Once again, `svn copy` comes to the rescue. If you want to create a snapshot of `/calc/trunk` exactly as it looks in the HEAD revision, then make a copy of it:

 {{{
$ svn copy http://svn.example.com/repos/calc/trunk \
http://svn.example.com/repos/calc/tags/release-1.0 \
-m "Tagging the 1.0 release of the 'calc' project."
Committed revision 351.
 }}}
 
This example assumes that a `/calc/tags` directory already exists. (If it doesn't, you can create it using `svn mkdir`.) After the copy completes, the new `release-1.0` directory is forever a snapshot of how the project looked in the HEAD revision at the time you made the copy. Of course you might want to be more precise about exactly which revision you copy, in case somebody else may have committed changes to the project when you weren't looking. So if you know that revision 350 of `/calc/trunk` is exactly the snapshot you want, you can specify it by passing `-r 350` to the `svn copy` command.

__But wait a moment: isn't this tag-creation procedure the same procedure we used to create a branch? Yes, in fact, it is. '''In Subversion, there's no difference between a tag and a branch. Both are just ordinary directories that are created by copying. Just as with branches, the only reason a copied directory is a “tag” is because humans have decided to treat it that way:''' as long as nobody ever commits to the directory, it forever remains a snapshot. If people start committing to it, it becomes a branch.__

If you are administering a repository, there are two approaches you can take to managing tags. The first approach is “hands off”: as a matter of project policy, decide where your tags will live, and make sure all users know how to treat the directories they copy in there. (That is, make sure they know not to commit to them.) The second approach is more paranoid(多疑的): you can use one of the access-control scripts provided with Subversion to prevent anyone from doing anything but creating new copies in the tags-area (See Chapter 6, Server Configuration.) __The paranoid approach, however, isn't usually necessary. If a user accidentally commits a change to a tag-directory, you can simply undo the change as discussed in the previous section. This is version control, after all.__

==== Creating a Complex Tag ====

Sometimes you may want your “snapshot” to be more complicated than a single directory at a single revision.

For example, pretend(假裝) your project is much larger than our calc example: suppose it contains a number of subdirectories and many more files. In the course of your work, you may decide that you need to create a working copy that is designed to have specific features and bug fixes. You can accomplish this by selectively backdating(回溯) files or directories to particular revisions (using `svn update -r` liberally(自由地)), or by switching files and directories to particular branches (making use of `svn switch`). When you're done, your working copy is a hodgepodge(雜燴) of repository locations from different revisions. But after testing, you know it's the precise combination of data you need.

Time to make a snapshot. Copying one URL to another won't work here. In this case, you want to make a snapshot of your exact working copy arrangement and store it in the repository. Luckily, `svn copy` actually has four different uses (which you can read about in Chapter 9, Subversion Complete Reference), including the ability to copy a working-copy tree to the repository:

 {{{
$ ls
my-working-copy/
$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag
Committed revision 352.
 }}}
 
Now there is a new directory in the repository, `/calc/tags/mytag`, which is an exact snapshot of your working copy—mixed revisions, URLs, and all.

__Other users have found interesting uses for this feature. Sometimes there are situations where you have a bunch of local changes made to your working copy, and you'd like a collaborator to see them. Instead of running `svn diff` and sending a patch file (which won't capture tree changes, symlink changes or changes in properties), you can instead use `svn copy` to “upload” your working copy to a private area of the repository. Your collaborator can then either check out a verbatim(一字不差的) copy of your working copy, or use `svn merge` to receive your exact changes.__

While this is a nice method for uploading a quick snapshot of your working copy, note that this is not a good way to initially create a branch. Branch creation should be an event onto itself, and this method conflates(合併) the creation of a branch with extra changes to files, all within a single revision. This makes it very difficult (later on) to identify a single revision number as a ''branch point''.

Have you ever found yourself making some complex edits (in your `/trunk` working copy) and suddenly realized, “hey, these changes ought to be in their own branch?” A great technique to do this can be summarized in two steps:

 {{{
$ svn copy http://svn.example.com/repos/calc/trunk \
http://svn.example.com/repos/calc/branches/newbranch
Committed revision 353.
$ svn switch http://svn.example.com/repos/calc/branches/newbranch
At revision 353.
 }}}
 
The `svn switch` command, like `svn update`, preserves your local edits. At this point, your working copy is now a reflection of the newly created branch, and your next `svn commit` invocation will send your changes there.

=== Branch Maintenance ===

__You may have noticed by now that Subversion is extremely flexible. Because it implements branches and tags with the same underlying mechanism (directory copies),__ and because branches and tags appear in normal filesystem space, many people find Subversion intimidating(嚇人的). It's almost too flexible. In this section, we'll offer some suggestions for arranging and managing your data over time.

==== Repository Layout ====

There are some standard, recommended ways to organize a repository. Most people create a `trunk` directory to hold the “main line” of development, a `branches` directory to contain branch copies, and a `tags` directory to contain tag copies. If a repository holds only one project, then often people create these top-level directories:

 {{{
/trunk
/branches
/tags
 }}}
 
If a repository contains multiple projects, admins typically index their layout by project (see the section called “Planning Your Repository Organization” to read more about “project roots”):

 {{{
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
 }}}

Of course, you're free to ignore these common layouts. You can create any sort of variation, whatever works best for you or your team. Remember that whatever you choose, it's not a permanent commitment(約束). You can reorganize your repository at any time. Because branches and tags are ordinary directories, the `svn move` command can move or rename them however you wish. __Switching from one layout to another is just a matter of issuing a series of server-side moves; if you don't like the way things are organized in the repository, just juggle the directories around.__

Remember, though, that while moving directories may be easy to do, you need to be considerate of your users as well. Your juggling can be disorienting to users with existing working copies. __If a user has a working copy of a particular repository directory, your `svn move` operation might remove the path from the latest revision. When the user next runs `svn update`, she will be told that her working copy represents a path that no longer exists, and the user will be forced to `svn switch` to the new location. (這不成問題, 因為 local modifications 會被保留)__

==== Data Lifetimes ====

Another nice feature of Subversion's model is that branches and tags can have finite lifetimes, just like any other versioned item. For example, suppose you eventually finish all your work on your personal branch of the calc project. After merging all of your changes back into `/calc/trunk`, there's no need for your private branch directory to stick around(逗留) anymore:

 {{{
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
-m "Removing obsolete branch of calc project."
Committed revision 375.
 }}}
 
__And now your branch is gone. Of course it's not really gone: '''the directory is simply missing from the HEAD revision, no longer distracting(使人分心) anyone.''' If you use `svn checkout`, `svn switch`, or `svn list` to examine an earlier revision, you'll still be able to see your old branch.__

If browsing your deleted directory isn't enough, you can always bring it back. Resurrecting data is very easy in Subversion. If there's a deleted directory (or file) that you'd like to bring back into HEAD, simply use `svn copy` -r to copy it from the old revision:

 {{{
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
http://svn.example.com/repos/calc/branches/my-calc-branch
Committed revision 376.
 }}}
 
__'''In our example, your personal branch had a relatively short lifetime: you may have created it to fix a bug or implement a new feature. When your task is done, so is the branch.'''__ In software development, though, it's also common to have two “main” branches running side-by-side for very long periods. For example, suppose it's time to release a stable version of the calc project to the public, and you know it's going to take a couple of months to shake bugs out of the software. You don't want people to add new features to the project, but you don't want to tell all developers to stop programming either. So instead, you create a “stable” branch of the software that won't change much: (這只不過就是 release branch 而已)

 {{{
$ svn copy http://svn.example.com/repos/calc/trunk \
http://svn.example.com/repos/calc/branches/stable-1.0 \
-m "Creating stable branch of calc project."
Committed revision 377.
 }}}
 
And now developers are free to continue adding cutting-edge (or experimental) features to `/calc/trunk`, and you can declare a project policy that only bug fixes are to be committed to `/calc/branches/stable-1.0`. That is, as people continue to work on the trunk, a human selectively ports bug fixes over to the stable branch. Even after the stable branch has shipped, you'll probably continue to maintain the branch for a long time—that is, as long as you continue to support that release for customers.

=== Vendor branches ===

[~~~]

=== Summary ===

We've covered a lot of ground in this chapter. We've discussed the concepts of tags and branches, and demonstrated how Subversion implements these concepts by copying directories with the `svn copy` command. We've shown how to use `svn merge` to copy changes from one branch to another, or roll back bad changes. We've gone over the use of `svn switch` to create mixed-location working copies. And we've talked about how one might manage the organization and lifetimes of branches in a repository. 

__Remember the Subversion mantra(聖歌): branches and tags are cheap. So use them liberally! '''At the same time, don't forget to use good ''merging habits''. Cheap copies are only useful when you're careful about tracking your merging actions.'''__

== Chapter 5. Repository Administration ==

The Subversion repository is the central storehouse(儲藏所) of all your versioned data. As such, it becomes an obvious candidate for all the love and attention an administrator can offer. While the repository is generally a low-maintenance item, it is important to understand how to properly configure and care for it so that potential problems are avoided, and actual problems are safely resolved.

In this chapter, we'll discuss how to create and configure a Subversion repository. We'll also talk about repository maintenance, providing examples of how and when to use the `svnlook` and `svnadmin` tools provided with Subversion. We'll address some common questions and mistakes, and give some suggestions on how to arrange(安排) the data in the repository.

If you plan to access a Subversion repository only in the role of a user whose data is under version control (that is, via a Subversion client), you can skip this chapter altogether. However, if you are, or wish to become, a Subversion repository administrator, this chapter is for you. This may sound really prestigious(有威信的) and lofty(傲慢的), but we're just talking about anyone who is interested in that mysterious(神秘的) realm beyond the working copy where everyone's data hangs out.

=== The Subversion Repository, Defined ===

Before jumping into the broader topic of repository administration, let's further define what a repository is. How does it look? How does it feel? Does it take its tea hot or iced, sweetened, and with lemon? __As an administrator, you'll be expected to understand the composition of a repository both from a ''literal, OS-level perspective''—how a repository looks and acts with respect to non-Subversion tools—and from a ''logical perspective''—dealing with how data is represented inside the repository.__

Seen through the eyes of a typical file browser application (such as the Windows Explorer) or command-line based filesystem navigation tools, __the Subversion repository is just another directory full of stuff. There are some subdirectories with human-readable configuration files in them, some subdirectories with some not-so-human-readable data files, and so on. As in other areas of the Subversion design, ''modularity'' is given high regard, and ''hierarchical organization'' is preferred to cluttered chaos(散亂).__ So a shallow(淺薄的) glance into a typical repository from a nuts-and-bolts(實際的) perspective is sufficient to reveal the basic components of the repository:

 {{{
$ ls repos
conf/ dav/ db/ format hooks/ locks/ README.txt
 }}}

Here's a quick fly-by(繞飛) overview of what exactly you're seeing in this directory listing. (Don't get bogged down(停頓) in the terminology—detailed coverage of these components exists elsewhere in this and other chapters.)

 * __`conf`: A directory containing repository configuration files.__
 * `dav`: A directory provided to `mod_dav_svn` for its private housekeeping(內務處理) data.
 * __`db`: The ''data store'' for all of your versioned data.__
 * `format`: A file that contains a single integer that indicates the version number of the repository layout.
 * __`hooks`: A directory full of ''hook script templates'' (and ''hook scripts'' themselves, once you've installed some).__
 * `locks`: A directory for Subversion's repository ''lock files'', used for tracking accessors to the repository.
 * `README.txt`: A file whose contents merely inform(告知) its readers that they are looking at a Subversion repository.

__Of course, when accessed via the Subversion libraries, this otherwise unremarkable(尋常的) collection of files and directories suddenly becomes an implementation of a ''virtual, versioned filesystem'', complete with customizable ''event triggers''. This filesystem has its own notions of directories and files, very similar to the notions of such things held by real filesystems (such as NTFS, FAT32, ext3, and so on). But this is a special filesystem—it hangs(懸掛) these directories and files from revisions, keeping all the changes you've ever made to them safely stored and forever accessible. This is where the entirety(全部) of your versioned data lives.__

=== Strategies for Repository Deployment ===

Due largely to the simplicity of the overall design of the Subversion repository and the technologies on which it relies, creating and configuring a repository are fairly straightforward tasks. There are a few preliminary(初步的) decisions you'll want to make, but the actual work involved in any given setup of a Subversion repository is pretty straightforward, tending towards mindless repetition if you find yourself setting up multiples of these things.

Some things you'll want to consider up front(預先), though, are:

 * What data do you expect to live in your repository (or repositories), and how will that data be organized?
 * Where will your repository live, and how will it be accessed?
 * __What types of ''access control'' and ''repository event reporting'' do you need?__
 * Which of the available types of data store do you want to use?
 
In this section, we'll try to help you answer those questions.

==== Planning Your Repository Organization ====

While Subversion allows you to move around versioned files and directories without any loss of information, and even provides ways of moving whole sets of versioned history from one repository to another, doing so can greatly disrupt(瓦解) the workflow of those who access the repository often and come to expect things to be at certain(一定的) locations. So before creating a new repository, try to peer into(窺視) the future a bit; plan ahead(提前計劃) before placing your data under version control. __By conscientiously(認真地) “laying out” your repository or repositories and their versioned contents ahead of time(提早), you can prevent many future headaches.__

Let's assume that as repository administrator, you will be responsible for supporting the version control system for several projects. Your first decision is whether to use a single repository for multiple projects, or to give each project its own repository, or some compromise of these two.

__There are benefits to using a single repository for multiple projects, most obviously the lack of ''duplicated maintenance''. A single repository means that there is one set of hook programs, one thing to routinely backup, one thing to dump and load if Subversion releases an incompatible new version, and so on. '''Also, you can move data between projects easily, and without losing any historical versioning information. (這是否意謂著, 合併多個 repositories 時一定會丟失歷史記錄[?])'''__

The downside of using a single repository is that different projects may have different requirements in terms of the repository event triggers, such as needing to send commit notification emails to different mailing lists, or having different definitions about what does and does not constitute(構成) a legitimate(合法的) commit. __These aren't insurmountable(不能克服的) problems, of course—it just means that all of your hook scripts have to be sensitive to the layout of your repository rather than assuming that the whole repository is associated with a single group of people. Also, remember that Subversion uses repository-global revision numbers. While those numbers don't have any particular magical powers, some folks still don't like the fact that even though no changes have been made to their project lately(最近), the youngest revision number for the repository keeps climbing(上升的) because other projects are actively adding new revisions.__ Whether founded in ignorance or in poorly considered concepts about how to derive legitimate software development metrics[?], __'''global revision numbers are a silly thing to fear(不值得擔憂而言), and not the kind of thing you should weigh when deciding how to arrange your projects and repositories.'''__

__'''A middle-ground(中庸的) approach can be taken, too. For example, projects can be ''grouped'' by how well they relate to each other.''' You might have a few repositories with a handful of(少數) projects in each repository. That way, projects that are likely to want to share data can do so easily, and as new revisions are added to the repository, at least the developers know that those new revisions are at least remotely related to everyone who uses that repository.__

__例如 http://svn.apache.org/repos/asf/ 是由多個不相干的專案組成 (只因為都是 ASF 的專案, revision 已經來到 720481), 而 http://anonsvn.jboss.org/repos/hibernate/ 則是一個 repository 只放一個大專案 (由許多子專案組成). 其中 JBoss 的規劃方式就屬於上面所提的 "中庸之道", 以下是一些實務上的範例:__

 * simpllibs 應該獨立成一個 repository, 因為底下會有許多 libs 專案.
 * 每一家公司都應該獨立成一個 repository (而不是區分成 simplbug 與 bitstrut), 例如 bscosmos-htltw 與 bazaar, zappy, pasta, shuttle 等案子都應該放在同一個 repository 裡.

After deciding how to organize your projects with respect to repositories, you'll probably want to think about ''directory hierarchies'' within the repositories themselves. __Because Subversion uses regular directory copies for branching and tagging (see Chapter 4, Branching and Merging), the Subversion community recommends that you choose a repository location for each ''project root''—the “top-most” directory which contains data related to that project—and then create three subdirectories beneath that root: `trunk`, meaning the directory under which the main project development occurs; `branches`, which is a directory in which to create various ''named branches'' of the main development line; `tags`, which is a collection of ''tree snapshots'' that are created, and perhaps destroyed, but ''never changed''. The `trunk`, `tags`, and `branches` trio(三件一組) are sometimes referred to as “the TTB directories”. (這就是 [http://svn.apache.org/repos/asf/ Apache Software Foundation] 所採用的架構)__

For example, your repository might look like:

 {{{
/
  calc/
    trunk/
    tags/
    branches/
  calendar/
    trunk/
    tags/
    branches/
  spreadsheet/
    trunk/
    tags/
    branches/
  ...
 }}}

Note that it doesn't matter where in your repository each project root is. If you have only one project per repository, the logical place to put each project root is at the root of that project's respective repository. If you have multiple projects, you might want to arrange them in groups inside the repository, perhaps putting projects with similar goals or shared code in the same subdirectory, or maybe just grouping them alphabetically. Such an arrangement might look like:

 {{{
/
  utils/
    calc/
      trunk/
      tags/
      branches/
    calendar/
      trunk/
      tags/
      branches/
    ...
  office/
    spreadsheet/
      trunk/
      tags/
      branches/
    ...
 }}}
 
Lay out your repository in whatever way you see fit. __Subversion does not expect or enforce a particular layout—in its eyes, a directory is a directory is a directory. Ultimately, you should choose the repository arrangement that meets the needs of the people who work on the projects that live there.__

In the name of full disclosure(披露), though, we'll mention another very common layout. In this layout, the `trunk`, `tags`, and `branches` directories live in the root directory of your repository, and your projects are in subdirectories beneath those, like:

 {{{
/
  trunk/
    calc/
    calendar/
    spreadsheet/
    ...
  tags/
    calc/
    calendar/
    spreadsheet/
    ...
  branches/
    calc/
    calendar/
    spreadsheet/
    ...
 }}}
 
There's nothing particularly incorrect about such a layout, but it may or may not seem as intuitive(直覺的) for your users. Especially in large, multi-project situations with many users, those users may tend to be familiar with only one or two of the projects in the repository. But the projects as-branch-siblings tends to de-emphasize project individuality and focus on the entire set of projects as a single entity. That's a social issue though. __We like our originally suggested arrangement for purely practical reasons—it's easier to ask about (or modify, or migrate elsewhere) the entire history of a single project when there's a single repository path that holds the entire history—past, present, tagged, and branched—for that project and that project alone.__

==== Deciding Where and How to Host Your Repository ====

__Before creating your Subversion repository, an obvious question you'll need to answer is where the thing is going to live. This is strongly connected to a myriad of(許多) other questions involving how the repository will be accessed (via a Subversion server or directly), by whom (users behind your corporate firewall or the whole world out on the open Internet), what other services you'll be providing around Subversion (''repository browsing interfaces'', ''e-mail based commit notification'', etc.), your ''data backup strategy'', and so on.__

We cover server choice and configuration in Chapter 6, Server Configuration, but the point we'd like to briefly make here is simply that the answers to some of these other questions might have implications(牽連) that force your hand when deciding where your repository will live. For example, certain deployment scenarios might require accessing the repository via a remote filesystem from multiple computers, in which case (as you'll read in the next section) your choice of a repository back-end data store turns out not to be a choice at all because only one of the available back-ends will work in this scenario.

Addressing each possible way to deploy Subversion is both impossible, and outside the scope of this book. We simply encourage you to evaluate your options using these pages and other sources as your reference material, and plan ahead.

==== Choosing a Data Store ====

As of version 1.1, Subversion provides two options for the type of underlying data store—often referred to as “the back-end” or, somewhat confusingly, “the (versioned) filesystem”—that each repository uses. One type of data store keeps everything in a Berkeley DB (or BDB) database environment; repositories that use this type are often referred to as being “BDB-backed”. __The other type stores data in ordinary flat files, using a custom format. Subversion developers have adopted the habit of referring to this latter data storage mechanism as FSFS —a versioned filesystem implementation that uses the native OS filesystem directly—rather than via a database library or some other ''abstraction layer''—to store data. (可以由 `db/fs-type` 看出實際採用的 data store, 自 1.2 之後就預設採用較新的 FSFS; [http://svn.collab.net/repos/svn/trunk/notes/fsfs 這裡]有說明它的優缺點)__

Table 5.1, “Repository Data Store Comparison” gives a comparative overview of Berkeley DB and FSFS repositories.

|| Category || Feature || Berkeley DB || FSFS ||
||<|2> Reliability || Data integrity || when properly deployed, extremely reliable; Berkeley DB 4.4 brings auto-recovery || older versions had some rarely demonstrated(證明), but data-destroying bugs ||
|| Sensitivity to interruptions || very; crashes and permission problems can leave the database “wedged(卡住的)”, requiring journaled(每日的) recovery procedures || quite insensitive(這樣比較好) ||
||<|4> Accessibility || Usable from a read-only mount[?] || no || yes ||
|| Platform-independent storage || no || yes (實驗確認, 同一個目錄在 Windows 及 Linux 下都可以直接存取) ||
|| Usable over network filesystems[?] || generally, no || yes ||
|| Group permissions handling || sensitive to user ''umask problems''; best if accessed by only one user || works around umask problems ||
||<|3> Scalability || Repository disk usage || larger (especially if logfiles aren't purged) || smaller ||
|| Number of revision trees || database; no problems || some older native filesystems don't scale well with thousands of entries in a single directory ||
|| Directories with many files || slower || faster ||
||<|2> Performance || Checking out latest revision || no meaningful difference || no meaningful difference ||
|| Large commits || slower overall, but cost is amortized(分期償還) across the lifetime of the commit || faster overall, but ''finalization delay'' may cause client timeouts ||

__There are advantages and disadvantages to each of these two back-end types. '''Neither of them is more “official” than the other, though the newer FSFS is the default data store as of Subversion 1.2. Both are reliable enough to trust with your versioned data.''' But as you can see in Table 5.1, “Repository Data Store Comparison”, the FSFS backend provides quite a bit more flexibility in terms of its supported ''deployment scenarios''. More flexibility means you have to work a little harder to find ways to deploy it incorrectly. Those reasons—plus the fact that not using Berkeley DB means there's one fewer component in the system (少維護一個資料庫而言)—largely explain why '''today almost everyone uses the FSFS backend when creating new repositories.'''__

Fortunately, most programs which access Subversion repositories are blissfully(幸福地) ignorant(ignorant) of which back-end data store is in use. __And you aren't even necessarily stuck with your first choice of a data store—in the event that you change your mind later, Subversion provides ways of migrating your repository's data into another repository that uses a different back-end data store.__ We talk more about that later in this chapter.

The following subsections provide a more detailed look at the available data store types.

===== Berkeley DB =====

When the initial design phase of Subversion was in progress, the developers decided to use Berkeley DB for a variety of reasons, including its open-source license, transaction support, reliability, performance, API simplicity, thread-safety, support for cursors, and so on.

Berkeley DB provides real transaction support—perhaps its most powerful feature. Multiple processes accessing your Subversion repositories don't have to worry about accidentally clobbering(拉垮) each other's data. The isolation provided by the transaction system is such that for any given operation, the Subversion repository code sees a static view of the database—not a database that is constantly changing at the hand of some other process—and can make decisions based on that view. __If the decision made happens to conflict with what another process is doing, the entire operation is rolled back as if it never happened, and Subversion ''gracefully retries'' the operation against a new, updated (and yet still static) view of the database.__

Another great feature of Berkeley DB is ''hot backups''—the ability to backup the database environment without taking it “offline”. We'll discuss how to backup your repository in the section called “Repository Backup”, but the benefits of being able to make fully functional copies of your repositories without any downtime should be obvious.

Berkeley DB is also a very reliable database system when properly used. Subversion uses Berkeley DB's logging facilities, which means that the database first writes to on-disk log files a description of any modifications it is about to make, and then makes the modification itself. This is to ensure that if anything goes wrong, the database system can back up to a previous checkpoint—a location in the log files known not to be corrupt—and replay transactions until the data is restored to a usable state. See the section called “Managing Disk Space” for more about Berkeley DB log files.

But every rose has its thorn(棘), and so we must note some known limitations of Berkeley DB. First, Berkeley DB environments are not portable. You cannot simply copy a Subversion repository that was created on a Unix system onto a Windows system and expect it to work. While much of the Berkeley DB database format is architecture independent, there are other aspects of the environment that are not. Secondly, Subversion uses Berkeley DB in a way that will not operate on Windows 95/98 systems—if you need to house a BDB-backed repository on a Windows machine, stick with Windows 2000 or newer. (這個問題不大)

While Berkeley DB promises to behave correctly on network shares that meet a particular set of specifications (Berkeley DB requires that the underlying filesystem implement strict POSIX locking semantics, and more importantly, the ability to map files directly into process memory.), most networked filesystem types and appliances(裝置) do not actually meet those requirements. And in no case can you allow a BDB-backed repository that resides on a network share to be accessed by multiple clients of that share at once (which quite often is the whole point of having the repository live on a network share in the first place).

Warning: If you attempt to use Berkeley DB on a non-compliant remote filesystem, the results are unpredictable—you may see mysterious errors right away, or it may be months before you discover that your repository database is subtly corrupted. __You should strongly consider using the FSFS data store for repositories that need to live on a ''network share''[?].__

Finally, because Berkeley DB is a ''library linked'' directly into Subversion, it's more sensitive to interruptions than a typical relational database system. Most SQL systems, for example, have a dedicated server process that mediates(斡旋) all access to tables. If a program accessing the database crashes for some reason, the database daemon notices the lost connection and cleans up any mess(混亂) left behind(遺留下來). And because the database daemon is the only process accessing the tables, applications don't need to worry about permission conflicts. __These things are not the case with Berkeley DB, however. Subversion (and programs using Subversion libraries) access the database tables directly, which means that a program crash can leave the database in a temporarily inconsistent, inaccessible state. When this happens, an administrator needs to ask Berkeley DB to restore to a checkpoint, which is a bit of an annoyance. Other things can cause a repository to “wedge” besides crashed processes, such as programs conflicting over ownership and permissions on the database files.__

Note: Berkeley DB 4.4 brings (to Subversion 1.4 and better) the ability for Subversion to automatically and transparently recover Berkeley DB environments in need of such recovery. When a Subversion process attaches to a repository's Berkeley DB environment, it uses some ''process accounting mechanisms'' to detect any unclean disconnections by previous processes, performs any necessary recovery, and then continues on as if nothing happened. This doesn't completely eliminate instances of repository wedging, but it does drastically(大幅度地; 但還是無法完全避免) reduce the amount of human interaction required to recover from them.

__So while a Berkeley DB repository is quite fast and scalable, it's best used by a single server process running as one user—such as Apache's httpd or svnserve (see Chapter 6, Server Configuration)—rather than accessing it as many different users via `file://` or `svn+ssh://` URLs.__ If using a Berkeley DB repository directly as multiple users, be sure to read the section called “Supporting Multiple Repository Access Methods”.

===== FSFS =====

__In mid-2004, a second type of repository storage system—one which doesn't use a database at all—came into being. An FSFS repository stores the changes associated with a revision in a ''single file (=revision file)'', and so all of a repository's revisions can be found in a single subdirectory full of numbered files (檔案系統在單一目錄下所能存放的檔案數目, 可能會有上限). '''Transactions are created in separate subdirectories as individual files. When complete, the ''transaction file'' is renamed and moved into the revisions directory (由 transaction file 轉變成 revision file), thus guaranteeing that commits are ''atomic''.''' And because a ''revision file'' is permanent and unchanging, the repository also can be backed up while “hot”, just like a BDB-backed repository.__

__The FSFS revision files describe a revision's directory structure, file contents, and ''deltas'' against files in other revision trees. Unlike a Berkeley DB database, this storage format is portable across different operating systems and isn't sensitive to CPU architecture. Because there's no journaling or shared-memory files being used, the repository can be safely accessed over a network filesystem and examined in a ''read-only environment''(為什麼一直強調唯讀[?]). The lack of database overhead also means that the overall repository size is a bit smaller.__

__FSFS has different ''performance characteristics'' too. When committing a directory with a huge number of files, FSFS is able to more quickly append directory entries. On the other hand, FSFS writes the latest version of a file as a delta against an earlier version, which means that checking out the latest tree is a bit slower than fetching the fulltexts stored in a Berkeley DB HEAD revision. FSFS also has a longer delay when ''finalizing a commit'', which could in extreme cases cause clients to time out while waiting for a response.__

The most important distinction, however, is FSFS's imperviousness to “wedging” when something goes wrong. If a process using a Berkeley DB database runs into a permissions problem or suddenly crashes, the database can be left in an unusable state until an administrator recovers it. __If the same scenarios happen to a process using an FSFS repository, the repository isn't affected at all. At worst, some transaction data is left behind. (按下面的說法, 這些發生意外的 transaction 並不會對 repository 造成傷害)__

The only real argument against FSFS is its relative immaturity(未成熟) compared to Berkeley DB. Unlike Berkeley DB, which has years of history, its own dedicated development team and, now, Oracle's mighty name attached to it (Oracle bought Sleepycat and its flagship(旗艦) software, Berkeley DB, on Valentine's Day in 2006.), __FSFS is a much newer bit of engineering. Prior to Subversion 1.4, it was still shaking out(抖出) some pretty serious data integrity bugs which, while only triggered in very rare cases, nonetheless(然而) did occur. That said, FSFS has quickly become the back-end of choice for some of the largest public and private Subversion repositories, and promises a lower barrier to entry for Subversion across the board(全面地; 昇級到 1.4 之後就沒什麼問題了!!).__

以下做了一個簡單的實驗, 觀察 `db` 目錄底下檔案的變化:

 {{{
~/tmp$ pwd
/home/sardine/tmp
~/tmp$ svnadmin create repo
~/tmp$ cat repo/db/current
0 1 1
~/tmp$ cat repo/db/revs/0
PLAIN
END
ENDREP
id: 0.0.r0/17
type: dir
count: 0
text: 0 0 4 4 2d2977d1c96f487abe4a1e202dd03b4e
cpath: /


17 107 <-- 這就是所謂的 "position pointer"
~/tmp$ cat repo/db/revprops/0
K 8
svn:date
V 27
2008-07-08T22:20:01.684555Z
END
~/tmp$ svn checkout file:///home/sardine/tmp/repo work
Checked out revision 0.
~/tmp$ cd work
~/tmp/work$ echo 'Hello World' > HelloWorld.txt
~/tmp/work$ svn add HelloWorld.txt
A         HelloWorld.txt
~/tmp/work$ svn commit -m 'say hello to the world.'
Adding         HelloWorld.txt
Transmitting file data .
Committed revision 1.
~/tmp/work$ cat ../repo/db/current
1 2 1
~/tmp/work$ vi ../repo/db/revs/1
DELTA
SVN^A^@^@^L^B^M^A<8c>^LHello World
ENDREP
id: 1.0.r1/37
type: file
count: 0
text: 1 0 24 12 e59ff97941044f85df5297e1c302d260
cpath: /HelloWorld.txt
copyroot: 0 /

PLAIN
K 14
HelloWorld.txt
V 14
file 1.0.r1/37
END
ENDREP
id: 0.0.r1/215
type: dir
pred: 0.0.r0/17
count: 1
text: 1 158 44 44 8ecbce03bc7c751f41a3a669960b9a6a
cpath: /
copyroot: 0 /

_0.0.t0-1 add true false /HelloWorld.txt


215 340
~/tmp/work$ cat ../repo/db/revprops/1
K 10
svn:author
V 7
sardine
K 8
svn:date
V 27
2008-07-08T22:26:01.971049Z
K 7
svn:log
V 23
say hello to the world.
END
~/tmp/work$ mkdir trunk branches tags
~/tmp/work$ svn add trunk branches tags
A         trunk
A         branches
A         tags
~/tmp/work$ svn commit -m ''
Adding         branches
Adding         tags
Adding         trunk

Committed revision 2.
~/tmp/work$ cat ../repo/db/current
2 3 2
~/tmp/work$ cat ../repo/db/revs/2
id: 4.0.r2/0
type: dir
count: 0
cpath: /trunk
copyroot: 0 /

id: 2.0.r2/61
type: dir
count: 0
cpath: /branches
copyroot: 0 /

id: 3.0.r2/126
type: dir
count: 0
cpath: /tags
copyroot: 0 /

PLAIN
K 14
HelloWorld.txt
V 14
file 1.0.r1/37
K 8
branches
V 13
dir 2.0.r2/61
K 4
tags
V 14
dir 3.0.r2/126
K 5
trunk
V 12
dir 4.0.r2/0
END
ENDREP
id: 0.0.r2/334
type: dir
pred: 0.0.r1/215
count: 2
text: 2 188 133 133 8e05e2e64ac8a25634be032aec9c15d7
cpath: /
copyroot: 0 /

_2.0.t1-1 add false false /trunk

_0.0.t1-1 add false false /branches

_1.0.t1-1 add false false /tags


334 462
~/tmp/work$ cat ../repo/db/revprops/
K 10
svn:author
V 7
sardine
K 8
svn:date
V 27
2008-07-08T22:52:12.208805Z
K 7
svn:log
V 0

END
~/tmp/work$ svn move HelloWorld.txt trunk
A         trunk/HelloWorld.txt
D         HelloWorld.txt
~/tmp/work$ svn commit -m ''
Deleting       HelloWorld.txt
Adding         trunk/HelloWorld.txt

Committed revision 3.
~/tmp/work$ cat ../repo/db/current
3 4 3
~/tmp/work$ cat ../repo/db/revs/3
id: 1.1.r3/0
type: file
pred: 1.0.r1/37
count: 1
text: 1 0 24 12 e59ff97941044f85df5297e1c302d260
cpath: /trunk/HelloWorld.txt
copyfrom: 1 /HelloWorld.txt

PLAIN
K 14
HelloWorld.txt
V 13
file 1.1.r3/0
END
ENDREP
id: 4.0.r3/212
type: dir
pred: 4.0.r2/0
count: 1
text: 3 156 43 43 8a6f1ce9da4a66ef328a9ef96c7020b0
cpath: /trunk
copyroot: 0 /

PLAIN
K 8
branches
V 13
dir 2.0.r2/61
K 4
tags
V 14
dir 3.0.r2/126
K 5
trunk
V 14
dir 4.0.r3/212
END
ENDREP
id: 0.0.r3/449
type: dir
pred: 0.0.r2/334
count: 3
text: 3 341 95 95 95383d4a8c778f573cd4ded77f645de0
cpath: /
copyroot: 0 /

1.0.r1/37 delete false false /HelloWorld.txt

1._0.t2-1 add false false /trunk/HelloWorld.txt
1 /HelloWorld.txt

449 575
~/tmp/work$ cat ../repo/db/revprops/3
K 10
svn:author
V 7
sardine
K 8
svn:date
V 27
2008-07-08T23:05:49.491676Z
K 7
svn:log
V 0

END
~/tmp/work$ svn copy trunk tags/1.0
A         tags/1.0
sardine@sardine-laptop:~/tmp/work$ svn commit -m ''
Adding         tags/1.0
Adding         tags/1.0/HelloWorld.txt

Committed revision 4.
~/tmp/work$ cat ../repo/db/current
4 5 4
~/tmp/work$ cat ../repo/db/revs/4
id: 1.3.r4/0
type: file
pred: 1.1.r3/0
count: 2
text: 1 0 24 12 e59ff97941044f85df5297e1c302d260
cpath: /tags/1.0/HelloWorld.txt
copyfrom: 3 /trunk/HelloWorld.txt

PLAIN
K 14
HelloWorld.txt
V 13
file 1.3.r4/0
END
ENDREP
id: 4.2.r4/220
type: dir
pred: 4.0.r2/0
count: 1
text: 4 164 43 43 4089f81f6e50904b2f302f24d8606cf9
cpath: /tags/1.0
copyfrom: 2 /trunk

PLAIN
K 3
1.0
V 14
dir 4.2.r4/220
END
ENDREP
id: 3.0.r4/402
type: dir
pred: 3.0.r2/126
count: 1
text: 4 357 32 32 c691579a221d170644064e41f54a6b79
cpath: /tags
copyroot: 0 /

PLAIN
K 8
branches
V 13
dir 2.0.r2/61
K 4
tags
V 14
dir 3.0.r4/402
K 5
trunk
V 14
dir 4.0.r3/212
END
ENDREP
id: 0.0.r4/640
type: dir
pred: 0.0.r3/449
count: 4
text: 4 532 95 95 47b7b2a5d30adad71dfbe0d6e3fe267f
cpath: /
copyroot: 0 /

1._1.t3-1 add false false /tags/1.0/HelloWorld.txt
3 /trunk/HelloWorld.txt
4._0.t3-1 add false false /tags/1.0
2 /trunk

640 766
~/tmp/work$ cat ../repo/db/revprops/4
K 10
svn:author
V 7
sardine
K 8
svn:date
V 27
2008-07-08T23:07:36.923077Z
K 7
svn:log
V 0

END
~/tmp/work$ svn copy file:///home/sardine/tmp/repo/trunk file:///home/sardine/tmp/repo/tags/2.0 -m ''

Committed revision 5.
~/tmp/work$ cat ../repo/db/current
5 5 5
~/tmp/work$ cat ../repo/db/revs/5
id: 4.4.r5/0
type: dir
pred: 4.0.r3/212
count: 2
text: 3 156 43 43 8a6f1ce9da4a66ef328a9ef96c7020b0
cpath: /tags/2.0
copyfrom: 4 /trunk

PLAIN
K 3
1.0
V 14
dir 4.2.r4/220
K 3
2.0
V 12
dir 4.4.r5/0
END
ENDREP
id: 3.0.r5/208
type: dir
pred: 3.0.r4/402
count: 2
text: 5 137 58 58 eee1a7b0bf5f886164b82305c63a82e1
cpath: /tags
copyroot: 0 /

PLAIN
K 8
branches
V 13
dir 2.0.r2/61
K 4
tags
V 14
dir 3.0.r5/208
K 5
trunk
V 14
dir 4.0.r3/212
END
ENDREP
id: 0.0.r5/446
type: dir
pred: 0.0.r4/640
count: 5
text: 5 338 95 95 99df545f74a711c46ab4c43a4494015b
cpath: /
copyroot: 0 /

4._0.t4-1 add false false /tags/2.0
4 /trunk

446 572
~/tmp/work$ cat ../repo/db/revprops/5
K 10
svn:author
V 7
sardine
K 8
svn:date
V 27
2008-07-09T01:26:31.377033Z
K 7
svn:log
V 0

END
~/tmp/work$ echo 'Hello Sardine' > trunk/HelloWorld.txt
~/tmp/work$ svn commit -m ''
Sending        trunk/HelloWorld.txt
Transmitting file data .
Committed revision 6.
~/tmp/work$ vi ../repo/db/revs/6
DELTA 1 0 24
SVN^A^@^L^N^B^O^A<8e>^NHello Sardine
ENDREP
id: 1.1.r6/46
type: file
pred: 1.1.r3/0
count: 2
text: 6 0 26 14 067b7ed42eefccf2932d304ac84f8f05
cpath: /trunk/HelloWorld.txt
copyroot: 3 /trunk/HelloWorld.txt

PLAIN
K 14
HelloWorld.txt
V 14
file 1.1.r6/46
END
ENDREP
id: 4.0.r6/265
type: dir
pred: 4.0.r3/212
count: 2
text: 6 208 44 44 c304b450a827e9b0f041705c43dc76e2
cpath: /trunk
copyroot: 0 /

PLAIN
K 8
branches
V 13
dir 2.0.r2/61
K 4
tags
V 14
dir 3.0.r5/208
K 5
trunk
V 14
dir 4.0.r6/265
END
ENDREP
id: 0.0.r6/504
type: dir
pred: 0.0.r5/446
count: 6
text: 6 396 95 95 d2ae41e9aa66bdd134470c108bfe256d
cpath: /
copyroot: 0 /

1.1.t5-1 modify true false /trunk/HelloWorld.txt


504 630
~tmp/work$ cd ..
~tmp$ 將 ../repo/db/revs/4 裡下面這一段 "動作" 拿掉
1._1.t3-1 add false false /tags/1.0/HelloWorld.txt
3 /trunk/HelloWorld.txt
4._0.t3-1 add false false /tags/1.0
2 /trunk
~tmp$ svnadmin verify repo
* Verified revision 0.
* Verified revision 1.
* Verified revision 2.
* Verified revision 3.
* Verified revision 4.
* Verified revision 5.
* Verified revision 6.
~tmp$ svnadmin dump repo > repo.dump
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
* Dumped revision 4.
* Dumped revision 5.
* Dumped revision 6.
~tmp$ svnadmin create repo2
~tmp$ svnadmin load repo2 < repo.dump
<<< Started new transaction, based on original revision 1
     * adding path : HelloWorld.txt ... done.

------- Committed revision 1 >>>

<<< Started new transaction, based on original revision 2
     * adding path : branches ... done.
     * adding path : tags ... done.
     * adding path : trunk ... done.

------- Committed revision 2 >>>

<<< Started new transaction, based on original revision 3
     * adding path : trunk/HelloWorld.txt ...COPIED... done.
     * deleting path : HelloWorld.txt ... done.

------- Committed revision 3 >>>

<<< Started new transaction, based on original revision 4 <-- transaction 4 沒有異動

------- Committed revision 4 >>>

<<< Started new transaction, based on original revision 5
     * adding path : tags/2.0 ...COPIED... done.

------- Committed revision 5 >>>

<<< Started new transaction, based on original revision 6
     * editing path : trunk/HelloWorld.txt ... done.

------- Committed revision 6 >>>
~/tmp$ svn checkout file:///home/sardine/tmp/repo/tags/1.0 work-1.0
A    work-1.0/HelloWorld.txt
Checked out revision 6. <-- tags/1.0 竟然還在存, 用 Subclipse 去觀察 repository 時發現, 1.0 的分支確實存在, 但 log 是空的

 }}}

=== Creating and Configuring Your Repository ===

In the section called “Strategies for Repository Deployment”, we looked at some of the important decisions that should be made before creating and configuring your Subversion repository. Now, we finally get to get our hands dirty! In this section, we'll see how to actually create a Subversion repository and configure it to perform custom actions when special repository events occur.

==== Creating the Repository ====

Subversion repository creation is an incredibly(難以置信地) simple task. The `svnadmin` utility that comes with Subversion provides a subcommand (`create`) for doing just that.

 {{{
$ svnadmin create /path/to/repos
 }}}

__This creates a new repository in the directory `/path/to/repos`, and with the default filesystem data store. '''Prior to Subversion 1.2, the default was to use Berkeley DB; the default is now FSFS.''' You can explicitly choose the filesystem type using the `--fs-type` argument, which accepts as a parameter either `fsfs` or `bdb`.__

 {{{
$ # Create an FSFS-backed repository
$ svnadmin create --fs-type fsfs /path/to/repos
$
 }}}

 {{{
# Create a Berkeley-DB-backed repository
$ svnadmin create --fs-type bdb /path/to/repos
$
 }}}

After running this simple command, you have a Subversion repository.

The path argument to `svnadmin` is just a regular filesystem path and not a URL like the svn client program uses when referring to repositories. __Both `svnadmin` and `svnlook` are considered ''server-side utilities''—they are used on the machine where the repository resides to examine or modify aspects of the repository, and are in fact unable to perform tasks across a network. A common mistake made by Subversion newcomers is trying to pass URLs (even “local” `file://` ones) to these two programs.__

__Present in the `db/` subdirectory of your repository is the implementation of the versioned filesystem. '''Your new repository's versioned filesystem begins life at revision 0, which is defined to consist of nothing but the top-level root (`/`) directory.''' Initially, revision 0 also has a single revision property, `svn:date`, set to the time at which the repository was created.__

Now that you have a repository, it's time to customize it.

__Warning: While some parts of a Subversion repository—such as the configuration files and hook scripts—are meant to be examined and modified manually, you shouldn't (and shouldn't need to) tamper with(瞎搞) the other parts of the repository “by hand”. The `svnadmin` tool should be sufficient for any changes necessary to your repository, or you can look to third-party tools (such as Berkeley DB's tool suite) for tweaking relevant subsections of the repository. Do not attempt manual manipulation of your version control history by poking and prodding around(閒逛) in your repository's data store files!__

==== Implementing Repository Hooks ====

__A ''hook'' is a program ''triggered'' by some ''repository event'', such as the creation of a new revision or the modification of an ''unversioned property''[?]. '''Some hooks (the so-called “pre hooks”) run in advance of a repository operation and provide a means by which to both report what is about to happen and to prevent it from happening at all. Other hooks (the “post hooks”) run after the completion of a repository event, and are useful for performing tasks that examine—but don't modify—the repository.''' Each hook is handed enough information to tell what that event is (or was), the specific repository changes proposed (or completed), and the username of the person who triggered the event. (以命令列參數的方式傳入)__

The `hooks` subdirectory is, by default, filled with ''templates'' for various repository hooks.

 {{{
$ ls repos/hooks/
post-commit.tmpl post-unlock.tmpl pre-revprop-change.tmpl
post-lock.tmpl pre-commit.tmpl pre-unlock.tmpl
post-revprop-change.tmpl pre-lock.tmpl start-commit.tmpl
 }}}
 
__There is one template for each hook that the Subversion repository supports, and by examining the contents of those template scripts, you can see ''what triggers'' (指 repository event 而言) each script to run and what data is passed to that script. Also present in many of these templates are examples of how one might use that script, in conjunction with other Subversion-supplied programs, to perform common useful tasks. '''To actually install a ''working hook'', you need only place some executable program or script into the `repos/hooks` directory which can be executed as the name (like `start-commi`t or `post-commit`) of the hook. (特定 repository event 發生時, 只有特定檔名的程式會被呼叫; 這些程式的名稱, 就是所謂的 "hook name")'''__

__在 `post-commit.tmpl` 裡有這麼一段 - "Subversion runs this hook by invoking a program (script, executable, binary, etc.) named 'pre-commit' ... On a Unix system, the normal procedure is to have 'pre-commit' invoke other programs to do the real work, though it may do the work itself too". 由此可見, '''一個 event 只對應一個 hook, 而這個 hook 可以再往外呼叫...'''__

On Unix platforms, this means supplying a script or program (which could be a shell script, a Python program, a compiled C binary, or any number of other things) named exactly like the ''name of the hook''. Of course, the template files are present for more than just informational purposes—the easiest way to install a hook on Unix platforms is to simply copy the appropriate template file to a new file that lacks the `.tmpl` extension, customize the hook's contents, and ensure that the script is ''executable''. Windows, however, uses file extensions to determine whether or not a program is executable, so you would need to supply a program whose basename is the name of the hook, and whose extension is one of the special extensions recognized by Windows for executable programs, such as `.exe` for programs, and `.bat` for batch files.

__For security reasons, the Subversion repository executes hook programs with an ''empty environment''—that is, no environment variables are set at all, not even `$PATH` (or `%PATH%`, under Windows). Because of this, many administrators are baffled(困惑) when their hook program runs fine by hand, but doesn't work when run by Subversion. '''Be sure to explicitly set any necessary environment variables in your hook program and/or use absolute paths to programs.'''__

__'''Subversion executes hooks as the same user who owns the process which is accessing the Subversion repository. In most cases, the repository is being accessed via a Subversion server, so this user is the same user as which that server runs on the system.''' The hooks themselves will need to be configured with ''OS-level permissions'' that allow that user to execute them. Also, this means that any file or programs (including the Subversion repository itself) accessed directly or indirectly by the hook will be accessed as the same user. In other words, be alert(留心的) to potential permission-related problems that could prevent the hook from performing the tasks it is designed to perform.__

There are nine hooks implemented by the Subversion repository, and you can get details about each of them in the section called “Repository Hooks”. __As a repository administrator, you'll need to decide which of hooks you wish to implement (是否要對特定的 events 做出回應而言; by way of providing an appropriately named and permissioned hook program), and how. When you make this decision, keep in mind the big picture of how your repository is deployed. '''For example, if you are using ''server configuration'' to determine which users are permitted to commit changes to your repository, then you don't need to do this sort of access control via the ''hook system''.''' (如果可以透過組態來完成的工作, 就不要再用 hook 重寫)__

There is no shortage of Subversion hook programs and scripts freely available either from the Subversion community itself or elsewhere. __These scripts cover a wide range of utility—basic access control (這一段一般會留給 server configuration 做), ''policy adherence checking'', ''issue tracker integration'', email- or syndication-based commit notification, and beyond.__ See Appendix D, Third Party Tools for discussion of some of the most commonly used hook programs. Or, if you wish to write your own, see Chapter 8, Embedding Subversion.

While hook scripts can do almost anything, there is one dimension in which hook script authors should show restraint(自制): do not modify a commit transaction using hook scripts. While it might be tempting to use hook scripts to automatically correct errors or shortcomings or policy violations present in the files being committed, doing so can cause problems. Subversion keeps client-side caches of certain bits of repository data, and if you change a commit transaction in this way, those caches become indetectably(不易發現的) stale. This inconsistency can lead to surprising and unexpected behavior. __Instead of modifying the transaction, you should simply validate the transaction in the `pre-commit` hook and reject the commit if it does not meet the desired requirements. As a bonus, your users will learn the value of careful, compliance- minded(有心的) work habits.__

=== Repository Maintenance ===

Maintaining a Subversion repository can be daunting(使人畏縮的), mostly due to the complexities inherent in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield(熟練地操作) them to accomplish tasks such as repository data migration, upgrades, backups and cleanups.

==== An Administrator's Toolkit ====

Subversion provides a handful of utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools.

===== svnadmin =====

The `svnadmin` program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of `svnadmin` is similar to that of other Subversion command-line programs:

 {{{
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS & OPTIONS ...]
Type 'svnadmin help <subcommand>' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
...
 }}}

We've already mentioned `svnadmin`'s `create` subcommand (see the section called “Creating the Repository”). Most of the others we will cover later in this chapter. And you can consult the section called “svnadmin” for a full rundown(摘要) of subcommands and what each of them offers.

===== svnlook =====

__'''`svnlook` is a tool provided by Subversion for examining the various ''revisions'' and ''transactions'' (which are revisions in-the-making(在形成中)) in a repository. No part of this program attempts to change the repository.''' `svnlook` is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the `pre-commit` hook) or that were just committed (in the case of the `post-commit` hook) to the repository.__ A repository administrator may use this tool for diagnostic purposes.

`svnlook` has a straightforward syntax:

 {{{
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS & OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help <subcommand>' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
...
 }}}

Nearly every one of `svnlook`'s subcommands can operate on either a revision or a transaction tree, printing information about the tree itself, or how it differs from the previous revision of the repository. You use the `--revision` (`-r`) and `--transaction` (`-t`) options to specify which revision or transaction, respectively, to examine. In the absence of both the `--revision` (`-r`) and `--transaction` (`-t`) options, svnlook will examine the ''youngest'' (or “HEAD”) revision in the repository. So the following two commands do exactly the same thing when 19 is the youngest revision in the repository located at `/path/to/repos`:

 {{{
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos -r 19
 }}}

The only exception to these rules about subcommands is the `svnlook youngest` subcommand, which takes no options, and simply prints out the repository's youngest revision number.

 {{{
$ svnlook youngest /path/to/repos
19
 }}}

__'''Note: Keep in mind that the only transactions you can browse are uncommitted ones. (只有在 hook 裡才有可能碰到這種狀況, 或者 dead transactions) Most repositories will have no such transactions, because transactions are usually either committed (in which case, you should access them as revision with the `--revision` (`-r`) option) or aborted and removed.'''__

Output from `svnlook` is designed to be both human- and ''machine-parsable''. Take as an example the output of the `info` subcommand:

 {{{
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
 }}}

The output of the `info` subcommand is defined as:

 1. The author, followed by a newline.
 2. The date, followed by a newline.
 3. The number of characters in the log message, followed by a newline.
 4. The log message itself, followed by a newline.

This output is human-readable, meaning items like the datestamp are displayed using a textual representation instead of something more obscure (such as the number of nanoseconds since the Tasty Freeze guy drove by). But the output is also machine-parsable—because the log message can contain multiple lines and be unbounded(無限制的) in length, __`svnlook` provides the length of that message before the message itself. This allows scripts and other wrappers around this command to make intelligent decisions about the log message,__ such as how much memory to allocate for the message, or at least how many bytes to skip in the event that this output is not the last bit of data in the stream.

`svnlook` can perform a variety of other queries: displaying subsets of bits of information we've mentioned previously, recursively listing versioned directory trees, reporting which paths were modified in a given revision or transaction, showing textual and property differences made to files and directories, and so on. See the section called “svnlook” for a full reference of `svnlook`'s features.

===== svndumpfilter =====

__While it won't be the most commonly used tool at the administrator's disposal(支配), `svndumpfilter` provides a very particular brand of useful functionality—the ability to quickly and easily ''modify'' streams(=repository dump streams) of Subversion repository history data by acting as a ''path-based filter''.__

The syntax of `svndumpfilter` is as follows:

 {{{
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS & OPTIONS ...]
Type "svndumpfilter help <subcommand>" for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
 }}}

There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream:

 * `exclude`: Filter out a set of paths from the dump data stream.
 * `include`: Allow only the requested set of paths to pass through the dump data stream.

You can learn more about these subcommands and `svndumpfilter`'s unique purpose in the section called “Filtering Repository History”.

===== svnsync =====

The `svnsync` program, which is new to the 1.4 release of Subversion, provides all the functionality required for maintaining a ''read-only mirror'' of a Subversion repository. The program really has one job—to transfer one repository's versioned history into another repository. And while there are few ways to do that, its primary strength is that it can operate remotely—the “source” and “sink”(=sync) repositories may be on different computers from each other and from `svnsync` itself.

As you might expect, `svnsync` has a syntax that looks very much like every other program we've mentioned in this chapter:

 {{{
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS & OPTIONS ...]
Type 'svnsync help <subcommand>' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
 }}}

We talk more about replication repositories with `svnsync` in the section called “Repository Replication”.

==== Commit Log Message Correction(更正) ====

__Sometimes a user will have an error in her log message (a misspelling or some misinformation(誤報), perhaps). If the repository is configured (using the `pre-revprop-change` hook; see the section called “Implementing Repository Hooks”) to accept changes to this log message after the commit is finished, then the user can “fix” her log message remotely using the `svn` program's `propset` command (see [http://svnbook.red-bean.com/en/1.4/svn.ref.svn.c.propset.html svn propset]). However, because of the potential to lose information forever, Subversion repositories are not, by default, configured to allow changes to ''unversioned properties''—except by an administrator.__

If a log message needs to be changed by an administrator, this can be done using `svnadmin setlog`. This command changes the log message (the `svn:log` property) on a given revision of a repository, reading the new value from a provided file.

 {{{
$ echo "Here is the new, correct log message" > newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
 }}}

The `svnadmin setlog` command, by default, is still bound by the same protections against modifying unversioned properties as a remote client is—the `pre-` and `post-revprop-change` hooks are still triggered, and therefore must be set up to accept changes of this nature. But an administrator can get around these protections by passing the `--bypass-hooks` option to the `svnadmin setlog` command.

Warning: Remember, though, that by bypassing the hooks, you are likely avoiding such things as email notifications of property changes, backup systems which track unversioned property changes, and so on. In other words, be very careful about what you are changing, and how you change it.

==== Managing Disk Space ====

While the cost of storage has dropped incredibly(非常地) in the past few years, disk usage is still a valid concern for administrators seeking to version large amounts of data. Every bit of version history information stored in the live repository needs to be backed up elsewhere, perhaps multiple times as part of ''rotating backup schedules''. It is useful to know what pieces of Subversion's repository data need to remain on the live site, which need to be backed up, and which can be safely removed.

===== How Subversion saves disk space =====

__To keep the repository small, Subversion uses ''deltification (or, “deltified storage”)'' within the repository itself. Deltification involves encoding the representation of a chunk of data as a collection of ''differences'' against some other chunk of data. If the two pieces of data are very similar, this deltification results in storage savings for the ''deltified chunk''—rather than taking up space equal to the size of the original data, '''it takes up only enough space to say, “I look just like this other piece of data over here, except for the following couple of changes”.''' The result is that most of the repository data that tends to be bulky—namely(笨重的), the contents of versioned files—is stored at a much smaller size than the original “fulltext” representation of that data. '''And for repositories created with Subversion 1.4 or later, the space savings are even better—now those fulltext representations of file contents are themselves compressed.'''__

Note: Because all of the data that is subject to deltification in a BDB-backed repository is stored in a single Berkeley DB database file, reducing the size of the stored values will not immediately reduce the size of the database file itself. Berkeley DB will, however, keep internal records of unused areas of the database file, and consume those areas first before growing the size of the database file. So while deltification doesn't produce immediate space savings, it can drastically slow future growth of the database.

===== Removing dead transactions =====

__Though they are uncommon, there are circumstances in which a Subversion commit process might fail, leaving behind in the repository the remnants(殘留) of the revision-to-be that wasn't—an uncommitted transaction and all the file and directory changes associated with it. This could happen for several reasons: perhaps the client operation was inelegantly terminated by the user, or a network failure occurred in the middle of an operation. Regardless of the reason, dead transactions can happen. '''They don't do any real harm, other than consuming disk space.''' A fastidious(挑剔的) administrator may nonetheless wish to remove them.__

You can use `svnadmin`'s `lstxns` command to list the names of the currently outstanding(未完成的) transactions.

 {{{
$ svnadmin lstxns myrepos
19
3a1
a45
$
 }}}

Each item in the resultant output can then be used with `svnlook` (and its `--transaction` (`-t`) option) to determine who created the transaction, when it was created, what types of changes were made in the transaction—information that is helpful in determining whether or not the transaction is a safe candidate for removal! If you do indeed want to remove a transaction, its name can be passed to `svnadmin rmtxns`, which will perform the cleanup of the transaction. In fact, the `rmtxns` subcommand can take its input directly from the output of `lstxns`!

 {{{
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
 }}}

If you use these two subcommands like this, you should consider making your repository temporarily inaccessible to clients. That way, no one can begin a legitimate(正當的) transaction before you start your cleanup. Example 5.1, “txn-info.sh (Reporting Outstanding Transactions)” contains a bit of shell-scripting that can quickly generate information about each outstanding transaction in your repository.

Example 5.1. `txn-info.sh` (Reporting Outstanding Transactions)

 {{{
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done


The output of the script is basically a concatenation of several chunks of svnlook info output (see the section called “svnlook”), and will look something like:

$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
 }}}

A long-abandoned transaction usually represents some sort of failed or interrupted commit. A transaction's datestamp can provide interesting information—for example, how likely is it that an operation begun nine months ago is still active?

In short, transaction cleanup decisions need not be made unwisely(魯莽地). Various sources of information—including Apache's error and access logs, Subversion's operational logs, Subversion revision history, and so on—can be employed in the decision-making process. And of course, an administrator can often simply communicate with a seemingly(表面上) dead transaction's owner (via email, for example) to verify that the transaction is, in fact, in a ''zombie(僵屍) state''.

==== Migrating Repository Data Elsewhere ====

A Subversion filesystem has its data spread throughout files in the repository, in a fashion generally understood by (and of interest to) only the Subversion developers themselves. However, circumstances may arise that call for all, or some subset, of that data to be copied or moved into another repository.

__Subversion provides such functionality by way of ''repository dump streams''. A repository dump stream (often referred to as a “dumpfile” when stored as a file on disk) is a portable, flat file format that describes the various revisions in your repository—what was changed, by whom, when, and so on. This dump stream is the primary mechanism used to ''marshal'' versioned history—in whole or in part, with or without modification—between repositories. And Subversion provides the tools necessary for creating and loading these dump streams—the `svnadmin dump` and `svnadmin load` subcommands, respectively.__

__Warning: While the Subversion repository dump format contains ''human-readable'' portions and a familiar structure (it resembles an [http://www.ietf.org/rfc/rfc0822.txt RFC-822] format, the same type of format used for most email), it is not a plaintext file format. It is a ''binary file format'', highly sensitive to meddling(干預). For example, many text editors will corrupt the file by automatically converting line endings. (注意 dump file 是二進位檔, 不過有些部份是可讀的; 實驗發現, 即便用 vi 開起來只修改可讀的部份回存, 後續使用時還是會出現 "svnadmin: Found malformed header in revision file" 的錯誤)__

There are many reasons for dumping and loading Subversion repository data. Early in Subversion's life, the most common reason was due to the evolution of Subversion itself. As Subversion matured, there were times when changes made to the back-end database schema caused compatibility issues with previous versions of the repository, so users had to dump their repository data using the previous version of Subversion, and load it into a freshly created repository with the new version of Subversion. __Now, these types of ''schema changes'' haven't occurred since Subversion's 1.0 release, and the Subversion developers promise not to force users to dump and load their repositories when upgrading between minor versions (such as from 1.3 to 1.4) of Subversion.__ But there are still other reasons for dumping and loading, including re-deploying a Berkeley DB repository on a new OS or CPU architecture, switching between the Berkeley DB and FSFS back-ends, or (as we'll cover in the section called “Filtering Repository History”) purging versioned data from repository history.

Whatever your reason for migrating repository history, using the `svnadmin dump` and `svnadmin load` subcommands is straightforward. __`svnadmin dump` will output a range of repository revisions that are formatted using Subversion's custom filesystem dump format. '''The dump format is printed to the ''standard output'' stream, while informative messages are printed to the ''standard error'' stream. This allows you to redirect the output stream to a file while watching the status output in your terminal window. (原來 standard error 可以這樣用!!)''' For example:__

 {{{
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos > dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
...
* Dumped revision 25.
* Dumped revision 26.
 }}}

At the end of the process, you will have a single file (dumpfile in the previous example) that contains all the data stored in your repository in the requested range of revisions. __Note that `svnadmin dump` is reading revision trees from the repository just like any other “reader” process would (`svn checkout`, for example), so it's safe to run this command at any time.__

__The other subcommand in the pair, `svnadmin load`, parses the ''standard input'' stream as a Subversion repository dump file, and effectively ''replays'' those dumped revisions into the target repository for that operation.__ It also gives informative feedback, this time using the standard output stream:

 {{{
$ svnadmin load newrepos < dumpfile
<<< Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     ...
------- Committed new rev 1 (loaded from original rev 1) >>>

<<< Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) >>>

...

<<< Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) >>>

<<< Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) >>>
 }}}

__'''The result of a load is ''new revisions'' added to a repository—the same thing you get by making commits against that repository from a regular Subversion client.'''__ And just as in a commit, you can use hook programs to perform actions before and after each of the commits made during a load process. By passing the `--use-pre-commit-hook` and `--use-post-commit-hook` options to `svnadmin load`, you can instruct Subversion to execute the `pre-commit` and `post-commit` hook programs, respectively, for each loaded revision. You might use these, for example, to ensure that loaded revisions pass through the same validation steps that regular commits pass through. Of course, you should use these options with care—if your `post-commit` hook sends emails to a mailing list for each new commit, you might not want to spew hundreds or thousands of commit emails in rapid succession at that list! You can read more about the use of hook scripts in the section called “Implementing Repository Hooks”.

Note that because `svnadmin` uses standard input and output streams for the repository dump and load process, people who are feeling especially saucy can try things like this (perhaps even using different versions of `svnadmin` on each side of the pipe):

 {{{
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
 }}}

__By default, the dump file will be quite large—much larger than the repository itself. That's because by default every version of every file is expressed(解壓縮; 搭配 "a range of revisions" 時, 可能檔案有多個 revisions, 造成 dump file 大小成偣數增長) as a full text in the dump file. This is the fastest and simplest behavior, and nice if you're piping the dump data directly into some other process (such as a compression program, filtering program, or into a loading process). '''But if you're creating a dump file for longer-term storage, you'll likely want to save disk space by using the `--deltas` option. With this option, ''successive revisions'' of files will be output as ''compressed, binary differences''—just as file revisions are stored in a repository.''' This option is slower, but results in a dump file much closer in size to the original repository.__

We mentioned previously that `svnadmin dump` outputs a range of revisions. Use the `--revision` (`-r`) option to specify a single revision to dump, or a range of revisions. If you omit this option, all the existing repository revisions will be dumped.

 {{{
$ svnadmin dump myrepos -r 23 > rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 > revs-100-200.dumpfile
 }}}

__As Subversion dumps each new revision, it outputs only enough information to allow a future loader to ''re-create'' that revision based on the previous one. In other words, for any given revision in the dump file, only the items that were changed in that revision will appear in the dump. The only exception to this rule is the first revision(做為後續差異的基準) that is dumped with the current `svnadmin dump` command.__

By default, Subversion will not express the first dumped revision as merely differences to be applied to the previous revision. For one thing, there is no previous revision in the dump file! And secondly, Subversion cannot know the state of the repository into which the dump data will be loaded (if it ever is). __'''To ensure that the output of each execution of `svnadmin dump` is ''self-sufficient'', the first dumped revision is by default a full representation of every directory, file, and property in that revision of the repository.'''__

__However, you can change this default behavior. If you add the `--incremental` option when you dump your repository, `svnadmin` will compare the first dumped revision against the previous revision in the repository, the same way it treats every other revision that gets dumped. It will then output the first revision exactly as it does the rest of the revisions in the dump range—mentioning only the changes that occurred in that revision. '''The benefit of this is that you can create several small dump files that can be loaded in succession, instead of one large one, (因此 load 的起點, 必須與 dump 時相同)''' like so:__

 {{{
$ svnadmin dump myrepos -r 0:1000 > dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental > dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental > dumpfile3
 }}}

These dump files could be loaded into a new repository with the following command sequence:

 {{{
$ svnadmin load newrepos < dumpfile1
$ svnadmin load newrepos < dumpfile2
$ svnadmin load newrepos < dumpfile3
 }}}

Another neat(巧妙的) trick you can perform with this `--incremental` option involves ''appending'' to an existing dump file a new range of dumped revisions. For example, you might have a `post-commit` hook that simply appends the repository dump of the single revision that triggered the hook. Or you might have a script that runs nightly to append dump file data for all the revisions that were added to the repository since the last time the script ran. __'''Used like this, `svnadmin dump` can be one way to back up changes to your repository over time in case of a system crash or some other catastrophic(災難的) event. (搭配 `--incremental` 時, 可以實現 incremental backup)'''__

__The dump format can also be used to ''merge'' the contents of several different repositories into a single repository. By using the `--parent-dir` option of `svnadmin load`, you can specify a new ''virtual root'' directory for the load process.__ That means if you have dump files for three repositories, say `calc-dumpfile`, `cal-dumpfile`, and `ss-dumpfile`, you can first create a new repository to hold them all:

 {{{
$ svnadmin create /path/to/projects
$
 }}}

Then, make new directories in the repository which will encapsulate the contents of each of the three previous repositories: (下面 "`file:///`" 的用法很直覺, 這跟 mount 有關嗎[?])

 {{{
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
 }}}

Lastly, load the individual dump files into their respective locations in the new repository:

 {{{
$ svnadmin load /path/to/projects --parent-dir calc < calc-dumpfile
...
$ svnadmin load /path/to/projects --parent-dir calendar < cal-dumpfile
...
$ svnadmin load /path/to/projects --parent-dir spreadsheet < ss-dumpfile
...
$
 }}}
 
__如果沒有用 `--parent-dir` 重新定位的話, 會有什麼結果? 不用加前置的斜線[?] 用 `svndumpfilter include calc/trunk calc/brances calc/tags < repos-dumpfile > calc-dumpfile` 取得上述的 `calc-dumpfile`[?]__

We'll mention one final way to use the Subversion repository dump format—conversion from a different storage mechanism or version control system altogether. Because the dump file format is, for the most part, human-readable, it should be relatively easy to describe generic sets of changes—each of which should be treated as a new revision—using this file format. In fact, the `cvs2svn` utility (see the section called “Converting a Repository from CVS to Subversion”) uses the dump format to represent the contents of a CVS repository so that those contents can be copied into a Subversion repository.

==== Filtering Repository History ====

Since Subversion stores your versioned history using, at the very least, ''binary differencing algorithms'' and ''data compression'' (optionally in a completely opaque database system), attempting manual tweaks is unwise, if not quite difficult, and at any rate strongly discouraged. __And once data has been stored in your repository, Subversion generally doesn't provide an easy way to remove that data (That's rather the reason you use version control at all, right?). But inevitably(不可避免地), there will be times when you would like to manipulate the history of your repository. You might need to strip out all instances of a file that was accidentally added to the repository (and shouldn't be there for whatever reason). Or, perhaps you have multiple projects sharing a single repository, and you decide to split them up into their own repositories. (要合併多個 repositories 也是可能的)__ To accomplish tasks like this, administrators need a more manageable and malleable(可塑性大的) representation of the data in their repositories—the Subversion repository dump format.

As we described in the section called “Migrating Repository Data Elsewhere”, the Subversion repository dump format is a human-readable representation of the changes that you've made to your versioned data over time. You use the `svnadmin dump` command to generate the dump data, and `svnadmin load` to populate a new repository with it (see the section called “Migrating Repository Data Elsewhere”). __The great thing about the human-readability aspect of the dump format is that, if you aren't careless(粗心的) about it, you can manually inspect and modify it. Of course, the downside is that if you have three years' worth of repository activity encapsulated in what is likely to be a very large dump file, it could take you a long, long time to manually inspect and modify it.__

__That's where `svndumpfilter` becomes useful. This program acts as ''path-based filter'' for repository dump streams. Simply give it either a list of paths you wish to keep, or a list of paths you wish to not keep, then pipe your repository dump data through this filter. The result will be a ''modified stream'' of dump data that contains only the versioned paths you (explicitly or implicitly) requested.__

Let's look a realistic example of how you might use this program. We discuss elsewhere (see the section called “Planning Your Repository Organization”) the process of deciding how to choose a layout for the data in your repositories—using one repository per project or combining them, arranging stuff within your repository, and so on. But sometimes after new revisions start flying in, you rethink your layout and would like to make some changes. A common change is the decision to move multiple projects which are sharing a single repository into separate repositories for each project.

Our imaginary repository contains three projects: `calc`, `calendar`, and `spreadsheet`. They have been living side-by-side in a layout like this:

 {{{
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
 }}}

To get these three projects into their own repositories, we first dump the whole repository:

 {{{
$ svnadmin dump /path/to/repos > repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
...
$
 }}}

Next, run that dump file through the filter, each time including only one of our top-level directories, and resulting in three new dump files:

 {{{
$ svndumpfilter include calc < repos-dumpfile > calc-dumpfile
...
$ svndumpfilter include calendar < repos-dumpfile > cal-dumpfile
...
$ svndumpfilter include spreadsheet < repos-dumpfile > ss-dumpfile
...
$
 }}}

__At this point, you have to make a decision. '''Each of your dump files will create a valid repository, but will preserve the paths exactly as they were in the original repository.''' This means that even though you would have a repository solely for your calc project, that repository would still have a top-level directory named `calc`. If you want your `trunk`, `tags`, and `branches` directories to live in the root of your repository, you might wish to edit your dump files, tweaking the `Node-path` and `Node-copyfrom-path` headers to no longer have that first `calc/` path component. (大量取代? 跟前面提到的 `--parent-dir` 用法好像不太一樣[?])__ Also, you'll want to remove the section of dump data that creates the `calc` directory. It will look something like:

 {{{
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
 }}}

Warning: If you do plan on manually editing the dump file to remove a top-level directory, make sure that your editor is not set to automatically convert end-of-line characters to the native format (e.g. `\r\n` to `\n`), as the content will then not agree with the metadata. This will render the dump file useless.

All that remains now is to create your three new repositories, and load each dump file into the right repository:

 {{{
$ svnadmin create calc; svnadmin load calc < calc-dumpfile
<<< Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
...
$ svnadmin create calendar; svnadmin load calendar < cal-dumpfile
<<< Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
...
$ svnadmin create spreadsheet; svnadmin load spreadsheet < ss-dumpfile
<<< Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
...
$
 }}}

__Both of `svndumpfilter`'s subcommands accept options for deciding how to deal with ''“empty” revisions''. If a given revision contained only changes to paths that were ''filtered out'', that now-empty revision could be considered uninteresting or even unwanted. So to give the user control over what to do with those revisions,__ `svndumpfilter` provides the following command-line options:

 * `--drop-empty-revs`: Do not generate empty revisions at all—just omit them.
 * __`--renumber-revs`: If empty revisions are dropped (using the `--drop-empty-revs` option), change the revision numbers of the remaining revisions so that there are no gaps in the numeric sequence.__
 * `--preserve-revprops`: If empty revisions are not dropped, preserve the revision properties (log message, author, date, custom properties, etc.) for those empty revisions. Otherwise, empty revisions will only contain the original datestamp, and a generated log message that indicates that this revision was emptied by `svndumpfilter`.

While `svndumpfilter` can be very useful, and a huge timesaver, there are unfortunately a couple of gotchas(=unexpected capture or discovery.). __First, this utility is overly sensitive to ''path semantics''. Pay attention to whether paths in your dump file are specified with or without leading slashes.__ You'll want to look at the `Node-path` and `Node-copyfrom-path` headers.

 {{{
...
Node-path: spreadsheet/Makefile
...
 }}}

__If the paths have leading slashes, you should include leading slashes in the paths you pass to `svndumpfilter include` and `svndumpfilter exclude` (and if they don't, you shouldn't). Further, if your dump file has an inconsistent usage of leading slashes for some reason '''(While `svnadmin dump` has a consistent leading slash policy—to NOT include them—other programs which generate dump data might not be so consistent.)''', you should probably normalize those paths so they all have, or lack, leading slashes.__

__Also, copied paths can give you some trouble. Subversion supports copy operations in the repository, where a new path is created by copying some already existing path. It is possible that at some point in the lifetime of your repository, you might have copied a file or directory from some location that `svndumpfilter` is excluding, to a location that it is including. In order to make the dump data self-sufficient, `svndumpfilter` needs to still show the addition of the new path—including the contents of any files created by the copy—and not represent that addition as a copy from a source that won't exist in your filtered dump data stream. But because the Subversion repository dump format only shows what was changed in each revision, the contents of the copy source might not be readily available[?]. If you suspect(感覺到) that you have any copies of this sort in your repository, you might want to rethink your set of included/excluded paths, perhaps including the paths that served as sources of your troublesome copy operations, too.__

Finally, `svndumpfilter` takes path filtering quite ''literally''. If you are trying to copy the history of a project rooted at `trunk/my-project` and move it into a repository of its own, you would, of course, use the `svndumpfilter include` command to keep all the changes in and under `trunk/my-project`. __But the resulting dump file makes no assumptions about the repository into which you plan to load this data. Specifically, the dump data might begin with the revision which added the `trunk/my-project` directory, but it will not contain directives which would create the `trunk` directory itself (because `trunk` doesn't match the include filter; 就這個例子而言, 沒有事先建立 `trunk` 時, 會出現 "File not found" 的錯誤, 但如果先建好 `my-project` 時, 又會出現 "File already exist" 的錯誤, 由此就可以深刻感覺上述 "replay" 的意思!!). '''You'll need to make sure that any directories which the new dump stream expect to exist actually do exist in the target repository before trying to load the stream into that repository.'''__

==== Repository Backup ====

Despite numerous advances in technology since the birth of the modern computer, one thing unfortunately rings true(聽起來有道理) with crystalline clarity—sometimes, things go very, very awry. Power outages(斷電), network connectivity dropouts(失靈), corrupt RAM and crashed hard drives are but a taste of the evil that Fate(災難) is poised(搖擺不定的) to unleash(發動攻擊) on even the most conscientious(盡責的) administrator. And so we arrive at a very important topic—how to make backup copies of your repository data.

__There are two types of backup methods available for Subversion repository administrators—''full and incremental''. A full backup of the repository involves squirreling away(積存) in one sweeping(全面性的) action all the information required to fully reconstruct that repository in the event of a catastrophe(災變). Usually, it means, quite literally, the duplication of the entire repository directory (which includes either a Berkeley DB or FSFS environment). Incremental backups are lesser things, backups of only the portion of the repository data that has changed since the previous backup.__

__As far as full backups go, the naive approach might seem like a sane(理智的) one, but '''unless you temporarily disable all other access to your repository, simply doing a ''recursive directory copy'' runs the risk of generating a faulty backup.'''__ In the case of Berkeley DB, the documentation describes a certain order in which database files can be copied that will guarantee a valid backup copy. A similar ordering exists for FSFS data. But you don't have to implement these algorithms yourself, because the Subversion development team has already done so. __The `svnadmin hotcopy` command takes care of the minutia(細節) involved in making a hot backup of your repository. And its invocation is as trivial as Unix's `cp` or Windows' `copy` operations: (把 repository 整個複製出來, 但過程中如果有其他人在存取, 並不會造成備份結果異常)__

 {{{
$ svnadmin hotcopy /path/to/repos /path/to/repos-backup
 }}}

__The resulting backup is a ''fully functional'' Subversion repository, able to be dropped in as a replacement for your live repository should something go horribly wrong. (若要用 `tar` 將整個 repository 包起來, 來源應該是 hotcopy 的結果才是)__

When making copies of a Berkeley DB repository, you can even instruct `svnadmin hotcopy` to purge any unused Berkeley DB logfiles (see the section called “Purging unused Berkeley DB logfiles”) from the original repository upon completion of the copy. Simply provide the `--clean-logs` option on the command-line.

 {{{
$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup
 }}}

__Additional tooling around this command is available, too. The `tools/backup/` directory of the Subversion source distribution holds the `hot-backup.py` script. This script adds a bit of backup management atop `svnadmin hotcopy`, allowing you to keep only the most recent configured number of backups of each repository. It will automatically manage the names of the backed-up repository directories to avoid collisions with previous backups, and will “rotate off” older backups, deleting them so only the most recent ones remain. Even if you also have an incremental backup, you might want to run this program on a regular basis. For example, you might consider using `hot-backup.py` from a program scheduler (such as `cron` on Unix systems) which will cause it to run nightly (or at whatever granularity of Time you deem safe).__

Some administrators use a different backup mechanism built around generating and storing repository dump data. We described in the section called “Migrating Repository Data Elsewhere” how to use `svnadmin dump --incremental` to perform an incremental backup of a given revision or range of revisions. And of course, there is a full backup variation of this achieved by omitting the `--incremental` option to that command. __There is some value in these methods, in that the format of your backed-up information is flexible—it's not tied to a particular platform, versioned filesystem type, or release of Subversion or Berkeley DB. But that flexibility comes at a cost, namely that restoring that data can take a long time—longer with each new revision committed to your repository. '''(雖然 dump 的方式也是可行, 但似乎用 `svnadmin hotcopy` 來做 backup 會比較恰當. 除非是要做 incremental backup, 那就非 `svnadmin dump --incremental` 不可了)'''__ Also, as is the case with so many of the various backup methods, revision property changes made to already-backed-up revisions won't get picked up by a non-overlapping, incremental dump generation. For these reasons, we recommend against relying solely on dump-based backup approaches.[?]

__As you can see, each of the various backup types and methods has its advantages and disadvantages. The easiest is by far the full hot backup, which will always result in a perfect working replica(複製品) of your repository. Should something bad happen to your live repository, you can restore from the backup with a simple recursive directory copy. Unfortunately, if you are maintaining multiple backups of your repository, these full copies will each eat up just as much disk space as your live repository. '''Incremental backups, by contrast, tend to be quicker to generate and smaller to store. But the restoration process can be a pain, often involving applying multiple incremental backups. And other methods have their own peculiarities(特性). Administrators need to find the balance between the cost of making the backup and the cost of restoring it.'''__

The `svnsync` program (see the section called “Repository Replication”) actually provides a rather handy middle-ground approach. If you are regularly synchronizing a read-only mirror with your main repository, then in a pinch(在緊要關頭), your read-only mirror is probably a good candidate for replacing that main repository if it falls over. The primary disadvantage of this method is that only the versioned repository data gets synchronized—repository configuration files, user-specified repository path locks, and other items which might live in the physical repository directory but not inside the repository's virtual versioned filesystem are not handled by `svnsync`.

__In any backup scenario, repository administrators need to be aware of how modifications to ''unversioned revision properties''[?] affect their backups. Since these changes do not themselves generate new revisions, they will not trigger `post-commit` hooks, and may not even trigger the `pre-revprop-change` and `post-revprop-change` hooks. '''And since you can change revision properties without respect to chronological(按時間先後的) order—you can change any revision's properties at any time—an incremental backup of the latest few revisions might not catch a property modification to a revision that was included as part of a previous backup.'''__

Generally speaking, only the truly paranoid(偏執狂) would need to backup their entire repository, say, every time a commit occurred. However, assuming that a given repository has some other redundancy(過多的?) mechanism in place with relatively fine granularity (like `per-commit` emails or incremental dumps), __a hot backup of the database might be something that a repository administrator would want to include as part of a ''system-wide nightly backup''.__ It's your data—protect it as much as you'd like.

Often, the best approach to repository backups is a diversified(形形色色的) one which leverages combinations of the methods described here. __The Subversion developers, for example, back up the Subversion source code repository nightly using `hot-backup.py` and an offsite `rsync` of those full backups; keep multiple archives of all the commit and property change notification emails; and have repository mirrors maintained by various volunteers using `svnsync`.__ Your solution might be similar, but should be catered(迎合) to your needs and that delicate(微妙的) balance of convenience with paranoia. __And whatever you do, validate your backups from time to time—what good is a spare tire that has a hole in it? While all of this might not save your hardware from the iron fist of Fate, [40] it should certainly help you recover from those trying times. (確認備份是有效的[?])__

== Chapter 6. Server Configuration ==

A Subversion repository can be accessed simultaneously by clients running on the same machine on which the repository resides using the `file://` method. But the typical Subversion setup involves a single server machine being accessed from clients on computers all over the office—or, perhaps, all over the world.

This chapter describes how to get your Subversion repository exposed outside its host machine for use by remote clients. We will cover Subversion's currently available ''server mechanisms'', discussing the configuration and use of each. After reading this section, you should be able to decide which networking setup is right for your needs, and understand how to enable such a setup on your host computer.

=== Overview ===

__Subversion was designed with an ''abstract'' network layer. This means that a repository can be ''programmatically'' accessed by any sort of server process, and the client “repository access” API allows programmers to write plugins that speak relevant network protocols. In theory, Subversion can use an infinite number of network implementations.__ In practice, there are only two servers at the time of this writing.

__Apache is an extremely popular webserver; using the `mod_dav_svn` module, Apache can access a repository and make it available to clients via the WebDAV/DeltaV protocol, which is an extension of HTTP.__ Because Apache is an extremely extensible web server, it provides a number of features “for free”, such as encrypted SSL communication, logging, integration with a number of third-party authentication systems, and limited built-in ''web browsing of repositories''.

In the other corner is `svnserve`: a small, lightweight server program that speaks a ''custom protocol'' with clients. Because its protocol is explicitly designed for Subversion and is ''stateful'' (unlike HTTP), it provides significantly faster network operations—but at the cost of some features as well. It only understands CRAM-MD5 authentication, has no logging, no ''webbrowsing'', and no option to encrypt network traffic. __It is, however, extremely easy to set up and is often the best option for small teams just starting out with Subversion.__

A third option is to use `svnserve` tunneled over an SSH connection. Even though this scenario still uses `svnserve`, it differs quite a bit in features from a traditional `svnserve` deployment. SSH is used to encrypt all communication. SSH is also used exclusively to authenticate, so real system accounts are required on the server host (unlike ''vanilla svnserve[?]'', which has its own private user accounts.) __Finally, because this setup requires that each user spawn a private, temporary `svnserve` process, it's equivalent (from a permissions point of view) to allowing a group of local users to all access the repository via `file://` URLs. Path-based access control has no meaning, since each user is accessing the repository database files directly.__ Here's a quick summary of the three typical server deployments.

'''Table 6.1. Comparison of Subversion Server Options'''

|| Feature || Apache + mod_dav_svn || svnserve || svnserve over SSH ||
|| Authentication options || HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or any other mechanism available to Apache `httpd`  || [http://en.wikipedia.org/wiki/CRAM-MD5 CRAM-MD5] || SSH ||
|| User account options || private `users` file (別於 system accounts 而言) || private `users` file || system accounts ||
|| Authorization options || read/write access can be granted over whole repository, or specified per-path. || read/write access can be granted over whole repository, or specified per-path. || read/write access only grantable over whole repository ||
|| Encryption || via optional SSL || none || SSH tunneled ||
|| Logging || full Apache logs of each HTTP request, with optional “high-level” logging of general client operations || no logging || no logging ||
|| Interoperability || partially usable by other WebDAV clients (可以做為 versioned file server 使用) || only talks to svn clients || only talks to svn clients ||
|| Web viewing || limited built-in support, or via 3rd-party tools such as [http://www.viewvc.org/ ViewVC] || only via 3rd-party tools such as ViewVC || only via 3rd-party tools such as ViewVC ||
|| Speed || somewhat slower || somewhat faster || somewhat faster ||
|| Initial setup || somewhat complex || extremely simple || moderately(適度地) simple ||

=== Choosing a Server Configuration ===

So, which server should you use? Which is best?

Obviously, there's no right answer to that question. Every team has different needs, and the different servers all represent different sets of tradeoffs(取捨). The Subversion project itself doesn't endorse(背書) one server or another, or consider either server more “official” than another.

Here are some reasons why you might choose one deployment over another, as well as reasons you might not choose one.

==== The svnserve Server ====

Why you might want to use it:

 * Quick and easy to set up.
 * Network protocol is stateful and noticeably faster than WebDAV.
 * No need to create system accounts on server.
 * __Password is not passed over the network.__
 
Why you might want to avoid it:

 * Network protocol is not encrypted.
 * Only one choice of authentication method.
 * Password is stored in the clear on the server.
 * No logging of any kind, not even errors.

==== svnserve over SSH ====

Why you might want to use it:

 * Network protocol is stateful and noticeably faster than WebDAV.
 * __You can take advantage of existing ssh accounts and ''user infrastructure''.__
 * All network traffic is encrypted.
 
Why you might want to avoid it:

 * Only one choice of authentication method.
 * No logging of any kind, not even errors.
 * __Requires users to be in same system group, or use a shared ssh key.__
 * If used improperly, can lead to file permissions problems.

==== The Apache HTTP Server ====

Why you might want to use it:

 * Allows Subversion to use any of the numerous authentication systems already integrated with Apache.
 * __No need to create system accounts on server. (這到底是優點還是缺點?)__
 * Full Apache logging.
 * Network traffic can be encrypted via SSL.
 * __HTTP(S) can usually go through corporate firewalls.__
 * Built-in repository browsing via web browser.
 * __'''Repository can be mounted as a network drive for ''transparent version control''. (See the section called “Autoversioning”.)'''__

Why you might want to avoid it:

 * Noticeably slower than `svnserve`, because HTTP is a stateless protocol and requires more turnarounds(往返所需的時間).
 * Initial setup can be complex.

==== Recommendations ====

In general, the authors of this book recommend a ''vanilla svnserve'' installation for small teams just trying to get started with a Subversion server; it's the simplest to set up, and has the fewest maintenance issues. You can always switch to a more complex server deployment as your needs change.

Here are some general recommendations and tips, based on years of supporting users:

 * If you're trying to set up the simplest possible server for your group, then a vanilla svnserve installation is the easiest, fastest route. Note, however, that your repository data will be transmitted in the clear(用普通文字) over the network. __If your deployment is entirely within your company's LAN or VPN, this isn't an issue. If the repository is exposed to the wide-open internet, then you might want to make sure the repository's contents aren't sensitive (e.g. it contains only open-source code.)__

 * __'''If you need to integrate with existing ''identity systems'' (LDAP, Active Directory, NTLM, X.509, etc.), then an Apache-based server is your only real option.''' Similarly, if you absolutely need server-side logs of either server errors or client activities, then an Apache-based server is required.__

 * __If you've decided to use either Apache or ''stock svnserve(相對於 "vanilla svnserve" 的說法?)'', '''create a single `svn` user on your system and run the server process as that user. Be sure to make the repository directory wholly owned by the `svn` user as well. From a security point of view, this keeps the repository data nicely siloed(貯藏) and protected by operating system filesystem permissions, changeable by only the Subversion server process itself.'''__

 * If you have an existing infrastructure heavily based on SSH accounts, and if your users already have system accounts on your server machine, then it makes sense to deploy an svnserve-over-ssh solution. Otherwise, we don't widely recommend this option to the public. __'''It's generally considered safer to have your users access the repository via (imaginary(虛構的)) accounts managed by `svnserve` or Apache, rather than by full-blown(成熟的) system accounts.''' If your deep desire for encrypted communication still draws you to this option, we recommend using Apache with SSL instead.__

 * __Do not be seduced(瞞騙) by the simple idea of having all of your users access a repository directly via `file://` URLs. Even if the repository is readily available to everyone via ''network share'', this is a bad idea. '''It removes any layers of protection between the users and the repository: users can accidentally (or intentionally) corrupt the repository database,''' it becomes hard to take the repository offline for inspection or upgrade, and it can lead to a mess of file permissions problems (see the section called “Supporting Multiple Repository Access Methods”.) '''Note that this is also one of the reasons we warn against accessing repositories via `svn+ssh://` URLs—from a security standpoint, it's effectively the same as local users accessing via `file://`, and can entail(必然伴有) all the same problems if the administrator isn't careful. (原來 svnserve-over-ssh 比單純用 svnserve 還糟)'''__
 
=== svnserve, a custom server [...] ===

=== httpd, the Apache HTTP server ===

The Apache HTTP Server is a “heavy duty” network server that Subversion can leverage. Via a custom module, `httpd` makes Subversion repositories available to clients via the WebDAV/DeltaV protocol, which is an extension to HTTP 1.1 (see http://www.webdav.org/ for more information). __This protocol takes the ubiquitous(無所不在的) HTTP protocol that is the core of the World Wide Web, and adds writing—specifically, ''versioned writing''—capabilities. The result is a standardized, robust system that is conveniently packaged as part of the Apache 2.0 software, is supported by numerous operating systems and third-party products, and doesn't require network administrators to open up yet another custom port.__ While an Apache-Subversion server has more features than `svnserve`, it's also a bit more difficult to set up. With flexibility often comes more complexity.

Much of the following discussion includes references to Apache configuration directives. While some examples are given of the use of these directives, describing them in full is outside the scope of this chapter. The Apache team maintains excellent documentation, publicly available on their website at http://httpd.apache.org. For example, a general reference for the configuration directives is located at http://httpd.apache.org/docs-2.0/mod/directives.html.

Also, as you make changes to your Apache setup, it is likely that somewhere along the way a mistake will be made. If you are not already familiar with Apache's logging subsystem, you should become aware of it. In your `httpd.conf` file are directives that specify the on-disk locations of the access and error logs generated by Apache (the `CustomLog` and `ErrorLog` directives, respectively). __Subversion's `mod_dav_svn` uses Apache's ''error logging interface'' as well. You can always browse the contents of those files for information that might reveal the source of a problem that is not clearly noticeable otherwise.__

==== Why Apache 2? ====

If you're a system administrator, it's very likely that you're already running the Apache web server and have some prior experience with it. At the time of writing, Apache 1.3 is by far the most popular version of Apache. __The world has been somewhat slow to upgrade to the Apache 2.X series for various reasons: some people fear change, especially changing something as critical as a web server. Other people depend on plug-in modules that only work against the Apache 1.3 API, and are waiting for a 2.X port.__ Whatever the reason, many people begin to worry when they first discover that Subversion's Apache module is written specifically for the Apache 2 API.

__The proper response to this problem is: don't worry about it. It's easy to run Apache 1.3 and Apache 2 side-by-side; simply install them to separate places, and use Apache 2 as a dedicated Subversion server that runs on a port other than 80. Clients can access the repository by placing the port number into the URL:__

 {{{
$ svn checkout http://host.example.com:7382/repos/project
 }}}

==== Prerequisites ====

To network your repository over HTTP, you basically need four components, available in two packages. __You'll need Apache httpd 2.0, the `mod_dav` DAV module that comes with it, Subversion, and the `mod_dav_svn` ''filesystem provider'' module distributed with Subversion.__ Once you have all of those components, the process of networking your repository is as simple as:

 * getting httpd 2.0 up and running with the `mod_dav` module,
 * installing the `mod_dav_svn` ''plugin'' to `mod_dav`, which uses Subversion's libraries to access the repository, and
 * configuring your `httpd.conf` file to export (or expose) the repository.
 
You can accomplish the first two items either by compiling `httpd` and Subversion from source code, or by installing pre-built binary packages of them on your system. For the most up-to-date information on how to compile Subversion for use with the Apache HTTP Server, as well as how to compile and configure Apache itself for this purpose, see the `INSTALL` file in the top level of the Subversion source code tree.

==== Basic Apache Configuration ====

Once you have all the necessary components installed on your system, all that remains is the configuration of Apache via its `httpd.conf` file. Instruct Apache to load the `mod_dav_svn` module using the `LoadModule` directive. __This directive must precede any other Subversion-related configuration items.__ If your Apache was installed using the default layout, your `mod_dav_svn` module should have been installed in the `modules` subdirectory of the Apache install location (often `/usr/local/apache2`). The `LoadModule` directive has a simple syntax, mapping a named module to the location of a ''shared library'' on disk:

 {{{
LoadModule dav_svn_module modules/mod_dav_svn.so
 }}}

__Note that if `mod_dav` was compiled as a shared object (instead of statically linked directly to the `httpd` binary), you'll need a similar `LoadModule` statement for it, too. Be sure that it comes before the `mod_dav_svn` line:__

 {{{
LoadModule dav_module modules/mod_dav.so
LoadModule dav_svn_module modules/mod_dav_svn.so
 }}}

At a later location in your configuration file, you now need to tell Apache where you keep your Subversion repository (or repositories). The `Location` directive has an XML-like notation, starting with an opening tag, and ending with a closing tag, with various other configuration directives in the middle. __The purpose of the `Location` directive is to instruct Apache to do something special when handling requests that are directed at a given URL or one of its children. In the case of Subversion, you want Apache to simply hand off support for URLs that point at versioned resources to the ''DAV layer''.__ You can instruct Apache to delegate the handling of all URLs whose path portions (the part of the URL that follows the server's name and the optional port number) begin with `/repos/` to a DAV provider whose repository is located at `/absolute/path/to/repository` using the following `httpd.conf` syntax:

 {{{
<Location /repos>
  DAV svn
  SVNPath /absolute/path/to/repository
</Location>
 }}}

__If you plan to support multiple Subversion repositories that will reside in the same parent directory on your local disk, you can use an alternative directive, the `SVNParentPath` directive, to indicate that common parent directory.__ For example, if you know you will be creating multiple Subversion repositories in a directory `/usr/local/svn` that would be accessed via URLs like http://my.server.com/svn/repos1, http://my.server.com/svn/repos2, and so on, you could use the `httpd.conf` configuration syntax in the following example:

 {{{
<Location /svn>
  DAV svn
  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
</Location>
 }}}

__Using the previous syntax, Apache will delegate the handling of all URLs whose path portions begin with `/svn/` to the ''Subversion DAV provider'', which will then assume that any items in the directory specified by the `SVNParentPath` directive are actually Subversion repositories. '''This is a particularly convenient syntax in that, unlike the use of the `SVNPath` directive, you don't have to restart Apache in order to create and network new repositories.'''__

__Be sure that when you define your new `Location`, it doesn't overlap with other exported `Location`s. For example, if your main `DocumentRoot` is exported to `/www`, do not export a Subversion repository in `<Location /www/repos>`. If a request comes in for the URI `/www/repos/foo.c`, Apache won't know whether to look for a file `repos/foo.c` in the `DocumentRoot`, or whether to delegate `mod_dav_svn` to return `foo.c` from the Subversion repository. '''The result is often an error from the server of the form ''301 Moved Permanently''.'''__

 '''Server Names and the COPY Request'''
 
 __Subversion makes use of the `COPY` request type to perform server-side copies of files and directories. As part of the sanity(健全) checking done by the Apache modules, the source of the copy is expected to be located on the same machine as the destination of the copy. '''To satisfy this requirement, you might need to tell `mod_dav` the name you use as the hostname of your server. (告訴它這台機器所有可能的名字, 即便來源與目的的名稱不同, 但只要指向同一台機器即可)''' Generally, you can use the `ServerName` directive in `httpd.conf` to accomplish this.__
 
 {{{
ServerName svn.example.com
 }}}

 __If you are using Apache's virtual hosting support via the `NameVirtualHost` directive, you may need to use the `ServerAlias` directive to specify additional names that your server is known by.__ Again, refer to the Apache documentation for full details.
 
At this stage, you should strongly consider the question of permissions. If you've been running Apache for some time now as your regular web server, you probably already have a collection of content—web pages, scripts and such. These items have already been configured with a set of permissions that allows them to work with Apache, or more appropriately, that allows Apache to work with those files. __Apache, when used as a Subversion server, will also need the correct permissions to read and write to your Subversion repository.__

__You will need to determine a permission system setup that satisfies Subversion's requirements without messing up any previously existing web page or script installations. This might mean changing the permissions on your Subversion repository to match those in use by other things that Apache serves for you, '''or it could mean using the `User` and `Group` directives in `httpd.conf` to specify that Apache should run as the user and group that owns your Subversion repository. (這樣做好嗎[?])'''__ There is no single correct way to set up your permissions, and each administrator will have different reasons for doing things a certain way. Just be aware that permission-related problems are perhaps the most common oversight(疏忽) when configuring a Subversion repository for use with Apache.

==== Authentication Options ====

At this point, if you configured `httpd.conf` to contain something like

 {{{
<Location /svn>
  DAV svn
  SVNParentPath /usr/local/svn
</Location>
 }}}

...then your repository is “anonymously” accessible to the world. Until you configure some authentication and authorization policies, the Subversion repositories you make available via the `Location` directive will be generally accessible to everyone. In other words,

 * anyone can use their Subversion client to check out a working copy of a repository URL (or any of its subdirectories),
 * anyone can interactively browse the repository's latest revision simply by pointing their web browser to the repository URL, and
 * anyone can commit to the repository.

Of course, you might have already set up a `pre-commit` hook script to prevent commits (see the section called “Implementing Repository Hooks”). But as you read on, you'll see that it's also possible use Apache's built-in methods to restrict access in specific ways.

===== Basic HTTP Authentication =====

The easiest way to authenticate a client is via the HTTP Basic authentication mechanism, which simply uses a username and password to verify that a user is who she says she is. Apache provides an `htpasswd` utility for managing the list of acceptable usernames and passwords. Let's grant commit access to Sally and Harry. First, we need to add them to the password file.

 {{{
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
 }}}

__Next, you need to add some more `httpd.conf` directives inside your `Location` block to tell Apache what to do with your new password file. The `AuthType` directive specifies the type of authentication system to use. In this case, we want to specify the Basic authentication system. `AuthName` is an arbitrary name that you give for the authentication domain. Most browsers will display this name in the pop-up dialog box when the browser is querying the user for his name and password. Finally, use the `AuthUserFile` directive to specify the location of the password file you created using `htpasswd`.__

After adding these three directives, your `<Location>` block should look something like this:

 {{{
<Location /svn>
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
</Location>
 }}}

__This `<Location>` block is not yet complete, and will not do anything useful. It's merely telling Apache that whenever authorization is required, Apache should harvest(獲得) a username and password from the Subversion client. What's missing here, however, are directives that tell Apache ''which sorts of client requests'' require authorization. Wherever authorization is required, Apache will demand(請求) authentication as well. The simplest thing to do is protect all requests. Adding `Require valid-user` tells Apache that all requests require an authenticated user:__

 {{{
<Location /svn>
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
</Location>
 }}}

Be sure to read the next section (the section called “Authorization Options”) for more detail on the `Require` directive and other ways to set authorization policies.

__One word of warning: '''HTTP Basic Auth passwords pass in very nearly plain-text over the network, and thus are extremely insecure.''' If you're worried about password snooping, it may be best to use some sort of SSL encryption, so that clients authenticate via `https://` instead of `http://`;__ at a bare minimum, you can configure Apache to use a self-signed server certificate. (While self-signed server certificates are still vulnerable(脆弱的) to a “man in the middle” attack, such an attack is much more difficult for a casual observer to pull off(拉掉), compared to sniffing unprotected passwords.) Consult Apache's documentation (and OpenSSL documentation) about how to do that.

===== SSL Certificate Management =====

__'''Businesses that need to expose their repositories for access outside the company firewall should be conscious(意識到的) of the possibility that unauthorized parties could be “sniffing” their network traffic. SSL makes that kind of unwanted attention less likely to result in ''sensitive data leaks''.'''__

__If a Subversion client is compiled to use OpenSSL, then it gains the ability to speak to an Apache server via `https://` URLs. '''The [http://www.webdav.org/neon/ Neon] library used by the Subversion client is not only able to verify server certificates, but can also supply client certificates when ''challenged''. When the client and server have exchanged SSL certificates and successfully authenticated one another, all further communication is encrypted via a ''session key''.'''__

It's beyond the scope of this book to describe how to generate client and server certificates, and how to configure Apache to use them. Many other books, including Apache's own documentation, describe this task. But what can be covered here is how to manage server and client certificates from an ordinary Subversion client.

When speaking to Apache via https://, a Subversion client can receive two different types of information:

 * a server certificate
 * a demand for a client certificate

__'''If the client receives a server certificate, it needs to verify that it trusts the certificate: is the server really who it claims to be?''' The OpenSSL library does this by examining the signer of the server certificate, or ''certifying authority'' (CA; 認證機關). If OpenSSL is unable to automatically trust the CA, or if some other problem occurs (such as an expired certificate or hostname mismatch), the Subversion command-line client will ask you whether you want to trust the server certificate anyway:__

 {{{
$ svn list https://host.example.com/repos/project
Error validating server certificate for 'https://host.example.com:443':
- The certificate is not issued by a trusted authority. Use the
fingerprint to validate the certificate manually!
Certificate information:
- Hostname: host.example.com
- Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
- Issuer: CA, example.com, Sometown, California, US
- Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b
(R)eject, accept (t)emporarily or accept (p)ermanently?
 }}}

__This dialogue should look familiar; it's essentially the same question you've probably seen coming from your web browser (which is just another HTTP client like Subversion). If you choose the (p)ermanent option, the server certificate will be cached in your private run-time `auth/` area in just the same way your username and password are cached (see the section called “Client Credentials Caching”). If cached, Subversion will automatically trust this certificate in future negotiations(交涉).__

Your ''run-time servers file[?]'' also gives you the ability to make your Subversion client automatically trust specific CAs, either globally or on a per-host basis. Simply set the `ssl-authority-files` variable to a semicolon-separated list of PEM-encoded CA certificates:

 {{{
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
 }}}

Many OpenSSL installations also have a pre-defined set of “default” CAs that are nearly universally trusted. To make the Subversion client automatically trust these standard authorities, set the `ssl-trust-default-ca` variable to `true`.

When talking to Apache, a Subversion client might also receive a challenge for a client certificate. Apache is asking the client to identify itself: is the client really who it says it is? If all goes correctly, the Subversion client sends back a private certificate signed by a CA that Apache trusts. A client certificate is usually stored on disk in encrypted format, protected by a local password. When Subversion receives this challenge, it will ask you for both a path to the certificate and the password which protects it:

 {{{
$ svn list https://host.example.com/repos/project
Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12': ********
...
 }}}

Notice that the client certificate is a “p12” file. To use a client certificate with Subversion, it must be in [http://en.wikipedia.org/wiki/PKCS12 PKCS#12] format, which is a portable standard. Most web browsers are already able to import and export certificates in that format. Another option is to use the OpenSSL command-line tools to convert existing certificates into PKCS#12. Again, the runtime servers file allows you to automate this challenge on a per-host basis. Either or both pieces of information can be described in runtime variables:

 {{{
[groups]
examplehost = host.example.com
[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
 }}}

Once you've set the `ssl-client-cert-file` and `ssl-client-cert-password` variables, the Subversion client can automatically respond to a client certificate challenge without prompting you. (More security-conscious folk might not want to store the client certificate password in the runtime servers file.)

==== Authorization Options ====

__At this point, you've configured ''authentication'', but not ''authorization''. Apache is able to challenge clients and confirm ''identities(身分)'', but it has not been told how to allow or restrict access to the clients bearing those identities.__ This section describes two strategies for controlling access to your repositories.

===== Blanket Access Control =====

The simplest form of access control is to authorize certain users for either read-only access to
a repository, or read/write access to a repository.
You can restrict access on all repository operations by adding the Require valid-user directive
to your <Location> block. Using our previous example, this would mean that only clients
that claimed to be either harry or sally, and provided the correct password for their respective
username, would be allowed to do anything with the Subversion repository:
<Location /svn>
DAV svn
SVNParentPath /usr/local/svn
# how to authenticate a user
AuthType Basic
AuthName "Subversion repository"
AuthUserFile /path/to/users/file
# only authenticated users may access the repository
Require valid-user
</Location>
Sometimes you don't need to run such a tight ship. For example, Subversion's own source
code repository at http://svn.collab.net/repos/svn allows anyone in the world to perform readonly
repository tasks (like checking out working copies and browsing the repository with a web
browser), but restricts all write operations to authenticated users. To do this type of selective
restriction, you can use the Limit and LimitExcept configuration directives. Like the Location
directive, these blocks have starting and ending tags, and you would nest them inside your <Location> block.
The parameters present on the Limit and LimitExcept directives are HTTP request types
that are affected by that block. For example, if you wanted to disallow all access to your repository
except the currently supported read-only operations, you would use the LimitExcept
directive, passing the GET, PROPFIND, OPTIONS, and REPORT request type parameters. Then
the previously mentioned Require valid-user directive would be placed inside the
<LimitExcept> block instead of just inside the <Location> block.

<Location /svn>
DAV svn
SVNParentPath /usr/local/svn
# how to authenticate a user
AuthType Basic
AuthName "Subversion repository"
AuthUserFile /path/to/users/file
# For any operations other than these, require an authenticated user.
<LimitExcept GET PROPFIND OPTIONS REPORT>
Require valid-user
</LimitExcept>
</Location>
These are only a few simple examples. For more in-depth information about Apache access
control and the Require directive, take a look at the Security section of the Apache documentation's
tutorials collection at http://httpd.apache.org/docs-2.0/misc/tutorials.html.

===== Per-Directory Access Control =====

It's possible to set up finer-grained permissions using a second Apache httpd module,
mod_authz_svn. This module grabs the various opaque URLs passing from client to server,
asks mod_dav_svn to decode them, and then possibly vetoes requests based on access
policies defined in a configuration file.
If you've built Subversion from source code, mod_authz_svn is automatically built and installed
alongside mod_dav_svn. Many binary distributions install it automatically as well. To
verify that it's installed correctly, make sure it comes right after mod_dav_svn's LoadModule
directive in httpd.conf:
LoadModule dav_module modules/mod_dav.so
LoadModule dav_svn_module modules/mod_dav_svn.so
LoadModule authz_svn_module modules/mod_authz_svn.so
To activate this module, you need to configure your Location block to use the AuthzSVNAccessFile
directive, which specifies a file containing the permissions policy for paths within
your repositories. (In a moment, we'll discuss the format of that file.)
Apache is flexible, so you have the option to configure your block in one of three general patterns.
To begin, choose one of these basic configuration patterns. (The examples below are
very simple; look at Apache's own documentation for much more detail on Apache authentication
and authorization options.)
The simplest block is to allow open access to everyone. In this scenario, Apache never sends
authentication challenges, so all users are treated as “anonymous”.

Example 6.1. A sample configuration for anonymous access.
<Location /repos>
DAV svn
SVNParentPath /usr/local/svn
# our access control policy
AuthzSVNAccessFile /path/to/access/file
</Location>
On the opposite end of the paranoia scale, you can configure your block to demand authentication
from everyone. All clients must supply credentials to identify themselves. Your block unconditionally
requires authentication via the Require valid-user directive, and defines a
means to authenticate.
Example 6.2. A sample configuration for authenticated access.
<Location /repos>
DAV svn
SVNParentPath /usr/local/svn
# our access control policy
AuthzSVNAccessFile /path/to/access/file
# only authenticated users may access the repository
Require valid-user
# how to authenticate a user
AuthType Basic
AuthName "Subversion repository"
AuthUserFile /path/to/users/file
</Location>
A third very popular pattern is to allow a combination of authenticated and anonymous access.
For example, many administrators want to allow anonymous users to read certain repository
directories, but want only authenticated users to read (or write) more sensitive areas. In this
setup, all users start out accessing the repository anonymously. If your access control policy
demands a real username at any point, Apache will demand authentication from the client. To
do this, you use both the Satisfy Any and Require valid-user directives together.
Example 6.3. A sample configuration for mixed authenticated/anonymous
access.
<Location /repos>
DAV svn
SVNParentPath /usr/local/svn

# our access control policy
AuthzSVNAccessFile /path/to/access/file
# try anonymous access first, resort to real
# authentication if necessary.
Satisfy Any
Require valid-user
# how to authenticate a user
AuthType Basic
AuthName "Subversion repository"
AuthUserFile /path/to/users/file
</Location>
Once you've settled on one of these three basic httpd.conf templates, you need to create
your file containing access rules for particular paths within the repository. This is described in
the section called “Path-Based Authorization”.

== Chapter 9. Subversion Complete Reference ==

This chapter is intended to be a complete reference to using Subversion. This includes the command line client (`svn`) and all its subcommands, as well as the repository administration programs (`svnadmin` and `svnlook`) and their respective subcommands.

=== The Subversion Command Line Client: svn ===

To use the command line client, you type `svn`, the subcommand you wish to use (Yes, yes, you don't need a subcommand to use the `--version` option, but we'll get to that in just a minute.), and any options or targets that you wish to operate on—there is no specific order that the subcommand and the options must appear in. For example, all of the following are valid ways to use `svn status`:

 {{{
$ svn -v status
$ svn status -v
$ svn status -v myfile
 }}}

You can find many more examples of how to use most client commands in Chapter 2, Basic Usage and commands for managing properties in the section called “Properties”.

==== svn Subcommands ====

Here are the various subcommands:

===== svn add =====

'''Name'''

`svn add` — Add files, directories, or ''symbolic links''(如何與 svn 搭配運作[?]).

'''Synopsis'''

 {{{
svn add PATH...
 }}}
 
'''Description'''

''Schedule'' files, directories, or symbolic links in your working copy for addition to the repository. They will be uploaded and added to the repository on your next commit. If you add something and change your mind before committing, you can ''unschedule'' the addition using `svn revert`.

'''Alternate Names'''

None

'''Changes'''

Working Copy

'''Accesses Repository'''

No

'''Options'''

 * `--targets FILENAME`
 * `--non-recursive (-N)`
 * `--quiet (-q)`
 * `--config-dir DIR`
 * `--no-ignore`
 * `--auto-props`
 * `--no-auto-props`
 * `--force`

'''Examples'''

To add a file to your working copy:

 {{{
$ svn add foo.c
A foo.c
 }}}

When adding a directory, the default behavior of `svn add` is to recurse(遞回):

 {{{
$ svn add testdir
A testdir
A testdir/a
A testdir/b
A testdir/c
A testdir/d
 }}}

You can add a directory without adding its contents:

 {{{
$ svn add --non-recursive otherdir
A otherdir
 }}}

__Normally, the command `svn add *` will skip over any directories that are already under version control. Sometimes, however, you may want to add every unversioned object in your working copy, including those hiding deeper down. '''Passing the `--force` option makes `svn add` recurse into versioned directories: (方便一次將沒有加入版控的部份全部加入; @2008/11/25 發現在做完 `svn rm` 的動作之後, `svn add -force` 會造成刪掉的檔案又被加回去)'''__

 {{{
$ svn add * --force
A foo.c
A somedir/bar.c
A otherdir/docs/baz.doc
...
 }}}

=== svnadmin ===

`svnadmin` is the administrative tool for monitoring and ''repairing'' your Subversion repository. For detailed information, see the section called “svnadmin”.

__Since `svnadmin` works via ''direct repository access'' (and thus can only be used on the machine that holds the repository), it refers to the repository with a path, not a URL.__

==== svnadmin Options ====

 * `--bdb-log-keep` 
 
   (Berkeley DB specific) Disable automatic log removal of database log files. Having these log files around can be convenient if you need to restore from a catastrophic(災難的) repository failure.
   
 * `--bdb-txn-nosync`
 
   (Berkeley DB specific) Disables fsync when committing database transactions. Used with the `svnadmin create` command to create a Berkeley DB backed repository with `DB_TXN_NOSYNC` enabled (which improves speed but has some risks associated with it).
   
 * `--bypass-hooks`
 
   Bypass the repository hook system.
   
 * `--clean-logs`
 
   Removes unused Berkeley DB logs.
   
 * `--force-uuid`
 
   By default, when loading data into repository that already contains revisions, `svnadmin` will ignore the UUID from the dump stream. This option will cause the repository's UUID to be set to the UUID from the stream.
   
 * `--ignore-uuid`

   By default, when loading an empty repository, `svnadmin` will ignore the UUID from the dump stream. This option will force that UUID to be ignored (useful for overriding your configuration file if it has `--force-uuid` set).
   
 * `--incremental`

   Dump a revision only as a diff against the previous revision, instead of the usual fulltext.

 * `--parent-dir DIR`

   When loading a dump file, root paths at `DIR` instead of `/`.

 * `--revision (-r) ARG`
   
   Specify a particular revision to operate on.

 * `--quiet`
 
   Do not show normal progress—show only errors.
   
 * `--use-post-commit-hook`
 
   When loading a dump file, run the repository's `post-commit` hook after finalizing each newly loaded revision.
   
 * `--use-pre-commit-hook`
 
   When loading a dump file, run the repository's `pre-commit` hook before finalizing each newly loaded revision. If the hook fails, abort the commit and terminate the load process.
   
==== svnadmin Subcommands ====

===== svnadmin recover =====

'''Name'''

`svnadmin recover` — Bring a repository database back into a consistent state (applies only to repositories using the bdb backend). In addition, if `repos/conf/passwd` does not exist, it will create a default password file .

'''Synopsis'''

 {{{
svnadmin recover REPOS_PATH
 }}}

'''Description'''

Run this command if you get an error indicating that your repository needs to be recovered. 

'''Options'''

 * `--wait`
 
'''Examples'''

Recover a hung repository:

 {{{
$ svnadmin recover /usr/local/svn/repos/
Repository lock acquired.
Please wait; recovering the repository may take some time...
Recovery completed.
The latest repos revision is 34.
Recovering the database requires an exclusive lock on the repository. (This is a “database
lock”; see The three meanings of “lock”.) If another process is accessing the repository, then
svnadmin recover will error:
$ svnadmin recover /usr/local/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?
$
The --wait option, however, will cause svnadmin recover to wait indefinitely for other processes
to disconnect:
$ svnadmin recover /usr/local/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?
### time goes by...
Repository lock acquired.
Please wait; recovering the repository may take some time...
Recovery completed.
The latest repos revision is 34.
 }}}

===== svnadmin verify =====

'''Name'''

`svnadmin verify` — Verify the data stored in the repository.


'''Synopsis'''

 {{{
svnadmin verify REPOS_PATH
 }}}

'''Description'''

__Run this command if you wish to verify the integrity of your repository. This basically iterates through all revisions in the repository by internally dumping all revisions and discarding the output— '''it's a good idea to run this on a regular basis to guard against latent(潛在的) hard disk failures and “[http://en.wikipedia.org/wiki/Bitrot bitrot]”. If this command fails—which it will do at the ''first sign'' of a problem—that means that your repository has at least one corrupted revision and you should restore the corrupted revision from a backup (you did make a backup, didn't you? 這裡只提到從備份 restore 的方法, 是否意謂著 repository 本身不會有問題, 有問題一定出在 storage media[?]).'''

'''Examples'''

Verify a hung repository:

 {{{
$ svnadmin verify /usr/local/svn/repos/
* Verified revision 1729.
 }}}

=== Subversion properties ===

__'''Subversion allows users to invent arbitrarily-named ''versioned properties on files and directories'', as well as ''unversioned properties on revisions''.''' The only restriction is on properties whose names begin with `svn:` (those are reserved for Subversion's own use). While these properties may be set by users to control Subversion's behavior, users may not invent new `svn:` properties.__

==== Versioned Properties ====

 * `svn:executable`
 
   If present on a file, the client will make the file executable in Unix-hosted working copies. See the section called “File Executability”.
   
 * `svn:mime-type`
 
   __If present on a file, the value indicates the file's mime-type. '''This allows the client to decide whether line-based contextual merging is safe to perform during updates, and can also affect how the file behaves when fetched via web browser.''' See the section called “File Content Type”.__
 
 * `svn:ignore`

   If present on a directory, the value is a list of unversioned file patterns to be ignored by `svn status` and other subcommands. See the section called “Ignoring Unversioned Items”
 
 * `svn:keywords`

   __If present on a file, the value tells the client how to ''expand'' particular keywords within the file. See the section called “Keyword Substitution”. (可以用在版權宣告嗎[?])__

 * `svn:eol-style`
 
   If present on a file, the value tells the client how to manipulate the file's line-endings in the working copy, and in exported trees. See the section called “End-of-Line Character Sequences” and `svn export`.
   
 * `svn:externals`
 
   If present on a directory, the value is a multi-line list of other paths and URLs the client should check out. See the section called “Externals Definitions”.
   
 * `svn:special`
 
   If present on a file, indicates that the file is not an ordinary file, but a ''symbolic link'' or other special object1.

 * `svn:needs-lock`

   __'''If present on a file, tells the client to make the file read-only in the working copy, as a reminder that the file should be locked before editing begins.''' See the section called “Lock Communication”.__
   
==== Unversioned Properties ====

 * `svn:author`
 
   If present, contains the authenticated username of the person who created the revision. (If not present, then the revision was committed anonymously.)
   
 * `svn:date`
 
   Contains the UTC time the revision was created, in ISO 8601 format. The value comes from the server machine's clock, not the client's.
   
 * `svn:log`
 
   Contains the log message describing the revision.
   
 * `svn:autoversioned`
 
   If present, the revision was created via the autoversioning feature. See the section called “Autoversioning”.

=== Repository Hooks ===

==== start-commit ====

Notification of the beginning of a commit. (ex. access control)

__The `start-commit` hook is run before the ''commit transaction'' is even created. It is typically used to decide if the user has commit privileges at all.__

If the `start-commit` hook program returns a non-zero exit value, the commit is stopped before the commit transaction is even created, and anything printed to stderr is marshalled back to the client.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. authenticated username attempting the commit

==== pre-commit ====

Notification just prior to commit completion. (ex. change validation and control)

__The `pre-commit` hook is run just before a commit transaction is promoted(創立) to a new revision. '''Typically, this hook is used to protect against commits that are disallowed due to content or location (for example, your site might require that all commits to a certain branch include a ticket number from the bug tracker, or that the incoming log message is non-empty).'''__

If the pre-commit hook program returns a non-zero exit value, the commit is aborted, the commit transaction is removed, and anything printed to stderr is marshalled back to the client.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. commit transaction name
 
`pre-commit.tmpl`:

 {{{
#!/bin/sh

# PRE-COMMIT HOOK
#
# The pre-commit hook is invoked before a Subversion txn is
# committed.  Subversion runs this hook by invoking a program
# (script, executable, binary, etc.) named 'pre-commit' (for which
# this file is a template), with the following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] TXN-NAME     (the name of the txn about to be committed)
#
# The default working directory for the invocation is undefined, so
# the program should set one explicitly if it cares.
#
# If the hook program exits with success, the txn is committed; but
# if it exits with failure (non-zero), the txn is aborted, no commit
# takes place, and STDERR is returned to the client.   The hook
# program can use the 'svnlook' utility to help it examine the txn.
#
# On a Unix system, the normal procedure is to have 'pre-commit'
# invoke other programs to do the real work, though it may do the
# work itself too.
#
#   ***  NOTE: THE HOOK PROGRAM MUST NOT MODIFY THE TXN, EXCEPT  ***
#   ***  FOR REVISION PROPERTIES (like svn:log or svn:author).   ***
#
#   This is why we recommend using the read-only 'svnlook' utility.
#   In the future, Subversion may enforce the rule that pre-commit
#   hooks should not modify the versioned data in txns, or else come
#   up with a mechanism to make it safe to do so (by informing the
#   committing client of the changes).  However, right now neither
#   mechanism is implemented, so hook writers just have to be careful.
#
# Note that 'pre-commit' must be executable by the user(s) who will
# invoke it (typically the user httpd runs as), and that user must
# have filesystem-level permission to access the repository.
#
# On a Windows system, you should name the hook program
# 'pre-commit.bat' or 'pre-commit.exe',
# but the basic idea is the same.
#
# The hook program typically does not inherit the environment of
# its parent process.  For example, a common problem is for the
# PATH environment variable to not be set to its usual value, so
# that subprograms fail to launch unless invoked via absolute path.
# If you're having unexpected problems with a hook program, the
# culprit may be unusual (or missing) environment variables.
# 
# Here is an example hook script, for a Unix /bin/sh interpreter.
# For more examples and pre-written hooks, see those in
# the Subversion repository at
# http://svn.collab.net/repos/svn/trunk/tools/hook-scripts/ and
# http://svn.collab.net/repos/svn/trunk/contrib/hook-scripts/


REPOS="$1"
TXN="$2"

# Make sure that the log message contains some text.
SVNLOOK=/usr/bin/svnlook
$SVNLOOK log -t "$TXN" "$REPOS" | \
   grep "[a-zA-Z0-9]" > /dev/null || exit 1

# Check that the author of this commit has the rights to perform
# the commit on the files and directories being modified.
/usr/share/subversion/hook-scripts/commit-access-control.pl "$REPOS" "$TXN" commit-access-control.cfg || exit 1

# All checks passed, so allow the commit.
exit 0
 }}}
 
==== post-commit ====

Notification of a successful commit. (ex. commit notification, tool integration)

__The `post-commit` hook is run after the transaction is committed, and a new revision created. Most people use this hook to send out descriptive emails about the commit or to notify some other tool (such as an issue tracker) that a commit has happened. Some configurations also use this hook to trigger backup processes.__

The output from, and exit value returned by the post-commit hook program are ignored.

The command-line arguments passed to the hook program, in order, are:

  1. repository path
  2. revision number created by the commit

`post-commit.tmpl`:

 {{{
#!/bin/sh

# POST-COMMIT HOOK
#
# The post-commit hook is invoked after a commit.  Subversion runs
# this hook by invoking a program (script, executable, binary, etc.)
# named 'post-commit' (for which this file is a template) with the 
# following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] REV          (the number of the revision just committed)
#
# The default working directory for the invocation is undefined, so
# the program should set one explicitly if it cares.
#
# Because the commit has already completed and cannot be undone,
# the exit code of the hook program is ignored.  The hook program
# can use the 'svnlook' utility to help it examine the
# newly-committed tree.
#
# On a Unix system, the normal procedure is to have 'post-commit'
# invoke other programs to do the real work, though it may do the
# work itself too.
#
# Note that 'post-commit' must be executable by the user(s) who will
# invoke it (typically the user httpd runs as), and that user must
# have filesystem-level permission to access the repository.
#
# On a Windows system, you should name the hook program
# 'post-commit.bat' or 'post-commit.exe',
# but the basic idea is the same.
# 
# The hook program typically does not inherit the environment of
# its parent process.  For example, a common problem is for the
# PATH environment variable to not be set to its usual value, so
# that subprograms fail to launch unless invoked via absolute path.
# If you're having unexpected problems with a hook program, the
# culprit may be unusual (or missing) environment variables.
# 
# Here is an example hook script, for a Unix /bin/sh interpreter.
# For more examples and pre-written hooks, see those in
# the Subversion repository at
# http://svn.collab.net/repos/svn/trunk/tools/hook-scripts/ and
# http://svn.collab.net/repos/svn/trunk/contrib/hook-scripts/


REPOS="$1"
REV="$2"

/usr/share/subversion/hook-scripts/commit-email.pl "$REPOS" "$REV" commit-watchers@example.org
 }}}

==== pre-revprop-change ====

Notification of a revision property change attempt. (ex. access control, change validation and control)

__The `pre-revprop-change` hook is run immediately prior to the modification of a revision property when performed ''outside the scope of a normal commit''[?]. Unlike the other hooks, the default state of this one is to ''deny'' the proposed action. The hook must actually exist and return a zero exit value before a revision property modification can happen.__

If the `pre-revprop-change` hook doesn't exist, isn't executable, or returns a non-zero exit value, no change to the property will be made, and anything printed to stderr is marshalled back to the client.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. revision whose property is about to be modified
 3. authenticated username attempting the propchange
 4. name of the property changed
 5. change description: A (added), D (deleted), or M (modified)
  
__Additionally, Subversion passes to the hook program via ''standard input'' the ''proposed value'' of the property.__

==== post-revprop-change ====

Notification of a successful revision property change. (ex. propchange notification)

The `post-revprop-change` hook is run immediately after to the modification of a revision property when performed outside the scope of a normal commit. As can be derived from the description of its counterpart, the `pre-revprop-change` hook, this hook will not run at all unless the `pre-revprop-change` hook is implemented. It is typically used to send email notification of the property change.

The output from, and exit value returned by, the post-revprop-change hook program are ignored.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. revision whose property was modified
 3. authenticated username of the person making the change
 4. name of the property changed
 5. change description: A (added), D (deleted), or M (modified)
 
Additionally, Subversion passes to the hook program, via standard input, the ''previous value'' of the property.

==== pre-lock ====

Notification of a path lock attempt. (ex. access control)

__The `pre-lock` hook runs whenever someone attempts to lock a path. It can be used to prevent locks altogether, or to create a more complex policy specifying exactly which users are allowed to lock particular paths. If the hook notices a pre-existing lock, then it can also decide whether a user is allowed to “steal” the existing lock. (強制取得鎖定而言)__

If the `pre-lock` hook program returns a non-zero exit value, the lock action is aborted and anything printed to stderr is marshalled back to the client.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. versioned path which is to be locked
 3. authenticated username of the person attempting the lock

==== post-lock ====

Notification of a successful path lock. (ex. lock notification)

The `post-lock` hook runs after ''one or more'' paths has been locked. It is typically used to send email notification of the lock event.

The output from and exit value returned by the `post-lock` hook program are ignored.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. authenticated username of the person who locked the paths
 
Additionally, the list of paths locked is passed to the hook program via standard input, one path per line.

==== pre-unlock ====

Notification of a path unlock attempt. (ex. access control)

__The `pre-unlock` hook runs whenever someone attempts to remove a lock on a file. It can be used to create policies that specify which users are allowed to unlock particular paths. It's particularly important for determining policies about ''lock breakage(斷裂)''. If user A locks a file, is user B allowed to break the lock? What if the lock is more than a week old? These sorts of things can be decided and enforced by the hook.__

If the `pre-unlock` hook program returns a non-zero exit value, the unlock action is aborted and anything printed to stderr is marshalled back to the client.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. versioned path which is to be locked
 3. authenticated username of the person attempting the lock
 
==== post-unlock ====

Notification of a successful path unlock. (ex. unlock notification)

The `post-unlock` hook runs after one or more paths has been unlocked. It is typically used to send email notification of the unlock event. 

The output from and exit value returned by, the `post-unlock` hook program are ignored.

The command-line arguments passed to the hook program, in order, are:

 1. repository path
 2. authenticated username of the person who unlocked the paths
 
Additionally, the list of paths unlocked is passed to the hook program via standard input, one path per line.




















== Repository Maintenance ==

Maintaining a Subversion repository can be a daunting(使人畏縮的) task, mostly due to the complexities inherent(與生俱來的) in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield(運用) them to accomplish tasks such as repository data migration, upgrades, backups and cleanups.

=== An Administrator's Toolkit ===

Subversion provides a handful of(少數) utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools. (如果採用 Berkeley DB 當做底層資料庫的話)

'''`svnadmin`'''

The `svnadmin` program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of svnadmin is similar to that of other Subversion command-line programs:

 {{{
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS & OPTIONS ...]
Type 'svnadmin help <subcommand>' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
…
 }}}

'''`svnlook`'''

`svnlook` is a tool provided by Subversion for examining the various revisions and transactions in a repository. No part of this program attempts to change the repository. `svnlook` is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the `pre-commit` hook) or that were just committed (in the case of the `post-commit` hook) to the repository. A repository administrator may use this tool for diagnostic purposes.

[...]

'''`svndumpfilter`'''

While it won't be the most commonly used tool at the administrator's disposal(處置), `svndumpfilter` provides a very particular brand(種類) of useful functionality—the ability to quickly and easily modify streams of Subversion repository history data by acting as a path-based filter.

The syntax of `svndumpfilter` is as follows: (由於沒有指定來源檔案的地方, 所以必須搭配 pipeline 來傳入資料)

 {{{
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS & OPTIONS ...]
Type 'svndumpfilter help <subcommand>' for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version number.

Available subcommands:
   exclude
   include
   help (?, h)
 }}}

There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream: (路徑的表示法類似 `/source/trunk/src/`; 這裡的 explicit/implicit 指的是 排除/內含 的概念)

 * `exclude`: Filter out a set of paths from the dump data stream.
 * `include`: Allow only the requested set of paths to pass through the dump data stream.

=== Berkeley DB Recovery ===

A Berkeley DB repository can sometimes be left in frozen state if not closed properly. When this happens, an administrator needs to rewind(卷回; 會不會有資料的漏失[?]) the database back into a consistent state. This is unique to BDB-backed repositories, though—if you are using FSFS-backed ones instead, this won't apply to you (若 FSFS 出狀況怎麼排除[?]). And for those of you using Subversion 1.4 with Berkeley DB 4.4 or better, you should find that Subversion has become much more resilient(能恢復原來形狀的) in these types of situations. Still, wedged(卡住的) Berkeley DB repositories do occur, and an administrator needs to know how to safely deal with this circumstance.

In order to protect the data in your repository, Berkeley DB uses a locking mechanism. This mechanism ensures that portions of the database are not simultaneously modified by multiple database accessors, and that each process sees the data in the correct state when that data is being read from the database. When a process needs to change something in the database, it first checks for the existence of a lock on the target data. If the data is not locked, the process locks the data, makes the change it wants to make, and then unlocks the data. Other processes are forced to wait until that lock is removed before they are permitted to continue accessing that section of the database. (This has nothing to do with the locks that you, as a user, can apply to versioned files within the repository; we try to clear up the confusion caused by this terminology collision(碰撞) in The three meanings of "lock"; 將技術細節包裝成使用者更容易理解的概念...)

__In the course(過程) of using your Subversion repository, fatal errors or interruptions can prevent(使...不能) a process from having the chance to remove the locks it has placed in the database. The result is that the back-end database system gets "wedged" (這表示交易未完成, 但已發生的異動並沒有被 rollback, 所以才會有上面 "rewind the database back into..." 的說法; 但這不是 DBMS 很基本的功能嗎? 為何不能自行做 rollback 之後再自動釋放 lock[?]). When this happens, any attempts to access the repository hang indefinitely (since each new accessor is waiting for a lock to go away—which isn't going to happen).__

If this happens to your repository, don't panic(驚慌). The Berkeley DB filesystem takes advantage of database transactions and checkpoints and pre-write journaling to ensure that only the most catastrophic(大災難) of events can permanently destroy a database environment. A sufficiently paranoid(多疑的) repository administrator will have made off-site backups(異地備份) of the repository data in some fashion, but don't head off to the tape backup storage closet just yet[?].

[...]

== svnadmin ==

=== svnadmin recover ===

Bring a repository database back into a consistent state (applies only to repositories using the bdb backend; 難道 FSFS 不會出狀況嗎[?]). In addition, if `repos/conf/passwd` does not exist, it will create a default password file (這跟密碼檔有什麼關係[?]). Run this command if you get an error indicating that your repository needs to be recovered. (要如何判讀 repository 是處於 inconsistent 的狀態? `svnadmin verify` 可以檢查得出來嗎[?])

 {{{
svnadmin recover REPOS_PATH [--wait]
 }}}

'''Examples'''

Recover a hung repository:

 {{{
$ svnadmin recover /usr/local/svn/repos/
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
 }}}

Recovering the database requires an exclusive lock on the repository. If another process is accessing the repository, then `svnadmin recover` will error:

 {{{
$ svnadmin recover /usr/local/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?

$
 }}}

The `--wait` option, however, will cause `svnadmin recover` to wait indefinitely(無期限地) for other processes to disconnect:

 {{{
$ svnadmin recover /usr/local/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by…

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
 }}}

=== svnadmin verify ===

Verify the data stored in the repository. Run this command if you wish to verify the integrity of your repository. This basically iterates through all revisions in the repository by internally dumping all revisions and discarding the output.

 {{{
svnadmin verify REPOS_PATH
 }}}

'''Examples:'''

Verify a hung repository:

 {{{
$ svnadmin verify /usr/local/svn/repos/
* Verified revision 1729.
 }}}


