= Domain-Driven Design Quickly - A Summary of Eric Evans' Domain-Driven Design =
<<TableOfContents>>

{{attachment:overview.png}}

== Preface: Why DDD Quickly? ==

I first heard about Domain Driven Design and met Eric Evans at a small gathering(聚會) of architects(設計師) at a mountain summit(高峰會議) organized by Bruce Eckel (Thinking in Java 的作者) in the summer of 2005. The summit was attended(列席) by a number of people I respect, including Martin Fowler, Rod Johnson, Cameron Purdy, Randy Stafford, and Gregor Hohpe.

The group seemed quite impressed with the vision of Domain Driven Design, and was eager to learn more about it. I also got the feeling that everyone wished that these concepts were more mainstream. When I noticed how Eric used the domain model to discuss solutions to some of the various technical challenges the group discussed, and how much emphasis he placed on the business domain instead of technology-specific hype(花招), I knew right away that this vision is one that the community sorely needed.

__We, in the enterprise development community, especially the web development community, have been tainted by years of hype that took us away from proper object oriented software development. '''In the Java community, good domain modeling was lost in the hype of EJB and the container/component models of 1999-2004. Luckily, shifts in technology and the collective experiences of the software development community are moving us back towards traditional object oriented paradigms.''' However, the community is lacking a clear vision for how to apply object orientation on an ''enterprise scale'', which is why I think DDD is important.__

Unfortunately, outside of a small group of the most senior architects, I perceived(發覺) that very few people were aware of DDD, which is why InfoQ commissioned(委託) the writing of this book.

It is my hope that by publishing a short, quickly-readable summary and introduction to the fundamentals of DDD and making it freely downloadable on InfoQ with an inexpensive pocket-sized print version, this vision can become mainstream.

This book does not introduce any new concepts; it attempts to concisely(簡潔地) summarize the essence(精髓) of what DDD is, drawing(汲取) mostly Eric Evans’ original book on the subject, as well other sources since published such as Jimmy Nilsson’s http://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202[Applying DDD] and various DDD discussion forums. The book will give you a crash(速成) course on the fundamentals of DDD, but it is no substitute for the numerous examples and case studies provided in Eric’s book or the hands-on(實習的) examples provided in Jimmy’s book. I highly encourage you to read both of these excellent works. In the meantime, if you agree that the community needs DDD to be part of our group consciousness(意識), please let people know about this book and Eric’s work.

Floyd Marinescu <<BR>>
Co-founder & Chief Editor of InfoQ.com

== Introduction ==

Software is an instrument created to help us deal with the complexities of our modern life. Software is just the means to an end(目的), and usually that end is something very practical and real. For example, we use software for air traffic control, and this is directly related to the world surrounding us. We want to fly from one place to another, and we do that using sophisticated machineries(機器), so we create software to coordinate the flight of thousands of airplanes which happen to be in the air at any time.

__'''Software has to be practical and useful; otherwise we would not invest so much time and resources into its creation. That makes it extremely connected to a certain ''aspect'' of our lives. (映射)''' A useful package of software cannot be decoupled from that sphere(範疇) of reality, the domain it is supposed to help us manage. On the contrary, the software is deeply entangled(糾纏) with it. Software design is an art, and like any art it cannot be taught and learned as a precise science, by means of theorems(定理) and formulas. '''We can discover principles and techniques useful to be applied throughout the process of software creation, but we probably won’t ever be able to provide an exact path to follow from the real world need to the code module meant to serve that need.'''__ Like a picture or a building, a software product will include the personal touch(風格) of those who designed and developed it, something of the charisma(神力) and flair (天賦; or the lack of it) of those who contributed to its inception(開端) and growth.

There are different ways to approach software design. For the last 20 years, the software industry has known and used several methods to create its products, each with its advantages and shortcomings. __The purpose of this book is to focus on a design method which has emerged(形成) and evolved over the last two decades, but has crystallized(明確) more clearly during the last few years: domain-driven design. (這本書是 2007 年初發表的, 所以現在學 DDD 還不會太遲...)__ Eric Evans has made a great contribution to this subject matter by writing down in one book much of the accumulated knowledge about domain-driven design. For a more detailed presentation of this topic, we recommend reading his book “Domain-Driven Design: Tackling Complexity in the Heart of Software”, published by Addison-Wesley, ISBN: 0-321-12521-5.

Many valuable insights can also be learned by following the Domain Driven Design discussion group at:

 http://groups.yahoo.com/group/domaindrivendesign

This book is only an introduction to the topic, intended to quickly give you a fundamental, but not a detailed understanding of Domain Driven Design. We just want to whet your appetite(激起興趣) for good software design with the principles and guidelines used in the world of domain-driven design.

== What Is Domain-Driven Design ==

__'''Software development is most often applied to automating processes that exist in the real world, or providing solutions to real business problems; The business processes being automated or real world problems that the software is the domain of the software. We must understand from the beginning that software is originated from and deeply related to this domain.'''__

Software is made up of code. We might be tempted(陷入) to spend too much time with the code, and view the software as simply objects and methods.

Consider car manufacturing as a metaphor. The workers involved in auto manufacturing may specialize in producing parts of the car, but in doing so they often have a limited view of the entire car manufacturing process. They start viewing the car as a huge collection of parts which need to fit together, but a car is much more than that. A good car starts with a vision. It starts with carefully written specifications. And it continues with design. Lots and lots of design. Months, maybe years of time spent on design, changing and refining it until it reaches perfection, until it reflects the original vision. The processing design is not all on paper. Much of it includes doing models of the car, and testing them under certain conditions to see if they work. The design is modified based on the testing results. The car is sent to production eventually, and the parts are created and assembled together.

__Software development is similar. We can’t just sit down and type code. We can do that, and it works well for trivial cases. But we cannot create complex software like that.__

In order to create good software, you have to know what that software is all about. You cannot create a banking software system unless you have a good understanding of what banking is all about, one must understand the ''domain'' of banking.

__Is it possible to create complex banking software without good ''domain knowledge''? No way. Never. Who knows banking? The software architect? No. He just uses the bank to keep his money safe and available when he needs them. The software analyst? Not really. He knows to analyze a given topic, when he is given all the necessary ingredients(要素). The developer? Forget it. Who then? '''The bankers, of course. The banking system is very well understood by the people inside, by their specialists(專家). They know all the details, all the catches(陷阱), all the possible issues, all the rules. This is where we should always start: the domain.'''__

__'''When we begin a software project, we should focus on the domain it is operating in. The entire purpose of the software is to ''enhance a specific domain''.''' To be able to do that, the software has to fit harmoniously(調和地) with the domain it has been created for. Otherwise it will introduce strain(拉扯、曲解) into the domain, provoking(惱人的) malfunction(運作失常), damage, and even wreak(報復) chaos(深淵). How can we make the software fit harmoniously with the domain? '''The best way to do it is to make software ''a reflection of the domain''. Software needs to incorporate the core concepts and elements of the domain, and to precisely realize the relationships between them. Software has to ''model the domain''. Somebody without knowledge of banking should be able to learn a lot just by reading the code in a ''domain model''. (可以驗證 domain model 是否足以成為 "a reflection of the domain"; code 是由 domain model 推導而來 - code 與 model 兩者要一致, 但兩者畢竟是不同的東西)''' This is essential. Software which does not have its roots planted deeply into the domain will not react well to ''change over time''. So we start with the domain. Then what? A domain is something of this world. It cannot just be taken and poured(灌注) over the keyboard into the computer to become code. '''We need to create an ''abstraction of the domain''. We learn a lot about a domain while talking with the ''domain experts''. But this raw knowledge is not going to be easily transformed into software constructs, unless we build an abstraction of it, a blueprint in our minds. In the beginning, the blueprint always incomplete. But in time, while working on it, we make it better, and it becomes more and more clear to us. What is this abstraction? It is a ''model'', a model of the domain.''' According to Eric Evans, a domain model is not a particular diagram; it is the idea that the diagram is intended to convey(表達). '''It is not just the knowledge in a domain expert’s head; it is a rigorously(精確地) organized and selective abstraction of that knowledge (強調 "model" 與 "domain" 的不同, 所以才會有 "model the domain" 的說法).''' A diagram can represent and communicate a model, as can carefully written code, as can an English sentence.” (按 "as can carefully written code" 的說法, 作者應該沒有叫人畫圖的意思...)__

__'''The model is our ''internal representation'' of the target domain, and it is very necessary throughout the design and the development process. (這裡 "internal" 不單單是指 developers 內部, 而是 developers 與 domain experts 之間)''' During the design process we remember and make lots of references to the model. The world around us is way too much for our heads to handle. Even a specific domain could be more than a human mind can handle at one time. We need to organize information, to systematize it, to divide it up in smaller pieces, to group those pieces into logical modules, and take one at a time and deal with it. '''We even need to leave some parts of the domain out. A domain contains just too much information to include it all into the model. And much of it is not even necessary to be considered. (只考慮跟目標系統相關, 用得到的部份; 因此 Modeling 時最好以功能性驅動, 目標並非要得到完整的企業模型, 那是 ISO 顧問師的工作 ^^[...])''' This is a challenge by itself. What to keep and what to throw away? It’s part of the design, the software creation process.__ The banking software will surely keep track of the customer’s address, but it should not care about the customer’s eye color. That is an obvious case, but other examples might not be so obvious.

A model is an essential part of software design. We need it in order to be able to deal with complexity. All our thinking process about the domain is synthesized(合成) into this model. That’s good, but it has to come out of our head(因為要能夠被溝通、被實作...). It is not very useful if it remains in there, is it? We need to communicate this model with domain experts, with fellow(同事) designers, and with developers. __The model is the essence of the software, but we need to create ways to express it, to communicate it with others. '''We are not alone in this process, so we need to share knowledge and information, and we need to do it well, precisely, completely, and without ambiguity.''' There are different ways to do that. One is graphical: diagrams, use cases, drawings, pictures, etc. Another is writing. We write down our vision about the domain. Another is ''language''. We can and we should create a language to communicate specific issues about the domain.__ We will detail all these later, but the main point is that we need to ''communicate the model''.

When we have a model expressed, we can start doing ''code design'' (= development process). This is different from software design. Software design is like creating the architecture of a house, it’s about the big picture. On the other hand, code design is working on the details, like the location of a painting on a certain wall. __Code design is also very important, but not as fundamental as software design. A code design mistake is usually more easily corrected, while software design errors are a lot more costly to repair.__ It’s one thing to move a painting more to the left, and a completely different thing to tear down one side of the house in order to do it differently. Nonetheless the final product won’t be good without good code design. Here code design patterns come handy, and they should be applied when necessary. Good coding techniques help to create clean, maintainable code.

There are different approaches to software design. One is the waterfall design method. This method involves a number of stages. The business experts put up a set of requirements which are communicated to the business analysts. The analysts create a model based on those requirements, and pass the results to the developers, who start coding based on what they have received. It’s a one way flow of knowledge. While this has been a traditional approach in software design, and has been used with a certain level of success over the years, it has its flaws and limits. __The main problem is that there is no feedback from the analysts to the business experts or from the developers to the analysts.__

__Another approach is the Agile methodologies, such as Extreme Programming (XP). These methodologies are a collective movement against the waterfall approach, resulting from the difficulties of trying to come up with(提出) all the requirements upfront, particularly in light of(根據) requirements change. '''It’s really hard to create a complete model which covers all ''aspects'' of a domain upfront. It takes a lot of thinking, and often you just cannot see all the issues involved from the beginning, nor can you foresee(預見) some of the negative side effects or mistakes of your design.''' Another problem Agile attempts to solve is the so called “analysis paralysis(麻痺)”, with team members so afraid of making any ''design decisions'' that they make no progress at all(沒辦做的部份而言). While Agile advocates(提倡) recognize the importance of design decision, they resist(反抗) upfront design. Instead they employ a great deal of implementation flexibility, and through iterative development with continuous business stakeholder(利益攸關者) participation and a lot of ''refactoring'', '''the development team gets to learn more about the customer domain and can better produce software that meets the customers needs.'''__

__The Agile methods have their own problems and limitations; they advocate simplicity, but everybody has their own view of what that means. '''Also, continuous refactoring done by developers without solid design principles will produce code that is hard to understand or change.''' And while the waterfall approach may lead to over-engineering, the fear of overengineering may lead to another fear: the fear of doing a deep, thoroughly thought out design.__

This book presents the principles of domain driven design, which when applied can great increase any development processes ability to model and implement the complex problems in the domain in a maintainable way. __Domain Driven Design combines design and development practice, and shows how design and development can work together to create a better solution. '''Good design will accelerate the development, while feedback coming from the development process will enhance the design.'''__

=== Building Domain Knowledge ===

Let’s consider the example of an airplane flight control system project, and how domain knowledge can be built.

Thousands of planes(飛機) are in the air at a given moment all over the planet. They are flying their own paths towards their destinations, and it is quite important to make sure they do not collide(相撞) in the air. We won’t try to elaborate on(詳細說明) the entire traffic control system, but on a smaller subset which is a flight monitoring system. The proposed project is a monitoring system which tracks every flight over a certain area, determines if the flight follows its supposed route or not, and if there is the possibility of a collision.

__Where do we start from a software development perspective? In the previous section we said that we should start by understanding the domain, which in this case is air traffic monitoring. '''Air traffic controllers are the specialists of this domain. But the controllers are not system designers or software specialists.''' You can’t expect them to hand you a complete description of their problem domain.__

__'''The air traffic controllers have vast knowledge about their domain, but in order to be able to build up a model you need to extract essential information and generalize(歸納) it. (顯然這一段工作不是人人能做的, 事前要做很多的功課, 才有可能達到 "歸納" 的境界; 問題的提問要有技巧, 否則這些專家可能也會懶得跟一個完全沒進入狀況的人溝通...)'''__ When you start talking to them, you will hear a lot about aircrafts taking off, and landing, aircrafts in midair(半空中) and the danger of collision, planes waiting before being allowed to land, etc. To find order in this seemingly(表面上) chaotic(混亂的) amount of information, we need to start somewhere.

The controller and you agree that each aircraft has a departure(出發) and a destination airfield(機場). So we have an ''aircraft'', a ''departure'' and a ''destination'', as shown in the figure below.

{{attachment:air1.png}}

OK, the plane takes off from some place and touches down in another. But what happens in the air? What path of flight does it go? Actually we are more interested in what happens while it is airborn(飛行中的). The controller says that each plane is assigned a flight plan which is supposed to describe the entire air travel. While hearing about a flight plan, you may think in your mind that this is about the path followed by the plane while in the air. After further discussion, you hear an interesting word: ''route''(航線). It instantly catches your attention, and for a good reason. The route contains an important concept of flight travel. That’s what planes do while flying, they follow a route. It is obvious that the departure and destination points of the aircraft are also the starting and ending points of the route. So, instead of associating the aircraft with the departure and destination points, it seems more natural to associate it with a route, which in turn is associated with the corresponding departure and destination.

{{attachment:air2.png}}

Talking with the controller about the routes airplanes follow, you discover that actually the route is made up of small segments, which put together constitute(構成) some sort of a crooked(彎曲的) line from departure to destination. The line is supposed to pass through predetermined fixed points. So, a route can be considered a series of consecutive ''fixes''(方位). __At this point you no longer see the departure and destination as the terminal points of the route, but just another two of those fixes. '''This is probably quite different from how the controller sees them, but it is a necessary abstraction which helps later.'''__ The resulting changes based on these discoveries are:

{{attachment:air3.png}}

The diagram shows another element, the fact that each fix is a point in space followed by the route, and it is expressed as a three dimensional point. But when you talk to the controller, you will discover that he does not see it that way. Actually he sees the route as the projection(投影) on earth of the plane flight. The fixes are just points on Earth surface uniquely determined by their latitude(緯度) and longitude(經度). So the correct diagram is: (航線沒有分飛行高度嗎[?])

{{attachment:air4.png}}

__What is actually happening here? '''You and the domain experts are talking, you are ''exchanging knowledge''.''' You start asking questions, and they respond. While they do that, you dig essential concepts out of the air traffic domain. Those concepts may come out unpolished(粗糙的) and disorganized, but nonetheless they are essential for understanding the domain. You need to learn as much as possible about the domain from the experts. '''And by putting the right questions, and processing the information in the right way,''' you and the experts will start to sketch a view of the domain, a domain model. This view is neither complete nor correct, but it is the start you need. Try to figure out the essential concepts of the domain.__

__This is an important part of the design. Usually there are long discussions between software architects or developers and the domain experts. '''The software specialists want to extract knowledge from the domain experts, and they also have to ''transform it into a useful form''.''' At some point, they might want to create an early prototype to see how it works so far. While doing that they may find some issues with their model, or their approach, and may want to change the model. The communication is not only one way, from the domain experts to the software architect and further to the developers. There is also feedback, which helps create a better model, and a clearer and more correct understanding of the domain. '''Domain experts know their area of expertise well, but they organize and use their knowledge in a specific way, which is not always the best to be implemented into a software system. The analytical(分析的) mind of the software designer helps unearth(挖掘) some of the ''key concepts'' of the domain during discussions with domain experts, and also help construct a structure for future discussions as we will see in the next chapter (分析師必須有 "設計問題" 的能力). We, the software specialists (software architects and developers) and the domain experts, are creating the model of the domain together, and the model is the place where those two areas of expertise(專門技術) meet.''' This might seem like a very time consuming process, and it is, but this is how it should be, because in the end the software’s purpose is to solve business problems in a real life domain, so it has to blend(融合) perfectly with the domain.__

== The Ubiquitous Language ==

=== The Need for a Common Language ===

The previous chapter made the case that it is absolutely necessary to develop a model of the domain by having the the software specialists work with the domain experts; however, that approach usually has some initial difficulties due to a fundamental communication barrier(障礙). __'''The developers have their minds full of classes, methods, algorithms, patterns, and tend to always make a match between a real life concept and a programming artifact.''' They want to see what object classes to create and what relationships to model between them. They think in terms of inheritance, polymorphism, OOP, etc. And they talk like that all the time. And it is normal for them to do so. '''Developers will be developers. (這一句話講得真好!!)''' But the domain experts usually know nothing about any of that. They have no idea about software libraries, frameworks, persistence, in many case not even databases. They know about their specific area of expertise.__

In the air traffic monitoring example, the domain experts know about planes, about routes, altitudes(高度), longitudes and latitudes, they know about deviances(偏差) from the normal route, about plane trajectories(軌道). And they talk about those things in their own jargon(術語), which sometimes is not so straightforward to follow by an outsider (隔行如隔山).

To overcome this difference in communication style, when we build the model, we must communicate to exchange ideas about the model, about the elements involved in the model, how we connect them, what is relevant and what is not. Communication at this level is paramount(最重要的) for the success of the project. If one says something, and the other does not understand or, even worse, understands something else, what are the chances for the project to succeed?

A project faces serious problems when team members don’t share a common language for discussing the domain. Domain experts use their jargon while technical team members have their own language tuned(調整) for discussing the domain in terms of design.

__'''The terminology of day-to-day discussions is disconnected from the terminology embedded in the code''' (ultimately the most important product of a software project). And even the same person uses different language in speech and in writing, so that the most incisive(清楚的) expressions of the domain often emerge(形成) in a transient form that is never captured in the code or even in writing. '''(這裡暗示 domain - model - code design 的相對位置, 其中 model 是最適合拿來做為 developers 與 domain experts 間溝通的基礎)'''__

__'''During these sessions of communication, ''translation'' is often used to let the others understand what some concepts are about.''' Developers might try to explain some design patterns using a layman(外行人)’s language, and sometimes without success. The domain experts will strive to bring home(使明白) some of their ideas probably by creating a new jargon (事情會變得更為複雜). During this process communication suffers, and this kind of translation does not help the knowledge building process.__

We tend to use our own dialects(專業用語) during these design sessions, but none of these dialects can be a common language because none serves everyone’s needs.

We definitely need to speak the same language when we meet to talk about the model and to define it. What language is it going to be? The developers’ language? The domain experts’ language? Something in between?

__A core principle of domain-driven design is to use ''a language based on the model''. Since the model is the common ground(共同的立場), the place where the software meets the domain, it is appropriate to use it as the building ground for this language.__

__Use the model as the backbone of a language. '''Request that the team use the language consistently in all communications, and also in the code.''' While sharing knowledge and hammering out(設計出) the model, the team uses speech, writing and diagrams. Make sure this language appears consistently in all the communication forms used by the team; for this reason, the language is called the ''Ubiquitous Language''. (如果要寫 use case, 採用這裡的 ubiquitous language 應該會有更好的效果[...])__

The Ubiquitous Language connects all the parts of the design, and creates the premise(前提) for the design team to function well. It takes weeks and even months for large scale project designs to take shape. The team members discover that some of the initial concepts were incorrect or inappropriately used, or they discover new elements of the design which need to be considered and fit into the overall design. All this is not possible without a common language.

__Languages do not appear overnight(一夜之間). It takes hard work and a lot of focus to make sure that the key elements of the language are brought to light(發現). '''We need to find those ''key concepts'' which define the domain and the design, and find corresponding words (= terms, 詞條) for them, and start using them.''' Some of them are easily spotted(認出), but some are harder.__

__Iron out(消除) difficulties(爭議) by experimenting with ''alternative expressions'', which reflect ''alternative models''[?]. Then refactor the code, renaming classes, methods, and modules to conform to the new model. '''Resolve confusion over terms in conversation, in just the way we come to agree on the meaning of ordinary words.'''__

__Building a language like that has a clear outcome: '''the model and the language are strongly interconnected with one another. A change in the language should become a change to the model.''' Domain experts should object to(反對) terms or structures that are awkward(難用的) or inadequate(不充分的) to convey domain understanding. If domain experts cannot understand something in the model or the language, then it is most likely that there is something is wrong with it. '''On the other hand, developers should watch for ambiguity(曖昧) or inconsistency that will tend to appear in design (= code design).'''__

=== Creating the Ubiquitous Language ===

How can we start building a language? Here is a hypothetical(假想的) dialog between a software developer and a domain expert in the
air traffic monitoring project. Watch out for the words appearing in bold face.

Developer: We want to monitor air traffic. Where do we start?

Expert: Let’s start with the basics. All this traffic is made up of '''planes'''. Each plane takes off from a '''departure''' place, and lands at a '''destination''' place.

Developer: That’s easy. When it flies, the plane can just choose any air path the pilots like? Is it up to them to decide which way they should go, as long as they reach destination?

Expert: Oh, no. The pilots receive a '''route''' they must follow. And they should stay on that route as close as possible.

Developer: I’m thinking of this '''route''' as a 3D path in the air. If we use a Cartesian(笛卡兒) system of coordinates, then the '''route''' is simply a series of 3D points.

Expert: I don’t think so. We don’t see '''route''' that way. The '''route''' is actually the projection on the ground of the expected air path of the airplane. The '''route''' goes through a series of points on the ground determined by their '''latitude''' and '''longitude'''.

Developer: OK, then let’s call each of those points a '''fix''', because it’s a fixed point of Earth’s surface. And we’ll use then a series of 2D points to describe the path. And, by the way, the '''departure''' and '''destination''' are just fixes. We should not
consider them as separate concepts. The '''route''' reaches destination as it reaches any other '''fix'''. The plane must follow the '''route''', but does that mean that it can fly as high or as low as it likes?

Expert: No. The '''altitude''' that an airplane is to have at a certain moment is also established in the '''flight plan'''.

Developer: '''Flight plan'''? What is that?

Expert: Before leaving the airport, the pilots receive a detailed '''flight plan''' which includes all sorts of information about the '''flight''': the '''route''', cruise(巡航) '''altitude''', the cruise '''speed''', the type of '''airplane''', even information about the crew members(機組人員).

Developer: Hmm, the '''flight plan''' seems pretty important to me. Let’s include it into the model.

{{attachment:air5.png}}

Developer: That’s better. Now that I’m looking at it, I realize something. When we are monitoring air traffic, we are not actually interested in the planes themselves, if they are white or blue, or if they are Boeing or Airbus. We are interested in their '''flight'''. That’s what we are actually tracking and measuring. I think we should change the model a bit in order to be more
accurate. (將 Aircraft 改成 Flight)

__'''Notice how this team, talking about the air traffic monitoring domain and around their incipient(初期的) model, is slowly creating a language made up by the words in boldface. Also note how that language changes the model!'''__

__However, in real life such a dialog is much more verbose, and people very often talk about things indirectly, or enter into too much detail, or choose the wrong concepts; this can make coming up(被提出) with the language very difficult. To begin to address this, all team members should be aware of the need to create a common language and should be reminded to stay focused on essentials, and use the language whenever necessary. (顯然這個過程需要有經驗的人來帶領) '''We should use our own jargon during such sessions as little as possible, and we should use the Ubiquitous Language because this helps us communicate clearly and precisely.'''__

{{attachment:air6.png}}

__It is also highly recommended for the developers to implement the main concepts of the model in the code. A class could be written for `Route` and another for `Fix`. The `Fix` class could inherit from a `2DPoint` class, or could contain a `2DPoint` as its main attribute. That depends on other factors that will be discussed later. '''By creating classes for the corresponding model concepts, we are mapping between the model and the code, and between the language and the code. This is very helpful as it makes the code more readable, and makes it ''reproduce the model''.''' Having the code express the model pays off(有報償) later in the project, when the model grows large, and when changes in the code can have undesirable consequences(後果) if the code was not properly designed.__

We have seen how the language is shared by the entire team, and also how it helps building knowledge and create the model. What should we use for the language? Just speech? We’ve used diagrams (看起來很像是 ERD 或是 UML 的 Class Diagrams, 不過 ERP 沒有辦法表現繼承的概念; 用 Dia 來製作應該就夠用了). What else? Writing?

Some may say that UML is good enough to build a model upon. And indeed it is a great tool to write down ''key concepts'' as classes, and to express relationships between them. You can draw four or five classes on a sketchpad(草圖), write down their names, and show the relationships between them. __It’s very easy for everyone to follow what you are thinking, and a graphical expression of an idea is easy to understand. '''Everyone instantly shares the same vision about a certain topic, and it becomes simpler to communicate based on that.''' When new ideas come up, and the diagram is modified to reflect the conceptual change.__

UML diagrams are very helpful when the number of elements involved is small. But UML can grow like mushrooms(蕈類) after a nice summer rain. What do you do when you have hundreds of classes filling up a sheet of paper as long as Mississippi(密西西比河, 北美大陸最大的河流)? It’s hard to read even by the software specialists, not to mention domain experts. They won’t understand much of it when it gets big, and it does so even for medium size projects.

__Also, UML is good at expressing classes, their attributes and relationships between them. But the classes’ behavior and the constraints are not so easily expressed. For that UML resorts to(採取) text placed as notes into the diagram. '''So UML cannot convey two important ''aspects'' of a model: the meaning of the concepts it represents and what the objects are supposed to(應該) do.''' But that is OK, since we can add other communication tools to do it.__

__We can use documents. One advisable(可行的) way of communicating the model is to make some small diagrams each containing a subset of the model. These diagrams would contain several classes, and the relationship between them. That already includes a good portion of the concepts involved. Then we can add text to the diagram. The text will explain behavior and constraints which the diagram cannot. '''Each such subsection attempts to explain one important ''aspect'' of the domain, it points a “spotlight” to enlighten one part of the domain. (可以依照下面 module 的概念切割)'''__

Those documents can be even hand-drawn, because that transmits(傳達) the feeling that they are temporary, and might be changed in the near future, which is true, because the model is changed many times in the beginning before it reaches a more stable status.

It might be tempting to try to create one large diagram over the entire model. However, most of the time such diagrams are almost impossible to put together. And furthermore, even if you do succeed in making that unified diagram, it will be so cluttered(雜亂) that it will not convey the understanding better then did the collection of small diagrams.

__'''Be aware of long documents. It takes a lot of time to write them, and they may become obsolete(過時的) before they are finished. The documents must be in sync with the model. Old documents, using the wrong language, and not reflecting the model are not very helpful. Try to avoid them when possible.'''__

__It is also possible to communicate using code. This approach is widely advocated by the XP community. Well written code can be very communicative. Although the behavior expressed by a method is clear, is the method name as clear as its body? Assertions of a test talk for themselves, but how about the variable names and overall code structure? Are they telling the whole story, loud and clear? '''Code functionally does the right thing does not necessarily express the right thing. Writing a model in code is very difficult. (與 http://geekswithblogs.net/dlussier/archive/2007/11/29/117239.aspx[Dev Teach Day 4 - David Laribee: Fundamental Domain Driven Design] 這裡 "Model == Code" 的說不盡相同? 不過由 code 轉出 diagram 也是可行的方式之一[...])'''__

There are other ways to communicate during design. It’s not the purpose of this book to present all of them. One thing is nonetheless clear: the design team, made up of software architects, developers, and domain experts, needs a language that unifies their actions, and helps them create a model and express that model with code.

== Model-Driven Design ==

The previous chapters underscored(強調) the importance of an approach to software development that is centered on the business domain. We said that it is fundamentally important to create a model which is deeply rooted in the domain, and should reflect the essential concepts of the domain with great accuracy. The Ubiquitous Language should be fully exercised throughout the modeling process in order to facilitate communication between the software specialists and the domain experts, and to discover ''key domain concepts'' which should be used in the model. The purpose of this modeling process is to create a good model. __The next step is to implement the model in code. This is an equally important phase of the software development process. Having created a great model, but failing to properly transfer it into code will end up in software of questionable quality.__

It happens that software analysts work with business domain experts for months, discover the fundamental elements of the domain, emphasize the relationshipbs between them, and create a correct model, which accurately captures the domain. Then the model is passed on to the software developers. __The developers might look at the model and discover that some of the concepts or relationships found in it ''cannot be properly expressed in code''. So they use the model as the original source of inspiration(啟發), but they create their own design which borrows some of the ideas from the model, and adds some of their own. '''The development process continues further, and more classes are added to the code, expanding the divide(分歧) between the original model and the final implementation (工程師應該即時將這些問題回饋給分析師, 才是正確的態度).'''__ The good end result is not assured. Good developers might pull together a product which works, but will it stand the trials(受審) of time? Will it be easily extendable? Will it be easily maintainable?

__Any domain can be expressed with many models, and any model can be expressed in various ways in code. For each particular problem there can be more than one solution. Which one do we choose? '''Having one analytically(經分析地) correct model does not mean the model can be directly expressed in code. Or maybe its implementation will break some software design principles, which is not advisable. It is important to choose a model which can be easily and accurately put into code (因此 model 成形的過程中, 就要開始考量實作面的可行性).''' The basic question here is: how do we approach the transition from model to code?__

One of the recommended design techniques is the so called ''analysis model'', which is seen as separate from code design and is usually done by different people. The analysis model is the result of ''business domain analysis'', resulting in a model which has no consideration for the software used for implementation. Such a model is used to understand the domain. A certain level of knowledge is built, and the model resulting may be analytically correct. Software is not taken into account at this stage because it is considered to be a confusing factor. __This model reaches the developers which are supposed to do the design. Since the model was not built with design principles in mind, it probably won’t serve that purpose well. '''The developers will have to adapt it, or to create a separate design. And there is no longer a mapping between the model and the code. The result is that analysis models are soon abandoned after coding starts. (後續要修訂規格時, 問題就來了...)'''__

__One of the main issues with this approach is that analysts cannot foresee(預見) some of the defects in their model, and all the intricacies(複雜關係) of the domain. The analysts may have gone into too much detail with some of the components of the model, and have not detailed enough others. '''Very important details are discovered during the design and implementation process (因此分析師應該先把重點擺在廣度, 再斟酌一下深度, 而更深層的東西則要由 developer 以實作的角度來挖掘...). A model that is truthful(真實的) to the domain could turn out to have serious problems with object persistence, or unacceptable performance behavior.'''__

__'''Developers will be forced to make some decisions on their own, and will make ''design changes'' in order to solve a real problem which was not considered when the model was created. They create a design that slips away(悄悄離開) from the model, making it less relevant.'''__

__If the analysts work independently, they will eventually create a model. When this model is passed to the designers, some of the analysts’ knowledge about the domain and the model is lost. While the model might be expressed in diagrams and writing, chances are the designers won’t grasp(理解) the entire meaning of the model, or the relationships between some objects, or their behavior. There are details in a model which are not easily expressed in a diagram, and may not be fully presented even in writing. '''The developers will have a hard time figuring them out. In some cases they will make some ''assumptions'' about the intended behavior, and it is possible for them to make the wrong ones (工程師可能沒有商業上的敏感度), resulting in incorrect functioning of the program.'''__

__Analysts have their own closed(非公開的) meetings where many things are discussed about the domain, and there is a lot of knowledge sharing. '''They create a model which is supposed to contain all that information in a condensed(濃縮的) form, and the developers have to assimilate(消化) all of it by reading the documents given to them. It would be much more productive if the developers could join the analyst meetings and have thus attain(獲得) a clear and complete view of the domain and the model before they start designing the code. (如果分析師也有程式設計的背景, 就可以緩解這個問題, 但這樣的想法似乎有點不切實際...)'''__

__'''A better approach is to closely relate domain modeling and design. The model should be constructed with an eye open to the software and design considerations. Developers should be included in the modeling process. The main idea is to choose a model which can be appropriately expressed in software, so that the design process is straightforward and based on the model. Tightly relating the code to an underlying model gives the code meaning and makes the model relevant.'''__

__'''Getting the developers involved provides feedback. It makes sure that the model can be implemented in software. If something is wrong, it is identified at an early stage, and the problem can be easily corrected.'''__

__Those who write the code should know the model very well, and should feel responsible for its integrity. '''They should realize that a change to the code implies a change to the model; otherwise they will refactor the code to the point where it no longer expresses the original model.''' If the analyst is separated from the implementation process, he will soon lose his concern about the limitations introduced by development. The result is a model which is not practical.__

__'''Any technical person contributing to the model must spend some time touching the code, whatever primary role he or she plays on the project. Anyone responsible for changing code must learn to express a model through the code.''' Every developer must be involved in some level of discussion about the model and have contact with domain experts. Those who contribute in different ways must consciously(自覺地) engage(允諾) those who touch the code in a dynamic exchange of model ideas through the Ubiquitous Language.__

If the design, or some central part of it, does not map to the domain model, that model is of little value, and the correctness of the software is suspect(可疑的). At the same time, complex mappings between models and design functions are difficult to understand and, in practice, impossible to maintain as the design changes. A deadly(致命的) divide opens between analysis and design so that insight gained in each of those activities does not feed into the other.

Design a portion of the software system to reflect the domain model in a very literal way, so that mapping is obvious. Revisit the model and modify it to be implemented more naturally in software, even as you seek to make it reflect deeper insight into the domain. __Demand a single model that serves both purposes well, in addition to supporting a fluent(流暢的) Ubiquitous Language. Draw from the model the terminology used in the design and the basic assignment of responsibilities. '''The code becomes an expression of the model (這裡的 "expression" 意謂著, 寫程式就該像在 "講故事" 一樣), so a change to the code may be a change to the model. Its effect must ripple through the rest of the project’s activities accordingly.'''__

To tightly tie the implementation to a model usually requires software development tools and languages that support a modeling paradigm, such as object-oriented programming.

Object-oriented programming is suitable for model implementation because they are both based on the same paradigm. Object-oriented programming provides classes of objects and associations of classes, object instances, and messaging between them. OOP languages make it possible to create direct mappings between model objects with their relationships, and their programming counterparts.

Procedural languages offer limited support for model-driven design. Such languages do not offer the constructs necessary to implement key components of a model. Some say that OOP can be done with a procedural language like C, and indeed, some of the functionality can be reproduced that way. __Objects can be simulated as data structures. Such structures do not contain the behavior of the object, and that has to be added separately as functions. '''The meaning of such data exists only in developer’s mind, because the code itself is not explicit.''' A program written in a procedural language is usually perceived as a set of functions, one calling another, and working together to achieve a certain result. Such a program cannot easily encapsulate conceptual connections, making mapping between domain and code difficult to be realized.__

Some specific domains, like mathematics, can be easily modeled and implemented using procedural programming, because many mathematical theories are simply addressed using function calls and data structures because it is mostly about computations. More complex domains are not just a suite of abstract concepts involving computations, and cannot be reduced to a set of algorithms, so procedural languages fall short of the task of expressing the respective models. For that reason, procedural programming is not recommended for model-driven design.

=== The Building Blocks Of A Model-Driven Design ===

The following sections of this chapter will present the most important of ''patterns'' to be used in model-driven design. The purpose of these patterns is to present some of the key elements of object modeling and software design from the viewpoint of domain-driven design. The following diagram is a map of the patterns presented and the relationships between them.

attachment: overview.png

=== Layered Architecture ===

{{attachment:layered.png}}

__'''When we create a software application, a large part of the application is not directly related to the domain, but it is part of the ''infrastructure'' or serves the software itself.''' It is possible and ok for the domain part of an application to be quite small compared to the rest, since a typical application contains a lot of code related to database access, file or network access, user interfaces, etc.__

In an object-oriented program, UI, database, and other support code often gets written directly into the business objects. Additional business logic is embedded in the behavior of UI widgets and database scripts. This some times happens because it is the easiest way to make things work quickly. (邏輯分散)

However, when domain-related code is mixed with the other layers, it becomes extremely difficult to see and think about. Superficial(表面的) changes to the UI can actually change business logic. To change a business rule may require meticulous(小心翼翼的) tracing of UI code, database code, or other program elements. __Implementing coherent(有條理的), model-driven objects becomes impractical. '''Automated testing is awkward.''' With all the technologies and logic involved in each activity, a program must be kept very simple or it becomes impossible to understand. (只適用於小型的開發)__

__'''Therefore, partition a complex program into LAYERS. Develop a design within each LAYER that is cohesive(內聚的) and that depends only on the layers below. Follow standard architectural patterns to provide loose coupling to the layers above. Concentrate all the code related to the domain model in one layer and isolate it from the user interface, application, and infrastructure code.''' The domain objects, free of the responsibility of displaying themselves, storing themselves, managing application tasks, and so forth, can be focused on ''expressing'' the domain model. This allows a model to evolve to be rich enough and clear enough to capture essential business knowledge and put it to work.__

A common architectural solution for domain-driven designs contain four conceptual layers: (從 layer 的切割也看得到 MVC 的影子, 其中 M 就是 Domain Layer, V 就是 Presentation Layer, C 則是 Application Layer)

|| Layer || Responsibility ||
|| User Interface (Presentation Layer) || Responsible for presenting information to the user and interpreting user commands. ||
|| Application Layer || __This is a ''thin'' layer which coordinates the application activity. '''It does not contain business logic. It does not hold the state of the business objects, but it can hold the state of an ''application task progress''. (這裡指的是 facade 嗎[?])'''__ ||
|| Domain Layer || __This layer contains information about the domain. This is the heart of the business software. '''The state of business objects is held here.''' Persistence of the business objects and possibly their state is ''delegated'' (這呼應了將 DAO 或 Persistent Class 注入 Domain Object 實務做法) to the infrastructure layer.__ ||
|| Infrastructure Layer || This layer acts as a supporting library for all the other layers. It provides communication between layers, implements persistence for business objects, contains supporting libraries for the user interface layer, etc. (要注意 infrastructure 不只藏在 domain layer 的後面, 而是用來支撐其他所有的 layers) ||

It is important to divide an application in separate layers, and establish rules of interactions between the layers. __If the code is not clearly separated into layers, it will soon become so entangled(糾纏) that it becomes very difficult to ''manage changes''. One simple change in one section of the code may have unexpected and undesirable results in other sections. The domain layer should be focused on ''core domain issues''.__ It should not be involved in infrastructure activities. The UI should neither be tightly connected to the business logic (應該透過 application layer 轉介), nor to the tasks which normally belong to the infrastructure layer. __'''An application layer is necessary in many cases. There has to be a manager over the business logic which supervises(監督) and coordinates the overall activity of the application. (這就是 middleware 存在的價值)'''__ For example, a typical, the interaction of the application, domain and infrastructure could look like this. The user wants to book a flights route, and asks an ''application service'' in the application layer to do so. The application tier fetches the relevant domain objects from the infrastructure and invokes relevant methods on them, e.g. to check security margins(安全係數) to other already booked flights. Once the domain objects have made all checks and updated their status to “decided”(裁定), the application service persists the objects to the infrastructure.

==== Entities ====

__There is a category of objects which seem to have an ''identity'', which remains the same throughout the states of the software. '''For these objects it is not the attributes which matter (ID 不具任何意義),''' but a thread of ''continuity''(連續性[?]) and identity, which spans the life of a system and can extend beyond it. Such objects are called ''Entities''.__

__OOP languages keep object instances in memory, and they associate a reference or a memory address for each object. This reference is unique for each object at a given moment of time, but there is no guarantee that it will stay so for an indefinite(無期限地) period of time. Actually the contrary is true. '''Objects are constantly moved out and back into memory, they are serialized and sent over the network and recreated at the other end, or they are destroyed. This reference, which stands as an identity for the running environment of the program, is not the identity we are talking about.''' If there is a class which holds weather information, like temperature, it is quite possible to have two distinct instances of the respective class, both containing the same value. '''The objects are perfectly equal and ''interchangeable'' with one another, but they have different references. They are not entities.'''__

If we were to implement the concept of a Person using a software program, we would probably create a `Person` class with a series of attributes: name, date of birth, place of birth, etc. Are any of those attributes the identity of the person? Name cannot be the identity because there can be more people with the same name. We could not distinguish between two persons with the same name, if we were to take into account only their name. We can’t use date of birth either, because there are many people born on the same day. The same applies to the place of birth. An object must be distinguished from other objects even though they might have the same attributes. __'''Mistaken identity can lead to data corruption.'''__

Consider a bank accounting sytem. Each account has its own number. An account can be precisely identified by its number. This number remains unchanged throughout the life of the system, and assures continuity. __The account number can exist as an object in the memory, or it can be destroyed in memory and sent to the database. '''It can also be ''archived'' when the account is closed, but it still exists somewhere as long as there is some interest in keeping it around.''' It does not matter what representation it takes, the number remains the same.__

Therefore, implementing entities in software means ''creating identity''. For a person it can be a combination of attributes: name, date of birth, place of birth, name of parents, current address. The Social Security number is also used in US to create identity. For a bank account the account number seems to be enough for its identity. Usually the identity is either an attribute of the object, a combination of attributes, an attribute specially created to preserve and express identity, or even a behavior. __It is important for two objects with different identities to be to be easily distinguished by the system, '''and two objects with the same identity to be considered the same by the system.''' If that condition is not met, then the entire system can become corrupted. (不過以上所提的 account number, code, social security number 等, 都被賦予了某些意義, 不太適合拿來當做 ID...)__

__There are different ways to create a unique identity for each object. '''The ID could be automatically generated by a module, and used internally in the software without making it visible to the user. (ID 除了不具意義以外, 對使用者也是不可視的!!)''' It can be a primary key in a database table, which is assured to be unique in the database. Whenever the object is retrieved from the database, its ID is retrieved and recreated in memory.__ The ID could be created by the user as it happens with the codes associated to airports. Each airport has a unique string ID which is internationally recognized and used by the travel agencies all over the world to identify airports in their travel schedules. Another solution is to use the attributes of the object to create the ID, and when that is not enough, another attribute can be added to help identify the respective object.

When an object is distinguished by its identity, rather than its attributes, make this primary to its definition in the model. Keep the class definition simple and focused on ''life cycle'' continuity and identity. Define a means of distinguishing each object regardless of its form or history. __'''Be alert to requirements that call for matching objects by attributes. (ID 是給系統內部用的, 而 code, account, no 等都是給人看的, 雖然它們也具有唯一性, 但與 ID 的用途顯然不同)''' Define an operation that is guaranteed to produce a unique result for each object, possibly by attaching a symbol that is guaranteed unique. This means of identification may come from the outside, or it may be an arbitrary identifier created by and for the system, but it must correspond to the identity distinctions in the model. The model must define what it means to be the same thing.__

__Entities are important objects of a domain model, '''and they should be considered from the beginning of the modeling process. It is also important to determine if an object needs to be an entity or not,''' which is discussed in the next pattern.__

==== Value Objects ====

We have discussed entities and the importance of recognizing entities early during the modeling phase. Entities are necessary objects in a domain model. Should we make all objects entities? Should every object have an identity?

We may be tempted to make all objects entities. Entities can be tracked(追蹤). But tracking and creating identity comes with a cost. We need to make sure that each instance has its unique identity, and tracking identity is not very simple. It takes a lot of careful thinking to decide what makes an identity, because a wrong decision would lead to objects with the same identity, something that is not desired. __'''There are also performance implications in making all objects entities. There has to be one instance for each object.''' If Customer is an entity object, then one instance of this object, representing a specific bank client, cannot be reused for account operations corresponding to other clients. The outcome is that such an instance has to be created for every client. This can result in system performance degradation when dealing with thousands of instances.__

Let’s consider a drawing application. The user is presented a canvas and he can draw any points and lines of any thickness, style and color. It is useful to create a class of object named `Point`, and the program could create an instance of this class for each point on the canvas. Such a point would contain two attributes associated to screen or canvas coordinates. Is it necessary to consider each point as having an identity? Does it have continuity? It seems that the only thing that matters for such an object is its coordinates.

__There are cases when we need to contain some attributes of a domain element. '''We are not interested in which object it is, but what attributes it has. An object that is used to describe certain ''aspects'' of a domain, and which does not have identity, is named ''Value Object''. (本質上是不具 behavior 的, 比較像是資料結構, 要小心跟 DTO/Presentation Model 等混在一起, 因為好像也有 "不要共用" 的傾向? 但又沒有那麼強調[?])'''  It is necessary to distinguish between ''Entity Objects'' and ''Value Objects''. It is not helpful to make all object entities for the sake of uniformity(一致性; 為了 entity 而 entity). Actually, '''it is recommended to select as entities only those objects which conform to the entity definition. And make the rest of the objects Value Objects.''' (We will present another type of object in the next section, but we’ll assume that we have only entity objects and value objects for now.) This will simplify the design, and there will be some other positive consequences.__

__在 Entities 一節最後面有提到 "Be alert to requirements that call for matching objects by attributes", '''如果發現規劃不出 "一個對使用者有意義的代號" 來取得唯一值, 那它可能就不是一個 Model 上的 Entity, 而只是一個 Persistence 上的 Entity, 即便它在資料庫是一筆具有 PK 的記錄;''' 這樣的設計也相當合理, Model Entity 由 ModelHome 去快取, 而 Persistence Entity 則由 ORM 去快取... 例如 "個人業績排行結果"? 如果沒有事先統計出來, 就沒有這些爭議? 否則突然要將統計區間改成 "季" 而非原來的 "月" 怎麼辦? 還要 client 自己去加就太怪了!! 不該讓 "事先統計好" 的這個實作面往上浮現[?] 對於有爭議者, 都先視為 Value Object, 待實作上發覺非 Entity 不可時再做調整...__

__'''@2008/01/18 上述 "個人業績排行結果" 的狀況, 如果將它包裝成 Model Entity, 勢必就像是個 Entity. 但這麼做並沒有太大的意義, 因為它單純是資料的儲存型式, 稱不上是 Domain Model, 所以還是將它視為 Data 就好...'''__

__'''Having no identity, Value Objects can be easily created and discarded. Nobody cares about creating an identity, and the garbage collector takes care of the object when is no longer referenced by any other object. This simplifies the design a lot. It is highly recommended that value objects be ''immutable'' (因為 shareable 的本質; 這解釋了 Hibernate 裡 `org.hibernate.usertype.UserType` 為什麼會有個 `isMutable` 的方法需要被實作). They are created with a constructor, and never modified during their life time. (由於 immutable 的本質, 限定了實作上只能透過 getter 來讀取資料, 而不能提供 setter 或者以 public fields 的型式來表現; 由於 Value Object 相對單純, 因此不太需要用 interface 來實作, 但隔一層總是好的[...])''' When you want a different value for the object, you simply create another one. This has important consequences for the design. '''Being immutable, and having no identity, Value Objects can be shared. That can be imperative(必要的) for some designs. Immutable objects are ''sharable'' with important performance implications(牽涉).''' They also manifest(表明) integrity, i.e. ''data integrity''. Imagine what it would mean to share an object which is not immutable. An air travel booking system could create objects for each flight. One of the attributes could be the flight code. One client books a flight for a certain destination. Another client wants to book the same flight. The system chooses to reuse the object which holds the flight code, because it is about the same flight. In the meantime, the client changes his mind, and chooses to take a different flight. The system changes the flight code because this is not immutable. The result is that the flight code of the first client changes too.__

__'''One golden rule is: if Value Objects are ''shareable'', they should be ''immutable''. Value Objects should be kept thin and simple.''' When a Value Object is needed by another party, it can be simply passed by value, or a copy of it can be created and given. Making a copy of a Value Object is simple, and usually without any consequences(影響). If there is no identity, you can make as many copies as you wish, and destroy all of them when necessary.__

{{attachment:valueobject.png}}

__'''Value Objects can contain other Value Objects, and they can even contain references to Entities (後者的用法比較少見, 但似乎相當的務實? 這代表 Value Object 不一定能夠當 VO/DTO 使用, 也可能要從 factory 裡產生出來[...]).''' Although Value Objects are used to simply contain attributes of a domain object (= entity[?]), that does not mean that it should contain a long list with all the attributes. '''Attributes can be grouped in different objects. Attributes chosen to make up a Value Object should form a ''conceptual whole''. (這呼應了上面 "certain aspects of a domain" 的說法, 在某些情況下可以用 inner class/interface 來表現)'''__ A customer is associated with a name, a street, a city, and a state. It is better to contain the address information in a separate object, and the customer object will contain a reference to such an object. Street, city, state should have an object of their own, the `Address`, because they belong conceptually together, rather than being separate attributes of customer, as shown in the diagram below.

==== Services ====

When we analyze the domain and try to define the main objects that make up the model, we discover that some ''aspects'' of the domain are not easily mapped to objects. Objects are generally considered as having attributes, an internal state which is managed by the object, and exhibit(呈現) a behavior. __When we develop the ubiquitous language, the key concepts of the domain are introduced in the language, '''and the nouns of the language are easily mapped to objects. The verbs of the language, associated with their corresponding nouns become the part of the behavior of those objects. But there are some actions in the domain, some verbs, which do not seem to belong to any object.'''__ They represent an important behavior of the domain, so they cannot be neglected(輕忽) or simply incorporated(合併) into some of the Entities or Value Objects. __Adding such behavior to an object would spoil(破壞) the object, making it stand for functionality which does not belong to it. Nonetheless, using an object-oriented language, we have to use an object for this purpose. We can’t just have a separate function on its own (全域方法). It has to be attached to some object. '''Often this kind of behavior functions across several objects, perhaps of different classes. (注意 "of same class" 的狀況, 如同下面兩個 account 間金額移轉的例子)'''__ For example, to transfer money from one account to another; should that function be in the sending account or the receiving account? It ''feels'' just as misplaced(放錯地方) in either.

__When such a behavior is recognized in the domain, the best practice is to declare it as a ''Service''. '''Such an object does not have an internal state, and its purpose is to simply provide functionality for the domain.''' The assistance provided by a Service can be a significant one, and a '''Service can group related functionality which serves the Entities and the Value Objects. (這表示系統內可能會有多個 service) It is much better to declare the Service explicitly(明確地; 相對於歸入 entity 或 value object 而言), because it creates a clear distinction in the domain, it encapsulates a concept.'''__ It creates confusion to incorporate such functionality in an Entity or Value Object because it won’t be clear what those objects stand for.

__Services act as ''interfaces'' which provide operations (為何這裡要強調 "interface"[?]). Services are common in technical frameworks, but they can be used in the domain layer too. '''A service is not about the object performing the service, but is related to the objects the operations are performed on/for. In this manner(如此), a Service usually becomes a point of connection for many objects. This is one of the reasons why behavior which naturally belongs to a Service should not be included into domain objects.''' If such functionality is included in domain objects, '''a dense(緊密的) network of associations is created between them and the objects which are the beneficiary(受惠者) of the operations. (有時候會產生邏輯上的矛盾[...])''' A high degree of coupling between many objects is a sign of poor design because it makes the code difficult to read and understand, and more importantly, it makes it difficult to change.__

A Service should not replace the operation which ''normally'' belongs on domain objects. We should not create a Service for every operation needed. But when such an operation stands out(顯著) as an important concept in the domain, a Service should be created for it. There are three characteristics of a Service:

 1. The operation performed by the Service refers to(涉及) a domain concept which does not naturally belong to an Entity or Value Object.
 2. The operation performed refers to other objects in the domain.
 3. The operation is ''stateless''.

__When a significant process or ''transformation'' in the domain is not a natural responsibility of an Entity or Value Object, add an operation to the model as a standalone interface declared as a Service. Define the interface in terms of the language of the model and make sure the operation name is part of the Ubiquitous Language. '''Make the Service ''stateless''.'''__

__While using Services, is important to keep the domain layer isolated. It is easy to get confused between services which belong to the domain layer, and those belonging to the infrastructure. '''There can also be services in the application layer which adds a supplementary(額外的) level of complexity (@2008/01/12, 這顯然與之前認知到的 "service layer = application layer" 不同, 事實上這裡根本就沒有 "service layer" 這種東西[?]). Those services are even more difficult to separate from their ''counterparts'' residing in the domain layer. (按這裡的 "counterparts" 與之前 "thin layer" 的說法, application/domain layers 兩者之間一定有不單純的關係[...])''' While working on the model and during the design phase, we need to make sure that the domain level remains isolated from the other levels.__

__'''Both application and domain Services are usually built on top of domain Entities and Values providing required functionality directly related to those objects.''' Deciding the layer a Service belongs to is difficult. If the operation performed conceptually belongs to the application layer, then the Service should be placed there. If the operation is about domain objects, and is strictly related to the domain, ''serving a domain need'', then it should belong to the domain layer.__

Let’s consider a practical example, a web reporting application. The reports make use of data stored in a database, and they are generated based on templates. The final result is an HTML page which is shown to the user in a web browser.

The UI layer is incorporated in web pages and allows the user to login, to select the desired report and click a button to request it. The application layer is a thin layer which stands between the user interface, the domain and the infrastructure. It interacts with the database infrastructure during login operations (直接存取 infrastructure layer 的做法並不恰當), and interacts with the domain layer when it needs to create reports. The domain layer will contain the core of the domain, objects directly related to the reports. Two of those objects are `Report` and `Template`, which the reports are based on. (單純將 `Report` 取出, 然後套上 `Template` 而言) The infrastructure layer will support database access and file access.

When a user selects a report to be created, he actually selects the name of the report from a list of names. This is the `reportID`, a string. Some other parameters are passed, like the items shown in the report and the time interval of the data included in the report. But we will mention only the `reportID` for simplicity. __This name is '''passed through the application layer to the domain layer'''. The domain layer is responsible for creating and returning the report being given its name.__ Since reports are based on templates, a Service could be created, and its purpose would be to obtain the template which corresponds to a `reportID`. This template is stored in a file or in the database. It is not appropriate to put such an operation in the `Report` object itself. It does not belong to the `Template` object either. So we create a separate `Service` whose purpose is to retrieve a report template based on report’s ID. This would be a service located in the domain layer. It would make use of the file infrastructure to retrieve the template from the disk.

==== Modules ====

For a large and complex application, the model tends to grow bigger and bigger. The model reaches a point where it is hard to talk about as a whole, and understanding the relationships and interactions between different parts becomes difficult. For that reason, it is necessary to organize the model into modules. Modules are used as a method of organizing related concepts and tasks in order to reduce complexity.

__Modules are widely used in most projects. '''It is easier to get the picture of a large model if you look at the modules it contains, then at the relationships between those modules. After the interaction between modules is understood, one can start figuring out the details inside of a module.''' It’s a simple and efficient way to manage complexity.__

__Another reason for using modules is related to code quality. It is widely accepted that software code should have a high level of cohesion(內聚力) and a low level of coupling. '''While cohesion starts at the class and method level, it can be applied at module level. It is recommended to group highly related classes into modules to provide maximum cohesion possible.''' There are several types of cohesion. Two of the most used are ''communicational cohesion'' and ''functional cohesion''. Communicational cohesion is achieved when parts of the module operate on the same data. It makes sense to group them, because there is a strong relationship between them. '''The functional cohesion is achieved when all parts of the module work together to perform a ''well-defined task''. This is considered the best type of cohesion. (由 "communicational cohesion" 的存在, 意謂著即使採用 "functional cohesion", 還是會有 "operate on the same data" 的狀況)'''__

__'''Using modules in design is a way to increase cohesion and decrease coupling.''' Modules should be made up of elements which functionally or logically belong together assuring cohesion. '''Modules should have well defined ''interfaces'' which are accessed by other modules. (這裡的 interface, 與 layer 之間的 interface 有何不同[?]) Instead of calling three objects of a module, it is better to access one interface, because it reduces coupling.''' Low coupling reduces complexity, and increases maintainability. It is easier to understand how a system functions when there are few connections between modules which perform well defined tasks, than when every module has lots of connections to all the other modules.__

__'''Choose Modules that tell the ''story'' of the system and contain a cohesive(內聚的) set of concepts.''' This often yields(帶來) low coupling between modules, but if it doesn’t look for a way to change the model to disentangle(解開[?]) the concepts, or an overlooked concept that might be the basis of a Module that would bring the elements together in a meaningful way. Seek low coupling in the sense of concepts that can be understood and reasoned about independently of each other. '''Refine the model until it partitions according to ''high-level domain concepts'' and the corresponding code is decoupled as well.'''__

__'''Give the Modules names that become part of the Ubiquitous Language. Modules and their names should reflect insight into the domain. (這一點很容易被疏忽)'''__

__Designers are accustomed(習慣) to creating modules from the outset(一開始). They are common parts of our designs. After the role of the module is decided, it usually stays unchanged, while the internals of the module may change a lot. '''It is recommended to have some flexibility, and allow the modules to evolve with the project, and should not be kept frozen.''' It is true that module refactoring may be more expensive than a class refactoring, but when a module design mistake is found, it is better to address it by changing the module then by finding ways around it.__

==== Aggregates ====

The last three patterns in this chapter will deal with a different modeling challenge, one related to the ''life cycle'' of domain objects. __'''Domain objects go through a set of states during their life time. They are ''created''(這的 create 包含有 "新增資料" 與 "載入資料" 兩種意思), placed in memory and used in computations, and they are ''destroyed''(這裡的 destroy 指的不是 "刪除" 資料, 而是 "卸載" 資料).''' In some cases they are saved in permanent locations, like a database, where they can be retrieved from some time later, or they can be ''archived''. At some point they can be completely erased from the system, including database and the ''archive storage''.__

Managing the life cycle of a domain object constitutes a challenge in itself, and if it is not done properly, it may have a negative impact on the domain model. We will present three patterns which help us deal with it. __''Aggregate''(集合) is a domain pattern used to define object ''ownership'' and ''boundaries''. ''Factories'' and ''Repositories'' are two design patterns which help us deal with object creation and storage.__ We will start by talking about Aggregates.

__A model can contain a large number of domain objects. No matter how much consideration we put in the design, it happens that many objects are associated with one another, creating a complex net of relationships. There are several types of associations. '''For every ''traversable association'' in the model, there has to be corresponding software mechanism which enforces it. Real associations between domain object end up in the code, and many times even in the database (這裡的 "many times", 指的就是 ERD 裡的 multiplicity).'''__ A one-to-one relationship between a customer and the bank account opened on his name is expressed as a reference between two objects, and implies a relationship between two database tables, the one which keeps the customers and the one which keeps the accounts.

__'''The challenges of models are most often ''not to make them complete enough'', but rather to ''make them as simple and understandable as possible''.''' Most of the time it pays off to eliminate or simplify relations from the model.__ That is, unless they embed deep understanding of the domain.

A one-to-many association is more complex because it involves many objects which become related. This relationship can be simplified by transforming it into an association between one object and a collection of other objects, although it is not always possible.

__There are many-to-many associations and a large number of them are bidirectional. This increases complexity a lot, making the life cycle management of such objects quite difficult. '''The number of associations should be reduced as much as possible. Firstly, associations which are not essential for the model should be removed. They may exist in the domain, but they are not necessary in our model, so take them out (呼應上面 "make them as simple and understandable as possible" 的說法). Secondly, ''multiplicity''(多重性) can be reduced by adding a ''constraint''. If many objects satisfy a relationship, it is possible that only one will do it if the right constraint is imposed(強加) on the relationship. Thirdly, many times bidirectional associations(= many-to-many) can be transformed in unidirectional ones.''' Each car has an engine, and every engine has a car where it runs. The relationship is bidirectional, but it can be easily simplified considering that the car has an engine, and not the other way around.__

After we reduce and simplify associations between objects, we may still end up with many relationships. A banking system holds and processes customer data. This data includes customer personal data, like name, address, phone numbers, job description, and account data: account number, balance, operations performed, etc. __'''When the system archives or completely deletes information about a customer, it has to make sure that all the references are removed. (這裡一再出現 "archive" 的字眼, 真的要好好研究一下[...])''' If many objects hold such references, it is difficult to ensure that they are all removed (相依性存在, 無法刪除; 有些相依性無法以 database constraint 來表示, 所以處理上要很小心). Also, when some data changes for a customer, the system has to make sure that it is properly updated throughout the system, and data integrity is guaranteed. This is usually left to be addressed at database level. '''Transactions are used to enforce data integrity. But if the model was not carefully designed, there will be a high degree of database contention(競爭), resulting in poor performance. While database transactions play a vital role in such operations, it is desirable to solve some of the problems related to data integrity directly in the model (事實上 database 只應該做 constraint 的檢查即可, 不應該涉入 model 太多; 過度依賴 database 機制會讓 business logic 被拆散)'''__.

__'''It is also necessary to be able to enforce the ''invariants''. The invariants are those rules which have to be maintained whenever data changes. (這裡的 "invariant" 與上面套用在 relationships 上的概念 "constraint" 不同; 可以用 assertion 來達成[...])''' This is difficult to realize when many objects hold references to changing data objects.__

__It is difficult to guarantee the consistency of changes to objects in a model with complex associations. Many times invariants apply to closely related objects, not just discrete(離散的) ones. Yet cautious(謹慎的) locking schemes cause multiple users to interfere pointlessly(不得要領地) with each other and make a system unusable[?].__

__Therefore, use Aggregates. '''An Aggregate is a group of associated objects which are considered as one unit with regard to data changes. (這跟我們之前一直在討論的 relationships 不太一樣, 但也可以說是 relationship 的一種型式 - 包含關係: one class is part of another)''' The Aggregate is demarcated(界定) by a boundary which separates the objects inside from those outside. Each Aggregate has one root. The root is an Entity, and it is the only object accessible from outside. The root can hold references to any of the aggregate objects, and the other objects can hold references to each other, but an outside object can hold references only to the root object. '''If there are other Entities inside the boundary, the identity of those entities is ''local'', making sense only inside the aggregate. (搞得太複雜了, 因此還衍生出了 transient reference, local identity 的說法[...])'''__

How is the Aggregate ensuring data integrity and enforcing the invariants? __Since other objects can hold references only to the root, it means that they cannot directly change the other objects in the aggregate. All they can do is to change the root, or ask the root to perform some actions. And the root will be able to change the other objects, but that is an operation contained inside the aggregate, and it is controllable. '''If the root is deleted and removed from memory, all the other objects from the aggregate will be deleted too, because there is no other object holding reference to any of them.'''__ When any change is done to the root which indirectly affects the other objects in the aggregate, it is simple to enforce the invariants because the root will do that. It is much harder to do so when external objects have direct access to internal ones and change them. Enforcing the invariants in such a circumstance involves putting some logic in external objects to deal with it, which is not desirable.

It is possible for the root to pass ''transient references'' of internal objects to external ones, with the condition that the external objects do not hold the reference after the operation is finished. One simple way to do that is to pass copies of the Value Objects to external objects. It does not really matter what happens to those objects, because it won’t affect the integrity of the aggregate in any way.

__If objects of an Aggregate are stored in a database, '''only the root should be obtainable through queries. The other objects should be obtained through traversal associations.''' Objects inside an Aggregate should be allowed to hold references to roots of other Aggregates.__

__The root Entity has ''global identity'', and is responsible for maintaining the invariants. Internal Entities have ''local identity''. (無法想像 global/local identity 在實務上要怎麼做[?])__ Cluster(聚集) the Entities and Value Objects into Aggregates and define boundaries around each. Choose one Entity to be the root of each Aggregate, and control all access to the objects inside the boundary through the root. Allow external objects to hold references to the root only. Transient references to internal members can be passed out for use within a single operation only. Because the root controls access, it cannot be blindsided(攻其無防備之處) by changes to the internals. This arrangement makes it practical to enforce all invariants for objects in the Aggregate and for the Aggregate as a whole in any state change.

A simple example of an Aggregation is shown in the following diagram. The customer is the root of the Aggregate, and all the other objects are internal. If the Address is needed, a copy of it can be passed to external objects.

{{attachment:aggregates.png}}

==== Factories ====

__Entities and Aggregates can often be large and complex – too complex to create in the constructor of the root entity. '''Infact trying to construct a complex aggregate in its constructure is in contradiction(矛盾) with what often happens in the domain itself, where things are created by other things (like electronics(電子設備) get created in on assembly lines; 這個生產線的例子真是生動, 進而已出了 "factory" 的概念).''' It is like having the printer build itself.__

__When a client object wants to create another object, it calls its constructor and possibly passes some parameters. But when the object construction is a laborious(費勁的) process, '''creating the object involves a lot of knowledge about the internal structure of the object, about the relationships between the objects contained, and the rules applied to them. This means that each client of the object will hold specific knowledge about the object built.''' This breaks encapsulation of the domain objects and of the Aggregates.__ If the client belongs to the application layer, a part of the domain layer has been moved outside, messing up(弄亂) the entire design. In real life, it is like we are given plastic, rubber, metal, silicon, and we are building our own printer. It’s not impossible, but is it really worth doing it?

__'''Creation of an object can be a major operation in itself, but complex ''assembly'' operations do not fit the responsibility of the created objects (注意這裡 "assembly" 的說法; 在這一節的最後面有提到, factory 應用在 "新增" 與 "載入" 兩種狀況, 英文 "creation" 的用法, 會讓人誤以為 factory 只能用在 "新增" 的動作上; 這跟後面的 "Repository" 有何不同? 又 EJB 的 Home 又該歸屬在哪裡[?]). Combining such responsibilities can produce ungainly designs that are hard to understand (呼應前面 "contradiction with the domain" 的說法).'''__

__Therefore, a new concept is necessary to be introduced, one that help to encapsulate the process of complex object creation. This is called ''Factory''. '''Factories are used to encapsulate the knowledge necessary for object creation, and they are especially useful to create Aggregates.'''__ When the root of the Aggregate is created, all the objects contained by the Aggregate are created along with it, and all the invariants are enforced.

__It is important for the creation process to be ''atomic''. If it is not, there is a chance for the creation process to be half done for some objects, leaving them in an undefined state. This is even more true for Aggregates.__ When the root is created, it is necessary that all objects subject to invariants are created too. Otherwise the invariants cannot be enforced. For immutable Value Objects it means that all attributes are initialized to their valid state. If an object cannot be created properly, an exception should be raised, making sure that an invalid value is not returned.

__Therefore, shift the responsibility for creating instances of complex objects and Aggregates to a separate object, '''which may itself have no responsibility in the domain model but is still part of the domain design. Provide an interface that encapsulates all complex assembly and that does not require the client to reference the concrete classes of the objects being instantiated.'''__ Create entire Aggregates as a unit, enforcing their invariants. There are several design patterns used to implement Factories. The book Design Patterns by Gamma et all. describes them in detail, and presents these two patterns among others: ''Factory Method'', ''Abstract Factory''. We won’t try to present the patterns from a ''design perspective'', but from a domain modeling one.

__A Factory Method is an object method which contains and hides knowledge necessary to create another object. This is very useful when a client wants to create an object which belongs to an Aggregate. '''The solution is to add a method to the Aggregate root,''' which takes care of the object creation, enforces all invariants, and returns a reference to that object, or to a copy of it.__

{{attachment:factory1.png}}

The container contains components and they are of a certain type. It is necessary that when such a component is created to automatically belong to a container. The client calls the `createComponent(Type t)` method of the container. The container instantiates a new component. The concrete class of the component is determined based on its type. After its creation, the component is added to the collection of components contained by the container, and a copy of it is returned to the client.

There are times when the construction of an object is more complex, or when the creation of an object involves the creation of a series of objects. For example: the creation of an Aggregate. Hiding the internal construction needs of an Aggregate can be done in a separate Factory object which is dedicated to this task. Let’s consider the example of a program module which computes the route that can be followed by a car from departure to destination being given a series of constraints. The user logs in the web site running the application and specifies one of the following constraints: the shortest route, the fastest route, the cheapest route. The routes created can be annotated with user information which needs to be saved, so they can be later retrieved when the customer logs in again.

{{attachment:factory2.png}}

The Route ID generator is used to create a unique identity for each route which is necessary for an Entity.

__'''When creating a Factory, we are forced to violate an object’s encapsulation, which must be done carefully. (必要的折衷)''' Whenever something changes in the object that has an impact on construction rules or on some of the invariants, we need to make sure the Factory is updated to support the new condition. Factories are tightly related to the objects they are created. That can be a weakness(弱點), but it can also be a strength.__ An Aggregate contains a series of objects that are closely related. The construction of the root is related to the creation of the other objects in the Aggregate. There has to be some logic which puts together an Aggregate. The logic does not naturally belong to any of the objects, because it is about the construction of other objects. It seems appropriate to use a special Factory class which is given the task of creating the entire Aggregate, and which will contain the rules, the constraints and the invariants which have to be enforced for the Aggregate to be valid. The objects will remain simple and will serve their specific purpose without the clutter of complex construction logic.

__'''''Entity Factories'' and ''Value Object Factories'' are different.''' Values are usually immutable objects, and all the necessary attributes need to be produced at the time of creation. When the object is created, it has to be valid and ''final''. It won’t change. Entities are not immutable. They can be changed later, by setting some of the attributes with the mention that all invariants need to be respected. Another difference comes from the fact that Entities need identity, while Value Objects do not.__

__'''There are times when a Factory is not needed, and a simple constructor is enough. (過而不及)'''__ Use a constructor when:

 * The construction is not complicated.
 * The creation of an object does not involve the creation of others, and all the attributes needed are passed via the constructor.
 * The client is interested in the implementation, perhaps wants to choose the ''Strategy'' used. (產生實作上的相依, 反應了設計上的不良...)
 * The class is the type. There is no hierarchy involved, so no need to choose between a list of concrete implementations.

__Another observation is that Factories need to create new objects from scratch, or they are required to reconstitute(重新建立) objects which previously existed, but have been probably persisted to a database. Bringing Entities back into memory from their resting(靜止的) place in a database involves a completely different process than creating a new one. One obvious difference is that the new object does not need a new identity. The object already has one. '''Violations of the invariants are treated differently. When a new object is created from scratch, any violation of invariants ends up in an exception. We can’t do that with objects recreated from a database. The objects need to be repaired somehow, so they can be functional, otherwise there is data loss. (要從資料的修復下手, 而不是在 domain object 上做妥協)'''__

==== Repositories ====

__In a model-driven design, '''objects have a life cycle starting with ''creation'' and ending with ''deletion'' or ''archiving''.''' A constructor or a Factory takes care of object creation. The entire purpose of creating objects is to use them.__ In an object-oriented language, one must hold a reference to an object in order to be able to use it. To have such a reference, the client must either create the object or obtain it from another, by traversing an existing association. For example, to obtain a Value Object of an Aggregate, the client must request it from the root of the Aggregate. The problem is now that the client must have a reference to the root. __For large applications, this becomes a problem because one must make sure the client always has a reference to the object needed, or to another which has a reference to the respective object. '''Using such a rule in the design will force the objects to hold on a series of references they probably wouldn’t keep otherwise. This increases coupling, creating a series of associations which are not really needed. (因此在做 DI 時, 要記錄直接注入 "需要用到" 的部份)'''__

To use an object means the object has already been created. If the object is the root of an Aggregate, then it is an Entity, and chances are it will be stored in a persistent state in a database or another form of persistence. If it is a Value Object, it may be obtainable from an Entity by traversing an association. __'''It turns out that a great deal of objects can be obtained directly from the database.''' This solves the problem of getting reference of objects. When a client wants to use an object, it accesses the database, retrieves the object from it and uses it. This seems like a quick and simple solution, but it has negative impacts on the design.__

__Databases are part of the infrastructure. A poor solution is for the client to be aware of the details needed to access a database. For example, the client has to create SQL queries to retrieve the desired data. The database query may return a set of records, exposing even more of its internal details. '''When many clients have to create objects directly from the database, it turns out that such code is scattered(四散的) throughout the entire domain. At that point the domain model becomes compromised(妥協的結果). It has to deal with lots of infrastructure details instead of dealing with domain concepts.''' What happens if a decision is made to change the underlying database? All that scattered code needs to be changed to be able to access the new storage.__ When client code accesses a database directly, it is possible that it will restore an object internal to an Aggregate. This breaks the encapsulation of the Aggregate with unknown consequences.

__A client needs a practical means of acquiring references to preexisting domain objects. If the infrastructure makes it easy to do so, the developers of the client may add more traversable associations, muddling(搞亂) the model.__ On the other hand, they may use queries to pull the exact data they need from the database, or to pull a few specific objects rather than navigating from Aggregate roots. __Domain logic moves into queries and client code, and the Entities and Value Objects become mere data containers. The sheer technical complexity of applying most database access infrastructure quickly swamps(淹沒) client code, which leads developers to dumb-down the domain layer, which makes the model irrelevant. The overall effect is that the domain focus is lost and the design is compromised.__

__'''Therefore, use a Repository, the purpose of which is to encapsulate all the logic needed to obtain object references. (這就是一般所說的 object lookup)''' The domain objects won’t have to deal with the infrastructure to get the needed references to other objects of the domain. They will just get them from the Repository and the model is regaining(重新獲得) its clarity and focus.__

The Repository may store references to some of the objects. When an object is created, it may be saved in the Repository, and retrieved from there to be used later. If the client requested an object from the Repository, and the Repository does not have it, it may get it from the storage. Either way, the Repository acts as a storage place for globally accessible objects.

The Repository may also include a ''Strategy''. It may access one persistence storage or another based on the specified Strategy. It may use different storage locations for different type of objects. The overall effect is that the domain model is decoupled from the need of storing objects or their references, and accessing the underlying persistence infrastructure.

{{attachment:repository1.png}}

For each type of object that needs global access, create an object that can provide the illusion of an in-memory collection of all objects of that type. Set up access through a well-known global interface. Provide methods to add and remove objects, which will encapsulate the actual insertion or removal of data in the data store. Provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria, thereby encapsulating the actual storage and query technology. Provide repositories only for Aggregate roots that actually need direct access. Keep the client focused on the model, delegating all object storage and access to the Repositories.

A Repository may contain detailed information used to access the infrastructure, but its interface should be simple. A Repository should have a set of methods used to retrieve objects. The client calls such a method and passes one or more parameters which represent the selection criteria used to select an object or a set of matching objects. An Entity can be easily specified by passing its identity. Other selection criteria can be made up of a set of object attributes. The Repository will compare all the objects against that set and will return those that satisfy the criteria. The Repository interface may contain methods used to perform some supplementary calculations like the number of objects of a certain type.

It can be noted that the implementation of a repository can be closely liked to the infrastructure, but that the repository interface will be pure domain model.

{{attachment:repository2.png}}

Another option is to specify a selection criteria as a Specification. The Specification allows defining a more complex criteria, such as in the following:

{{attachment:repository3.png}}

There is a relationship between Factory and Repository. They are both patterns of the model-driven design, and they both help us to manage the life cycle of domain objects. While the Factory is concerned with the creation of objects, the Repository takes care of already existing objects. The Repository may cache objects locally, but most often it needs to retrieve them from a persistent storage. Objects are either created using a constructor or they are passed to a Factory to be constructed. For this reason, the Repository may be seen as a Factory, because it creates objects. It is not a creation from scratch, but a reconstitution of an object which existed. We should not mix a Repository with a Factory. The Factory should create new objects, while the Repository should find already created objects. When a new object is to be added to the Repository, it should be created first using the Factory, and then it should be given to the Repository which will store it like in the example below.

{{attachment:repository4.png}}

Another way this is noted is that Factories are “pure domain”, but that Repositories can contain links to the infrastructure, e g the database.

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
|| || ||

=== Links ===

=== Search ===

== Scratch ==

 * "Iin the previous section" -> "In the previous section" (p8)
 * "While they do that, they dig" -> "While they do that, you dig" (p11)
 * "e g to check security margins" -> "e.g. to check security margins" (p31)
 * "Such objects are called Entities" -> "Such objects are called Entities." (p31)
 * "distinguish between to persons with" -> "distinguish between two persons with" (p32)
 * "\Value Objects can contain" -> "Value Objects can contain" (p36)
 * "as shown in the diagram below." -> "as shown in the diagram above." (p36)
 * "Most of the time it pays of to" -> "Most of the time it pays off to" (p42)
