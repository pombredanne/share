= LEGO MINDSTORMS NXT-G Programming Guide =
http://www.apress.com/book/view/1590598717
<<TableOfContents>>

== Chapter 1 Robots and Programs ==

If you are already familiar with the subject of robots and the concept of programming, feel free to skip ahead a few chapters. But if you are just starting out with your LEGO Mindstorms NXT robotics kit and are asking yourself questions such as, “How is a robot different from a toaster(烤面包機)?” or “Just what is this thing called programming?” then you’re in the right place. If terms like “conditional statements,” “nested loops,” and “variables” make your head spin(暈眩), don’t worry— they make my head spin, too.

__There is simply no reason that learning to use the Mindstorms NXT robotics kit should cause stress. It’s supposed to be fun, right? Building robots and making them do what you want them to do shouldn’t cause headaches.__ I don’t like headaches, and I certainly don’t want to give you one, so sit back and let me show you a less stressful method for getting the most out of NXT.

=== What Is a Robot? ===

I’m going to keep this short—I promise. What is a robot? There are numerous definitions. One definition is a human-shaped mechanical device that mimics human actions. Another definition is an electronic machine that functions independently, without human control. And there are many more. There truly doesn’t seem to be one official definition.

For the purpose of this book, I’m going to give you my definition. Here goes: __A robot is a device that is built to ''independently'' perform actions and interact with its surroundings. In a nutshell, a robot should be able to move and react all on its own. '''If you are controlling its actions, it’s just a remote-controlled toy, right?'''__ But if your device can do things like examine its surroundings, respond to obstacles(障礙) such as chairs or walls, pick out a red ball from a mix of colored balls, and hundreds of other activities without help from its human creator, then you’ve got a robot.

You can build a robot using all the great Mindstorms NXT components that came with your robotics kit. Your bot can have claws(爪子) or hands. It can have ears to listen and eyes to see. It can walk on legs or roll on wheels. But in order for a robot to be able to do all these things on its own, you must provide it with one additional component, a ''program''.

=== What Is a Program? ===

I know I told you that computer terminology makes my head spin, but there are some terms that cannot be avoided. But the terms I want to introduce to you are easy to explain and even easier to spell, so they can’t be all that bad!

When we talk about the Mindstorms NXT robotics kit, we’re talking about a piece of technology. Technology almost always requires a little learning, but that shouldn’t mean it has to be boring—NXT robots are cool and fun. So, let’s start right off by defining one of the coolest technical terms you need to understand—program.

I can’t really write a book about NXT programming without defining what a program is, can I? So let’s jump in with a small discussion about this word. I promise to keep it fun. Let’s take a look at a very basic robot. I call this robot SPOT and, for right now, SPOT only does one thing. He sits.

Take a look at Figure 1-1; there’s SPOT doing what he does best.

{{attachment:figure_1-1.png}} <<BR>> Figure 1-1. My bot SPOT

__Can we all agree that SPOT is a fairly boring robot? We all know that robots should do things! You could almost say that SPOT needs to be ''trained''. And that’s how I’m going to define the word “program.” Read the next two sentences slowly: '''A ''program'' is a set of ''instructions(指令)'' for my robot. ''Programming'' is what you do when you create a program.'''__

It’s not a long definition, and it certainly isn’t complicated. The definition will get a little more detailed as you read more chapters, but for now, let’s just start out with that very basic idea.

You’ve encountered a lot of programs in your lifetime. Don’t believe me? Okay, let me give you an example:

 * Teacher: Okay, class, take out your history books. [Grumbling(發隆隆聲), the students take out their books.]
 * Teacher: I want everyone to turn to page 55. [With more grumbling, everyone turns to page 55.]
 * Teacher: Everyone read through to page 65. [Loud grumbling]

The teacher just gave a program to follow: take out your book, turn to a specific page, and read a specified number of pages. Let me give you one more example: (作者很喜歡用 whatsit 跟 whatchamacallit 這兩個字, 意思都是 - something whose name has been forgotten or is not known)

 * Step 1: Place the widget firmly(緊緊地) against the whatsit.
 * Step 2: Snap the special wonder-whatchamacallit into the widget.
 * Step 3: Flip the whatsit over, and bend(使轉向) the thingamajig(某件東西) to the left.

Those are steps I found in an instruction manual—a program for me to follow. If I follow the steps, my whatsit should work perfectly (my whatchamacallit still isn’t working!).

__A simple program is just a set of instructions (written, spoken, or maybe provided in some other method) that needs to be followed. I certainly don’t want to call you a robot, but in a way, we all can frequently act like robots. When we follow a set of instructions, we are ''running'' a program! (Another word you might sometimes hear used instead of “run” is “execute”: “I told SPOT to run his SLEEP program” is the same as “I told SPOT to execute his SLEEP program.”)__

Let’s go back to SPOT. He’s just sitting there. How boring. Let’s pretend(假裝) for a moment that SPOT has ears, and I can give him some instructions. I’ll start off by giving SPOT some basic movements:

 * Me: SPOT, move forward. [SPOT starts to roll forward.]
 * Me: SPOT, stop. [SPOT stops rolling.]

__I’ve just given SPOT two very simple programs to follow. What? Two programs? Yes, the first program is “Move forward.” The second program is “Stop.” '''The simplest programs can be just one step!''' Now, I could combine them into one program, but I’ll encounter a problem:__

 * Me: SPOT, move forward and stop. [SPOT just sits there.]
 
__What happened? Well, think about someone telling you to “move forward and stop.” How far forward will you move? When will you stop? '''You’re smart, but robots are not. Robots must be told ''exactly'' what to do.''' And in this example, SPOT did exactly as he was told. SPOT moved forward and stopped. The reason you didn’t see him move is because the moment he started spinning(旋轉) his motors, he stopped.__

In the first example, I waited until SPOT began to roll before telling him to stop, so he had time to actually move. In the second example, I combined the instructions into one program (move forward and stop) without telling SPOT how far or maybe how long (in time) to move forward. So let’s try it again:

 * Me: SPOT, move forward for 5 seconds and stop. [SPOT moves forward for 5 seconds and then stops.]

Okay, so maybe SPOT isn’t the problem. I’ve just figured out that when I tell SPOT to do things, I’ve got to be ''very specific''.

One other thing that SPOT is good at is reading my handwriting(讀取程式而言). Let me give you another example of how specific I need to be when telling SPOT to execute a program, but this time, instead of telling him what to do, I simply take out a piece of paper and write down the following: SPOT, move forward 3 inches; turn left 90 degrees; move backward 2 inches; spin 360 degrees, and stop.

Next, I give the piece of paper to SPOT, and he reads it. He moves forward 3 inches, turns left 90 degrees, moves backward 2 inches, spins 360 degrees, and, finally, stops.

If your NXT robot is like mine, though, it probably doesn’t have the ability to listen to voice commands or read a sheet of paper.

__If your robot can’t hear you or read your handwriting, how exactly do you tell it what to do? Easy! You’re going to use ''programming software''. There are other names such as programming suite or ''graphical programming environment'', or blah blah blah—for now, let’s just use programming software, OK?__

__You’re in luck—your Mindstorms NXT robotics kit comes with programming software called '''''NXT-G'' (the G is for “Graphical,” meaning programs are not written instructions such as my previous handwritten steps for SPOT; 按http://en.wikipedia.org/wiki/G_(programming_language)[這裡]的說法, 這裡的 "G" 正是 LabVIEW 所採用的語言名稱).'''__

 Note: There are a lot of ways to program. Just as different people speak different languages, robots (and computers and other technical stuff) can speak different languages. Some examples of human languages are English, Spanish, French, German, and Italian. For your NXT robots, there are a variety of languages, too. I speak English, because that is the language I learned to speak in school. __Your ''NXT Brick'' comes from the factory understanding one language: NXT-G.__

 __I also speak Spanish. But it’s not my native language(母語). Your NXT Brick can learn to speak other languages, too, but its native language is NXT-G. Most people won’t learn another language until they understand their native language well. And that’s what you need to do—learn NXT-G well so you can talk to your robot (by giving it a program).__

=== NXT-G ===

NXT-G is the tool you will use to tell your robots what to do. NXT-G allows you to create programs that can be uploaded (installed; 按照官方的說法, 應該是 download) to your NXT robot. These programs can be instructions as simple as “move forward 2 inches and stop” or as advanced as you can imagine! NXT robots can be built with a variety of motors and sensors. But without a good program, your robot won’t know what to do: Do I spin my motors? What do I do with this Touch sensor? Without programming, you’ll have one confused robot on your hands.

NXT-G is installed on a computer (there are Windows and Macintosh versions) and exists as software. I’m not going to be covering the basics of using the software, so you’ll need to refer to the LEGO Mindstorms NXT User Guide that came with your NXT kit for installation instructions and steps on how to perform basic steps such as creating new programs, saving programs, and other items.

You will create and save your programs (just like you save a drawing or an essay(短文) on your computer) and then connect your NXT robot to the computer. When your NXT robot is connected, you will be able to upload one or more programs to your robot and run (execute) them.

__Right now, there are two versions of the Mindstorms NXT-G programming tool. One version comes with the NXT robotics kit that’s bought in a store (sometimes called the ''retail version''), and the other comes with NXT kits bought through the LEGO Education division (sometimes called the ''education version''). '''Education versions are typically purchased by schools and teachers, but anyone can actually buy this version if they wish.'''__

__If you’re not sure which version you have, take a look at Figures 1-2 and 1-3. Figure 1-2 shows the retail version (with the Robo Center), and Figure 1-3 shows the education version (with Robo Educator). Don’t stress too much over the version you own; there are differences, but for the purposes of this book, over 90 percent of the tools are identical. (兩者最大的差別就在畫面右側的 Robo Center 及 Robo Educator)__

{{attachment:figure_1-2.png}} <<BR>> Figure 1-2. NXT-G retail version comes with Robo Center

{{attachment:figure_1-3.png}} <<BR>> Figure 1-3. NXT-G education version comes with Robo Educator

The NXT-G Programming Software is fun to use; feel free play around with it. The best part about NXT-G is that much of it is extremely easy to figure out on your own. When you’re ready to start learning how to create some awesome programs, turn to Chapter 2. I’m keeping the chapters short so you’ll have plenty of time to read a little and then go play—no 50-page chapters in this book!

The next chapter is going to help you figure out what you want your robot to do. Go and experiment a little with NXT-G, and I’ll see you in Chapter 2.

== Chapter 2 Program Structure ==

I don’t really like using technical terms like “program structure,” but it is a very useful concept that will benefit you as you begin to program your robots. So bear with me for this short chapter.

=== What Do I Mean by Structure? ===

Back in Chapter 1, I gave you some examples of real-world programs. Would the following example have made any sense?

 * Teacher: Class, open your books to page 55. [The class looks confused.]
 * Teacher: Class, I want you to get out your history books. [Giving the teacher confused looks, the students get out their books.]

How can you read page 55 if you haven’t yet been told which book to open? You might answer, “Yes, but I’m in history class, and the teacher said turn to page 55. So I’m sure the teacher means my history book!”

__That’s true. As a human, you are able to figure out certain instructions on your own. '''But remember—robots aren’t that smart! They need to be given very strict and specific instructions. And those instructions need to be given in a specific ''order''. That order is another way of saying “program structure.” (以程序語言的角度來看待)'''__

Let’s get out SPOT for another example. He’s still doing his one and only trick—sit. We’re not quite ready to upload an NXT-G program yet, but let’s do some ''preplanning'' at this stage. __I want you to use something that computer programmers call ''pseudo-code''. What is pseudocode? Well, the definition of “pseudo” is fake (as in pretend, simulated, virtual—get the idea?); it’s not real. And “code” is simply another word for program. So put it all together and one way of looking at pseudo-code is this: fake program.__

Our fake program isn’t going to be written using NXT-G. The best way I can tell you to start creating a fake program is to pretend that SPOT has ears and tell SPOT what you want him to do. Let’s try writing some pseudo-code using a numbered list:

 1. SPOT, move forward until your Touch sensor is pressed and released; then stop.
 2. Okay, SPOT, I want you to turn left 90 degrees.
 3. Good job, SPOT. Now move backward until your Light sensor detects something black; then stop.
 4. Now, SPOT, do a little dance.

__That’s pseudo-code? Well, it’s a form of pseudo-code. Remember how I told you there are different programming languages? People write pseudo-code differently, too. '''The point I want you to understand is that before you can really program your robot using NXT-G, you need to have an idea of exactly what your robot will be doing. And the easiest way to do this is to simply write down, in simple language, instructions for your robot. That’s the beginning of a good structure for the future NXT-G program.'''__

When you write pseudo-code, you are accomplishing two things:

 * You are gaining a better understanding of the ''tasks'' your robot will perform.
 * You are creating an ''ordered'' set of instructions (structure) for your robot to follow.

You will use this pseudo-code to assist you when you begin to create your program with NXT-G. __One final thing I want to mention about pseudo-code is that each instruction you give the robot should be ''as simple as possible''.__ Take a look at the next two examples and tell me which one has the simpler instructions:

'''Example 1:'''

SPOT, move forward about 10 inches; turn left 90 degrees, and start moving forward; then start looking for a black object with your Ultrasonic sensor, because I want you to stop when you find a black object; then turn right 90 degrees, and move backward 2 feet, OK?

'''Example 2:'''

 * SPOT, move forward 10 inches and stop.
 * Now turn left 90 degrees.
 * Starting moving forward, and turn on your Ultrasonic sensor.
 * Stop when you find a black object.
 * Turn right 90 degrees and stop.
 * Now move backwards 2 feet and stop.

Which example is less complicated to read? If you said Example 2, you are right. Let’s be honest—some humans would be confused if you gave them the instructions in Example 1! __When writing pseudo-code, break down your instructions into short and simple statements for your robot. '''This will make it easier for you to convert your pseudo-code to an NXT-G program.'''__ Are you wondering how you convert pseudo-code to a real NXT-G program? Let me give you a small preview of what’s to come in the chapters ahead.

Take a look back at my original pseudo-code for SPOT and read step 3, “Now move backward until your Light sensor detects something black; then stop.” If I am programming in NXT-G and am familiar with all the tools it contains, I would realize that there are tools (called ''blocks'') that match up to my pseudo-code. Let me explain briefly.

When I want SPOT to move backward, he’s going to use his motors, right? Well, I’ll be using something called a MOVE block. The MOVE block will allow me to program my bot to spin the motors (and wheels) in reverse, so SPOT moves backward.

I only want SPOT to back up until his Light sensor detects the color black. To do this, I’ll use something called a SENSOR block to monitor the Light sensor. The SENSOR block will be programmed to look for the color black. (光感應器分辨得出顏色嗎[?])

Finally, I want SPOT to stop when the SENSOR block detects the color black. For this, I can use another MOVE block that tells the motors to stop spinning.

__You will use these blocks and many more to properly program your robot to follow your instructions. This book will teach you about all the different NXT-G blocks, so you’ll know which ones to use when converting your pseudo-code to an NXT-G program.__

Okay, I told you this chapter wouldn’t be long, and I meant it. If you can remember one thing from this chapter, it should be this: Programming your robot will be much easier if you take the time to write down the pseudo-code. If it helps, pretend your robot has ears, and tell it what you want it to do. Write down these instructions, and keep them short and simple.

In the next chapter, we’re going to actually write some pseudo-code and convert it to an NXT-G program. The key to writing excellent NXT-G programs is understanding how the NXT-G programming blocks work; when you know how the blocks work, you’ll know which blocks to use when converting your pseudo-code.

Chapter 3 is going to demonstrate the DISPLAY block, a very useful block that gives your robot the ability to write things to its LCD screen for others to read.

== Chapter 3 Hello World! ==

__There is a tradition in the world of programming for the first program you write to display the words “Hello World!” on the screen. In keeping with tradition, I’m going to show you how to create a simple version of this program for SPOT.__ This will allow me to demonstrate one of the simplest blocks included with the NXT software—the DISPLAY block. Once we’ve taken care of tradition, I’ll show you the rest of the DISPLAY block’s features.

=== The DISPLAY Block ===

In Chapter 2, I explained to you the concept of pseudo-code. Let me now give some pseudocode to SPOT: SPOT, I’d like you to display the words “Hello World!” on your LCD screen. Pseudo-code doesn’t get much simpler than this. All I want SPOT to do for now is put the words “Hello World!” on his LCD screen. To convert this pseudo-code to an NXT-G program, I’m going to use the DISPLAY block.

Let’s start by opening up the NXT software and entering "`HelloWorld`" in the Start New Program text box (see Figure 3-1). Click the Go button, and the `HelloWorld` program is open and ready.

{{attachment:figure_3-1.png}} <<BR>> Figure 3-1. Start a new program called HelloWorld

Figure 3-2 shows the new program opened (see the tab called !HelloWorld in the upper left corner?) and ready for you to start dropping NXT-G blocks. The word “Start” appears on the ''work space'' beam(桁條; 用來放置 programming blocks 的架子), telling you where your first ''programming block'' will be placed.

{{attachment:figure_3-2.png}} <<BR>> Figure 3-2. The `HelloWorld` program is open and ready for the DISPLAY block.

Are you ready for this? I want you to click the DISPLAY block on the Common Palette and hold down the mouse button. Drag and drop the block on the beam where it says “Start” (see Figure 3-3).

{{attachment:figure_3-3.png}} <<BR>> The DISPLAY block

Anytime you drop a block on the work space, the block’s configuration panel will be displayed in the lower left corner of the screen. The configuration panel is where you will be doing most of the programming work for your bots. The configuration panel is similar to a car’s dashboard. In a car, you can tune to a specific radio station, turn on the windshield wipers(雨刷), and even find out the car’s speed from the speedometer. __The configuration panel allows you to turn on and off certain things as well as receive ''feedback''. For example, you can use the DISPLAY block’s configuration panel to choose what to put on the LCD screen, but the DISPLAY block can also ''receive input[?]'' from items outside your control, just like your car can display a warning light on the dashboard when you need to check the oil or fill up on gasoline(汽油).__ Figure 3-4 shows the configuration panel for the DISPLAY block you just dropped on to the work space. To see the configuration panel for a block, simply click the block using the Pointer tool, and an aqua-colored band will appear around the block that is selected. If you select multiple blocks, no configuration panel will be displayed.

{{attachment:figure_3-4.png}} <<BR>> Figure 3-4. Configuration panel for the DISPLAY block

Now, to have SPOT’s LCD screen display the words “Hello World!”, make sure you’ve first selected the DISPLAY block (click it with the Pointer tool).

As you can see in Figure 3-4, by default, the DISPLAY block’s Action ''section'' has a dropdown menu with the Image option selected (there are four options: Image, Text, Drawing, or Reset). Click the drop-down menu, and select Text from the options listed. You will now see a text box with the words “Mindstorms NXT” inside. Change the text to Hello World!, and you’ll see the same text displayed in the Position section’s preview box on the right side of the configuration panel (see Figure 3-5).

{{attachment:figure_3-5.png}} <<BR>> Figure 3-5. The “Hello World!” text is displayed in the preview box.

Now, using the File menu, select Save, and use the Browse button to choose a location to save the file on your computer. Click the Save button when you are finished. After saving, connect SPOT to your computer, and upload the `HelloWorld` program.

Note: For the remaining chapters in the book, you’ll need to remember to save your programs. I won’t keep bugging you with instructions to save your programs and upload them to your robots. OK? Just get in a habit of saving often.

After the program is uploaded, select it from the File section, and press the orange button on the Brick to run the program.

Did you see it? The program probably ran so quickly that you didn’t even see the text displayed! __Why does this happen? Well, when the program runs it is supposed to write “Hello World!” to the LCD screen and then end. And that’s exactly what happened—the text displays, and the program ends. This happens so fast that you don’t even get to see the text displayed.__ The good news is that this is very easy to fix, so let me update my pseudo-code before I continue: SPOT, I’d like you to display the words “Hello World” on your LCD screen for 10 seconds.

There are numerous ways to keep the text on the screen until you have a chance to read it, but I’m only going to show you one method in this chapter. You’ll discover other methods as you continue with the book.

To fix this problem, I’d like you to move the mouse pointer over the WAIT block icon on the Common Palette. When you do this, a collection of WAIT blocks will appear on a fly-out menu, as shown in Figure 3-6.

{{attachment:figure_3-6.png}} <<BR>> Figure 3-6. Adding a WAIT block will allow you to view the “Hello World!” text.

The WAIT block does exactly what it says—it waits. As you can see in Figure 3-6, there are many different types of WAIT blocks, but the one I’m interested in right now is the WAIT block that allows me to specify how many seconds to wait. That would be the TIME WAIT block (the block that is circled on the fly-out menu in Figure 3-6).

Select the icon for the TIME WAIT block, and place it immediately after the DISPLAY block. In the configuration panel for the TIME WAIT block, select a reasonable time for the text to be displayed—my pseudo-code asked SPOT to wait for 10 seconds, so that is what I will configure (see Figure 3-7).

{{attachment:figure_3-7.png}} <<BR>> Figure 3-7. Configure the TIME WAIT block for 10 seconds.

Now run the program. You should see the text “Hello World!” display on the LCD screen for 10 seconds before the program ends.

You’re probably thinking what I’m thinking, “That wasn’t that exciting.” But remember this: with programming, you have to start somewhere. And, in a few simple steps, you’ve now figured out how to add text to the LCD screen for any robot you build in the future. Now, let’s look at some of the other things you can do with the DISPLAY block.

__Note: Every program block has its own unique settings, so each configuration panel is different.__ Sections for the DISPLAY block, for example, include Action, Display, File, Text, Type, and Position. Sometimes, a section will not be visible until other options are selected. Don’t let this worry you; I’ll be going over all the unique items for each block throughout the book.

Here are details for the DISPLAY block’s sections:

The Display section only has one configurable item—a Clear checkbox. When this box is checked (and the block is executed in a program), the Brick’s LCD screen will be cleared of any text or images that are currently on the screen. After the screen is cleared, the DISPLAY block will put what you configured on the screen. (要不要事先清空螢幕而言)

If you leave the box unchecked, any text or graphics you configure the DISPLAY block to put on the LCD will display on the screen along with whatever is currently displayed, instead of replacing it.

__This is useful when you want text to appear on multiple lines; you can use multiple DISPLAY blocks to keep adding text to make sentences and even paragraphs. And, without clearing the screen, you can create your own simple images using the Drawing option in the Action section, which I’ll explain next.__

With the Action section, you have four options in the drop-down menu: Image, Text, Drawing, and Reset. By default, the drop-down menu is set to Image for a new DISPLAY block placed on the work space.

When you select Image in the drop-down menu, the File section is displayed; this section gives you access to a collection of small built-in pictures that can be displayed on the LCD screen (see Figure 3-8).

{{attachment:figure_3-8.png}} <<BR>> Choose an image from the File section to place on the LCD.

By clicking and holding the image in the preview pane on the right side of the configuration panel, you can drag the image around the small pane and place it wherever you wish. You can also use the X and Y coordinates to type in numbers that will place the image at a location of your choosing (see this book’s appendix for a brief explanation of the X/Y coordinate system if you’re unfamiliar with it). You can use this ability to move the image around the preview pane to place multiple images (which require using additional DISPLAY blocks) on the LCD screen.

The next option in the Action drop-down menu is Text. You’ve already used this in the previous “Hello World!” example, but I’d like to add that you also have the ability to drag the text around the preview pane and place it in a particular location. __'''The LCD screen is broken into eight horizontal lines;''' you can use the small drop-down box next to the Preview pane to choose a number between 1 and 8 to define the line where text is placed.__

__The third option in the Action drop-down menu is Drawing (see Figure 3-9). You can choose to draw a line or a circle or to place a single point on the LCD screen, so your artistic talents(藝術天份) will be somewhat limited. (複雜的輸出就只能靠手動撰寫程式了) To create a detailed drawing, you would have to place dozens or more DISPLAY blocks one after the other, and the combination of lines, circles, and points would create the image. But the Drawing options can be useful to draw boxes around other text on the screen, so keep that in mind.__

{{attachment:figure_3-9.png}} <<BR>> Figure 3-9. The Drawing option can be used to place points, lines, and circles.

To use the Drawing tool, select Point, Line, or Circle from the Type section (this section only appears if you have selected Drawing in the Action drop-down menu). For the point, you can drag it around the Preview pane and place it anywhere. You can also use the X and Y coordinates to place the point more accurately.

If you choose the Line, the end point of the Line is at position 10,10 (in the lower left corner). Click anywhere in the Preview pane to draw a line from that point to the place where you clicked. You can change the end point (10,10) by entering new coordinates in the X and Y boxes. You can also type in X and Y coordinates for the other end of the line for more accurate control over it.

Finally, for the circle, you have the option of changing the radius of the circle by typing the number in the Radius text box. Drag the circle around the Preview pane to place it properly. The final option in the Action drop-down menu, __Reset, is useful when you would like to clear the LCD screen of any items. The ''default NXT screen'' (which shows the name of the program currently running) will appear on the LCD screen. (跟上面 Clear 的效果不太一樣)__

Before closing out this chapter on the DISPLAY block, I want to cover one additional item briefly: ''data hubs'' (this topic will be covered in more detail in Chapter 7).

=== Data Hubs ===

Most programming blocks come with what’s called a “data hub.” Take a look at Figure 3-10.

{{attachment:figure_3-10.png}} <<BR>> Figure 3-10. Click on the DISPLAY block here, and the data hub will drop down.

If you click the bottom-left edge of a block, this section will drop down and reveal the data hub (see Figure 3-11). Click the section again, and the data hub will close. It might take some practice to find the correct place to click, so try it a few times until you get used to opening and closing the data hub.

{{attachment:figure_3-11.png}} <<BR>> Figure 3-11. The DISPLAY block’s data hub can be used for more advanced programming.

__What is this data hub? The data hub allows you to draw ''data wires(資料線)'' from one block to another using ''data plugs''. Data wires and plugs will be covered in much more detail in Chapter 7, but for now, all you really need to know is that '''wires can connect blocks to share data. Data plugs are places on the block where you will connect wires. So there will be a data plug on one block with a wire going out and another data plug on a different block with a wire coming in. (變數傳遞的概念)''' Data wires can carry information such as text, numbers, and other values. Remember all those items you could configure in the DISPLAY block? Well, items such as the text displayed or the radius of a circle can all be configured without using the configuration panel. Instead, you can draw data wires from one block’s plugs into plugs on another block.__ I’ll cover this topic in more detail later in the book (in Chapter 7), but right now, I just want you to take a look at Figure 3-12, so I can give you a preview of what’s to come.

{{attachment:figure_3-12.png}} <<BR>> Figure 3-12. An example of one DISPLAY block plug providing data to another block.

__In Figure 3-12, I’ve placed a VARIABLE block in front of the DISPLAY block. I cover the VARIABLE block in Chapter 18, but for now, all you really need to know is that this type of block can hold text, a number, or what’s called a logic value (either True or False). In this example, I’ve configured the VARIABLE block to hold a number: 3. (視覺化的編程竟然也可以很直覺地將變數的概念帶進來!!)__

Now, here’s where it gets fun. Remember that when you draw a circle you can specify the radius of the circle in the configuration panel? Well, this VARIABLE block has only one plug in its data hub. For this block, it’s holding the value of 3. I click that plug and draw a line into the last plug of the DISPLAY block’s data hub. That last plug corresponds to the radius of a drawn circle (hover your mouse pointer over a plug, and it will tell you what it is). When I drag the wire out of the VARIABLE block plug and into the DISPLAY block plug, the line becomes ''solid yellow'', and I know I’ve correctly configured the DISPLAY block.

__上面 "drag" 的說法並不正確, 因為一般認知上的 drag 是按著滑鼠左鍵不動. 雖然那條線會自動調整位置, 但實驗結果都不太理想 (過程中會跳來跳去), 資料線一多時會交錯或重疊, 而造成資料流向難以判讀. 事實上這條線的路徑是可以手動控制的, 過程中有些地方要注意:__

 * 只要在 data plug 上點一下左鍵即可, 然後移動指標 (過程中不要按住滑鼠左鍵), 善用它自動調整位置的功能, 然後在關鍵的轉折處按一下滑鼠左鍵, 就可以控制資料線的走向. (按滑鼠右鍵則是取消)
 * 中間的位置, 不用刻意點左側的 input plug 或右側的 output plug? 如果兩端的 data plug 都有 input/output plugs, 內部是如何決定資料的走向[?]
 * __'''在 input end 點一下滑鼠左鍵, 就可以將連接的資料線刪除; 因為同一個 output plug 不只可以拉出一條資料線, 在 output plug 再點一下滑鼠左鍵時, 會被認定是要拉出另一條資料線. (觀察現有的資料線或同一 data plug 的兩端, 把滑鼠移到兩個端點上面時, input end 會出現一般選取的指標, output end 則會出現 "線捲" 的圖示, 表示可以拉出線路)'''__
 * __游標靠近資料線時, 會出現 "線捲" 的圖示, 表示可以做線路上的分支; 游標移到資料線上面時, 會出現一般選取的指標, 表示可以拖拉調整線段的位置__
 * 移動 block 會造成已經連接的資料線斷掉, 這一點很困擾人[?]
 * 將 output plug 拉往 output plug 時 (例如 RANDOM 的 Number plug), 由於兩端都不是 input end, 實驗發現會造成線路無法刪除的窘境. 目前已知的方法就是移動 block, 所有連接的資料線自然會斷掉.

__Note: Plugs on the left side of a block’s data hub are known as ''input plugs''. Plugs on the right side of the block’s data hub are called ''output plugs''. (I/O 的概念)__

__If the line is ''dotted'', it tells me I’ve incorrectly connected two plugs. This can happen for many reasons. For example, if I had put text into the VARIABLE block and dragged the wire into the DISPLAY block’s Radius plug, I would get a dotted line. This happens because the Radius plug expects a number value to be coming out of the VARIABLE block, not text. (悄悄地把資料型態的概念引入)__ As I mentioned earlier, I’ll cover data plugs in more detail in Chapter 7. Before you begin using these data wires for more advanced programming, however, you need to understand the basics of the programming blocks.

Let’s continue learning about blocks in Chapter 4 with the MOVE block.

== Chapter 4 Get Movin’ ==

I would say that the MOVE block is probably one of the most important blocks when it comes to programming a robot. Without the MOVE block, you can still build bots, but they won’t be able to do much. They can sit on a desk or table (just like SPOT), but they’re not going to be very exciting to watch. Any robot that you design that uses one or more motors will use the MOVE block.

So, let’s go over this very important block and see what it can do.

=== The MOVE block ===

Open your Mindstorms NXT software, and drag and drop a MOVE block from the Common Palette onto the beam. The configuration panel will appear in the lower-left corner of the screen (see Figure 4-1).

{{attachment:figure_4-1.png}} <<BR>> Figure 4-1. The MOVE block and its configuration panel

__Your Brick has three ports for motors: Port A, Port B, and Port C. You must plug motors into these ports in order for them to work properly. '''Motors have numerous options including how fast they spin (Power) and how long or far they spin (Duration). By default, a MOVE block is configured to control Port B and Port C on the Brick. (慣例)''' The other defaults include a Power setting of 75 and a Duration of 1 rotation, and the Next Action is set to Brake.__

==== Moving Forward and Backward ====

Before I move on, I want to bring to your attention the subject of motor spin ''direction(轉向)''. Take a look at Figure 4-2. It shows a motor in two different ''orientations(走向)''.

{{attachment:figure_4-2.png}} <<BR>> Figure 4-2. A MOVE block can configure a motor to spin in two different directions (note the direction settings for each).

__'''All motors can spin forward and backward. But you need to be careful when describing a motor as “spinning forward” or “spinning backward,” because the orientation of the motor also needs to be described. When we program, we have to take into consideration the orientation of the motor.'''__

__In Figure 4-2, the motor on the left has the up arrow selected in the Direction section on the MOVE block configuration panel. This up arrow corresponds to ''FORWARD'', and this motor spins in the direction shown, ''counterclockwise(逆時針)''. Now, if I ''flip'' this motor over (like the motor on the right side of Figure 4-2) but don’t change the Direction arrow selection, the motor will spin in the opposite direction (''clockwise; 順時針''). I have to change the Direction arrow to down (or ''REVERSE'') to make the motor spin counterclockwise when it’s position like the motor on the right.__

__Be sure to keep this in mind when building and programming your bots. Depending on whether you want your bot to move forward or backward, you’ll have to select the proper Direction arrow (up or down) based on how the motors are attached to the bot.__ Okay, now let’s go over the rest of the MOVE block configuration panel.

First, we’ll cover the ports. The MOVE block can control Ports A, B, and C and any motors attached to those ports. __There is no rule for the way in which you connect motors to ports, '''but I would recommend that you decide on a “standard” method for connecting motors and stick with it for all robots you build.'''__

__As an example, look at Figure 4-3. When I build a robot I always connect the motor on the left side of the Brick (with the Brick’s sensor ports on the bottom and motor ports on top) to Port B and the motor on the right side of the Brick to Port C. '''(MOVE 拉出來時預設將 C 放在 steering 設定的左側, B 則放在右側; 從 brick 的背後來看時, C 剛好在左側, B 剛好在右側, 下面 steering 的設定, 滑桿往哪一邊靠時, 就是往哪邊轉, 相當直覺) I always use Port A for my third motor. If I build a bot that doesn’t need a third motor, Port A is always left open. (這跟 Quick Start Guide 的安排一樣)'''__

{{attachment:figure_4-3.png}} <<BR>> Figure 4-3. Pick a method for connecting your motors to your ports, and always use it.

When you connect a motor to a port, you must make certain to check the box for that Port in the MOVE block’s configuration panel (see Figure 4-4). In Figure 4-4, you’ll also notice that the motor ports you select (in this example, Ports A and B) are listed on the MOVE block in the upper right corner. (在圖示的右上方, 而非 configuration panel) This can be helpful for troubleshooting and to remind you which motors will be used.

{{attachment:figure_4-4.png}} <<BR>> Figure 4-4. Use the MOVE block’s configuration panel to select motor ports.

==== Stopping ====

I’ve already mentioned the Direction control using the up and down arrows (or FORWARD and REVERSE). The other option shown in Figure 4-5 is STOP. If you select the STOP option, check the Port boxes for the motor(s) you want to stop.

{{attachment:figure_4-5.png}} <<BR>> Figure 4-5. Select the STOP option in the MOVE configuration panel to stop selected motors.

==== Steering(操舵) ====

The next item to discuss is steering. Figure 4-6 shows the Steering section that is available if you have selected either FORWARD or REVERSE for the Direction and have two motor ports checked. (If you select all three motor ports, the Steering control is turned off.)

{{attachment:figure_4-6.png}} <<BR>> Figure 4-6. The MOVE block’s Steering control in the configuration panel

__The Steering control can be very useful if you know how to use it. Depending on its setting, you can configure a bot to move in a small or large circle or just spin in place. (兩個輪子的轉速不同時就會產生轉彎的效果, 如果轉速相同就會直行)__

__If you have two motors configured for your bot’s movement (Ports B and C, for example), you can make your bot spin in place by dragging the Steering control all the way to the left or right (the direction you drag the control will determine if the bot spins clockwise or counterclockwise; '''左右的偏移其實就是在控制兩個輪子轉速的比例, 因此越往兩側偏移時, 兩個輪子的轉速就相差越大, 轉彎的幅度也就越大!!''').__ Try it! Drag the slider all to the way to the left. Save your program, upload it to your bot, and run the program. Which direction did the bot spin? Now let’s change it. Drag the slider all the way to the right. Save, upload, and run the program again. Did the bot spin in the opposite direction?

__You can also program your bot to drive in a circle; the size of the circle depends on how far you drag the Steering control left or right: dragging it closer to either the far right or far left will make the circle smaller. You’ll have to play around with the Steering control to get the size of the circle just the way you want it. (實驗發現, 滑桿移到最兩側時, 輪子轉動一圈會產生大約 180 度的偏移, 但不是很精確[...])__ Go ahead and try this, too. Drag the Steering slider to the left but not all the way. Upload the program, and run it. Did the bot move in a small or large circle? Try it again, but this time, move the Steering slider to a different location before you upload and run the program. Did the bot move in a smaller or larger circle?

==== Power Settings ====

Next on the configuration panel is the Power section (see Figure 4-7). The Power setting range is 0 to 100. You can type a value into the Power text box or drag the sliding bar to the right (to decrease power) or to the left (to increase power).

{{attachment:figure_4-7.png}} <<BR>> Figure 4-7. The MOVE block’s Power setting has a range of 0 to 100.

__'''Most uses of the Power setting will involve increasing or decreasing the spin speed of a motor. But there is one additional consideration, that is, ''lifting or pushing strength.''''' If your robot is lifting a heavy object, for example, you might need to set the Power setting to a higher value. The motor will not spin as fast as it would if there were no resistance(阻力), but you may find that you need that extra power for the motor to successfully lift the object. The same goes for pushing. To push an object, your bot might need a higher Power setting than it will if it’s not pushing anything. Surface(地面) conditions also affect power; climbing a hill will take more power and possibly slow the robot. Likewise, going down a hill won’t take as much power. Also, whether a surface is smooth or rough can affect power; for example, you need more power to move over carpet(地毯) than wood flooring. (同一個概念可以應用在這麼多的場合, 這也就是為什麼選項要稱做 "power" 而非 "speed" 的原因; 電池的電力也會影響吧[?])__ This is one of those settings where you’ll just have to experiment. Change the Power setting, and play around with the Steering slider. See how fast or slow you can program your bot to make a circle. This will give you a better understanding of how the Power setting will affect your future bots.

==== Duration Settings ====

The Duration section of the configuration panel offers the most control of the MOVE block. There are four options in the Duration drop-down menu: Unlimited, Degrees, Rotations, and Seconds (see Figure 4-8).

{{attachment:figure_4-8.png}} <<BR>> Figure 4-8. There are four options for the Duration section of a MOVE block.

__From the Duration section, you can choose to have your motors spin forever by clicking the drop-down menu and choosing Unlimited. When the Duration is set to Unlimited, a single MOVE block will continue to spin its motors until the program ends or until you stop it.__ (There are other ways to stop a MOVE block such as using a LOOP block; I’ll cover the LOOP block in Chapter 11.)

If you set the MOVE block Duration to Degrees, you must enter a value in the text box for the number of degrees for the motor(s) to spin. The value must be 0 or greater; it cannot be negative, but this limitation is simple to fix. If you wish for your motor to spin –90 degrees, for example, you simply type 90 in the text box and change the MOVE block Direction to its opposite setting (if it’s set to spin FORWARD, just change it to REVERSE). If you’ve experimented with other programming environments, this may be unusual; it’s possible you may have learned to use negative numbers to represent counterclockwise spinning of motors. Don’t worry; you’ll get used to the NXT-G method of simply changing the motor spin direction in the configuration panel. __Just experiment with this concept, and it will start to make sense. Remember that your bot can spin a positive number of degrees, but you have to tell it whether to spin clockwise or counterclockwise by using the FORWARD or REVERSE directional controls.__

If the Duration is set to Rotations, the same rules apply. You cannot enter a negative value for rotations, but any value of 0 and higher is acceptable. In order to spin the motor(s), a negative number of rotations, just change the Direction to its opposite setting (FORWARD or REVERSE). One thing you can do with Rotations is use ''fractional'' or decimal values. For example, you could configure a motor to spin 2.3 rotations or 50.9 rotations.

__You may be wondering why you would ever want to configure a motor to spin 2.3 rotations. Well, I’ll be covering that in this book’s appendix when I show you how to program MOVE blocks for specific distances. '''For now, just keep in mind that your bots have the ability to move very small distances or very large distances with ''good accuracy'', and it all depends on your ability to figure out exactly how many degrees or rotations to spin the motors''' (feel free to skip ahead to the appendix if you just can’t wait).__

The last option in the Duration section is Seconds. When you choose this option, you must specify the number of seconds for the MOVE block to spin a motor (or motors). For obvious reasons, you can’t configure it for a negative value (say, –5 seconds). Just type in the number of seconds you want the motor(s) to spin, and you’re finished.

==== Braking and Coasting ====

Now, take a look at Figure 4-9, which shows the last option you can configure for the MOVE block—the Next Action section. __There are two options: Brake(剎車) and Coast(慣性滑行; 自然停止而言). If you select the Brake option, any motors connected to the ports you’ve configured will be stopped fast when the Duration you set expires (for example, after 10 seconds). Braking is useful if you need your bot to stop quickly and accurately at a specific point. However, keep in mind that this ''takes battery power''.__

{{attachment:figure_4-9.png}} <<BR>> Figure 4-9. You can configure motors to brake or coast.

But what if you’re not concerned about your bot stopping accurately? Then choose the Coast option. __When you choose this option, any motors connected to the ports you’ve configured will ''stop receiving power'', but the bot’s momentum(動量) may carry it a little further; that’s why it’s labeled Coast—your bot will be coasting(滑行) for a little while.__ You definitely want to try this out! So let’s do that with some pseudo-code: SPOT, move forward 10 rotations at a Power of 75 and then Brake.

The MOVE block I’ve configured for SPOT is shown in Figure 4-10. Notice that I’ve configured Duration for 10 Rotations and Power at 75, and I’ve selected the Brake option. SPOT is also using Ports B and C for its motors, and I want it to travel in a straight line, so I’ve left the Steering control alone.

{{attachment:figure_4-10.png}} <<BR>> Figure 4-10. The braking pseudo-code has been converted to a NXT-G program for SPOT.

Now, when I upload and run this program, SPOT rapidly moves forward 10 rotations (about 6 feet) and comes to a quick stop.

Let’s try a different test: SPOT, move backward 720 degrees at a Power of 100, and then Coast.

This time, I want SPOT to move in reverse, and I want the motors in Ports B and C to spin for 720 degrees. I want him to move very fast, so I’ve set the Power setting to 100. I don’t need him to stop at a specific point, so I’ll let him coast to a stop. See Figure 4-11 for the ''block programming'' of the pseudo-code.

[[attachment:figure_4-11]] <<BR>> Figure 4-11. A new coasting program for SPOT

After I uploaded and ran this program, I watched as SPOT moved even faster in reverse for 720 degrees (about 15 inches). But this time, he didn’t stop right away; he continued to roll for a few more inches, because I programmed him to coast to a stop.

Now, it’s your turn. Using what you’ve learned in this chapter, create some different programs for your bot.

When you’re finished, I have a final test for you to run before continuing on to Chapter 5: Program your bot to move forward for 10 rotations at a Power setting of 50, and set it to Brake. Place a piece of tape(用膠帶標示位置而言) on the floor, and make this your bot’s starting position. Now, run the program, and mark its stopping position with tape as well.

Next, run the same program, but change the Brake option to Coast. How far did it go beyond the previous stopping position?

Finally, reduce the Power setting a little bit, and run the program again (with the Coast option). How far did it go beyond the stopping position this time?

Keep reducing the Power setting and running the program until the bot stops at the original stopping position. (因為車子本身有重量, 因此 power 低到一定程度時, 車子能夠緩慢地移動, 但只要停止供應能量, 就會馬上停止...)

__Why am I asking you to do this? Recall that I told you that the Brake option uses up battery power. This test shows you that you can save battery power by reducing the Power setting and keeping the Coast option. Running tests like this will help you to figure out how best to program your bot to save battery power and to correctly perform its programmed actions!__

Okay, that’s it for the MOVE block. Feel free to play around with the MOVE block until you’re comfortable with it. Then, continue on to Chapter 5, where I cover the RECORD/PLAY block.

== Chapter 6 Record and Play Back ==

__One nice feature of the NXT-G programming language is the RECORD/PLAY block. With this block, you can record the movements of your bot’s motors to a file that is stored on the Brick. This file can be used to later play back the bot’s movement. (錄製動作然後重新播放而言, 跟聲音的錄製無關; 下面提到的例子是用手移動, 然後將動作錄製下來再重播, 可惜錄製的結果並無法載入做分析...)__

For this chapter, we’ll use SPOT again. But this time, I’m going to add one additional motor (motor A) to make SPOT do something silly like spin an arm or a sensor around. Feel free to do what you like. My SPOT has motor B (in Port B) spinning the left wheel of my bot and motor C (in Port C) spinning the right wheel. I have motor A (in Port A) spinning a small propeller (like an airplane) on the front of the robot (see Figure 5-1).

{{attachment:figure_5-1.png}} <<BR>> Figure 5-1. SPOT with his new propeller(推進器)

I’m ready to record some basic movement. If you’ve built your own version of SPOT, follow along. Here’s how we will do it.

The RECORD/PLAY block is located on the Common Palette directly below the MOVE block. Drag and drop a RECORD/PLAY block on the beam (see Figure 5-2).

{{attachment:figure_5-2.png}} <<BR>> Figure 5-2. Start recording a bot’s movements with the RECORD/PLAY block.

I know it seems like common sense, but I still need to say it: we cannot play back SPOT’s recorded movements until we’ve actually recorded some. So the first thing we’re going to need to do is configure the RECORD/PLAY block to record SPOT’s movements. To do this, in the block’s Action section, select the Record option as shown in Figure 5-3. This is the default setting when you drop a RECORD/PLAY block onto the workspace.

{{attachment:figure_5-3.png}} <<BR>> Figure 5-3. First, choose the Record option in the Action section.

Next, we need to specify a name for the recorded movement. As an example, I want SPOT to move forward 2 feet (motors B and C will be spinning forward) and turn left. I then want motor A to spin the propeller a few times. I’m going to type the words "Takeoff" in the Name text box shown in Figure 5-4, but you can type whatever description you like that will help you remember the purpose of the recorded movement.

{{attachment:figure_5-4.png}} <<BR>> Figure 5-4. Give your recorded movement a unique name.

__The name you type in the Name text box is the name of a file that will be stored on the Brick. This file must be stored on the Brick in order for you to later play back the movement, so try to make the name memorable and easy to understand. (寫出成為檔案, 之後可以重覆播放一到數次, 而且錄製與播放的動作, 可以安排在不同的程式中)__

Now, look at Figure 5-5. The Recording section of the configuration panel is where you will specify which ports should be monitored. In my example, motors B and C will move my bot around, and motor A will spin the propeller. So I want to select all the ports. __If you are not using one of the motor Ports, you don’t need to select it. You won’t get an error if you select a motor port and don’t use it, however.__

{{attachment:figure_5-5.png}} <<BR>> Figure 5-5. Configure the motor ports to monitor and record.

The last item you will need to configure is the amount of time (in seconds) you wish to record your bot’s movements (see Figure 5-6). You can type in the number of seconds you want to record or click the up and down arrows with your mouse to select the number in the Time section.

{{attachment:figure_5-6.png}} <<BR>> Figure 5-6. Enter the number of seconds to record in the Time section.

You can record anywhere from 1 second up into the hundreds of hours. Is this realistic? Not really. __Your NXT Brick has a limited amount of memory, and you’ll find that you are limited to a few minutes at most. And even recording a few minutes of movement will probably not leave much memory for your actual program. You’ll have to play around with the Time section to test its limits.__

__Once you’ve got your RECORD/PLAY block configured, save the program, and upload it to your NXT bot. Place the bot at its starting position, and press the Run button for your new program. '''Using your hands, guide the bot through the movements you wish your bot to perform.'''__

For my example, I simply push the bot forward 2 feet and stop. I then turn the bot to the left and stop. Next, I spin the little propeller on the front of the bot 5 or 6 times, and I’m finished.

__I suggest that you time(計時) your movements as you’re doing them. If you come close to the number of seconds you configured, you can simply leave the recording time alone. If you didn’t have enough time, go back and add the right number of seconds to your program, save it, and run it again to record the complete movements. (感覺有點笨, 如果可以有一顆按鈕來控制開始及結束錄製就會好多了) Most importantly, if you originally configured too much time, reduce the number of seconds you entered in the Time section; '''because the recording process will continue to run until the time is over, the file stored on the Brick will be larger than it needs to be.'''__

Okay, so you’ve successfully recorded your bot’s movements, and there is a file stored on the Brick with the name you gave it in the Name section (you can verify this by connecting your Brick to your computer and checking its memory contents). Now, let me show you how to play back the file.

It’s so easy, you’re going to laugh. Create a new program, and drop in a RECORD/PLAY block. This time, however, select the Play option in the Action section (see Figure 5-7).

{{attachment:figure_5-7.png}} <<BR>> Figure 5-7. Configure your bot to play back the recorded movement.

The only other section that can be configured now is the Name section. Type the name of the file that contains the recorded movements in the Name section (see Figure 5-8). For my example, I’ve typed "`Takeoff`", the name I gave the file that moves the bot forward 2 feet, turns it left, and then spins the propeller a few times.

{{attachment:figure_5-8.png}} <<BR>> Figure 5-8. Enter the name of the file you created during the Record process.

Next, you need to save the new program and upload it to your Brick. Before you run the program, place your bot in the original starting position (or wherever you like), and press the Run button to run the program. The bot will begin to move and will match the movements you recorded earlier. That’s it for the RECORD/PLAY block.

Here are some ideas for using the RECORD/PLAY block:

 * A fun use for it is to record your bot doing some sort of dance (for 10 to 20 seconds) and save it to a file called `Dance`. If you keep the `Dance` file on your brick, you can drop in a RECORD/PLAY block anywhere in your program and have your bot do the little dance (you can drop it in multiple times, too).
 
 * __Teams could use this block when giving a ''presentation''. The bot might have interesting parts and mechanisms that you wish to focus attention on, and the RECORD/PLAY block could be used to let the audience view these more easily. Configure the times properly, and you can synchronize it to a speech given on the robot and its different components. (可以應用在教學上)__
 
Chapter 6 will show you how to give your robot the ability to talk and make some noise!

== Chapter 6 Make Some Noise! ==

Sound can be used to give a bot more personality. Think about how boring [ http://en.wikipedia.org/wiki/R2-D2 R2-D2] would be without all the chirps(啾啾) and whistles(汽笛聲). Well, you can give your bot plenty(豐富的) to say by using the SOUND block. Sound isn’t limited to just giving your bots character(特性), though. Sounds can be useful as a way to judge(判斷; 測試用途) your bot’s progress through a maze(迷宮), for example, with the bot programmed to issue specific sounds when it makes a left or encounters a dead end. Read on for all the details on the SOUND block.

=== The SOUND Block ===

When you drop in the SOUND block on the beam, you are given access to the configuration panel shown in Figure 6-1.

{{attachment:figure_6-1.png}} <<BR>> Figure 6-1. The SOUND block’s configuration panel

==== Action Settings ====

The first section I want to cover is the Action section. You have two options: Sound File or Tone.

===== Sound File =====

Select the Sound File option, and take a look at Figure 6-2. See the section called File? Clicking the Sound File option opens the File section; the File section contains a large collection of prerecorded sounds that your bot can play through the Brick’s speaker. Click one of the sound files, and if your computer has speakers, you will hear the sound file play.

{{attachment:figure_6-2.png}} <<BR>> Figure 6-2. The Sound File option allows you to select a sound from the File section.

===== Tone =====

Now, select the other option, Tone. Notice that the File section changes to a section called Note (see Figure 6-3).

{{attachment:figure_6-3.png}} <<BR>> Figure 6-3. The Tone option allows you to specify tones from the Note section.

==== Note(音符) Settings ====

The Note section provides you with a few options. The easiest option is to simply click one of the piano keys. You will hear the tone played if your computer has speakers attached. Notice that when you click on a key, the note you click is displayed in the text box above the keys in the form of a letter: A, B, C, D, E, F, or G (with sharps for the black keys).

The other option available in the Note section is the ability to specify how long the note will play. Type a number in the text box for the number of seconds to play the note.

That covers the Action section; the remaining sections for the SOUND block (Control, Volume, Function, and Wait) are the same whether you choose the Sound File or Tone option. Now, let me explain each of these remaining sections.

==== Control Settings ====

The second section on the SOUND block is Control. This section has two options: Play and Stop (see Figure 6-4).

{{attachment:figure_6-4.png}} <<BR>> Figure 6-4. The Control section of the SOUND block

The Play option is simple. Select it, and any sound file or tone you selected in the Action section will play. Not too difficult, right?

The Stop option requires a little more explanation. To do this, I need to jump ahead to the Function section (see Figure 6-5).

{{attachment:figure_6-5.png}} <<BR>> Figure 6-5. The Function section of the SOUND block

==== Function Settings ====

The Function section only has one option: Repeat. If the box is checked, the Sound File or Tone will continue to play until your program ends or until another SOUND block is reached with the Stop option selected in the Control section. If the box is unchecked, the sound file or tone will only play one time.

__So, you can see that the Stop option is useful only when you have another SOUND block that is continually playing.__

==== Volume Settings ====

OK, now for the Volume section. You can see in Figure 6-6 that the Volume control can be changed either by using the slider or by typing a value (0 to 100) in the text box. You will have to experiment with the Volume control to determine what works best for your robots, but keep in mind that loud sounds will use up more battery power than sounds played at a lower volume. (實驗發現即便開到 100 還是很小聲, 是因為電力不足嗎? 還是原始的音量就不大[?])

{{attachment:figure_6-6.png}} <<BR>> Figure 6-6. The Volume section of the SOUND block

==== Wait Settings ====

The last section in the SOUND block is the Wait section (see Figure 6-7). When you have selected a sound file or tone to play and the Repeat box (in the Function section) is not checked, the Wait for Completion checkbox is available.

{{attachment:figure_6-7.png}} <<BR>> Figure 6-7. The Wait section of the SOUND block

__If you place a check in the Wait for Completion box, the Sound File or Tone you choose will play completely before any further programming blocks are executed.__ Let me give you an example using pseudo-code: SPOT, play me a C note for 10 seconds and then move forward 5 rotations.

Now, here’s how I will convert the pseudo-code into a NXT-G program. First, I drop in a SOUND block and configure it to play a C note for 10 seconds (see Figure 6-8). I’m going to leave the Wait for Completion box unchecked and set the Volume to 75.

{{attachment:figure_6-8.png}} <<BR>> Figure 6-8. SPOT will first play a C note for 10 seconds.

Next, I’m going to drop in a MOVE block (see Figure 6-9). I’ll configure this MOVE block to spin motor B and motor C FORWARD for 5 rotations and then Brake. I’m also going to set Power at 50. 

{{attachment:figure_6-9.png}} <<BR>> Figure 6-9. SPOT will then MOVE forward 5 rotations.

Next, I save the program, upload it to SPOT, and run it. Go ahead and create and run this same program on your bot. What happens?

Well, I pressed the Run button and the C note started to play. But before the C note stopped, motors B and C started spinning. What happened?

Go back to Figure 6-8, and notice that the Wait For Completion box is unchecked. This means that when the SOUND block starts playing, the program will continue to the MOVE block that spins the motors. But that’s not what I wanted SPOT to do. Take a look again at the pseudo-code: SPOT, play a C note for 10 seconds and then move forward 5 rotations.

I wanted SPOT to play the C note for 10 seconds before moving forward. To do this, I simply need to go back to my SOUND block and check the Wait for Completion box. This will tell SPOT to wait until the SOUND block is finished (10 seconds) before continuing with the program. So, I make this change (see Figure 6-10) and run the program again.

{{attachment:figure_6-10.png}} <<BR>> Figure 6-10. Making one change to the SOUND block will fix the problem.

This time, SPOT does exactly what I wanted him to do. He plays the C note for 10 seconds, and when the SOUND block is finished, motors B and C spin, and SPOT moves forward 5 rotations. Perfect!

Now you can add sound files and tones to your robots to give them more personality. __But before we finish this chapter, let me also tell you that '''sounds can be used when ''testing'' your robots. For example, in a complex program you can drop in a SOUND block to let you know when the robot has reached a certain portion of the program. (內建有 00 ~ 10, Left, Forward, Yellow 等音效檔, 可以多加利用; 在實務上, 如果是要觀察程式的流程, 會在 SOUND 後面再加上一個 BUTTONS WAIT, 透過聲音的內容我們知道來到的分支, 透過按鈕的等待則可以營造出類似 break point 的效果)''' Let’s say you want to know when your robot has reached the part of a program where it has to decide between turning left and turning right. You could place a SOUND block directly in front of the MOVE blocks and program a sound to play when turning left and a different sound for turning right. '''After you’ve tested and verified the program is working properly, you can remove the SOUND blocks and run the program normally.''' In this example, SOUND blocks give you an idea of where a robot’s program is currently executing by giving you an ''audible alert'', which is very useful for troubleshooting and testing. (這跟一般程式所用的 `System.out.println()` 的技巧是一樣的)__

Now, before we investigate any new blocks, I want to go over the different ways your robots receive input—this includes motors, sensors, timers, and the buttons on the Brick. Chapter 7 covers all of this, so read on!

== Chapter 7 Wired! ==

Some of the questions I hear the most are related to data hubs and wires—and for good reason! A block’s data hub can be confusing, especially when a block has numerous options on the hub. And wires can be just as difficult to figure out.

In this chapter, I want to take a short break from learning about NXT-G programming blocks and give you some background and tips on how to use data hubs and wires. I hope that any confusion you have will be cleared up by the end of this chapter.

=== Passing Around Information ===

To help you understand hubs and wires, let me start with a fake programming block called the COLOR block. This block is shown in Figure 7-1.

{{attachment:figure_7-1.png}} <<BR>> Figure 7-1. The COLOR block

This imaginary block is one of the simplest blocks you’ll ever encounter. It can hold one color. This block holds Blue. It will always hold Blue and nothing else. There is no way to change the color. There’s even worse news—the block has no way of sharing this color with a robot. It’s a very boring and useless block.

What would make this block useful to us? Well, first, it would be nice to be able to change the color. My favorite color is green, so I’d at least like to change the block to a Green block. I might not be able to do anything else with the block at this point, but at least it will contain my favorite color!

One of the things the block lacks is a way to get inside the block and change Blue to Green. What’s so great about creating the COLOR block is that I can change it whenever I like (because it’s a fake block). The first thing I’m going to do is attach a very small color keyboard to the block so I can change the color. This color keyboard is a strange type of keyboard, though; it will only let me type colors. If I try to type in “Jim” or “five,” the keyboard will buzz to let me know that it’s not going to cooperate(配合). Take a look at the updated COLOR block in Figure 7-2.

{{attachment:figure_7-2.png}} <<BR>> Figure 7-2. I’ve added a fake color keyboard, so I can change the Blue block to a Green block.

Perfect! Now I can type Green. Later, if I want to change to Yellow or Red, I can simply type the new color, and the block will change.

Now I’ve changed the color, and I have a Green block. Other than looking at it, there’s really not much I can do with it. Just like I added a small keyboard to the block, I think I’ll now connect a small, fake color screen to the block that will take whatever color is stored inside and display it. This screen is just like my weird keyboard; it will only display a color. (If I had a “direction screen” and I connected it to the block, it wouldn’t know what to do with a color. But if I connected it to a DIRECTION block that holds North, East, West, or South, then it would definitely work!)

Figure 7-3 shows my new color screen connected to the Green block.

{{attachment:figure_7-3.png}} <<BR>> Figure 7-3. The color screen lets me see what color is stored in the COLOR block.

So, let’s review how this works: the COLOR block can hold only one color, not a number or a day or a name.

Next, the COLOR block has a color keyboard attached. I can change the color the COLOR block holds but only by using this special keyboard, and this keyboard will let me type in only colors.

Finally, I’ve attached a color screen to the COLOR block. This special screen will only display colors and nothing else, not names or types of food.

If I detach the color keyboard, can I still display the color inside? Yes, but only if I keep the color screen attached.

If I detach the color screen, can I still change the color inside the block? Yes, again, but only if I keep the color keyboard attached.

Let me give you another way to describe this COLOR block:

 * The COLOR block will accept a color as ''input'' from the keyboard.
 * The COLOR block will also provide a color as ''output'' to the screen.
 
__There are some programming words for you in that description: input and output. When thinking about blocks, always remember that any information that is provided to a block is ''input''. Any information that the block can give out (share) can be considered ''output''.__ Now, let’s look at a block with a few more options. Take a look at the fake CUP block in Figure 7-4.

{{attachment:figure_7-4.png}} <<BR>> Figure 7-4. The CUP block is a little more complex.

The CUP block can hold three pieces of information: the cup’s Color, its Height in inches, and a Yes answer if the cup is empty or a No answer if the cup is not empty. Now, here’s where it gets fun.

__Take a look at Figure 7-5. The COLOR block has an easier way for me to provide input to the block and to receive output from the block. It’s called a ''hub''.__

{{attachment:figure_7-5.png}} <<BR>> Figure 7-5. The CUP block has a hub for connecting things.

__You can see in the figure that there are three ''input plugs'' on the left side of the hub and three ''output plugs'' on the right side. These are where I will plug in keyboards, screens, and other items.__

Just like the COLOR block, though, the CUP block is very picky(挑剔的) about what types of devices are connected to it. For the Color input plug, I can only connect something that supplies a color. We already know that a color keyboard will work. I could connect a color keyboard and change the color of the cup from Blue to Green. But there’s a better way!

Remember that COLOR block we played around with earlier? Well, it has a ''data hub'', too; it was just hidden inside the block. If I click on the lower left edge of the COLOR block, the COLOR block’s hub will pop down; this is shown in Figure 7-6.

{{attachment:figure_7-6.png}} <<BR>> Figure 7-6. The COLOR block also has a hub.

__The input plug on the left side of the COLOR block is where I can plug in a color keyboard to change the color inside the block. The output plug on the right can be connected to a color screen, but in truth, it can be connected to any input plug that can accept a color. Notice the CUP block has an input plug that will accept a color! So instead of connecting a color keyboard to the CUP block, I can use a simple wire to connect the output plug on the COLOR block to the input plug on the CUP block (see Figure 7-7).__

{{attachment:figure_7-7.png}} <<BR>> Figure 7-7. I’ll connect a wire from the COLOR block to the CUP block.

I can also connect a height keyboard that can only be used to type in a cup’s height in inches. If I try to type in anything besides a number, the keyboard won’t work. I’ll also connect a logic keyboard to the Empty input plug. A logic keyboard is a very special keyboard—it can only be used to provide Yes or No answers. Not Maybe or Sometimes; only Yes or No.

What I would like to do with the CUP block is to connect it to a screen that will display one of two things (but not both):

 * Fill the [Color] cup with [Height] inches of water.
 * The [Color] cup is not empty.
 
To do this, I can use a screen to print the color and height that are provided by the CUP block (Figure 7-8 shows my setup so far).

{{attachment:figure_7-8.png}} <<BR>> Figure 7-8. Everything is hooked up and ready to use.

But before I print the color and height, I need another special block that can examine the contents of the cup and determine if it is empty or not empty. Now, all I need to do is reveal my new EXAMINE block, shown in Figure 7-9.

The EXAMINE block can perform a nice trick. It takes a Yes or No answer (logic) and, depending on the answer, performs action 1 or action 2. Action 1 will occur if the answer is Yes; Action 2 will occur if the answer is No (for more information on logic and the LOGIC block, feel free to jump ahead to Chapter 8).

I can use this block to examine the contents of the CUP block. It will first look at the data plug labeled Empty. If the data the Empty data plug provides is Yes, the EXAMINE block will use the “EXAMINE = Yes” screen. If the data is No, the block will use the “EXAMINE = No” screen. 

Figure 7-9 shows that when this program is run, the screen will display “Fill the Blue cup with 5 inches of water.” It does this because the EXAMINE block receives the Yes data from the CUP block. It then performs the actions required for a Yes answer.

If I go back and change the Color to Yellow and the Height of the cup to 3 (using a color keyboard and height keyboard), this information will be passed from the CUP block to the EXAMINE block. If I change the logic answer from Yes to No using the logic keyboard, the EXAMINE block will receive the No data from the CUP block and perform the action required for a No answer: the screen displays “The Yellow cup is not empty.”

{{attachment:figure_7-9.png}} <<BR>> Figure 7-9. The new EXAMINE block

__There are many more fake blocks that I could create, but I hope you’re starting to understand how blocks can receive input data and provide output data. Both types of data (input and output) can be provided by you (by typing information in or selecting options in a configuration panel), or the data can be provided by other blocks using wires.__

__'''One thing you also need to know is that some blocks might not have any input plugs; some blocks might not have any output plugs, and a few, rare blocks have no data plugs at all.'''__

You’ll also be happy to hear this bit of information: I’ve created a bunch of fake blocks that can only accept color or height (and I could create a bunch of fake types of input), but you’re fortunate, because when it comes to NXT-G, you only need to know about three types of data:

 * __'''Text''': Letters, words, sentences, and even numbers can be considered text.__
 * __'''Number''': Numbers can be positive or negative, and sometimes they are limited to integers (only numbers like –3, 0, 4, 8, or 10 and no numbers with decimal points like 4.3 or 8.5; 不支援小數點, 在實務應用上會不會產生什麼限制[?]).__
 * __'''Logic''': This can be Yes or No (another way to say it is True or False).__

__When you are programming, the only data that can be passed to and from a block are text, numbers, and logic types (Yes/No or True/False)—only these three! (這應該只是 NXT-G 的限制吧? 如果用其他語這來開發就沒這個問題了[?])__ And just as your CUP block wouldn’t let you use a logic keyboard to type in the color, a block’s input and output data plugs will be very picky about the types of data they accept. You’ll find an NXT-G block with plugs that accept Text and Logic, but no Number plug. Another NXT-G block will have no input plugs but maybe two output plugs that only provide Number data.

The good news is that if you ever drag a wire from one plug to an incompatible plug (if you try to drag a wire from a Text plug to a Logic plug, for example), the wire will be broken. __By that, I mean that the wire will become a dashed gray line indicating that you made a mistake. If you correctly connected a wire, the wire will have a color:__

 * The wire is yellow for the Number data type.
 * The wire is orange for the Text data type.
 * The wire is green for the Logic data type.
 * If the wire is gray (and dashed), the wire is broken and will not work.

It takes practice to drag and connect wires from plug to plug. Sometimes, the wires will do strange things and go off in strange directions. You’ll just have to play around with them until you figure out how to control them properly.

Well, now it’s time to get back to real NXT-G blocks. You’ll see in the figures I provide that many times I’ll have a block’s data hub opened. If you hover the mouse pointer over a data plug, it will show you the name of the data plug (something like Empty or Height in my examples).

__For some of the plugs, it’s fairly easy to figure out what type of ''data type'' they use (the Number plug requires the, duh(表示猶豫), Number data type). Others aren’t so easy to figure out. You can either check the help documentation, which provides a detailed description of a block’s data hub plugs along with the types of data they accept or you can just experiment and drag some wires to it; (學會查詢參考文件) the color of the wire will tell you if you’re correct, or a gray wire will tell you to try again.__

__My last bit of good news is that you cannot ruin(毀壞) a program with incorrect wires! '''If you connect a wire that’s incompatible, just click the ''input end'' of the wire (a wire always has an input end and an output end), and the wire will disappear.''' No worries!__

__This is a lot of information to absorb, and you’ve only scratched the surface of what wires can do for you. But there’s power in wires! '''Wires can save you time by allowing you to use existing data over and over again; wires can be split, meaning you can split one wire and provide two different blocks with the same data! Wires can also go in the other direction, so you can send an output wire from the end of your program all the way back to an input plug at the start of your program!'''__ Keep your eyes open throughout this book to learn some new ways to use wires. Experiment on your own, and you’ll discover even more uses for wires.

OK, up next in Chapter 8 is a short discussion on a method robots use for making decisions using Yes and No answers.

== Chapter 8 True or False? ==

What is the difference between the following two questions:

 * What color is the sky?
 * Is the sky blue?

Well, there are a lot of differences: the first question has five words and the second one has four words, for example. __My real point in asking these two questions is to point out that the first question is ''open-ended''; the sky could be blue, or gray, or any number of answers. The second question, however, only has two possible answers: yes or no.__

When it comes to programming your robots, you need to understand that many times your robots can only provide you with those two answers: yes or no. At other times, your robots can understand only a yes or no answer. Understanding how to take a yes/no answer and use it to properly program your bots is the focus of this short chapter.

=== One or the Other ===

Let’s have a question/answer session with SPOT:

 * Me: SPOT, what color is the box in front of you? [SPOT sits there and gives no response.]
 * Me: SPOT, what is the position of your Touch sensor button? [SPOT still sits there and gives no response.]

Hmmm . . . SPOT doesn’t seem to be to responsive today. I seem to remember, however, that SPOT prefers yes/no questions, so let me try this again:

 * Me: SPOT, is the color of the box in front of you blue?
 * SPOT: Yes [appears on the LCD screen]
 * Me: SPOT, is your Touch sensor button pressed?
 * SPOT: No [appears on the LCD screen]

__OK, now we’re getting somewhere. SPOT does prefer to communicate with me using yes or no answers. Another way of saying this is that SPOT prefers to communicate using ''logical responses''; a logical response is simply Yes or No. (不是還有 text 跟 number 嗎[?])__

__Note: Some computers and robots use True or False, but it’s all the same: Yes = True and No = False. Some computers and robots even use 1 or 0 as a logical response, where 1= True and 0 = False. There’s even another method: On or Off! In that case, On = True and Off = False. But for the purposes of this chapter and programming, let’s stick with either Yes/No or True/False.__

Let’s have another conversation with SPOT:

 * Me: SPOT, is your Ultrasonic sensor detecting an object 6 inches in front of you?
 * SPOT: True.
 * Me: SPOT, is your right button being pressed?
 * SPOT: False.

Apparently, SPOT’s sensors have the ability to return a logical response to SPOT that he can pass along to me. SPOT ''listens'' to his sensors’ ''conditions'' and responds with True or False. What does all this have to do with programming, though? Here’s your answer: your NXT robots can send and receive logical responses to and from the sensors, motors, buttons, and other items.[?]

As an example, take a look at Figure 8-1.

{{attachment:figure_8-1.png}} <<BR>> Figure 8-1. The Touch sensor’s configuration panel

What you are looking at in Figure 8-1 is the TOUCH SENSOR block and its configuration panel. Notice also that the TOUCH SENSOR block has its data hub visible (see Chapter 7 for a discussion on data hubs and Chapter 9 for a more detailed discussion of the sensors). If you are only seeing one data output plug on the data hub, click the data hub again to expand it to its full size. (預設只會秀出一個 Yes/No 的 output plug)

__On the data hub, you’ll see some small input and output data plugs. If you hover the mouse pointer over the third plug from the top, the words “Yes/No” will appear. What this tells you is that this data plug can provide output (using a data wire) in the form of a Logic data type. But how do you know if the output will be Yes or No? Simple—the answer is based on what you are monitoring with the sensor.__

__In Figure 8-1, notice that the Touch sensor’s Action section has the Pressed option selected. '''This means that if the Touch sensor’s button is pressed down (and not released) the Yes/No Logic plug would provide a Yes answer. If the button is not pressed, the Yes/No Logic plug will provide a No answer. (事實上 Yes/No plugin 是對應每個 sensor 內部 conditional statement 的運算結果)'''__

Think back to Chapter 7; I told you that when you connect two blocks with a wire, the input and output data plugs must be carrying the same data type. In this case, if you wish to connect a wire from the Yes/No data plug, it must be going into a block that has a Logic data type input plug.

As an example, take a look at the new block in Figure 8-2.

{{attachment:figure_8-2.png}} <<BR>> Figure 8-2. I’ve dropped a VARIABLE block on the beam.

This new block is a VARIABLE block. I cover this block in more detail in Chapter 18, but for now all you need to know about the VARIABLE block is that it can hold one of the three data types: Logic, Number, or Text. In Figure 8-2, I’ve configured the VARIABLE block to hold a Logic value. I’ve also opened the data hub, so you can see that it has a Yes/No input data plug. All that I need to do is connect it to the TOUCH SENSOR block with a wire (see Figure 8-3).

{{attachment:figure_8-3.png}} <<BR>> Figure 8-3. Connecting two blocks with a wire

__When connecting blocks in a program using data wires, always keep in mind that a data wire will only work if it is connected to an input and output plug that expect the same data type (Logic, Number, or Text).__ I also need to point out that many blocks hold either a True or False value as a default setting. For example, the VARIABLE block in Figure 8-2 is configured to hold a default value of False. But you could easily change this to True (I’ve got more examples later in this book where you’ll configure True/False values).

__The Logic data type can be found in many blocks, especially the sensor blocks (see Figure 8-4). The sensor blocks all have a data plug that provides a Yes/No response. These plugs are designated by a check mark and an “X” that symbolize the Yes/No response.__

{{attachment:figure_8-4.png}} <<BR>> Figure 8-4. The four sensors (Touch, Sound, Light, and Ultrasonic) all have Logic data plugs.

__Where the Logic data type really comes in handy, however, is with the LOOP and SWITCH blocks (these are covered in Chapters 11 and 12, respectively). Logic data types are very useful when programming a bot to make decisions on its own, and the LOOP and SWITCH blocks can both use a Yes/No response (as input) to give your robots more complex behaviors and control of itself. The bot can examine a sensor or motor or other type of input and, based on the Yes/ No response, make further decisions about what it does next.__

And that’s it for this short chapter on logic. As I said, you’ll get a more detailed description of how to use the Logic data type with the LOOP and SWITCH blocks in Chapters 11 and 12. Now let’s change direction in Chapter 9 and take a look at some more items that can be used to communicate with the NXT Brick: sensors, buttons, and ''timers''.

== Chapter 9 Feedback ==

__Your LEGO Mindstorms NXT kit comes with a collection of motors and sensors. And the NXT Brick has '''three built-in ''timers'' (跟一般涉及秒數的操作無關, 完全就是三個獨立的計時器, 從程式一開始執行就會一秒一秒跳, 過程中隨時可以重設...)''' plus the buttons on the Brick.__ Would it surprise you to learn that all of these items are able to provide some sort of ''feedback'' to the NXT Brick? The sensors are a little obvious; a sensor is designed to respond to ''external conditions'' such as light, touch, or sound and report this information to the Brick. But what about motors? And how can a timer be used as input or feedback to the Brick? All these questions have answers, and this chapter provides them.

=== What’s Your Condition? ===

Let’s start with the word ''condition''. A traffic light has three conditions: red, yellow, and green. A light switch has two conditions: on and off. Just using these two simple examples, I can give you some pseudo-code for SPOT:

 * Me: SPOT, move forward until the traffic light turns red.
 * Me: SPOT, display the words “Light On” on your LCD screen until the light switch is off.
 
In both these examples, I’m assuming that SPOT has eyes and can see the traffic light or light switch. If SPOT doesn’t have eyes, then I would need a way for the traffic light or light switch to provide their conditions to SPOT. The traffic light and light switch could then provide ''feedback'', or input, to SPOT.

Asking a traffic light to provide input isn’t realistic, but your NXT robots do have the ability to receive feedback from items such as the sensors. So I can change the pseudo-code for SPOT:

 * Me: SPOT, move forward until the Light sensor reports a value of 20.
 * Me: SPOT, display the word “Hello” until the Touch sensor reports that it has been pressed and released.
 * Me: SPOT, play a C note when the Ultrasonic sensor detects an object 6 inches in front of you.

The motors, too, can provide feedback:

 * Me: SPOT, spin motor A until motor B reports that it has spun 10 degrees.
 * Me: SPOT, display “5 rotations” when motor C has rotated five times.

I mentioned that the Brick has three built-in timers plus three buttons that can be used, so I could also write the following pseudo-code:

 * Me: SPOT, when 20 seconds have elapsed, turn 90 degrees.
 * Me: SPOT, play a B note if I press the left button and a C note if I press the right button.
 
__Okay, so you can see that the sensors, motors, buttons, and timers can provide input to the Brick to control other actions (MOVE, SOUND, and other blocks). You program your robot to perform specific actions based on the conditions of these items. Just like you know a light switch has two conditions, on and off, you need to know the various conditions that the sensors, buttons, timers, and motors possess and can report to the Brick.__

So, for the rest of this chapter, I’m going to explain the settings for these items, so you’ll know how to configure them properly. Future blocks that we’ll cover, including the WAIT, LOOP, and SWITCH blocks, will depend on your understanding of how to properly configure the conditions.

The method I’m going to use to do this is fairly simple: I’ll describe each item (sensor, motor, button, and so on) and provide a description of the settings that can be modified within the item’s configuration panel. __Please note that I am also providing information on the socalled ''legacy items'': the previous version of Mindstorms (http://mindstorms.lego.com/eng/products/ris/index.asp[Robotics Invention System], or RIS) included motors, sensors, and a lamp. These RIS items can be used with NXT robots but require special ''converter cables'' to connect to the NXT Brick. I call them “legacy” because they come from the older Mindstorms system, but they are still very useful and fully compatible with the NXT system.__

__Note: Right now, only the Education version of the NXT kit comes with software support for the legacy/RCX items. If you are running the Retail version, you may download NXT programming blocks for the RCX motors and sensors by visiting http://mindstorms.lego.com/Support/Updates/ and downloading the files from the ''Legacy Block Library'' section.__

=== Configuring the Sensors ===

Let’s start with the sensors—NXT Touch, RIS Touch, NXT Sound, NXT Light, RIS Light, NXT Ultrasonic, NXT Rotation, RIS Rotation, and RIS Temperature—which have some interesting rules to abide by(遵守).

__'''First, sensors detect a change in a condition.''' The condition could be a change in light level, a change in volume (sound), or maybe a change in position (movement). The sensor is simply “watching” the changes in its condition.__ The Light sensor, for example, can detect changes in the level of lighting in the room.

__'''Second, sensor programming blocks can only respond to one condition at a time.''' When you drop a sensor block into an NXT-G program, it has to be configured to test one condition. A single Light sensor, for example, cannot be configured to respond to whether the light in a room is below 80 and greater than 50. In order to test both conditions, you would need to use two Light sensor blocks in your program. (稍嫌麻煩, 但都是為了引入程式設計的概念)__

__'''Finally, sensors can provide only a Logic type response: True or False. (為什麼會有 "only" 的說法, 不是還有其他型態的 plugs 嗎[?] 難道這裡 "response" 說法有什麼特別之處嗎?)'''__ Think of our traffic light for a moment. Let’s assume that every car has special traffic Light sensors mounted on top. These Light sensors are programmed to examine the conditions of the traffic light. Cars will move while the light is green and stop when the light is red. If the light is yellow, the car will slow down.

These traffic Light sensors, then, can detect one of three possible conditions: green, yellow, or red. An NXT sensor can only check one condition, so if this were an NXT traffic Light sensor, each car would require three traffic Light sensors: (要裝三個 sensor, 會不會太誇張了[?])

 * If the first traffic Light sensor detects green, the car should keep moving.
 * If the second traffic Light sensor detects yellow, the car should start slowing down.
 * If the third traffic Light sensor detects red, the car should stop.
 
Notice that only one condition can be true at any given time; the light cannot be green and red at the same time. So when the sensor detecting green is triggered, yellow and red cannot be triggered. Therefore, we can examine a sensor’s Logic data type for a True/False response to the condition the sensor is configured to monitor. Let’s take a look now at the sensors.

==== NXT Touch Sensor ====

The NXT Touch sensor’s configuration panel is shown in Figure 9-1.

{{attachment:figure_9-1.png}} <<BR>> Figure 9-1. The NXT Touch sensor’s configuration panel

In the Port section, select the port where the NXT Touch sensor has been connected. The default port for the Touch sensor is Port 1.

__In the Action section, you can select Pressed, Released, or Bumped. Remember that '''Bumped means quickly pressing and releasing the button—less than .5 seconds for the entire press-and-release action.'''__

The NXT Touch sensor’s data hub is shown in Figure 9-2. Remember that you can hover your mouse pointer over a data plug to obtain the plug’s name.

{{attachment:figure_9-2.png}} <<BR>> Figure 9-2. The NXT Touch sensor’s data hub

The port number can be configured using the Port data plug and a Number data type wire with an input value of 1, 2, 3, or 4. This value can also be used as output by dragging a data wire out of the output Port data plug.

__The Action data plug can use a Number data type with an input value of 0 for Pressed, 1 for Released, or 2 for Bumped.__

The Yes/No data plug can provide an output value of True or False.

__The Raw Value data plug can provide an output Number value with a range of 0–1024. (對 touch sensor 而言, 0-1024 表示什麼[?])__

For the remaining blocks in this chapter, I will not be describing the blocks’ data hubs— only the blocks’ configuration panels (I simply wanted to show you that the sensor blocks can use their data hubs for even more options).

__Click the Help menu, and select the “Contents and Index” option to view the Help files. Select a programming block from the left side of the screen (see Figure 9-3). Details for the block’s data hub can be found at the bottom of that block’s Help documentation (also shown in Figure 9-3). You can always consult this Help documentation to determine the data types for the various data plugs (Number, Logic, or Text). (這份文件極具參考價值, 要找時間全部看過一遍!!)__

{{attachment:figure_9-3.png}} <<BR>> Figure 9-3. Touch Sensor Block is selected on the left and the Data Hub details are shown on the right.

==== RIS Touch Sensor ====

The legacy RIS Touch sensor’s configuration panel is shown in Figure 9-4.

{{attachment:figure_9-4.png}} <<BR>> Figure 9-4. The RIS Touch sensor’s configuration panel

In the Port section, select the port where the RIS Touch sensor has been connected. The default port for the Touch sensor is Port 1.

In the Action section, you can select Pressed, Released, or Bumped.

==== NXT Sound Sensor ====

The NXT Sound sensor’s configuration panel is shown in Figure 9-5.

{{attachment:figure_9-5.png}} <<BR>> Figure 9-5. The NXT Sound sensor’s configuration panel

In the Port section, select the port where the NXT Sound sensor has been connected. The default port for the Sound sensor is Port 2.

In the Compare section (對應到 Yes/No plugin), you must configure the sound value (0–100) as well as whether the sensor will monitor for sounds less than or greater than the configured value. You can use the drag bar to select the value or enter a numeric value in the range of 0–100 in the text box. Select the less than option (<) or the greater than option (>) from the drop-down menu or click the left or right radio button to configure this option.

==== NXT Light Sensor ====

The NXT Light sensor’s configuration panel is shown in Figure 9-6.

{{attachment:figure_9-6.png}} <<BR>> Figure 9-6. The NXT Light sensor’s configuration panel

In the Port section, select the port where the NXT Light sensor has been connected. The default port for the Light sensor is Port 3.

In the Compare section, you must configure the light value (0–100) as well as whether the sensor will monitor for a light value less than or greater than the configured value. You can use the drag bar to select the value or enter a numeric value in the range of 0–100 in the text box. Select the less than option (<) or the greater than option (>) from the drop-down menu, or click on the left or right radio button to configure this option.

__'''If you leave the “Generate light” box checked, the Light sensor will turn on its built-in LED to provide an artificial(人工的) light source for assisting with determining light levels. If you uncheck the box, the Light sensor will only detect ambient(=surrounding; 週圍的) light levels—that is, normal light conditions.'''__

==== RIS Light Sensor ====

The RIS Light sensor’s configuration panel is shown in Figure 9-7.

{{attachment:figure_9-7.png}} <<BR>> Figure 9-7. The RIS Light sensor’s configuration panel

In the Port section, select the port where the RIS Light sensor has been connected. The default port for the Light sensor is Port 3.

In the Compare section, you must configure the light value (0–100) as well as whether the sensor will monitor for a light value less than or greater than the configured value. You can use the drag bar to select the value or enter a numeric value in the range of 0–100 in the text box. Select the less than option (<) or the greater than option (>) from the drop-down menu, or click the left or right radio button to configure this option.

==== NXT Ultrasonic Sensor ====

The NXT Ultrasonic sensor’s configuration panel is shown in Figure 9-8.

{{attachment:figure_9-8.png}} <<BR>> Figure 9-8. The Ultrasonic sensor’s configuration panel

In the Port section, select the port where the NXT Ultrasonic sensor has been connected. The default port for the Ultrasonic sensor is Port 4.

In the Compare section, you must configure the Distance value as well as whether the sensor will monitor for a distance value less than or greater than the configured value. __You can use the drag bar to select the value in the range of 0–100, or you may type a value in the text box with a lower limit of 0 but an upper value greater than 100. (用滑桿拖拉只能輸入 0-100 的值, 如果要判斷更大的距離, 就要手動輸入)__ Using the drag bar limits you to a range of 0-100, but you are able to type in a value greater than 100. Select the less than option (<) or the greater than option (>) from the drop-down menu, or click on the left or right radio button to configure this option.

In the Show section, select either Centimeters or Inches from the drop-down menu.

==== NXT Rotation Sensor ====

__The NXT Rotation sensor’s configuration panel is shown in Figure 9-9. Remember that the Rotation sensor is built into the NXT motors, so don’t go looking for an actual NXT Rotation sensor by itself.__

{{attachment:figure_9-9.png}} <<BR>> Figure 9-9. The NXT Rotation sensor’s configuration panel

In the Port section, select the motor port where the NXT motor (Rotation sensor) has been connected. The default port for the Rotation sensor is Port A.

__In the Action section, you should select the Read option if you want the built-in rotation sensor to monitor the value (count) returned by the sensor. Select the Reset option to set the sensor count back to zero.__

__In the Compare section, select the motor’s spin direction (Forward or Reverse) to monitor. Select Degrees or Rotations from the bottom drop-down menu, and enter a numeric value in the text box. You must also decide whether the sensor will monitor for a value less than or greater than the configured value by selecting the option in the other drop-down menu '''(using the Yes/No data plug, you can test for a True or False logic response based on the settings you have configured in the panel)'''.__

==== RIS Rotation Sensor ====

The RIS Rotation sensor’s configuration panel is shown in Figure 9-10.

{{attachment:figure_9-10.png}} <<BR>> Figure 9-10. The RIS Rotation sensor’s configuration panel

In the Port section, select the port where the RIS Rotation sensor has been connected. The default port for the Rotation sensor is Port 2.

In the Action section, you should select the Read option if you want the built-in rotation sensor to monitor the value (count) returned by the sensor. Select the Reset option to set the sensor count back to zero.

In the Compare section, select the motor’s spin direction (Forward or Reverse) to monitor. Enter a numeric value in the text box for the number of ticks you wish to monitor; there are 16 ticks in 1 rotation. You must also decide whether the sensor will monitor for a value less than or greater than the configured value by selecting the option in the other drop-down menu.

==== RIS Temperature Sensor ====

The RIS Temperature sensor’s configuration panel is shown in Figure 9-11.

{{attachment:figure_9-11.png}} <<BR>> Figure 9-11. The RIS Temperature sensor’s configuration panel

In the Port section, select the port where the RIS Temperature sensor has been connected. The default port for the Temperature sensor is Port 4.

In the Compare section, you must enter a numeric Temperature value in the text box or use the drag bar to set a value. The value for Celsius must be in the range of –20 (negative 20) to 70. The value for Fahrenheit must be in the range of –4 (negative 4) to 158. Select the less than option (<) or the greater than option (>) from the drop-down menu, or click on the left or right radio button to configure this option.

In the Show section, select either Fahrenheit or Celsius from the drop-down menu. The value ranges the sensor can monitor are determined by this selection.

=== Other Input Types ===

There are three other methods that can be used to provide feedback to your NXT robots. These include the NXT buttons, the NXT timers, and a message received using Bluetooth technology by the NXT Brick using a RECEIVE MESSAGE programming block. I’ll cover the RECEIVE MESSAGE block (and its partner, the SEND MESSAGE block) in Chapter 25, so let me close this chapter with details on the NXT buttons and timers.

__Your NXT Brick has four buttons on its front: Left, Right, Enter (orange), and Cancel. The Cancel button cannot be used as input; its function is simply to cancel a running program,__ or if you are navigating around the on-screen LCD tools, it can be used to move back to a previous screen. That leaves the Left, Right, and Enter buttons—any program you create can use these three buttons to provide input.

Figure 9-12 shows the configuration panel for the NXT BUTTONS block.

{{attachment:figure_9-12.png}} <<BR>> Figure 9-12. The NXT buttons are configured here.

In the Button section, select the button (Enter, Left, or Right) from the drop-down menu. The default selection is the Enter button.

__In the Action section, select Pressed, Released, or Bumped. These work just like the Touch sensor, by the way.__

__The NXT Brick also has three built-in Timers. '''These timers begin counting the moment you press the Enter button to begin running a program.'''__ Figure 9-13 shows the TIMER block configuration panel.

{{attachment:figure_9-13.png}} <<BR>> Figure 9-13. The NXT Timer configuration panel

In the Timer section, select 1, 2, or 3 from the drop-down menu to select the timer you wish to use. The default selection is Timer 1.

In the Action section, select the Read option to obtain the current value of the timer. If you select Reset, the timer will be reset to zero when this block is executed.

The Compare section allows you to specify a value (in seconds) as a trigger that can be tested. Select either the greater than option or the less than option from the drop-down menu, and the TIMER block can now be used to provide a True/False Logic data type response. For example, if you configure the TIMER block for greater than 10 seconds for Timer 1, the Logic data plug will provide a False response until Timer 1 exceeds 10 seconds. After that, the data plug will provide a True response.

=== Using the Blocks ===

This chapter only showed you how to configure these blocks using the configuration panel. The real power comes with using these in conjunction with other blocks such as the LOOP, WAIT, and SWITCH blocks.

Chapter 11 will show you how to use the LOOP block to repeat certain tasks. When using a LOOP block, you can have the block loop forever, that is, performing the tasks over and over again until you cancel the program. Your other option is to configure the LOOP block to stop looping when a certain condition is met, for example, if the Light sensor detects a light level below 20, the Sound sensor detects a noise over level 80, or maybe a motor spins more than 20 degrees (Rotation sensor).

It’s the same with the WAIT and SWITCH blocks. Both of these blocks will allow you to use what you’ve learned in this chapter to give your robots ''decision-making'' power. So, read on—the WAIT block is up next in Chapter 10.

== Chapter 10 Wait for It! ==

One of the most useful things your robots will be doing is waiting. Yep, you heard me right— waiting. Don’t believe me? Okay, think about it this way:

 * SPOT is moving toward a black line, waiting for the Light sensor to detect the line.
 * SPOT is preparing to throw a ball at a target, waiting for the Touch sensor to be pressed and released.
 * SPOT is rolling towards the wall, waiting for the Ultrasonic sensor to detect the wall.
 * SPOT is sitting on the start line, waiting for the Sound sensor to hear me yell, “Go!”

__Are you beginning to see that waiting is an important part of a robot’s program? Your robots will probably always be waiting for something to happen. (事件機制)__ It may be as simple as waiting for you to press the Enter button on the Brick or something similar to the preceding examples. All this waiting is accomplished using the WAIT block, so keep reading to figure out how to program your bots to “wait for it!”

=== The WAIT Block ===

__When discussing the WAIT block, you need to understand one important concept: '''The WAIT block will stop waiting when specific conditions are met. (事件觸發)'''__

It doesn’t matter if you are using the Sound sensor, Touch sensor, Ultrasonic sensor, Light sensor, or a simple time limit. When you use a WAIT block, you must tell the WAIT block what conditions must be met before the waiting ends.

So, to show you how this works, let me give SPOT some more pseudo-code:

 * Me: SPOT, keep moving forward until something happens.

Vague(含糊的), isn’t it? What does “something happens” mean? Well, it can be anything:

 * Until 5 seconds have passed
 * Until the Sound sensor detects a loud noise
 * Until the Ultrasonic sensor detects something 8 inches in front of it

Do you get the idea? I want SPOT to keep moving forward until a special condition is met. And with NXT-G, that condition can occur using a sensor, a timer, an NXT button, or a time

limit. I’m going to go over each of these individually, so you’ll see how the conditions are configured. To demonstrate the different conditions, I’m going to have you first create an extremely simple program for SPOT (or your own bot).

Open the NXT-G software, and start a new program. Drop a MOVE block on the workspace, and configure it to spin motors B and C forward with an Unlimited Duration and a Power setting of 50 (see Figure 10-1).

{{attachment:figure_10-1.png}} <<BR>> Figure 10-1. A new NXT-G program for SPOT

Now it’s time to play around with different conditions that will end SPOT’s forward movement. The WAIT block is our answer.

Note: When I discuss the WAIT block, I’m going to put another word in front of it to tell you how I will configure it. For example, a TIME WAIT block will use time as the condition. If I want to use the Sound sensor to end the wait, I’ll use a SOUND SENSOR WAIT block. OK?

The WAIT blocks are found on the Common Palette. When you move your mouse pointer over the WAIT block, a fly-out menu appears with five options (see Figure 10-2).

{{attachment:figure_10-2.png}} <<BR>> Figure 10-2. There are five WAIT blocks that can be selected.

Let me start with the easiest to configure—the TIME WAIT block. Figure 10-3 shows the TIME WAIT block added and its configuration panel.

{{attachment:figure_10-3.png}} <<BR>> Figure 10-3. The TIME WAIT block and configuration panel

There are two items that can be configured on the TIME WAIT block. The first is a drop-down menu in the Control section. If you click this, you’ll see that the WAIT block can be set to Sensor or Time. Don’t change it yet, but be aware that by selecting Sensor you can change the TIME WAIT block to a SENSOR WAIT block. The Control section also gives you a couple of hidden WAIT blocks that I’ll cover later in this chapter.

The other option in the TIME WAIT block that can be configured is the Until section. You’ll notice that it expects you to enter a number in the text box for the number of seconds you wish for the WAIT block to . . . wait.

Figure 10-3 shows that I’ve configured the TIME WAIT block for 10 seconds. Go ahead and save the program, upload it to your bot, and then run it. What happens?

Did the motors run for 10 seconds and then stop? If not, check to make sure you configured the TIME WAIT block for 10 seconds; that’s the most likely problem.

Well, that’s it for the TIME WAIT sensor. Now let’s take a look at the SENSOR WAIT blocks.

For the remaining WAIT blocks, I’m going to cover the configuration panels and the options available. I highly encourage you to practice these with the program you’ve just created: replace the TIME WAIT block with each of the WAIT blocks discussed in the following sections. Configure each WAIT block and play around with it; upload each to your bot, and see how it works.

To get started, let me give you a shortcut for changing the type of the WAIT block. Go back to your original program with the MOVE block and the TIME WAIT block (shown in Figure 10-3). Click the TIME WAIT block to access the configuration panel. Click the Control section’s dropdown menu, and choose Sensor instead of Time. When you change to Sensor, you now have a new configuration panel section (called Sensor) with another drop-down menu. Click the drop-down menu, and take a look at your options (shown in Figure 10-4).

{{attachment:figure_10-4.png}} <<BR>> Figure 10-4. The options available to you in the Sensor section drop-down menu

__The options provided include Light Sensor, NXT Buttons, Receive Message, Rotation Sensor, Sound Sensor, Timer, Touch Sensor, and Ultrasonic Sensor. The small triangle at the bottom(要裝 Legacy Block Library 才會出現[?]) indicates there are more sensors available, so click it to see them all.__ I’m going to cover each of these except for the Receive Message option; I’ll cover the SEND MESSAGE and RECEIVE MESSAGE blocks in Chapter 25. So follow along as I show you each of these options and its corresponding configuration panel. Refer to Chapter 9 for details on the configuration panels for the sensors, NXT buttons, and timers.

==== The LIGHT SENSOR WAIT Block ====

Figure 10-5 shows the LIGHT SENSOR WAIT block and its configuration panel. (原來上面各 sensor Compare section 的設定與 WAIT 的使用沒有 "直接的" 關係[?])

{{attachment:figure_10-5.png}} <<BR>> Figure 10-5. The LIGHT SENSOR WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until the Light sensor detects a light level less than 20. When this occurs, the motors will stop spinning, and SPOT will stop moving forward.

==== The NXT BUTTONS WAIT Block ====

Figure 10-6 shows the NXT BUTTONS WAIT block and its configuration panel.

{{attachment:figure_10-6.png}} <<BR>> Figure 10-6. The NXT BUTTONS WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until the Left button has been released. When this occurs, the motors will stop spinning, and SPOT will stop moving forward.

==== The ROTATION SENSOR WAIT Block ====

Figure 10-7 shows the ROTATION SENSOR WAIT block and its configuration panel.

{{attachment:figure_10-7.png}} <<BR>> Figure 10-7. The ROTATION SENSOR WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until motor A has spun in the Reverse direction for 180 degrees or more. When this occurs, motors B and C will stop spinning, and SPOT will stop moving forward.

==== The SOUND SENSOR WAIT Block ====

Figure 10-8 shows the SOUND SENSOR WAIT block and its configuration panel.

{{attachment:figure_10-8.png}} <<BR>> Figure 10-8. The SOUND SENSOR WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until the Sound sensor detects a sound level below 30. When this occurs, motors B and C will stop spinning, and SPOT will stop moving forward.

==== The TIMER WAIT Block ====

Figure 10-9 shows the TIMER WAIT block and its configuration panel. (注意與上面 TIME WAIT 的不同)

{{attachment:figure_10-9.png}} <<BR>> Figure 10-9. The TIMER WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until Timer 2 exceeds 20 seconds. All timers start counting immediately when you run a program. So once you press the orange Enter button on the NXT Brick to run a program, this WAIT block will wait until the value read from Timer 2 equals 20 before the program continues. When this occurs, the motors will stop spinning, and SPOT will stop moving forward.

Later, you’ll learn how to reset the timers, but for now, you just need to know that there are three timers—Timer 1, Timer 2, and Timer 3—and all start counting when a program starts.

==== The TOUCH SENSOR WAIT Block ====

Figure 10-10 shows the TOUCH SENSOR WAIT block and its configuration panel.

{{attachment:figure_10-10.png}} <<BR>> Figure 10-10. The TOUCH SENSOR WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until the Touch sensor button has been Bumped (pressed and released quickly). When this occurs, motors B and C will stop spinning, and SPOT will stop moving forward.

==== The ULTRASONIC SENSOR WAIT Block ====

Figure 10-11 shows the ULTRASONIC SENSOR WAIT block and its configuration panel.

{{attachment:figure_10-11.png}} <<BR>> Figure 10-11. The ULTRASONIC SENSOR WAIT block and configuration panel

In this example, the WAIT block has been configured to wait until the Ultrasonic sensor detects an object (or obstacle) less than 25 centimeters in front of it. When this occurs, motors B and C will stop spinning, and SPOT will stop moving forward.

And that’s it! Now you can configure your robots to wait for a variety of different conditions. You know how to use the sensors, the built-in timers, and the NXT buttons to trigger a WAIT block to stop waiting.

Now, let me ask you a question. You know how to make your robot wait and wait and wait—but do you know how to make your robot do something else over and over again? To do this, you’ll use something called a LOOP block. I’ll show you how it works in Chapter 11.

== Chapter 11 Round and Round ==

At this point in the book, we’re almost finished with the blocks in the Common Palette. Throughout the remainder of the book, I’ll be introducing you to blocks and concepts that will allow you to build more complex programs than simply telling your bots to move forward, backward, or in a circle.

Now, I’d like to take a short break to introduce you to another concept. I’ll make this one fun too, I promise. Then, I’ll show you a new NXT-G programming block that you’ll really like.

=== Do It Again and Again and Again... ===

Let’s go back to our friendly bot, SPOT. Once again, let’s just pretend that he’s got a pair of ears and can understand verbal(口頭的) commands. I’m going to give him a set of unusual commands:

 * Me: SPOT, I want you to move forward six rotations, stop, and turn right. [SPOT moves forward six rotations, stops, and turns right.]
 * Me: SPOT, move forward six rotations, stop, and turn right. [SPOT moves forward six rotations, stops, and turns right.]
 * Me: SPOT, move forward six rotations, stop, and turn right. [SPOT moves forward six rotations, stops, and turns right.]
 * Me: SPOT, move forward six rotations, stop, and turn right. [SPOT moves forward six rotations, stops, and turns right.]

Now, where is SPOT? That’s right—he’s back where he started. The path he followed was square-shaped, and he’s once again waiting for my instructions.

If you were to create an NXT-G program for SPOT to make this square, you’d simply place eight MOVE blocks on the workspace (as shown in Figure 11-1) and configure each MOVE block with the same two settings, right? One MOVE block will spin motors B and C for six rotations and the next MOVE block will have SPOT make a right turn. I then repeat this pattern three more times for a total of eight MOVE blocks.

{{attachment:figure_11-1.png}} <<BR>> Figure 11-1. NXT-G program for SPOT to follow a square-shaped path

Well, it would work. But it seems like a lot of work just to make SPOT drive around in a square and return to his starting position. Is there a better way?

Let’s see if we can improve the pseudo-code a bit:

 * Me: SPOT, I want you to move forward six rotations, stop, and turn right. [SPOT moves forward six rotations, stops, and turns right.]
 * Me: SPOT, I want you to repeat my first set of instructions three more times. [SPOT moves forward six rotations, stops, and turns right.] [SPOT moves forward six rotations, stops, and turns right.] [SPOT moves forward six rotations, stops, and turns right.] 
 
Much better! I only had to tell him the instructions one time and ask him to do them again three more times. It takes just as long for SPOT to perform the movements, but I get to save my voice a bit!

In the pseudo-code, I gave SPOT commands, and I set a ''condition(結束的條件)''. You should be able to find the commands for SPOT: move, stop, turn right. But what is a condition? A condition is simply a rule your robot (SPOT) must follow. So my rule for SPOT is “Repeat my first set of instructions three more times.” I could have told him to repeat it twice or 60 times; it doesn’t matter as long as SPOT knows the rule and follows it.

Instead of telling him to repeat it three times, could I have used a different condition? Sure, here are some examples:

 * Me: SPOT, I want you to repeat my first set of instructions until your Touch sensor is triggered.
 * Me: SPOT, I want you to repeat my first set of instructions until your internal timer goes over 45 seconds.
 * Me: SPOT, I want you to repeat my first set of instructions forever.

Another way to look at it is that I’ve given SPOT instructions to do over and over and over— until something else happens. It could be that the Touch sensor is pressed or the Sound sensor detects a noise or the time reaches infinity (but trust me, SPOT’s batteries won’t last that long; eventually he’ll stop)!

If SPOT keeps doing something over and over again, someone might say, “That robot is loopy(多圈的)!” And that’s exactly right—he’s ''looping''.

__What is a loop? In real life, a loop could be a road or a piece of string(繩子?)—no matter how large it is, if you follow its path, you’ll eventually come back to your starting position. A programming loop is very similar. It just circles back on itself, either forever or until you program an escape from the loop.__

And it just so happens that the NXT-G software has a block just for this special occasion— the LOOP block (see Figure 11-2).

{{attachment:figure_11-2.png}} <<BR>> Figure 11-2. A new NXT-G program for SPOT to follow a square-shaped path

The LOOP block, by itself, is very boring. By default, it is set to loop forever; you can see this in the Control section of the LOOP block’s configuration panel. Right now, any block that I ''drop inside'' the LOOP block will keep repeating, over and over. Let me give you an example.

Note: When dropping a block inside a LOOP block, continue to hold down the mouse button and move the new block inside the LOOP block until the LOOP block expands.

I’m going to place a MOVE block inside the LOOP block. This MOVE block will be configured to spin the motors in Ports B and C for 1 Rotation (see Figure 11-3).

{{attachment:figure_11-3.png}} <<BR>> Figure 11-3. A simple MOVE block inside a LOOP block

I then save the program, upload it to SPOT, and run it. SPOT moves forward one rotation, and then there’s a ''slight pause''. Next, SPOT moves forward one more rotation, and there’s another pause. This continues until I get tired of watching him, and I cancel the program.

__''' pause is occurring when the MOVE block finishes its action and the LOOP block checks its condition (this happens very quickly).''' Remember, the condition is a rule that the bot must follow. The rule for this program is for the LOOP to continue forever, so it runs again and again and again—you get the picture. That explains the short pause between rotations of SPOT’s motors.__

Now let’s change the condition. How would we tell SPOT to run the MOVE block four times?

Take a look at the LOOP block’s configuration panel. The Control section has a drop-down menu. Go ahead and click it, and you’ll see some options (shown in Figure 11-4).

{{attachment:figure_11-4.png}} <<BR>> Figure 11-4. The Control section of the LOOP block

The options are Forever, Sensor, Time, Count, and Logic. Let me start with one of the easiest of the bunch: Time. Select Time from the drop-down menu in the Control section, and the configuration panel will change (see Figure 11-5).

{{attachment:figure_11-5.png}} <<BR>> Figure 11-5. The Control section of the LOOP block configured for Time

When you select Time as the Control, you have access to two other sections. The Until section is where you’ll enter a time (in seconds) in the text box. This is the amount of time that any programming blocks inside the LOOP block will run. Earlier I mentioned that a loop will cycle forever until you program an escape. Well, by setting this time limit, you’ve provided that escape from the loop. And that escape goes by another term—''loop break''.

__A loop break occurs when the loop stops. After the loop break, your program will continue with the next programming block, or it will stop if the LOOP block is the last block in your program. Easy, isn’t it? The loop can break if you cancel the program, but it can also be configured to break when a specific condition is met.__ In one of my earlier examples, I told SPOT to stop when the Touch sensor was bumped. The Touch sensor will break the LOOP block.

__'''I need to make one important point: if there are multiple blocks inside the LOOP block, they will all complete before the LOOP block breaks.''' So if you configure your LOOP block to run for 25 seconds and the blocks inside take 40 seconds to finish, the 25-second time limit will expire before the internal blocks are finished, so the LOOP block will not loop again.__

__The other section, Show, has one option: you can either enable or disable the ''counter''. Every time the LOOP block loops, the counter increases by one. If the box is checked, the LOOP block will provide a small data plug (see Figure 11-6; 原來有些 data plug 在特定組態下才會出現). I covered data hubs and data plugs in Chapter 7, but what you need to know about this option is that you can use the data plug to provide an output Number data type. This Number value is the number of loops the LOOP block has performed.__

{{attachment:figure_11-6.png}} <<BR>> Figure 11-6. If you select the Show option, a small data plug becomes available.

Another easy option is the Forever setting shown in Figure 11-7.

{{attachment:figure_11-7.png}} <<BR>> Figure 11-7. A LOOP block set to Forever

__When you configure a LOOP block to run Forever, that’s exactly what will happen: any blocks inside the loop will run over and over again until you cancel the program or the batteries give out(耗盡).__

Now click the drop-down menu in the Control section, and select Sensor; next, click the drop-down menu in the Sensor section to see the drop-down menu shown in Figure 11-8.

{{attachment:figure_11-8.png}} <<BR>> Figure 11-8. A LOOP block configured for Sensor input

As you can see, the Sensor section’s drop-down menu offers the following options: Light Sensor, NXT Buttons, Receive Message, Rotation Sensor, Sound Sensor, Timer, Touch Sensor, and Ultrasonic Sensor. These were covered in Chapter 9 and are easy to use. __What you are doing when you select one of these options is configuring the ''trigger'' that will break the loop.__

For example, in Figure 11-9, I have selected the NXT Buttons options from the Sensor section drop-down menu.

{{attachment:figure_11-9.png}} <<BR>> Figure 11-9. A LOOP block configured to break when the Left button is pressed

In this example, I have configured the loop to break when the Left button on the NXT Brick is pressed. Inside the loop, I have configured one MOVE block to move SPOT forward one rotation. I have also added a SOUND block that will play a short beep. Once the program is running, SPOT will move forward one rotation and beep, and he’ll continue to do this until the Left button is pressed. (I’ll have to chase(追逐) him to press the Left button!)

__Just keep in mind that when you choose an option from the Sensor section, you are configuring a condition that must be met ''before'' the LOOP block will break. (後置條件, 跟 do...while 的用法相同, 因此 loops 至少會執行一次)__

Your next possible option is to break the loop with a Count. Select Count from the dropdown menu in the Control section (see Figure 11-10).

{{attachment:figure_11-10.png}} <<BR>> Figure 11-10. A LOOP block configured to break using a Count

When using the Count option, you must provide an integer value in the Until section’s text box. You cannot use negative numbers, only zero and positive integers (1, 2, 3, and so on).

In Figure 11-10, I’ve configured the LOOP block to break when the Count reaches 12. When I run the program, SPOT will execute the first MOVE and SOUND blocks. When these are finished, Count goes from 0 to 1, and the loop starts again. The MOVE and SOUND blocks are executed again, and Count increases to 2. After the blocks have been executed a total of 12 times (Count = 12), the loop will break, and the program will end.

The last option available to break a loop is the Logic setting, shown in Figure 11-11.

{{attachment:figure_11-11.png}} <<BR>> Figure 11-11. A LOOP block configured to break using a Logic response

In Figure 11-11, notice that when Logic is selected in the Control section drop-down menu, a small data plug appears on the LOOP block.

__This data plug will only accept a Logic data wire as input. This means that the LOOP block will break when the Logic data type (True or False) you selected in the Until section is received. (由此往外延展, 彈性很大...)__ I’ll show you an example using this option in the next section.

That’s it for configuring an individual LOOP block. But there’s one more thing I’d like to show you with the LOOP block: ''nested loops''.

=== Nested Loops ===

To demonstrate this new concept, I’m going to create a simple program for SPOT that I’d like you to follow along and create yourself. First, let me explain what I want SPOT to do using pseudo-code:

 * Me: SPOT, I want you to move forward along a circular(圓形的) path for 3.5 rotations and then use your speaker to beep! Do this two more times (for a total of three times), and then check to see if your Light sensor detects a Light level greater than 90. If the Light sensor is not triggered, repeat this entire process.

I can use a LOOP block to hold a MOVE block and a SOUND block that will repeat three times. This is shown in Figure 11-12.

{{attachment:figure_11-12.png}} <<BR>> Figure 11-12. This LOOP block contains a MOVE block and a SOUND block and will use a Count of 3.

I’ve dropped a MOVE block and a SOUND block inside this LOOP block. In the Control section, you’ll see that I’ve selected the Count option and set it to 3. The next thing I want to do is see if the Light sensor is triggered. I’ve added and configured the Light sensor in Figure 11-13.

{{attachment:figure_11-13.png}} <<BR>> Figure 11-13. The Light sensor is added to the program.

But now I’ve got a problem. If you follow along with the program, you can see that the LOOP block will run three times: the MOVE and SOUND blocks inside it will execute three times and then the LOOP breaks. Then the Light sensor is tested. If the Light level is greater than 90, the program ends. But what if the Light level is less than 90? How do I make the program run again? One option is to simply have SPOT run the program again. I’ll have to press the Enter button on the Brick to run the program again, but this will work. It will also be very annoying. There ought to be an easier way, and there is.

Take a look at Figure 11-14, and you’ll notice that the entire program I just created is now inside another LOOP block. (應該還有更簡單的作法[?])

{{attachment:figure_11-14.png}} <<BR>> Figure 11-14. There is now a LOOP block inside a LOOP block.

__This is called a nested loop, which just means a loop inside a loop. When the program runs, any blocks inside the outer LOOP block will run. First, the inner LOOP block will run three times (executing the MOVE and SOUND blocks inside it) and then break. '''Then the Light sensor will send a True/False Logic response to the outer LOOP block’s data plug.''' If the Light sensor does not detect a light level greater than 90, the outer LOOP block will not break and will run whatever is inside it again.__

__Notice in Figure 11-14 that there is a data wire connecting the Light sensor to the outer LOOP block. In the Control section of the outer LOOP block, I’ve selected the Logic option and programmed it to wait Until it receives a True response from the Light sensor block. If the Light sensor block does not detect a light level greater than 90, the Yes/No data plug sends a False signal to the outer LOOP block, causing the outer LOOP block to loop again.__

For my final example, Figure 11-15 shows a complicated situation. Can you determine what will happen?

{{attachment:figure_11-15.png}} <<BR>> Figure 11-15. LOOP blocks everywhere

Yes, that is a loop inside a loop inside a loop—three LOOP blocks! If you examine this program carefully, you should be able to see what will happen when it is run.

First, the ''innermost'' LOOP block will begin to execute a MOVE block until the Touch sensor is triggered (in this case, bumped). Then the innermost LOOP block will break. Next, the middle LOOP block will begin executing a MOVE block until the Ultrasonic sensor is triggered. At that point, the middle LOOP block will break. Then the final, outer LOOP block will begin executing a MOVE block until the Sound sensor is triggered. Finally, when the Sound sensor is triggered, the outer LOOP block breaks, and the program ends. __'''(這裡 "由內往外" 執行的說法並不正確, 因為實際上是 "由外往內" 執行才是, 只是剛好每一個 loop 內部的第一個動作剛好碰上另一個 loop 而已)'''__

The LOOP block is a very useful and powerful block; you should spend some time experimenting with all the different options. You’ll use the LOOP block often when you want your robots to repeat certain blocks.

Now you know how to have your robot repeat certain actions such as turning left and moving forward 10 rotations. Up next in Chapter 12, I’m going to show you how to give your robots the ability to make choices: should SPOT turn left and move forward five rotations or turn right and move forward two rotations?

== Chapter 12 Decisions, Decisions ==

This chapter covers the final block in the Common Palette. When you are finished with this chapter, you will have the ability to create some great little programs for your robots and give them the ability to move, talk, listen, bump, stop, wait, and a lot more.

Let’s give your robots one more talent(才能)—the ability to make choices and select from multiple possible actions.

=== Left or Right? Door 1 or Door 2? ===

Let me give SPOT some pseudo-code for his next task:

 * Me: SPOT, I want you to move forward three rotations and stop. If your Light sensor detects a light level over 30, turn left. Otherwise, turn right.

At this point, you already know how to program SPOT with a MOVE block that moves him forward three rotations. But how do you take the light value from the Light sensor and use it to help SPOT make a decision about turning left or right?

The answer is easy; you’ll use the SWITCH block shown in Figure 12-1.

{{attachment:figure_12-1.png}} <<BR>> Figure 12-1. The SWITCH block lets your bots make choices.

__'''The SWITCH block uses an input value to determine a path to take. This value can be a number, a bit of text, or a Logic value (True or False). And you’re not just limited to two paths. (目前為止, 彈性最大的一個)'''__ You could configure a SWITCH block to handle the following pseudo-code:

 * Me: SPOT, pick a random number from 1 to 5.
 * Me: If the number is 1, turn left.
 * Me: If the number is 2, turn right.
 * Me: If the number is 3, spin 180 degrees.
 * Me: If the number is 4, spin 360 degrees.
 * Me: If the number is 5, keep moving forward.

In this example, I have SPOT pick a random number. This is done using the VARIABLE block that you’ll learn about later in Chapter 18. But for now, let’s just assume for the moment that SPOT can pick his own numbers. Now, since there are five potential numbers (1, 2, 3, 4, and 5), there are five potential actions that can be taken. __Throughout the remainder of this chapter, I’m also going to use the term ''path'' instead of action, because the SWITCH block will allow your bots to choose from different paths available to them.__

__Depending on the path a robot selects, different actions will occur.__ One path can have your robot moving forward, checking its Ultrasonic sensor for an object in front. Selecting a different path might send the same robot in the reverse direction, waiting for its Touch sensor to be pressed and counting the number of rotations the motors spin. That’s the great thing about the SWITCH block. __Each potential path choice can have unique programming blocks that give your robots even more power. (And you can add another SWITCH block to a path, creating another set of paths for your robot to choose from!)__

Now, before I show you how the SWITCH block works, I need to mention one special item in the SWITCH block’s configuration panel. Take a look at Figure 12-2.

{{attachment:figure_12-2.png}} <<BR>> Figure 12-2. Flat view for the SWITCH block

__When using the SWITCH block, you need to choose between ''Flat view'' and ''Tabbed view''. When using Flat view, you need to leave the Flat view box checked (as shown in Figure 12-2). '''Flat view does have a limitation that you need to be aware of, however. When using it, you can program only two paths.''' Notice in Figure 12-2 that there are two paths: one labeled with a checkmark and the other with an “X”. The checkmark path is also called the ''default path'' (more on this in a little bit).__

雖然 Flat View 與 Tabbed View 只是檢視方式的控制, 但實驗發現: 

 * Flat View 也不限定只能用 Logic, 只不過畫面上分別用 "打勾" 及 "打叉" 來表示兩種狀況, 因此 Flat View 比較適合用在 Logic vlaue.
 * 採用 Flat View 時, 就不能增加第三個選項, 有三個以上的選項時, 就不能勾選 Flat View
 * 採用 Flat View 時, 不能從內部拉出 wire 到外部做連結 (不太合理[?])

Now, in Figure 12-3 I’ve unchecked the Flat view box, and you can now see that the SWITCH block has tabs along the top edge.

{{attachment:figure_12-3.png}} <<BR>> Figure 12-3. Tabbed view for the SWITCH block

__With the Tabbed view, you must click a tab to see the programming blocks (if any) that have been placed ''inside'' it. (這裡 SWITCH 的表現方式與 LOOP 很像, 都是把其他 blocks 包在裡面) This is a small price to pay for the ability to specify more than two options,__ however. Remember the earlier pseudo-code where SPOT picked a random number between 1 and 5? Figure 12-4 shows a SWITCH block with five tabs; each tab will now correspond to one of the potential actions I asked SPOT to perform.

{{attachment:figure_12-4.png}} <<BR>> Figure 12-4. This SWITCH block has five tabs for five different paths.

Okay, now it’s time to show you how to configure the SWITCH block, so you can use it to give your robot choices.

In Figure 12-5, I’ve placed a single SWITCH block that is using the Flat view. This means I only have two possible paths for my robot to take. The first path (with the checkmark) is on top and the second path (with the “X”) is on the bottom.

{{attachment:figure_12-5.png}} <<BR>> Figure 12-5. This SWITCH block has two possible paths.

This example also shows you the power of the SWITCH block. In the Control section, you have a pull-down menu that offers two options: Sensor and Value. Choosing the Sensor option will allow you to configure the SWITCH block to determine the correct path for your robot using the sensor and its trigger, which you select.

__In this example, I’ve selected the Ultrasonic sensor. I’ve configured the Ultrasonic sensor to detect when an object or obstacle(障礙) is detected less than 25 centimeters in front of the robot. If this condition is met (True), the SWITCH block will execute any blocks found in the True path (the upper beam, with the checkmark). If the condition is not met (False), the SWITCH block executes any blocks found in the False path (the lower beam, with the “X” mark).__

For the moment, let’s assume that SPOT has his Ultrasonic sensor and Sound sensor mounted. I’m going to give SPOT the following pseudo-code:

 * Me: SPOT, when your Ultrasonic sensor detects an object less than 25 centimeters in front, turn left if your Sound sensor detects a sound level greater than 20.

I’ve already shown you how to configure the first SWITCH block to use the Ultrasonic sensor. So let’s assume that SPOT’s Ultrasonic sensor detects an object less than 25 centimeters in front of him. This means that any blocks on the upper beam (True path) will be executed. From the pseudo-code, we know that if the first condition is met, we want SPOT to turn left only if his Sound sensor detects a sound greater than 20. How will we do this? Simple—we’ll use another SWITCH block!

First, I drop another SWITCH block on the top beam and configure it as shown in Figure 12-6.

{{attachment:figure_12-6.png}} <<BR>> Figure 12-6. This second SWITCH uses the Sound sensor.

I configure the second SWITCH block to use the Sound sensor and to detect a sound greater than 20. If this happens, the True path (upper beam) in the second SWITCH block will execute any blocks found inside it. And that is where we’ll place the MOVE block that allows SPOT to turn left (see Figure 12-7).

{{attachment:figure_12-7.png}} <<BR>> Figure 12-7. SPOT will turn right if the first and second SWITCH block conditions are met.

__This is an example of ''embedded SWITCH blocks''. You could keep going and place more SWITCH blocks inside other SWITCH blocks. This will give your robots some excellent decisionmaking control!__

But what if you need to program your robot to test a greater number of conditions? Not all situations will have conditions that only have two options, right? So let’s take another example for SPOT; look at Figure 12-8.

{{attachment:figure_12-8.png}} <<BR>> Figure 12-8. SPOT has some decisions to make.

Here’s the pseudo-code:

 * Me: SPOT, when you come to the hallway(走廊) intersection, pick a number from 1 to 3. If the number is 1, turn left. If the number is 2, turn right. And if the number is 3, move forward.

To do this bit of programming, recall that I told you you’ll have to turn off the Flat view for a SWITCH block to use more than two conditions. That’s the first requirement. The second requirement for configuring a SWITCH block for more than two paths is that the SWITCH block must be configured to use the Value option. This is found in the drop-down menu in the Control section and is shown in Figure 12-9.

{{attachment:figure_12-9.png}} <<BR>> Figure 12-9. Start with a SWITCH block with Flat view turned off and using a Value.

__The SWITCH block now has a small input data plug that will be used. This data plug can accept a Number data type, a Text data type, or a Logic data type, and you select the option from the drop-down menu in the Type section. (同一個 data plug 也可能同時接受不同型態的值)__

Using our pseudo-code, we can see that there are three possible conditions:

 * Turn left if the number SPOT picks is 1.
 * Turn right if the number SPOT picks is 2.
 * If the number is 3, move forward.

For this example, I’m going to use the RANDOM block that is discussed in Chapter 14. For now, don’t worry about how it works—just drag and drop a RANDOM block from the Complete Palette onto the beam, and place it in front of the SWITCH block as shown in Figure 12-10. (If you really want to know how the RANDOM block works, just jump ahead and read Chapter 14; I’ll wait for you right here.)

{{attachment:figure_12-10.png}} <<BR>> Figure 12-10. A RANDOM block will generate a value of 1, 2, or 3.

For the configuration panel of the RANDOM block, simply enter a value of 1 in the Minimum text field and a value of 3 in the Maximum text field, as shown in Figure 12-10.

Drag a data wire from the RANDOM block to the SWITCH block (see Figure 12-11).

{{attachment:figure_12-11.png}} <<BR>> Figure 12-11. Connect the RANDOM block to the SWITCH block with a data wire.

Next, we need to configure the SWITCH block to accept more than two conditions. To do this, click the SWITCH block again (if it isn’t already selected), and look at the configuration panel. On the right side of the configuration panel, you’ll see the Conditions section (shown in Figure 12-12).

{{attachment:figure_12-12.png}} <<BR>> Figure 12-12. The Conditions section of the SWITCH block

Let me explain what you are looking at. __This is a list consisting of ''path numbers''. Each path number has a ''default value'' that the SWITCH block will check.__ In this example, you see the following:

 {{{
1. 0
2. 1
 }}}

__The 1 and 2 on the left are the ''possible conditions'', and these match the number of tabs you see along the top edge of the SWITCH block. The 0 and 1 values in the right column are the default Number values that the SWITCH block will use to pick a path. So, for example, if the Number value coming into the SWITCH block’s data plug is 0, then the first condition will be selected, and any blocks found under the first tab will be executed.__

Here’s one more example to make sure you understand this concept. In Figure 12-13, I’ve got three tabs for the SWITCH block.

{{attachment:figure_12-13.png}} <<BR>> Figure 12-13. Three possible paths for the SWITCH block

Notice that there is now a new row in the Condition section:

 {{{
1. 0
2. 1
3. 2
 }}}

There are now three tabs on the SWITCH block. Tab 3 will have its blocks executed if the SWITCH block detects a Number value of 2.

Here we have a small problem: SPOT will pick only 1, 2, or 3. But the only options shown are 0, 1, and 2. How can we change this?

Easy—if you click one of the conditions, you can change its value in the text box just below the Condition section. First, click the condition whose value you want to change (see Figure 12-14).

{{attachment:figure_12-14.png}} <<BR>> Figure 12-14. Click a Condition to change its value.

Next, you must click on the small asterisk (*) button shown in Figure 12-15; this will place a checkmark next to the value of the condition that you want to change (see Figure 12-16).

{{attachment:figure_12-15.png}} <<BR>> Figure 12-15. Click the small asterisk (*) button to select a condition to change.

Next, change the Number value in the text box just below the Condition section (see Figure 12-16).

{{attachment:figure_12-16.png}} <<BR>> Figure 12-16. Change the Number value.

In this example, I’ve changed the Number value for the third condition from 2 to 3. I’ll perform these same actions for conditions 1 and 2, changing their values, respectively, to 1 and 2. This is shown in Figure 12-17.

__Caution: Please be aware that you cannot have two or more conditions with the same Number value. This is because the SWITCH block would get confused and not know which path to take. Make sense? If condition 1 has a Number value of 1 and condition 2 has a Number value of 1, which path would the SWITCH block take if the RANDOM block sends a value of 1? Fortunately, the SWITCH block is smart and will not allow you to make this mistake.__

{{attachment:figure_12-17.png}} <<BR>> Figure 12-17. Three possible paths are now available to SPOT.

And now I can drop in a collection of MOVE blocks that will allow SPOT to turn left, turn right, or move forward.

If SPOT picks 1, then he turns left. So, I’ll click the first tab (see Figure 12-18) and drop in a MOVE block that will allow SPOT to turn left.

{{attachment:figure_12-18.png}} <<BR>> Figure 12-18. The first tab has a MOVE block that executes if SPOT picks 1.

I’ll do the same thing for the second and third tabs. __When the RANDOM block generates a number from 1 to 3, that number is passed to the SWITCH block. The SWITCH block takes this Number value and compares it to the values in its Condition section.__ If the RANDOM block sends a 3, the SWITCH blocks takes that value, notices that it equals the 3 in the third condition, and then executes any blocks found on the third tab. Easy!

__One final warning, though—what happens if the RANDOM block goes crazy and sends a value of 4 to the SWITCH block? There is no condition that has a matching value of 4, so what will happen? Well, remember when you selected a condition and clicked the * button and a checkmark appeared next to the condition? That checkmark also specifies the ''default condition''.__ Look back at Figure 12-16. The checkmark is next to the third tab. This means that if a value of 4 is provided by the RANDOM block and 4 isn’t a possible value in the Condition section, the default path will be chosen. So the blocks in the third tab will execute for a value of 4, 5, 100, or any other number except for 1 and 2.

__The SWITCH block is a very useful block for giving your robots some powerful decisionmaking skills. The SWITCH block can use Logic values (True or False), Numbers, Text, and sensors to determine which paths are chosen by your robot to execute. Keep this in mind when you need to give your robots the ability to make different decisions based on different types of input.__

As your programming skills progress, you’ll find the SWITCH block one of your favorite tools to use.

Next, we’ll be looking into some specialty(特製) blocks.

== Chapter 13 Stop It ==

This will be another short chapter. How much can one really say about a block that simply stops your program from running?

=== The STOP Block ===

__The most important thing you need to know about the STOP block is this: if your robot encounters a STOP block at any point in the program, the robot will simply stop at that point with no further action (there is one exception and that is when you are using data wires—more on that later).__

Your robot will always stop when it reaches the end of your program unless you have a LOOP block somewhere in the program that keeps the program running (or a LOOP block surrounding all other programming blocks, which means the program will run forever until you press the Cancel button or a STOP block is encountered somewhere in the inner workings of your program).

The STOP block is shown in Figure 13-1. Notice in its data hub that it only has one input data plug and one output data plug, which can use a Logic data type.

{{attachment:figure_13-1.png}} <<BR>> Figure 13-1. The STOP block and its configuration panel

__As I mentioned earlier, '''the STOP block will immediately stop the program when the STOP block is reached unless a data wire is providing a False input (''signal'') to the STOP block’s input data plug.'''__ Let’s look at the example in Figure 13-2.

{{attachment:figure_13-2.png}} <<BR>> Figure 13-2. A simple program using the STOP block

In Figure 13-2, I’ve got a small program for SPOT. It’s a LOOP block that contains a Touch sensor block, a STOP block, and a SOUND block. When the program is run, every time the LOOP block loops, SPOT will beep (using the SOUND block). This will continue until the Touch sensor is pressed. When the Touch sensor is pressed, a True response is sent (using the data wire) to the STOP block’s input data plug. And the program will stop. As long as the Touch sensor is not pressed, the STOP block will continue to receive a False response from the Touch sensor and will not stop the program. Simple!

Now, what do you think would happen if I didn’t connect a data wire between the Touch sensor and the STOP block, as shown in Figure 13-3?

{{attachment:figure_13-3.png}} <<BR>> Figure 13-3. Modifying the sample program’s data wire completely changes the way it works.

You can load the program and try it, but if you walk through the simple program visually I think you’ll figure it out.

When the program runs, the LOOP block starts. The Touch sensor block runs, followed by the STOP block. Will the program execute the SOUND block? The answer is, “No.” Remember my initial rule: the program will stop running when it executes a STOP block and will perform no further actions. This program will stop immediately and never execute the SOUND block (run the program to prove it to yourself).

__You might be wondering when you would ever want to put a STOP block in the middle of a program. Well, one answer involves the SWITCH block. Recall that using the SWITCH block allows your robots to choose different action paths to take. One path might send your robot into some more complex programming behavior while the other path might be a simple STOP block.__ Take a look at Figure 13-4, which shows an example of this process.

{{attachment:figure_13-4.png}} <<BR>> Figure 13-4. A SWITCH block might need a STOP block to keep your robot safe.

__In this example, I’ve placed SPOT on a tall table. SPOT’s Touch sensor is mounted facing downward on the table, so the button is pressed. If SPOT reaches the edge of the table, the Touch sensor button will no longer be pressed, right? (There’s no table surface to continue to press against the button; '''如何透過機械來巧妙地安排各種 sensor, 藉以獲取環境資訊做為下一步的依據, 將是設計上的重點...''')__

Figure 13-4 shows a simple LOOP block that contains a SWITCH block. I’ve configured the SWITCH block to test whether the Touch sensor button is Released. If it is, the True path will be selected. If the button is still pressed, the False path will be selected. I want SPOT to stop immediately when the Touch sensor button is released, so I place a STOP block in the True path and a MOVE block in the False path. As long as the button is pressed, SPOT will keep moving forward. But for SPOT’s safety, once the button is released (and he’s reached the edge of the table), I want the program to immediately end. __The trick to this program is placing the Touch sensor far out in front of SPOT, so he’s still safely back from the edge when the button is released—try it!__

__The STOP block is extremely easy to use. As a ''testing'' tool, you can always place a STOP block in your program if you’re testing a robot but don’t want it to continue past a certain point in the program.__ For example, let’s say you have a robot that performs three separate tasks, one after the other. Placing a STOP block after the programming blocks for the first task will allow you to run your program and test to make ''certain the program'' works for that task. If all is well, remove the STOP block and place another STOP block after the programming blocks for the second task. Now when you run the program, your robot will perform the steps for the first and second tasks but not for the third.

And now it’s time to STOP this chapter and MOVE on to the NXT one; it’s not a RANDOM chapter, but it does cover the RANDOM block. Sorry, I couldn’t resist(忍住).

== Chapter 14 Pick a Card, Any Card ==

Have you ever had someone perform a card trick and ask you to pick a card from the deck? There are 52 cards in a standard deck (the two jokers don’t count), and if it’s been properly shuffled, you should be able to pick a random card from the deck.

It’s the same with rolling a pair of dice(骰子). Each die(擲骰子) has the potential to roll a number from one to six. When you roll a normal pair of dice, the numbers that appear are random. The odds(幾率) of rolling a 2 on one die are the same as rolling a 6; they all have the same likelihood of appearing. What allows this to occur is simple randomness.

Your robots also have the ability to generate random numbers. You might want to build a robot that can roll a virtual set of dice or maybe pick a number between 1 and 1,000. Read on to learn how to have your bots generate random numbers and display them on the LCD screen.

=== The RANDOM Block ===

Your bots can use the RANDOM block to generate numbers in a range that you define. The RANDOM block is found on the Complete Palette in the Data fly-out menu. Take a look at the block and its configuration panel in Figure 14-1.

{{attachment:figure_14-1.png}} <<BR>> Figure 14-1. The RANDOM block and its configuration panel

The RANDOM block is another one of those blocks that is very simple to use. There are not a lot of options to configure, but what is there is important.

The first thing I want you to notice in the configuration panel is the Minimum and Maximum number fields in the Range section. In these boxes, you can type in the upper and lower values for the numbers you want the RANDOM block to generate. __The Minimum value can never be less than 0, and the Maximum value can never be greater than 32,767.__

There is one other method you can use for defining the Minimum and Maximum values. There are two small tabs on the Slider bar below the Minimum and Maximum values. You can drag the leftmost small tab to set the Minimum value. The rightmost small tab can be dragged to set the Maximum value.

Note: One thing you should be aware of is that the Slider bar can only be used for defining a range between 0 and 100. If you wish to use a Maximum value greater than 100, you need to type the number into the Maximum number field.

Now, let’s do an example with SPOT using pseudo-code:

 * Me: SPOT, show a random number on your LCD screen between 20 and 80 until I press the left button.

To do this, I’ll first drop a RANDOM block on the beam (see Figure 14-1). I’ve told SPOT that I want the Minimum value to be no less than 20, so I’ll use the Slider bar to set the Minimum value (see Figure 14-2).

{{attachment:figure_14-2.png}} <<BR>> Figure 14-2. The RANDOM block with the Minimum value set to 20

Now, what if I had wanted the value to be between 20 and 80 but not include 20?

__Remember, the Minimum and Maximum values you define will be included in the possible numbers generated by the RANDOM block. So if I didn’t want 20 to be a possible number, I would simply drag the Slider bar again to set the Minimum value to 21. By doing this, 21 would be a possibility, but 20 would be no longer allowed.__

My final step is to set the Maximum value; I drag the Slider bar to set the Maximum value to 80 (see Figure 14-3).

{{attachment:figure_14-3.png}} <<BR>> Figure 14-3. The RANDOM block with the Maximum value set to 80

Now all that’s left to do is to have SPOT display the value on the LCD screen. To do this, I need to introduce you to another NXT-G programming block: NUMBER TO TEXT.

=== The NUMBER TO TEXT Block ===

The NUMBER TO TEXT block is also found on the Complete Palette in the Data fly-out menu.

I’ll drag and drop it after the RANDOM block, so you can see its configuration panel (shown in Figure 14-4).

{{attachment:figure_14-4.png}} <<BR>> Figure 14-4. The NUMBER TO TEXT block is for displaying numbers on the LCD screen.

__If you’re wondering why the configuration panel is grayed out, it’s because the NUMBER TO TEXT block requires the number it will display on the LCD screen to come into its single-input data plug.__ The number that is passed to this block is converted to text that can be displayed using the DISPLAY block.

So, let me go ahead and drag a wire from the output Number data plug on the RANDOM block into the input Number data plug on the NUMBER TO TEXT block. You can see this in Figure 14-5.

{{attachment:figure_14-5.png}} <<BR>> Figure 14-5. Drag a wire from the RANDOM block to the NUMBER TO TEXT block.

As you can tell from Figure 14-5, the text you want to display will come from the output data plug on the NUMBER TO TEXT block. I’ll drop in a DISPLAY block and drag another wire from the output Text data plug on the NUMBER TO TEXT block into the input Text data plug on the DISPLAY block (see Figure 14-6). Remember to set the DISPLAY block to display Text, not Image or Drawing, in its configuration panel.

{{attachment:figure_14-6.png}} <<BR>> Figure 14-6. Drag a wire from the NUMBER TO TEXT block to the DISPLAY block.

Instead of using a TIME WAIT block to keep the text on screen as I’ve done with past examples, I’m going to use an NXT BUTTON WAIT block this time. The RANDOM number generated will stay on the LCD screen until I press the Left button.

To do this, I drop in an NXT BUTTON WAIT block and configure it as shown in Figure 14-7.

{{attachment:figure_14-7.png}} <<BR>> Figure 14-7. The generated number will stay on the LCD screen until the left button is pressed.

I’ve used a WAIT block with the Control section set to Sensor. In the Sensor section, I selected NXT Buttons from the drop-down menu. For the Button section, select Left button from the drop-down menu, and finally, in the Action section, I selected Pressed. By configuring the WAIT block this way, the random number will stay on the LCD screen until I press the left button on the NXT Brick. Then the program ends.

Not too difficult, huh?

__'''One final thing I want to point out on the NUMBER TO TEXT block is the output Number data plug. This block will still allow you to keep and use the random number you generated in a Number format.''' You might need that random number later in the program. If so, you can drag a data wire out of the output Number data plug—it will still be a number and not changed to text.__

So now you know how the RANDOM block is configured and used. If you want your robot to move randomly around the room, for example, you could configure a RANDOM block to generate a number between 1 and 4. Program your bot to go left if the number is 1, right if the number is 2, forward if the number is 3, and in reverse if the number is 4. By using a random number to control the bot’s direction, you can give the bot some unpredictable behavior. Refer to Chapter 12’s discussion of the SWITCH block for using conditions such as a random number to control movement.

Next, in Chapter 15, we’ll look at the COMPARE block.

== Chapter 15 Apples and Oranges ==

There’s an old saying, “That’s like comparing apples to oranges.” What it means is that it’s sometimes unfair(不公平的) to compare dissimilar(不同的) objects. I said “sometimes,” because at other times it’s completely fair. Suppose I hand you one apple and one orange. Which one is heavier? Which one has a larger diameter(直徑)? These aren’t unfair questions, are they?

So sometimes you can compare apples to oranges! And when it comes to your robots, there’s a way for your robots to compare things, too—not apples and oranges but numbers. 

=== The COMPARE Block ===

Remember that we discussed the concept of Logic back in Chapter 8? True or False? (If you said False, you need to go back and read Chapter 8 again!)

Well, NXT-G comes with a programming block called the COMPARE block that relies on your understanding of Logic.

Suppose I ask you, “Is 5 greater than 3?” Your answer would be, “Yes.” When you program, the same question is given to a computer or robot in the form of a statement, “5 is greater than 3.” This statement, to your robot, is either True or False.

Similarly, if I ask you, “Is the Earth square-shaped?” you would answer, “No.” A robot would not be asked this question, but instead told, “The Earth is square-shaped.” And it would respond with False.

__So, here’s an important item to remember: '''robots respond to statements with True or False.'''__

Before I show you the COMPARE block, let’s create a test program for SPOT using pseudocode: 

 * Me: SPOT, I want you to create two random numbers between 1 and 9 (number A and number B), show them on the LCD screen, and tell me if A is greater than B.

To do this, we’ll start by dropping two RANDOM blocks (see Chapter 14) on to the beam, as shown in Figure 15-1. I’ve configured both RANDOM blocks with identical settings, as shown in the configuration panel.

{{attachment:figure_15-1.png}} <<BR>> Figure 15-1. Two RANDOM blocks will generate numbers for comparison.

Next, I’ll convert them to text using two NUMBER TO TEXT blocks (see Figure 15-2). Review Chapter 14 for information on the NUMBER TO TEXT block.

{{attachment:figure_15-2.png}} <<BR>> Figure 15-2. Convert the random numbers to Text.

And before we get to the Compare block, I’ll use a TEXT block to create a statement in the form of “A greater than B,” as shown in Figure 15-3.

{{attachment:figure_15-3.png}} <<BR>> Figure 15-3. Create a text statement to be displayed on the LCD screen.

As you can see from Figure 15-3, the first RANDOM block number is used as input in the second NUMBER TO TEXT block (the fourth block from the left). The second RANDOM block number is used as input in the first NUMBER TO TEXT block (the third block from the left).

__For the TEXT block, I have taken the first number (now converted to text) and used it as input to the A data plug. Also, I have taken the second number (now converted to text) and used it as input to the C data plug. I enter the words “greater than” in the B text box (前後要各加一個空白, 否則字會黏在一起). This will create a single sentence (also called a ''statement''; 字串串接): A greater than C (where A and C will be numbers between 1 and 9).__

I now send the ''combined text'' to a DISPLAY block configured to display Text on Line 3 with position X=2 and Y=40 (see Figure 15-4; 注意 X 座標要往左調整, 否則輸出時字串的尾部會被截掉).

{{attachment:figure_15-4.png}} <<BR>> Figure 15-4. The DISPLAY block will display a statement on the LCD screen.

Now we’re ready to see how the COMPARE block works. (Sorry it took so long to get here, but the COMPARE block by itself can’t do anything—we need a good example with things to compare to see it in action.)

__I’m going to break off a new beam to run ''in parallel''. (這跟多執行緒的平行處理無關, 這種分出支線的結構, 也很容易跟 SWITCH 的概念混淆; beam 的架法跟執行順序有什麼關係? 或者這正是 function 的概念[?]) To do this, I hold down the Shift key and drag an extra beam, shown in Figure 15-5.__

{{attachment:figure_15-5.png}} <<BR>> Figure 15-5. An extra beam will be used to compare values.

This parallel beam will let me compare value A to value B. Remember, I want to check the statement “A greater than B” and determine if it is True or False.

The first thing I need to do is drop the COMPARE block onto the new beam, as shown in Figure 15-6.

{{attachment:figure_15-6.png}} <<BR>> Figure 15-6. The COMPARE block will check to see if value A is greater than value B.

Notice in Figure 15-6 that the COMPARE block has two input data plugs. I’ll take the original random numbers from the NUMBER TO TEXT blocks’ output Number data plugs and drag data wires into the two COMPARE block input data plugs.

__Note: Back in Chapter 14, I told you that the NUMBER TO TEXT block had an output Number data plug that could be used to keep the number in Number format and not Text format. You’ll use this ability now to send these original random numbers into the COMPARE block.__

Carefully drag a data wire out of the second NUMBER TO TEXT block (the fourth one from the left) and into the value A’s input data plug. Do the same for the first NUMBER TO TEXT block (the third from the left). This configuration is shown in Figure 15-7.

{{attachment:figure_15-7.png}} <<BR>> Figure 15-7. Use the original number values as input for the COMPARE block.

Now, click the COMPARE block to view its configuration panel (shown in Figure 15-8).

{{attachment:figure_15-8.png}} <<BR>> Figure 15-8. The COMPARE block’s configuration panel

The COMPARE block’s configuration panel has a drop-down menu in the Operation section. Click this drop-down, and you’ll see three options: Less than, Greater than, and Equals.

If you choose the “Less than” option, the COMPARE block will evaluate the statement “A Less than B” and determine if it is True or False. If you choose the “Greater than” option, the COMPARE block will evaluate the statement “A Greater than B” and determine if it is True or False. And if you choose the Equals option, the statement “A Equals B” will be evaluated.

For my example, I choose the “Greater than” option, as shown in Figure 15-8. Now, my program will take the values for A and B and check to see if A is greater in value than B. The COMPARE block does this, and the answer will come from the output Result data plug.

If we go back to the pseudo-code, we’ll see that I wanted True or False to be displayed on the LCD screen along with the original statement “A greater than B.” To do this, I’m going to use the SWITCH block I covered in Chapter 12.

There are a bunch of items I need to configure for this to work. I drop a SWITCH block after the COMPARE block, and in the Display section, I uncheck the Flat view box (see Figure 15-9). In the Control section, I choose Value, and in the Type section, I choose Logic. I also drag a data wire out of the output Result data plug on the COMPARE block and connect it to the input data plug on the SWITCH block.

{{attachment:figure_15-9.png}} <<BR>> Figure 15-9. The SWITCH block will help me display True or False on the screen.

Next, I need to decide what will happen when the SWITCH block receives a True or a False signal from the COMPARE block. Let’s start with the True tab; it’s already selected in Figure 15-9.

I want to send the word “True” to the LCD display if the statement is True, so I’ll drop in a TEXT block that will contain the word “True.” This is shown in Figure 15-10.

In order for this text to appear on the LCD screen, I need to drop in another DISPLAY block on the original beam (see Figure 15-11). I drag a data wire out of the output Text data plug into the input Text data plug on this new DISPLAY block (I configured the block to display Text, and I also unchecked the Clear box; 附加在第一個 DISPLAY 輸出的後面).

{{attachment:figure_15-10.png}} <<BR>> Figure 15-10. This TEXT block contains the text “True”.

{{attachment:figure_15-11.png}} <<BR>> Figure 15-11. A new DISPLAY block will display the text “True” if the statement is True.

Now, to finish up this example, I click the other tab (the False tab) of the SWITCH block and drop a TEXT block inside, configured to hold the word “False.” Just like the True tab, I drag a data wire out of the output Text data plug into the input Text data plug on a new, third DISPLAY block, as shown in Figure 15-12.

{{attachment:figure_15-12.png}} <<BR>> Figure 15-12. The new DISPLAY block will display the text “False” if the statement is False.

__Finally, I drop in a NXT BUTTON WAIT block configured to wait for the left button to be pressed. This will give me time to view the results on the LCD screen (see Figure 15-13).__

Let’s walk through the program and see how it works. First, two RANDOM blocks generate two numbers, A and B. These numbers are converted to text (with the NUMBER TO TEXT blocks) and these “text numbers” are combined to create a text statement, “A greater than B,” which is fed into a DISPLAY block.

__為何在顯示完 "A greater than B" 之後, 程式知道要先轉往 COMPARE 所在的那條 beam 執行, 是因為下一個 DISPLAY 在等待輸入嗎? 又為何 beam 拆開的地方不在 TEXT 之後, 反而在程式的最開頭[?] '''可以在顯示 "True" 的 DISPLAY 前後各加上一組 SOUND 與 BUTTON WAIT, 發現即便 COMPARE 後面的 SWITCH 會產生分支, 但兩組 SOUND 與 BUTTON WAIT 都會被執行到, 只是剛好兩個 DISPLAY 只有一個 "有東西可以輸出", 所以造成好像只有一個 DISPLAY 被執行到的錯覺...'''__

__''After'' the random numbers are generated, these numbers are also ''fed into'' the COMPARE block, which takes the two numbers and looks to see if A is greater than B. If it is, the SWITCH statement executes the TEXT block in the True tab and displays the word “True” on the LCD screen. If A is not greater than B, the SWITCH statement executes the TEXT block in the False tab and displays the word “False” on the screen.__

{{attachment:figure_15-13.png}} <<BR>> Figure 15-13. A final NXT BUTTON WAIT block keeps the program from ending.

I encourage you to create this program and test it yourself. You’ll gain a better understanding of using wires, and you can tinker with(瞎擺弄) it. Play around with changing the condition to “Less than” or Equals and see how the results change.

When you are finished, continue on to the next chapter, where I’ll introduce you to the RANGE block.

== Chapter 16 Inside or Out? ==

In the last chapter, you learned how to use the COMPARE block to test whether a value was less than, greater than, or equal to another value. The block compares the two numbers and determines whether the statement (A Less than B, A Greater than B, or A Equals B) was True or False.

Sometimes, however, you want to check to see if a value falls inside or outside a range of numbers: Is 28 inside the range 2 through 30? True. Is 50 outside the range 1 through 10? True.

NXT-G provides a block that allows you test the condition of a number (A) to determine whether it falls inside or outside the range of two other numbers (B and C). Here’s how it works.

=== The RANGE Block ===
Just like the COMPARE block, the RANGE block uses the following rule: robots respond to statements with True or False.

The statements that a RANGE block will evaluate look like these:

 * A is inside the range of numbers beginning with B and ending with C.
 * A is outside the range of numbers beginning with B and ending with C.

That’s it. The RANGE block evaluates the statement and returns a True or False response. Let’s build a small program for SPOT that can use the RANGE block. As usual, we’ll start with the pseudo-code.

 * Me: SPOT, I want you to create a random number between 1 and 100, show it on the LCD screen, and tell me if it is inside the range of 40 to 60.

To do this, we place one RANDOM block on to the beam and configure it as shown in Figure 16-1.

{{attachment:figure_16-1.png}} <<BR>> Figure 16-1. A RANDOM block generates a number between 1 and 100.

Next, I convert the number to text using a NUMBER TO TEXT block (see Figure 16-2).

{{attachment:figure_16-2.png}} <<BR>> Figure 16-2. Convert the random numbers to Text.

Next, I’ll add a TEXT block to create a statement in the form of “A between 40 and 60” as shown in Figure 16-3. (但下面好像又拼成 "[number] inside range"[?])

{{attachment:figure_16-3.png}} <<BR>> Figure 16-3. Create a text statement to be displayed on the LCD screen.

In Figure 16-3, the RANDOM block number is used as input to the NUMBER TO TEXT block. The TEXT block then takes this bit of text (A) and combines it with the statement “inside range.”

In Figure 16-4, I use a data wire to send the text from the TEXT block to a DISPLAY block configured to display Text on Line 3 with position X=2 and Y=40 (see Figure 16-4).

{{attachment:figure_16-4.png}} <<BR>> Figure 16-4. The DISPLAY block will display “[number] inside range”.

I need to add one more DISPLAY block, so I can add the text “40 and 60” on Line 4 with position X=2 and Y=32 (see Figure 16-5). Remember to remove the check from the Clear box, so the text in the first DISPLAY box doesn’t disappear!

{{attachment:figure_16-5.png}} <<BR>> Figure 16-5. This DISPLAY block puts “40 and 60” on the screen on the next line.

And now it’s time to use the RANGE block to evaluate the statement. I drop the RANGE block onto the beam as shown in Figure 16-6.

{{attachment:figure_16-6.png}} <<BR>> Figure 16-6. The RANGE block will check to see if A is inside the range of 40 to 60.

In Figure 16-6, you can see that I’ve selected Inside Range in the drop-down menu for the Operation section. I’ve also entered a value of 40 in the A field and 60 in the B field. I could have used the Slider bar to select the Lower Limit and Upper Limit for the range, but keep in mind that the Slider bar will only allow you to define a range between 0 and 100. If you need a larger range, you’ll have to enter the values manually.

__Note: The other option in the drop-down menu is Outside Range. If I select this option, the statement will be True if the random number is outside the range of 40 to 60 and False if it is inside the range. Also notice that a Test Value can be entered in the Test Value field. You can use this if you do not have a number from an outside block (a RANDOM block, for example) to use as input.__ And finally, the Upper Limit and Lower Limit can also be provided to the RANGE block dynamically by using data wires to provide input (in Number format) to the Upper Limit data plug and the Lower Limit data plug.

My next step is to run a data wire into the RANGE block that contains the original random number. There are two ways to do this. The first is to drag a data wire out of the NUMBER TO TEXT block (remember that this block has an output data plug for the original Number). I used that method in Chapter 15 for the COMPARE block. Now I want to show you the other method.

__If you click the output Number data plug on the RANDOM block, you can drag a data wire to the input Test Value data plug on the RANGE block. I’ve done this in Figure 16-7. Notice that the original data wire going into the NUMBER TO TEXT block now ''splits'' into two wires—one still goes in the NUMBER TO TEXT block, and the other goes into the RANGE block.__

{{attachment:figure_16-7.png}} <<BR>> Figure 16-7. The Test Value is evaluated to see if it is inside the range of 40 to 60.

The pseudo-code tells SPOT to display on the LCD screen whether the statement “[number] inside range 40 and 60” is True or False. To do this, I’ve dropped a SWITCH block after the RANGE block. In the Display section, I uncheck the Flat view box; in the Control section, I choose Value, and in the Type section, I choose Logic. I also drag a data wire out of the output Result data plug on the RANGE block and connect it to the input data plug on the SWITCH block (see Figure 16-8).

{{attachment:figure_16-8.png}} <<BR>> Figure 16-8. The SWITCH block will help me display True or False on the screen.

Now all that is left is for the LCD screen to display “True” or “False.” This is simple enough: I’ll drop one DISPLAY block in the True tab (see Figure 16-9) that puts the word “True” on the LCD screen on line 7. I’ll drop another DISPLAY block in the False tab (see Figure 16-10) that puts the word “False” on the LCD screen on line 7 (remember to remove the check from the Clear box so text on the LCD screen doesn’t get erased).

{{attachment:figure_16-9.png}} <<BR>> Figure 16-9. This DISPLAY block puts the word “True” on the screen.

Now, if the statement is evaluated as True, the SWITCH block will execute the DISPLAY block found in the True tab. And if the statement is evaluated as False, the SWITCH block will execute the other DISPLAY block found in the False tab.

{{attachment:figure_16-10.png}} <<BR>> Figure 16-10. This DISPLAY block puts the word “False” on the screen.

Next, I’ll drop in a NXT BUTTON WAIT block and configure it to wait for the left button to be pressed (see Figure 16-11). This will allow me time to view the results.

{{attachment:figure_16-11.png}} <<BR>> Figure 16-11. The NXT BUTTON WAIT block gives me time to view the results.

Play around with the program. Try the Outside Range option, and change the range of the RANDOM block. Experiment with the program until you have a solid understanding of how the RANGE block works.

When you’re finished, continue on to Chapter 17, where I’ll cover the LOGIC block.

== Chapter 17 Yes? No? Maybe? ==

In Chapter 15, I introduced you to the COMPARE block, which takes two numbers, A and B, and examines them to determine if A is greater than, less than, or equal to B (depending on the option you select). The result of this comparison is then converted to a Logic data type (either True or False) that can be used as output using a data wire.

Well, in this chapter, I’m going to show you a block that is similar to the COMPARE block but not quite the same. Instead of comparing two numbers, this block will compare two Logic data type inputs and output the True/False Logic data type response.

=== The LOGIC Block ===

The Logic block (shown in Figure 17-1) is an interesting one.

{{attachment:figure_17-1.png}} <<BR>> Figure 17-1. The LOGIC block and its configuration panel

Let me set up a scenario for SPOT that I think will help you understand how this block works. I’ve attached a Light sensor and a Sound sensor to SPOT. Here’s my first bit of pseudocode for SPOT to try out:

 * Me: SPOT, I want you to move forward three rotations if two conditions are True.
 * Me: The first condition is that the Light sensor detects a light level below 30.
 * Me: The second condition is that the Sound sensor detects a sound level below 20.

OK, what will happen here? Well, SPOT will check to see if his Light sensor detects a low light level in the room (< 30). He’ll also check to see if his Sound sensor is detecting a quiet room (<20). Recall from our discussion of sensors that a sensor can return a True or False reply based on the conditions you have configured the sensor to detect.

Let’s start our program by dropping a Light sensor block on the beam and configuring it as shown in the configuration panel in Figure 17-2.

{{attachment:figure_17-2.png}} <<BR>> Figure 17-2. Configure the Light sensor as shown in the configuration panel.

Next, we’ll add a Sound sensor block and configure it as shown in Figure 17-3.

{{attachment:figure_17-3.png}} <<BR>> Figure 17-3. Configure the Sound sensor as shown in the configuration panel.

Now we have two sensors that will check the conditions of the light and sound in the room.

If we look back at our pseudo-code, SPOT will move forward only if both of the sensors are triggered. This means the Light sensor must receive a value less than 30 for the room’s lighting level, and the Sound sensor must receive a value less than 20 for the room’s sound level—both conditions must exist, or SPOT will not move forward.

What will happen if the room is bright and quiet? SPOT will not move.

What will happen if the room is dark and loud? SPOT will still not move.

What happens if the room is bright and loud? SPOT will get a headache. Just kidding—he still won’t move.

So, how can SPOT quickly examine the lighting and sound conditions of the room and decide if he can move forward or not? Simple—he’ll use the LOGIC block.

Go ahead and drop the LOGIC block on the beam, as shown in Figure 17-4.

{{attachment:figure_17-4.png}} <<BR>> Figure 17-4. The LOGIC block helps SPOT to examine the light and sound conditions.

Take a look at the drop-down menu in the Operation section. The drop-down menu has four options: And, Or, Xor, and Not. For now, select the And option (I’ll explain the other three options shortly).

Next, I want you to drag a wire out of the Yes/No data plug on the Light sensor block and connect it to the A input data plug on the LOGIC block, as shown in Figure 17-5.

Drag another wire out of the Yes/No data plug on the Sound sensor block, and connect it to the B input data plug on the LOGIC block, as shown in Figure 17-6.

{{attachment:figure_17-5.png}} <<BR>> Figure 17-5. Connect the Light sensor block to the LOGIC block.

{{attachment:figure_17-6.png}} <<BR>> Figure 17-6. Connect the Sound sensor block to the LOGIC block.

Now, let me explain what is happening so far. The LOGIC block is taking a Yes/No response from the Light sensor. It is also taking a Yes/No response from the Sound sensor. By selecting the And option on the LOGIC block, we are forcing the LOGIC block to take the result in plug A (Yes or No) and the result in plug B (Yes or No) and add them together to create a single Yes/No response. I can already hear you asking, “How do you add Yes/No responses?”

Well, the answer is fairly simple and relies on the option you selected in that drop-down menu (the And, Or, Xor, and Not options):

 * And option: If you select the And option, both responses must be Yes for a final Yes result to be generated. If plug A is Yes and plug B is No, then the final result will be No. Likewise, if plug A is No and plug B is Yes, the final result will still be No. And if plug A is No and Plug B is No, the final result is No.
 
 * Or option: If you select the Or option, only one response must be Yes for a final Yes result to be generated. If plug A is Yes and plug B is No, then the final result will be Yes. Likewise, if plug A is No and plug B is Yes, the final result will still be Yes. If both plug A and plug B are both Yes, then the final result will be Yes. Only if plug A is No and Plug B is No, the final result is No.
 
 * __Xor option: This is a weird(怪異的) one. If you select the Xor option, only one plug value can be Yes for a final Yes result to be generated.__ If plug A is Yes and plug B is No, then the final result will be Yes. Likewise, if plug A is No and plug B is Yes, the final result will still be Yes. However, if plug A and plug B are both Yes, the final result will be No. And if plug A and plug B are both No, the final result is No.
 
 * __Not option: This is another strange one. This option doesn’t really return a final value— it simply changes the Logic value input for plug A to its opposite.__ For example, if plug A is Yes, then the output for plug A will be No. This option reverses the Logic value for you and nothing else. Be aware that plug B will not work for the Not option.

Now, let’s finish up our sample program. If you look back at Figure 17-6, we now have the LOGIC block ready to provide a Yes/No response (using a data wire).

If you recall, we are testing to see if the Sound sensor detects a value below 30 and the Light sensor detects a value below 20. If these conditions are both true, then SPOT will move forward three rotations. If either of these two conditions is not true, SPOT will not move.

So, our next step is to drop in a SWITCH block to test the condition of the LOGIC block. First, select Value from the Control section drop-down menu. Next, choose Logic from the Type section drop-down menu. We can leave the Flat View box checked, because we only have two possible options (True or False). This configuration is shown in Figure 17-7.

{{attachment:figure_17-7.png}} <<BR>> Figure 17-7. A SWITCH block will use the LOGIC block output to control SPOT’s actions.

Now, here’s where it can get a little tricky. If the Light sensor detects a light value below 30, then it sends a True value to the LOGIC block. If the Sound sensor detects a sound value below 20, then it sends a True value to the LOGIC block. We have configured the LOGIC block using the And option, because we want to test if both conditions are True. If they are, the LOGIC block will send a True value to the SWITCH block. If either of the conditions is False, the LOGIC block will send a False value to the SWITCH block.

So, all that’s left is to drop in a MOVE block for the True condition in the SWITCH block, as shown in Figure 17-8.

{{attachment:figure_17-8.png}} <<BR>> Figure 17-8. A MOVE block is configured for three forward rotations.

If the SWITCH block detects a True response from the LOGIC block, the MOVE block executes (three forward rotations), and the program ends. If the SWITCH block detects a False response from the LOGIC block, there are no additional blocks to run, and the program ends without SPOT moving.

__'''And that’s it! The LOGIC block is a useful tool for you to take two Logic data type responses (Yes/No or True/False) and “add” them together to produce one Logic data type. (如果有三個以上的邏輯要合併, 就要用多個 LOGIC 逐一兩兩做合併運算的動作...)''' Are you wondering what you would do if, for example, you had four Logic data type inputs and needed to combine them? You would need to use two LOGIC blocks: each block would take two of the Logic data type input values and provide a final Logic response. These two Logic responses would then be combined using a third LOGIC block to obtain the true “final” Logic response. Confusing? A little. But when you start using the LOGIC block, you’ll begin to see how it can be used with LOOP and SWITCH blocks to give your robots even better decision-making abilities.__

== Chapter 18 Title = Anything You Like ==

That’s a strange title, isn’t it? You can pick anything you like and make it the title. But that doesn’t mean the material covered in this chapter will change. Nope(不是), this chapter covers a special type of block called the VARIABLE block. You’ll find this block useful when you need to store a piece of information for later use. So let’s take a look.

=== The VARIABLE Block ===

Let’s imagine for just a moment that you want to give SPOT some information to remember. This information consists of some words, a few numbers, and a couple of logical True/False values. SPOT has the ability to place each piece of information in a ''virtual folder'' that exists in his memory. Here’s the pseudo-code:

 * Me: SPOT, will you please store the words “pizza” and “cheesecake” in your memory?
 * Me: SPOT, I also need you to store the numbers “50” and “200” in your memory.
 * Me: SPOT, will you also please store one logical “True” and one logical “False” in your memory?

Now, before we convert this pseudo-code to an NXT-G program, I need to tell you a little bit about how an NXT-G program stores information, changes it, and retrieves it. All of this is done using the VARIABLE block.

A VARIABLE block can do one of two things:

 * Information can be written to a virtual folder that is stored in memory.
 * Information can be read from a virtual folder that is stored in memory.

These virtual folders are also known as variables. An NXT-G variable can only be configured to hold one of three types of data: Text, Number, or Logic (True or False).

Text is easy enough; my pseudo-code tells SPOT to store “pizza” and “cheesecake,” but it could just as easily have told SPOT to store the letter “A” or the sentence “My name is SPOT.”

__Numbers are even easier: when an NXT-G VARIABLE block is configured to hold a number, it can only be a positive or negative integer. Numbers such as 4.5 or –10.2 will be ''rounded to the nearest integer'' (5 and –10 for my examples).__

Logic values only have two choices: True or False. An NXT-G VARIABLE block configured to hold a logical value can hold only True or False and nothing else.

OK, now it’s time to take a look at the VARIABLE block. This block is found on the Complete Palette on the Data fly-out menu. Select the VARIABLE block, and drop it on the beam (see Figure 18-1).

{{attachment:figure_18-1.png}} <<BR>> Figure 18-1. The VARIABLE block and its configuration panel

__I mentioned to you that information can be read from or written to a VARIABLE block. In Figure 18-1, you’ll notice that, by default, the first time you drop a block on the beam it is configured to Read (in the Action section; 選擇 Read 或  Write 會在 block 上分別出現 output 或 input plugs) a Logic Type value. The variable also has a Name assigned to it: Logic 1. (這個介面實在很怪, 為什麼會有一個 List 可以選不同變數名稱跟型態? 這裡的 Name 會出現在哪裡[?])__

This means that if True or False is stored in the variable, this value can be read from the variable. Notice that the Value section is grayed out; it isn’t available for you to edit. Also notice that the default value selected in the Value section is False.

Before I show you how to change this, select the variable named Number 1 in the VARIABLE block’s configuration panel (see Figure 18-2).

{{attachment:figure_18-2.png}} <<BR>> Figure 18-2. The VARIABLE block with Number 1 selected as the variable name

If you choose Number 1 as the variable name, you’ll see that the default value stored is zero (0). This number is the value that will be read from the variable named Number 1.

Next, choose Text 1 in the VARIABLE block’s configuration panel (see Figure 18-3).

{{attachment:figure_18-3.png}} <<BR>> Figure 18-3. The VARIABLE block with Text 1 selected as the variable name

If you choose Text 1 as the variable name, the default value stored is ''blank''; there is no text stored in the Text 1 variable.

__In Figures 18-1, 18-2, and 18-3, notice also that the each of the blocks has only one output data plug. This matches what we know about a VARIABLE block with the Action section configured to Read. The variables can only be read from; other blocks (a DISPLAY block, for example) would use a data wire from this output data plug as input. This is “reading from” the variable.__

I want to make sure you understand this concept, so take a look at Figure 18-4, and I’ll explain it further.

{{attachment:figure_18-4.png}} <<BR>> Figure 18-4. A VARIABLE block providing its variable value to another block

In Figure 18-4, I’ve connected a VARIABLE block called Logic 1 to a SWITCH block. The SWITCH block’s configuration panel is visible in Figure 18-4, and you can see that I’ve configured it to check for a Logic value in the Type section. When the program is executed, the SWITCH block will read the value from the VARIABLE block. If the value is True, the SWITCH block will execute the SOUND block I’ve dropped in the True tab. If the value is False, the SWITCH block will execute a MOVE block that I dropped in the False tab.

Now, that example involved reading the data directly from the VARIABLE block. What if I want to put some data in? Then I’d have to write some data into the block. Here is how you do it.

Take a look at Figure 18-5. In this figure, I’ve selected Write in the Action section.

{{attachment:figure_18-5.png}} <<BR>> Figure 18-5. The VARIABLE block with Write selected in the Action section

__In Figure 18-5, I can change the logic value. Remember that the default is False, so I’ve changed it to True. Did you also notice the input data plug that was added on the data hub? This means that I could actually have the True or False value determined by a data wire from another block. '''(上面切換為 True 的動作就是在做 "初始化", 因為 input plug 如果沒有東西寫入, 從這個變數讀出來的值就是 True)'''__ (In this example, the data wire must carry a logic value of True or False; anything else would give me a broken wire that wouldn’t work. Likewise, if the List section has Number or Text selected, the input data wire must be providing a data type of the selected item.)

Figure 18-6 shows the configuration panels for the Number 1 and Text 1 blocks. I’m including them, because I want you to see how you can modify the data when the Action option is set to Write. For the Number 1 variable, you can type either a positive or a negative integer in the Value field. For the Text 1 variable, you can type words, sentences, or even entire paragraphs in the Value field.

{{attachment:figure_18-6.png}} <<BR>> Figure 18-6. The VARIABLE block with Write selected for the Number 1 and Text 1 variables

__'''After you’ve modified the data in a variable block, you can either ''close'' the variable by selecting Read in the Action menu (this prevents the data from being changed) or leave the block alone. (有點類似於 Java 裡頭的 final 變數) If you choose to leave the Action section option as Write, you can drag a data wire from another block to the input data plug on the variable block'''__ (just remember that the type of data wire going into the input data plug must match the type of data the variable is configured to hold—Text, Number, or Logic).

Now, let’s go back to the original pseudo-code I gave SPOT:

 * Me: SPOT, will you please store the words “pizza” and “cheesecake” in your memory?
 * Me: SPOT, I also need you to store the numbers “50” and “200” in your memory.
 * Me: SPOT, will you also please store one logical “True” and one logical “False” in your memory?

Do you see a problem? I’ve got two pieces of text to store and two number values. I already know that a variable block can only hold one piece of data. If I store the number 50, for example, in the Number 1 variable, where will I store the number 200? And I can store “pizza” in the Text 1 variable, but what about “cheesecake?”

The answer is simple. NXT-G allows you to create as many variables as you need. You can even rename a variable from something like Text 1 to something easier to remember like “Food”, or Number 1 to something like “Test Scores”. Here’s how it’s done.

If you need to create another variable, start by clicking the Edit menu at the top of the NXT-G software. Click the menu option labeled Define Variables.

A small window, like the one shown in Figure 18-7, opens.

{{attachment:figure_18-7.png}} <<BR>> Figure 18-7. The Edit Variables window allows you to create new variables.

Click the Create button, and a new variable will appear in the List section with a default name like MyVariable_1 (see Figure 18-8).

{{attachment:figure_18-8.png}} <<BR>> Figure 18-8. Your new variable appears in the List section.

You can change the name of the variable by typing a new name in the Name field. Select the type of data the variable will contain in the drop-down menu in the Datatype section. I’ve named my new variable Test Scores and configured it to hold a Number (see Figure 18-9). You can click the Create button again to make another variable. Click the Close button when you are finished.

{{attachment:figure_18-9.png}} <<BR>> Figure 18-9. Give the new variable a Name and a Datatype to hold.

Now, when you drop a VARIABLE block on the beam, you’ll notice that your new variable appears as a selection in the List section (see Figure 18-10). Using this method, you can create as many Text, Number, and Logic variables as you need.

{{attachment:figure_18-10.png}} <<BR>> Figure 18-10. Your new variable now appears in the List section of the configuration panel.

OK, now you know how to put data into a variable (Write) and how to get data from a variable (Read). You also know how to create additional variables. The last thing I want to cover in this chapter is how to use variables throughout your programs.

Here’s a bit of pseudo-code for SPOT:

 * Me: SPOT, I want you to wait for me to press and release the Enter button (orange button) for 3 seconds.
 * Me: If I press and release the button, display “Pressed” on the screen.
 * Me: If I do not press and release the button, display “Not Pressed” on the screen.

I’ll first start off with a WAIT block configured to loop for 3 seconds (see Figure 18-11).

{{attachment:figure_18-11.png}} <<BR>> Figure 18-11. The WAIT block is configured to loop for 3 seconds.

I’ll next drop in an NXT BUTTONS SENSOR block and configure it to detect the press and release (Bumped) of the Enter button (see Figure 18-12).

{{attachment:figure_18-12.png}} <<BR>> Figure 18-12. The NXT BUTTONS SENSOR block will monitor the Enter button.

I created a new VARIABLE block called “Pressed” that holds a Logic value. I next drop a VARIABLE block after the NXT BUTTONS SENSOR block. I choose my new variable, Pressed, and in the Action section, I choose Write. I also drag a data wire out of the NXT BUTTONS SENSOR block’s output data plug into the input data plug on the VARIABLE block (see Figure 18-13).

{{attachment:figure_18-13.png}} <<BR>> Figure 18-13. The variable Pressed will hold True or False.

If the Enter button is pressed and released during the first 3 seconds, the NXT BUTTONS SENSOR block will detect the press and release and change the logic value to True. A value of True or False will continue to be written to the Pressed variable block until the 3 seconds expire. When the program starts, the initial value will be False, but it can change anytime to True if the Enter button is bumped.

When the WAIT block ends (after 3 seconds), we need to display “Pressed” or “Not Pressed” on the LCD screen. To do this, we’ll drop in another VARIABLE block. This time I’m going to choose my Pressed variable again, but I’m changing its Action section option to Read (see Figure 18-14).

{{attachment:figure_18-14.png}} <<BR>> Figure 18-14. The variable Pressed will be read from by a SWITCH block.

Now, I drop in a SWITCH block and configure it to read a Logic value (see Figure 18-15), and I’ve turned off Flat view so the SWITCH block is visible in its tabbed format. I’ve also dragged a data wire from the VARIABLE block to the SWITCH block that contains the value True or False.

{{attachment:figure_18-15.png}} <<BR>> Figure 18-15. The SWITCH block will read the Pressed variable’s value.

In the True tab, I place a DISPLAY block that clears the LCD screen and puts the word “Pressed” on the screen (see Figure 18-16).

{{attachment:figure_18-16.png}} <<BR>> Figure 18-16. This DISPLAY block will display “Pressed” if the variable has a value of True.

On the False tab, I place another DISPLAY block that clears the LCD screen and puts the words “Not Pressed” on the screen (see Figure 18-17).

{{attachment:figure_18-17.png}} <<BR>> Figure 18-17. The words “Not Pressed” will display if the variable has a value of False.

Finally, I drop in an NXT BUTTON WAIT block to wait until the left button is pressed; this will give me time to view the results on the screen (see Figure 18-18).

{{attachment:figure_18-18.png}} <<BR>> Figure 18-18. If I press the left button, the program will end.

Now run the program. Try it a few times—press and release the Enter button, or don’t press and release it. Your decision to bump or not bump the button will be converted to a True or False value that is written to the Pressed variable. After 3 seconds, the Pressed variable is read by the SWITCH block, and the proper text is written on the LCD screen.

Variables are a powerful way for your robot to store away information—and to use that data later. Once the variable has been created and data written to it, that data will be available anytime you need it—well, at least until the program ends. If you want to store data for use after the program ends and/or after the power has been turned off, you’ll need a different type of block; we’ll discuss that later in Chapter 22. But in the next chapter, I’ll show you how to use the TEXT block.

== Chapter 19 Basic Text ==





== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==
