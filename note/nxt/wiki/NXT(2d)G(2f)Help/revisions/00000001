= NXT-G Online Help =
<<TableOfContents>>

== General Topics ==

=== Calibrate(校準) Sensors ===

__Ambient (週圍的; surrounding) conditions can affect the performance(表現) of both light and sound sensors. Therefore, it is important to calibrate these sensors for a particular environment so that they perform in an optimal way. '''(Reflected Light 比較不受照明條件的影響, 開頭 "ambient" 的說法, 意謂著 Light 的校準, 是針對 Ambient Light 而言)'''__

For instance, in a very bright room, an un-calibrated light sensor might deliver only high readings(讀數), reducing its potential performance. If you created your program in a dimmer(較暗的) location, your robot might react in an unusual ways when it is moved under more intense(強烈的) light. __'''Calibrating the light sensor will allow it to read values ''over its full range'' under different conditions.[...]'''__

__'''事實上 light/sound sensors 內部偵測到的數據 (raw value) 都是絕對的亮度或分貝, 由於這兩種概念都有點複雜, 而且程式多半也只在乎明暗或大小聲之間的 "差異", 因此在應用上多半轉化成百分比來表示.'''__

There are two ways to calibrate light and sound sensors using the MINDSTORMS NXT software. The first is to use the Calibrate Sensors function from the Tools menu. __Using this function, you can calibrate a light or sound sensor ''just once per location'' (and not every time your program runs). For instance, if you attend a First LEGO League competition with brightly lighted competition tables, you can calibrate your light sensor just once on a table and not have to worry about calibrating each time you run your program. '''(只要把含有 Calibration block 的程式獨立出來, 需要的時候再執行即可, 這樣就不用額外接電腦做校準了; 事實上用 NXT software 校準也是下載類似的程式到 NXT 執行而已)'''__

The second option for calibration involves using use several Calibration blocks in your program. __Each time you run your program, these blocks will calibrate the sensors for current conditions. '''(如果程式執行的過程中, 會經歷多個條件相差很大的環境, 可能就需要就每個階段分別校準一次)'''__ (See the Calibration block Help entry.)

==== Using the Calibrate Sensors function ====

To use this function, first make sure that your NXT is connected to your computer and that it is turned on. Also, make sure that the sensors you want to calibrate are connected to the NXT. Pay particular attention to the ports they are connected to.

When you are ready, select the Calibrate Sensors function from the Tools menu. The Calibrate Sensors dialog box will appear. If no NXT is connected to your computer, the dialog box will appear grayed out.

{{attachment:calibrate_02.png}} <<BR>> Image of Calibrate Sensors dialog box

===== Calibrating a light sensor =====

__Select the light sensor and the port the sensor is connected to. Then click the Calibrate button. This will download a small program to the NXT and run it automatically. '''(即使編譯一支名為 "`Calibration`" 的程式到 NXT 去執行; 這支程式可以保留下來做為日後沒有接電腦時校準感應器使用, 不過要注意它的 port 是寫死的, 不能再做改變)'''__

__這支程式會一直更新螢幕上的讀數, 大概是用 Loop NXT Button 來偵測 Enter 鍵是否被按下, 由於 Loop Sensor 在迴圈結尾才會去檢查感應器的狀態, 在那當下 Enter 鍵必須要被按下才行, 所以才會覺得有時候按 Enter 鍵好像沒什麼用...__

On the NXT’s screen you will see text that reads “Min Value:”. Point the light sensor towards a material or spot that represents what the light sensor should measure as ''dark''. Press the orange Enter button on the NXT.

Next you will see text that reads “Max Value:”. Point the light sensor towards a material or spot that represents the ''brightest'' location the sensor will encounter ''during the program''. Press the orange Enter button again. Calibration is complete.

===== Calibrating a sound sensor =====

Select the sound sensor and the port the sensor is connected to. Then click the Calibrate button. This will download a small program to the NXT and run it automatically.

On the NXT’s screen you will see text that reads “Min Value:”. __Position the sound sensor in the environment it will encounter when the program is running and where any background noise is ''measurable(不可忽視的)''.__ Press the orange Select button on the NXT.

Next you will see text that reads “Select Max:”. Measure or make the loudest sound you want to measure and press the Select button again. Calibration is complete.

==== Learning more ====

To learn more about the different sensors’ abilities and measurements please see the NXT Technology chapter in the printed User Guide that came with your MINDSTORMS NXT product.

__Note: ''Calibration values'' set using the Calibrate Sensors function can be overwritten by Calibration blocks in a program, and vice versa. '''The most recent calibration event will take precedence.''' The calibration will stay in effect until you deliberately(故意地) change the values or and reset them (see below).__

__Note: '''The calibration will work for the specific sensor no matter which port you connect it to after completing the calibration process.''' If you calibrate the light sensor on port 3, the calibration will still remain in effect if you later connect the light sensor to port 4.__

==== Restoring default calibration values ====

If you want to start over and restore the ''factory default'' calibration values, follow the instructions below.

First, turn on the NXT and connect it to your computer.

Select the Calibrate Sensors item from the Tools menu. The Calibrate Sensors dialog box will appear. If no NXT is connected, the dialog box will appear grayed out.

Select the sensor you want to restore to factory default settings and click Default.

=== Data Wire ===

''Data wires'' carry information between ''programming blocks''. Many blocks require that a data wire be ''attached'' if the blocks are to function at all. For example, the output from a Random block can only be sent out via a data wire.

==== Opening data hubs and creating data wires ====

__You create a data wire by “drawing it out” of a block’s ''data hub''. Nearly all of the programming blocks have data hubs and can support data wires.__

Open a block’s data hub by clicking the ''tab(附於帳簿邊緣等作索引的耳片)'' at the lower left edge of the block after it has been placed on the ''work area''.

{{attachment:datawires_01.png}} <<BR>> Image showing two blocks side-by-side: one with an unopened data hub (with the tab surrounded with a colored rectangle), the other block with an open data hub (with a mouse pointer shown ''drawing out'' a data wire)

__Note: '''Sometimes data hubs will not open ''completely'', leaving some ''plugs'' hidden. (展開 data hub 用完後, 可以再按一次 tab area 將沒有用到的部份收起來, 不過即便沒有用到任何 data plug, 也沒辦法回到 block 剛被拉出來的那個樣子了)''' Reveal all of a data hub’s plugs by clicking again on the ''tab area'' (as shown in the left image above). You can also close a data hub (or hide any unused plugs not connected to data wires) by clicking the tab area. This will help clean up your work area.__

===== Drawing out a data wire =====

The cursor will change shape (像是一個線捲) when it hovers over or is near a ''data plug''. If you then press the mouse button and drag to the ''right'', a data wire will “unroll(展開成卷的東西)” that can be connected to a plug on another block’s data hub.

上面 "drag" 的說法並不正確, 因為一般認知上的 drag 是按著滑鼠左鍵不動. 雖然那條線會自動調整位置, 但實驗結果都不太理想 (過程中會跳來跳去), 資料線一多時會交錯或重疊, 而造成資料流向難以判讀. 事實上這條線的路徑是可以手動控制的, 過程中有些地方要注意:

 * 只要在 data plug 上點一下左鍵即可, 然後移動指標 (過程中不要按住滑鼠左鍵), 善用它自動調整位置的功能, 然後在關鍵的轉折處按一下滑鼠左鍵, 就可以控制資料線的走向. (按滑鼠右鍵則是取消)
 * 點選中間的位置, 不用刻意點左側的 input plug 或右側的 output plug? 如果兩端的 data plug 都有 input/output plugs, 內部是如何決定資料的走向[?]
 * __'''在 input end 點一下滑鼠左鍵, 就可以將連接的資料線刪除; 因為同一個 output plug 不只可以拉出一條資料線, 在 output plug 再點一下滑鼠左鍵時, 會被認定是要拉出另一條資料線. (觀察現有的資料線或同一 data plug 的兩端, 把滑鼠移到兩個端點上面時, input end 會出現一般選取的指標, output end 則會出現 "線捲" 的圖示, 表示可以拉出線路)'''__
 * __游標靠近資料線時, 會出現 "線捲" 的圖示, 表示可以做線路上的分支; 游標移到資料線上面時, 會出現一般選取的指標, 表示可以拖拉調整線段的位置 '''(其實過程中讓系統自動調整後, 再手動微調的效果也不錯)'''__
 * __將 output plug 拉往 output plug 時 (例如 RANDOM 的 Number plug), 由於兩端都不是 input end, 實驗發現會造成線路無法刪除的窘境. 目前已知的方法就是移動 block, 所有連接的資料線自然會斷掉.__

===== Deleting a data wire =====

To delete a data wire that stretches(延伸) from ''left to right'' between two data plugs, click on the right plug.

==== Input and output ====

__Data wires carrying information to a block (i.e., carrying input) are connected to the plugs on the left side of its data hub. Data wires carrying information away from a block to another block (i.e., carrying output) are connected to the plugs on the right side. '''(因此習慣上稱位在 data hub 左側的 plug 為 ''input plug'', 位在右側的則稱之為 ''output plug''; 而 data wire 則有兩個端點, 從 input plug 這一端來看時, 我們稱之為 ''input data wrie'', 從 output plug 這一端來看時, 我們則稱之為 ''output data wire'')'''__

__這一章一直在強調 left 與 right; 實驗發現將兩個 block 的位置互換, 由右往左拉出 data wire 時, 最後都不會成功, '''這或許是 input/output plugs 分別位在 data hub 的兩側所形成的習慣吧. (看似一種限制, 但好處是寫出來的程式不會像是義大利麵條一樣)'''__

{{attachment:helpadd_02.png}} <<BR>> Image of data wires

 * [A] Input plug
 * [B] Output plug
 * [C] ''Number'' data wire (yellow)
 * [D] ''Logic'' data wire (green)
 * [E] ''Text'' data wire (orange)
 * [F] Broken data wire (gray)

==== Data wires carry specific types of data ====

Each data wire carries a specific ''type of data'' between blocks. (NXT-G 就只支援 Number, Logic, Text 三種型態) For example, if a data wire is dragged from a logic plug on a block’s data hub, it can only be connected to a logic plug on another block’s data hub.

==== Data wire colors ====

Data wires are identified with specific colors:

 * wires carrying number data are colored yellow
 * wires carrying logic (true/false) data are colored green
 * wires carrying text data are colored orange.

==== Broken data wires ====

If you try to connect a data wire to a plug of the wrong ''data type'', the data wire will be “broken” and colored gray. You will not be able to download your program if it contains broken data wires.

__If you click (實驗發現, 是 hover 才對) on a broken wire you can read why it is broken in the small help window at the lower right corner of the work area.__

{{attachment:datawires_02.png}} <<BR>> Image of the little help window.

==== Data must be within the possible range of the plug ====

__'''If an input data wire transmits a value outside the possible range of the plug it is connected to, the block will either ignore the value or change it to a value within its range. (無論是 ignore 或 change, 程式的行為都將變得不可預測; 實務上應該避免傳入合理範圍之外的值)''' For plugs that allow just a few input values (example: just 0, 1, or 2), the plug will ignore the input if a value arrives outside its range.__

For plugs that accept larger input ranges (example: 0 – 100), the plug will force any input outside its range to fit. For example, if a Move block’s Power plug receives an input value of 150, the block will change the input value to 100 (i.e., a number within the Power plug’s range).

==== Passing data from the input plug to the output plug ====

{{attachment:datawires_03.png}} <<BR>> Image of two input/output pairs of plugs – show the first with both logic input and output wires; show the second with only a gray output wire; show some indication that the first example is okay and the second if is not

__'''If an input plug has a corresponding output plug, the input data will ''pass through'' from the input plug to the output plug without being changed.''' In this case, you can only use the output plug if the input plug is connected to an input data wire; connecting an output data wire to such an output plug without a connected input data wire will cause the output data wire to be “broken” and colored gray.__

__實驗證實, 這種同時具有 input/output plugs 的 data plug, 從 output plug 拉出 output data wire 時, 對應的 input plug 一定要有 input data wire 拉進來才行; '''這種設計乍看之下沒什麼道理, 例如下圖所示, 為什麼在執行期沒辦法直接讀取 port 值? 那是因為 port 不是 sound sensor 的一個 "狀態", 而是 sound sensor "block" 的一個 "設定值" 而已 (轉換成程式碼來思考, 假設有一個方法可以用來讀取 sound level, 那麼 port 只不過是該方法的一個參數而已, 例如 `getSoundLevel(port)`)'''__

__'''在文件裡若有特別強調 "out" 時 (例如 Motor 的 "Direction out"), 表示該 data plug 只有 output plug, 否則都同時具有 input/output plugs.'''__

{{attachment:twoway-plug.png}}

==== Data Hub chart ====

The Help file for each programming block contains a chart that shows the different characteristics of the plugs on the block’s data hub. For example, the chart for the Keep Alive block looks like this:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_timetillsleep.png}} || Time until sleep || Number || 0 - 4294967296 || Time in milliseconds until the NXT goes to sleep || ||

=== Broken Data Wires ===

__While there is ''no way'' to improperly order blocks in a program, there are four ways to improperly connect them using data wires. Such connection errors create “broken” data wires that are colored gray. '''Programs containing broken data wires cannot be downloaded to the NXT. (無法完成編譯)'''__

The four possible data wire errors are:

 * Type mismatch
 * Cycle
 * Missing input
 * Too many inputs

==== Type mismatch ====

Each data wire carries a specific type of data between programming blocks. For example, if a data wire is dragged from a logic output plug on a block’s data hub, it will be carrying logic data. This data wire can only connect to a logic input plug on another block’s data hub.

For the same reason, number output plugs must be connected to number input plugs and text output plugs must be connected to text input plugs.

A ''type mismatch'' error occurs if you connect a data wire between plugs that handle different types of data, for example, connecting a logic output plug to a text input plug.

__Avoid this error be paying particular attention to the data types of the plugs you are attaching data wires to. (可以查閱線上手冊每一 programming block 的 "Data Hub chart" 區段, 瞭解每個 data plug 的 data type)__

'''Example:'''

Suppose you would like to display a number on your NXT’s screen.

In the first program shown below, a data wire is attempting to carry number data to a text input port. The data wire is “broken” and colored gray. This program is invalid and cannot be downloaded.

{{attachment:broken-wire_01.png}}

__In the corrected program, a Text Format block (found in the Advanced block palette) has been added to first convert the number data to text. Then the text output from the Text Format block is carried to the Display block’s text input plug. '''(藉此帶入 "強型態" 的概念)'''__ This program is valid and can be downloaded.

{{attachment:broken-wire_02.png}}

==== Cycle ====

__'''Given any set of blocks and wires, if you are able to follow a wire path that visits the same block twice, you have a ''cycle''.''' This will cause broken data wires and an invalid program.__

The solution is to remove one or more wires from the cycle.

'''Example:'''

Suppose you want to create a program that keeps doubling the duration value for a motor by reading the motor’s current duration, multiplying it by two, and then feeding it back to the motor’s input plug.

The program below will not work because the data wires create a cycle. You can see that the wire path visits each of these blocks twice.

{{attachment:broken-wire_03.png}}

__The program below solves the problem by using a number variable to send the doubled duration back in the loop.__

{{attachment:broken-wire_03a.png}}

==== Missing input ====

A data wire without a data source cannot function; it has no data to carry and will be marked as broken.

__'''For instance, on a data hub that has both input and output plugs for a certain ''property'', the output plug will only work if another data wire is also connected to the input plug providing the output plug with a data source.'''__

'''Example:'''

Suppose you want to pass data through another block’s data hub.

In the program below, the broken data wire (in gray) has no data to carry because nothing is “passed through” from the input plug. This program is invalid and cannot be downloaded.

{{attachment:broken-wire_04.png}}

In the corrected program below, an input data wire has been connected to the input plug. Number data from the Sound Sensor block can now be ''passed through'' the Math block to the Text Convert block.

{{attachment:broken-wire_05.png}}

==== Too many inputs ====

More than one data wire connected to the same input plug will cause broken data wires and an invalid program.

The solution to this problem is to delete or move broken data wires so that each input plug is connected to only one output plug.

The illustrations below show an invalid program with broken data wires and then a corrected program.

{{attachment:broken-wire_06.png}}

{{attachment:broken-wire_07.png}}

==== Deleting a data wire ====

To delete a data wire that stretches from left to right between two data plugs, click on the right plug.

=== Download to Multiple NXTs ===

This function allows you to download one or more programs to multiple NXTs. This is especially useful if you need to load a number of NXTs with the same program(s) for a competition or ''classroom assignment?''.

__The Download to Multiple NXTs feature is only available in the educational version of the LEGO MINDSTORMS NXT Software.__

You can download a number of programs to an NXT until this memory is full. An average program is 11 kilobytes in size but this varies. When the memory is full, you can select programs to delete in order to make space. See the Help file “Managing files and memory on the NXT” for details.

Note: Before using this function, make sure that all of the programs you would like to download are open in the software. When you open more than one program at the same time, the program names appear as tabs along the top of the work area (as shown in the graphic below). Also, make sure your bricks are "available" by pressing Scan in the NXT window. Otherwise they will not appear in the Download to Multiple NXTs window.

{{attachment:multipleNXTs_01.png}} <<BR>> Image – show at least three program tabs in a row and a bit of surrounding interface

When the programs that you would like to download are open, launch the function by choosing Download to Multiple NXTs... in the Tools menu. This will open the Download to Multiple NXTs dialog box, shown below.

{{attachment:multipleNXTs_02.png}} <<BR>> Image of Download to Multiple NXTs dialog box with callouts(插圖的編號) 1 & 2 marked

 1. Choose NXTs lists all of the NXTs that are currently available.
 2. Choose Programs lists all of the programs that are currently open.

Note: If you do not see an NXT in the list, close the Download to Multiple NXTs tool and open the NXT window (accessible from the controller). Make sure that all the NXTs have been configured in this window before launching the Download to Multiple NXTs tool.

==== Downloading to Multiple NXTs ====

First, choose the NXTs to which you would like to download by clicking in the box(es) to the left of the NXT names. You can select all available NXTs by clicking the Select All button below the list. Clicking the Deselect All button deselects all of the NXTs.

Then choose the programs you would like to download by clicking the boxes to the left of the program names.

When your selection is complete, click the Download button below the program list. This begins the download process. The progress columns display the download progress.

During the compilation process there are four status messages that can be displayed in the Programs list box:

 * Skipped - if you did not select that program file
 * Compiling - if the file is currently compiling
 * Done - when that program has been compiled
 * Error - if a problem is encountered while compiling the program

Once all of the selected programs have been compiled, the download process begins. During download, there are four status messages that can be displayed in the NXT list box:

 * Skipped - if you did not select that NXT
 * Downloading - if it is currently downloading to the NXT
 * Done - when downloading all programs to that NXT is complete
 * Error - if a problem is encountered during the download process

Click the Close button when you are finished downloading programs to multiple NXTs.

__Note: To share programs between computers (allowing the programs to be edited on a different computer), you should exchange the `.rbt` file of the program by using email or a USB drive.__

=== Managing Files and Memory on the NXT ===

It is sometimes necessary to manage files and memory on the NXT. You can do this by accessing the Memory tab of the NXT window that is launched from the upper left button of the ''controller''.

{{attachment:ManagingMemory_01.png}} <<BR>> Image of the controller with the NXT window button highlighted

__The memory tab of the NXT window provides a graphical overview of memory usage on your NXT. From here you can also send programs, sounds, graphics and other files to your NXT from a PC, and copy and delete files that are already on your NXT. '''(以 NXT 的立場出發, upload 指的是 PC 往 NXT 的方向, download 指的則是 NXT 往 PC 的方向; 實驗發現 upload/download 遇到檔案已存在時都不會做提示, 因此操作上要小心)'''__

{{attachment:ManagingMemory_02.png}} <<BR>> Image of the controller with the NXT window button highlighted

 1. A graphical overview of used and available memory.
 2. __The different ''file categories'' (programs, sounds, graphics, other...) that take up the NXT’s memory. Clicking on a category name will display these types of files in the list. '''(這裡的 "file category", 其實是由檔案的 "副檔名" 所營造出來的, 而非檔案系統下的不同資料夾; 實驗發現, 從 Sound 分類下載 "MyFile.txt" 後, 該檔案還是只出現在 Other 分類)'''__
 3. A list of files in the currently selected category.
 4. Delete. This button deletes any selected files from the NXT.
 5. Download. This button will download files from your PC to the NXT. (開窗選取 `.rcd`, `.rso`, `.ric` 或 `.rxe` 檔)
 6. Upload. This button will copy any selected files from the NXT to your PC.
 7. Delete all ''User Files'' (按鈕上標示著 "Delete All"). This button deletes all user files and cleans up the NXT’s memory.
 8. __Show System Files. Checking this box will reveal all ''factory-installed'' files on the NXT.__

==== The NXT’s memory ====

__'''Each NXT has an available memory of about 130.7 kilobytes. (在 Firmware v1.05 下, 這個數字相當接近將包括系統在內的所有檔案刪除後的空間 - 121.5 KB)''' Some of this memory is used to store example programs, graphics and sound files that are pre-loaded on the NXT device when you first get it. This leaves(剩下) about 56 kilobytes for the files you create and download. (firmware v1.05 之下, 可用的記憶體約 97.2 KB)__

==== Running out of memory ====

If you run out of memory you can delete some or all of the files on your NXT. To do this, examine the memory overview graphic to the left (1) and identify which types of files take up most memory. Click that category name (2) and its files will be displayed in the list. Select the files you don’t need in the list and click the Delete button.

==== Deleting all of your files ====

You can erase all of your created files and clean up the NXT’s memory by clicking the Delete all User Files button. This will delete all of the files you have ever sent to the NXT and re-organize the memory to leave the maximum amount free for new files. Doing this will not delete any of the system files that were pre-loaded in the NXT at the factory.

__Note: '''On rare occasions you can get an out-of-memory error message even when the graphical memory overview (1) indicates there is free space available. This is caused by memory “fragmentation.” (一般使用者可能很難理解這個錯誤; 還好要修正這個問題只要將所有檔案刪除即可)''' Fix this problem by using the Delete All User Files button but remember to back up any of your essential files before proceeding.__

You can also delete files using the icons on the NXT itself. For details, see the NXT Technology section in the printed User Guide.

==== Freeing up as much memory as possible ====

__'''If deleting your user files does not free up enough memory, you can also delete the demo and example files that came pre-loaded in the NXT.''' These files are referred to as system files and take up around 62 kilobytes. The system files include the start-up and other sounds as well as the demo and Try Me programs.__

__You can always restore the NXT device’s memory back to factory default condition (with all of the system files) by ''restoring the firmware''. See “Restoring an NXT’s memory...” below.__

To delete system files, check the Show System Files box (8). Then select a file category (2) and choose the system files you want to remove (3). Click Delete for each file you want to erase from memory.

__Note: By deleting system files you will free up memory but at the same time also remove features from the NXT. However, you cannot “break” the NXT by deleting system files. '''(實驗確認, 勾選 "Show System Files" 後, 再按下 Delete All 會連同系統內建的音效檔、範例程式等一併刪除, 釋出更大的空間, 但 NXT 系統還是可以使用, 只是沒有聲音而已)'''__

Here is a list of the system files and the features they enable:

|| Category || File name || Description ||
||<|5> Other || `NVConfig.sys` || __Settings like sleep time and volume are stored in this file. If you delete this file, a new one will be created automatically.__ ||
|| `Try-*.rtm` || Any system file starting with “Try-“ is a Try Me program for a specific sensor or output. Deleting each of these will remove the individual Try Me programs from the Try Me NXT menu. ||
|| `RPGreader.sys` || __This program lets you run ''NXT programs'' (programs that are created on the NXT itself using the NXT Program icon). Deleting this file will remove the ability to run programs made on the NXT. Programs created and downloaded from a PC will still work.__ ||
|| `*.tmp` || Any file ending with “.tmp” is a temporary file. Temporary files can always be deleted. ||
|| `*.bak` || Any file ending with “.bak” is a temporary file. Temporary files can always be deleted. ||
||<|2> Graphics || `faceopen.ric` || Picture of LEGO http://en.wikipedia.org/wiki/Minifigure[minifig] head (with mouth open; 小人頭) used in the Try Me programs. ||
|| `faceclosed.ric` || Picture of LEGO minifig head (with mouth closed) used in the Try Me programs. ||
||<|4> Sounds || `Woops.rso` || Sound file used in the Try Me programs. Deleting this file will remove the sound from the programs it is used in. The programs will still work without the sound. ||
|| `! Startup.rso` || Sound file played when the NXT starts up. Deleting this file will remove the sound at start up. ||
|| `! Click.rso` || Sound file played when a button is pressed on the NXT. Deleting this file will remove the sound when a button is pressed on the NXT. ||
|| `! Attention.rso` || Sound file played when the NXT issues a warning. Deleting this file will remove the sound when a warning is issued. ||
|| Programs || `Demo.rxe` || Demo program for the Quick Start model. Deleting this will remove the Demo program from the NXT. ||

==== Restoring an NXT’s memory back to factory default condition ====

__You can restore an NXT’s memory back to factory default condition by ''re-installing'' the NXT firmware.__ For details on this operation, see the Help topic, “Updating the NXT's Firmware.” Be aware that re-installing the NXT firmware will delete all files in the NXT’s memory -- make sure to make a back up of any personal files you want to keep before proceeding.

==== Copying and backing up files stored on the NXT ====

To make a back up copy of your personal files or to share files stored on the NXT with friends, you should copy the files off the NXT to your PC.

To do this, first select the file category (2) for the files you would like to back up or share. Select the desired files in the list (3) and click Upload (7). Finally, select the folder where the files will be saved on your PC and click OK.

==== Sending a file back to the NXT ====

To send a file back to the NXT, click the Download (5) button. Select the file you want to copy from your PC and click OK.

=== Profiles ===

__You can create a personal profile that will save all of your programs and My Blocks in one folder. '''This is especially useful if you use a computer that is shared by many people. (適合教學上使用; 為每一個學生建立一個 profile, 可以將範例程式事先複製到每個學生的資料夾下, 也避免修改到其他學生的檔案)'''__ When you use a personal profile, your programs and blocks are not mixed in with everyone else’s.

==== Creating a profile ====

{{attachment:profile_01.png}} <<BR>> Image of open Edit menu showing Manage Profiles item

To create a profile, first choose the Manage Profiles item from the Edit menu. This will open the Manage Profiles dialog box.

{{attachment:profile_02.png}} <<BR>> Image of Manage Profiles dialog box

Click the Create button and type in your name (or the profile name that you would like your files to be saved under). Click the Close button.

__Now whenever you are ready to program using the MINDSTORMS NXT software, choose your preferred profile from the User Profile pull-down menu in the Toolbar. When you go to open or save a program, the selected profile folder will be visible as the ''default folder''.__

{{attachment:profile_03.png}} <<BR>> Image of the Toolbar showing the User Profile pull-down

==== Profile and program files locations ====

__The default folder for your profiles is `..\My Documents\LEGO Creations\MINDSTORMS Projects\profiles\[Your profile name]`.__

Each profile folder contains the program files saved when using that specific profile. Each profile folder has a `Blocks` sub folder that contains the custom blocks (including My Blocks) for the particular profile.

__The profile folder will also contain a file call `settings.ini`. This file contains the recorded preferences for that specific profile. It includes details on the NXT devices associated with the profile and the most recent programs worked on while signed in under the profile. '''The "data directory" is the default location for opening/saving ''RBT files''. It defaults to the profile directory, but can feasibly(可能) be changed (to a network drive, etc.).''' "Known bricks" is a registry of NXTs you have seen or been paired with (via Bluetooth).__

`setttings.ini` 的內容如下:

 {{{
[LEGO Mindstorms Software]
Data Directory="/C/Documents and Settings/User/My Documents/LEGO Creations/MINDSTORMS Projects/Profiles/Default"
Recent Files="C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\Untitled-3.rbt;C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\Blocks\\My Blocks\\Note.rbt;C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\LightReading.rbt;C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\TriBot.rbt;C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\bee.rbt;C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\BeeBee.rbt;C:\\Documents and Settings\\User\\My Documents\\LEGO Creations\\MINDSTORMS Projects\\Profiles\\Default\\Sound.rbt"
Known Bricks=USB0::0x0694::0x0002::001653057855::RAW+00:16:53:05:78:55+Robbie+1+0;BTH::Judy::00:16:53:05:78:55::7+00:16:53:05:78:55+Robbie+0+1
Active Brick Index=0
Startup Palette=-1
Last Palette=1
Academy Startup=-1
Academy State=0
Help Startup=-1
Last Help Tab=1
Resize Editor=FALSE
Editor Location=-350;139;926;867
Enable Advanced Features=FALSE <-- 改為 TRUE 之後並沒有什麼不同
 }}}

==== Renaming or deleting a profile ====

To rename or delete a profile, choose the Manage Profiles item from the Edit menu and select the profile name you would like to rename or delete. Then choose either the Rename or Delete button. If you are renaming a profile, you will be able to type a new name for the profile.

When finished, click the Close button.

=== Sequence Beam ===

__'''The ''sequence beam'' controls the ''flow'' of your program. (這裡 "sequence" 的用法, 完全符合 [[Flowchart|flowchart]] 中 "sequence of some activities" 的說法) It indicates the ''sequence'' in which programming blocks will run. Blocks ''connected'' to the sequence beam can be downloaded to the NXT. Other blocks in the work area that are not connected to the sequence beam will not be downloaded. (沒有放在 main beam 上面的 blocks, 還是可以透過 "Download and run selected" 的功能執行 - 下載到 NXT 的檔名就是 "`Selection`")'''__

在 beam 上移動 blocks 時有一些技巧要注意:

 * __'''在實務上, 可以將某一段程式或整個分支選取起來, 拖動之後就會跟原來的 beam 脫離 (由於是整段移動, 所以其間的 data wires 不會斷掉), 這些脫離 main beam 的 blocks 就會變成灰色 (不會被編譯), 需要的時候可以再整個拼接回去即可; 這個特性可以應用在開發時期測試之用.'''__
 * __移動 block 會造成已經連接的資料線斷掉, 這一點很困擾人; '''目前已知選取多個相串連的 block 一起移動時, 其間的資料線不會斷掉, 但選取範圍兩側的連線還是會斷掉.'''__
 * __移動 beam 上面最得後一個 block 時, 原先配置好的 beam 會縮回去 (如果該 beam 沒有其他 block 了, 整個 beam 會不見); '''要避開這個問題, 可以在最後一個 block 後面暫時加上一個沒有用的 block, 待移動完最後一個 block 之後再將它刪除即可.'''__

{{attachment:seq-beam_01.png}} <<BR>> Image of the ''starting point'' plus a move block and a sound block on a sequence beam

__'''You can use the starting point to create additional sequence beams that will allow your program to run ''simultaneous tasks''.''' For example, you might have the ''main sequence beam'' in your program controlling a robot’s forward motion but have a second sequence beam controlling a robotic arm that sits on top of the robot.__

__'''上述 "simultaneous tasks" 指的正是 multi-threading 多執行緒的概念.''' 下圖的迴圈會在使用者 "按住" Enter 鍵時離開, 然後顯示秒數在 LCD 上, 等按下右鍵之後程式就結束了. 實驗發現, 程式顯示完秒數之後, 按右鍵並無法結束程式, 因為另一個執行緒還在等待 Touch 被按下的事件, 這與  Java 中 non-daemon thread 的反應很像, 此時只要按下 Touch Sensor, 該執行緒就會結束, 然後整個程式就結束了.__

{{attachment:mutilthreading.png}}

{{attachment:seq-beam_02.png}} <<BR>> Image of a program with a main sequence beam and a ''parallel'' sequence beam coming out of the starting point perpendicularly(垂直地) and then turning to run parallel

Create a parallel sequence beam by moving the mouse pointer over the starting point (or over the ''wire stub?''), and pressing and holding your mouse button while you move the mouse upwards or downwards. This will draw out a sequence beam that can be connected to programming blocks. __'''When you download and run the program, the blocks on both sequence beams will ''run in parallel''. You can use data wires to have the blocks on both sequence beams communicate with each other. (可以在執行緒之間交換資料; 這會對執行順序造成什麼影響? 例如一個分支在等另一個分支所產生的輸入時[?])'''__

{{attachment:seq-beam_03.png}} <<BR>> Image of the starting point with a new sequence beam being drawn upwards

__You can also start a new sequence beam later in your program (i.e., not from the starting point). '''Do this by holding down the Shift key and moving your mouse pointer straight up or down from a position on the main sequence beam. (程式來到分叉點的時候, 才會開始執行衍生出來的分支)'''__

{{attachment:seq-beam_04.png}} <<BR>> Image showing a mouse pointer, moving straight up or down, “drawing out” a new sequence beam from the ''master'' sequence beam

=== Simple Text Fields ===

If a text field is marked as below, it supports only ''simple text''.

{{attachment:NXT-Simple-Text_01.png}} <<BR>> Simple Text field

__'''If a text field is not marked, it supports full text including accented and Asian characters. (可以輸入中文, 但不是 unicode 的支援, 因此在英文 OS 下要將 chinese/taiwan 的 locale 執行才可以; 另外刪除中文字時要小心, 字可能會被截一半...)'''__

__You should limit your text to the characters listed below to avoid having them display as ''blanks'' on the NXT device.__

==== What is Simple Text? ====

The supported characters for the ''NXT display'' are the capital and lower letters A-Z, the numerals 0-9, and the punctuation(標點符號) and symbols shown below.

{{attachment:NXT-Simple-Text_02.png}} <<BR>> Supported characters for the NXT display

__Simple Text is used for the brick name, My Blocks, file names (including programs and the files created with the File Access Block and Record/Play Block), and displaying text on the NXT device using the Display Block. '''If simple text fields contain other than simple characters or symbols, they will display a blank instead. The NXT does ''preserve'' the characters, and they will display correctly on the connected computer, (單純只是無法顯示而已, 資料本身還是完整的)''' but to avoid confusion caused by lots of blanks, you probably want to use simple characters for the marked text fields.__

__All places mentioned above require that you use “Simple Text”. They won’t let you type in other characters. '''The exceptions are the program filename and the text in the Display Block.'''__

__'''輸入檔名時, 雖然畫面上提示 Simple Text, 但有些字元還是不能輸入, 例如 "`\/:*?"<>|`" 等 (在電腦上儲存程式時, 檔名的長度與可使用的字元是受限於電腦的檔案系統). 而且(主檔名)長度限制在 15 個字 - 例如程式 "01234567890123456789.rbt" 編譯下載到 NXT 之後, 會變成 "`012345678901234.rxe`"'''__

=== Starting Point ===

This is the starting point for all programs. Blocks connected to the starting point will be downloaded to the NXT when you use the controller to hit Download, Download and run, or Download and run Selected.

{{attachment:starting-point_01.png}} <<BR>> Image of the Starting Point with Move block attached

__If you click the starting point, you can type a note in the configuration panel that will be saved with the program.__

{{attachment:starting-point_02.png}} <<BR>> Image of note field in the configuration panel

=== Updating the NXT’s Firmware ===

__Firmware is software that is ''embedded'' in the NXT. Without its firmware, the NXT wouldn’t be able to control motors, take input from sensors, or basically work at all.__

Occasionally, the LEGO Group may release new versions of the firmware that add enhanced functionality or fix discovered software bugs. By updating your NXT’s firmware to the most recent version, you can take advantage of the latest technology and improve your NXT’s performance and reliability.

Updating the firmware is easy to do. First, choose Update NXT Firmware... in the Tools menu. This will launch the Update NXT Firmware dialog box as shown below.

{{attachment:firmware_01.png}} <<BR>> Image of Update NXT Firmware dialog box

First make sure to turn on and connect your NXT.

If you are online you can check if new firmware updates are available by pressing the Check Online Updates button. This will cause the LEGO MINDSTORMS NXT software to scan MINDSTORMS.com for the most recent version of the firmware.

Select the most recent firmware version and make sure to record where the retrieved firmware will be saved. We recommend these locations:

 * For Macintosh: `Macintosh HD:Applications:LEGO MINDSTORMS NXT:engine:Firmware`
 * For Windows: `C:\Program Files\LEGO Software\LEGO MINDSTORMS EDU NXT\engine\Firmware`

When the retrieval is complete (after 1 to 3 minutes depending on your Internet connection speed), the new firmware will be ready to install. If you retrieved the firmware file to the above path, you can simply select the file from the list and press Download. The progress bar at the bottom of the Update NXT Firmware window will show you how the download to your NXT is proceeding.

If you retrieved the firmware file to a different location, click the Browse button to browse to the folder where you saved the firmware. You can then begin to download the saved firmware to your NXT.

==== Re-installing the firmware that shipped with your product ====

If your NXT stops working for some reason it may help to re-install the firmware that shipped with your product.

You will need to ''reset'' your NXT before proceeding with re-installation. See “Troubleshooting” in the printed User Guide for help on resetting your NXT.

When you have finishing resetting your NXT, just follow the instructions above to re-install the firmware that shipped with your product.

__Note: Make sure to check your NXT’s batteries before reinstalling any firmware. Any problems may simply be due to worn-down(疲乏不堪的) batteries.__

== Action Blocks ==

=== Display Block ===

Use this block to display an image, write some text, or draw a shape on the NXT’s display screen.

__By positioning several Display blocks ''in a row(連續; 不做清除的動作而言)'' you can create more complex drawings by adding additional images, text and shapes with each new Display block.__

If you want to erase the contents of the screen before beginning, check the “Clear” checkbox.

If you would like to return to the default LEGO MINDSTORMS icon, select Reset in the pull-down menu.

__The screen measures 100 pixels wide by 64 pixels high.__

{{attachment:AB_display_01.png}} <<BR>> Image of Display block, default settings, draw a box around the closed data hub and identify as item 2

 1. This icon shows whether the block is set to display an image, some text, or a drawing; or whether it will just reset the display to the default icon.
 
 2. You can change values dynamically by connecting data wires to this block’s data hub.

==== Configuring the Display Block: ====

{{attachment:AB_display_02.png}} <<BR>> Image of the configuration pane for the Display block set to display an image

 1. Use the pull-down menu to choose whether you want to display an image, some text, or your own drawing; or whether you just want to reset the display.

 2. To erase the contents of the NXT’s screen, check the “Clear” checkbox.

If you choose to display an image (as in the configuration panel above), you’ll be able to set the following additional ''properties'':

 3. The File property will you let select the image to display. Click on each name to see a preview. __Images are stored in the Image Files folder of the LEGO MINDSTORMS software on your hard drive. '''(圖檔來源位置是在 NXT software 安裝位置下 `..\engine\Pictures` 的子目錄裡, 副檔名都是 `.ric`; 可以用 http://ric.dreier-privat.de/Docu/index.htm[nxtRICeditV2] 程式製作 RIC 檔, 檔案格式可參考 http://nxtasy.org/2007/02/20/ric-revealed/[RIC Revealed])'''__

 4. __Use your mouse to move an image, some text, or a drawing around the preview screen to position it. The X and Y input boxes let you precisely position the image. Typing zeros into both boxes will set the image against the left and bottom edges of the screen. '''(也就是說 100 x 64 LCD 座標系統的原點 [0,0] 在左下方; 實驗發現拖拉文字或圖形可以讓 X 或 Y 出現負值, 但手動修改 X 或 Y 時, 如果輸入負值都會被歸零)'''__

{{attachment:AB_display_03.png}} <<BR>> Image of the configuration pane for the Display block set to display some text

If you choose to display some text (as in the configuration panel above), you’ll be able to set the following additional properties:

 5. __The Text property will allow you to enter the text to be displayed on screen. '''(單行超出螢幕範圍的部份也會被截掉; 不支援多行文字, 事實上在 NXT-G 裡的 Text 型態指的就是單行文字而已)'''__

 6. __'''Use the pull-down menu to choose the ''line number'' (內建字體大小 W/H = 6x8 等寬字, 因此 64/8 = 8 行; 行數是由上往下算, 跟 Y 坐標的算法剛好相反; 調整行數時, X/Y 的數值也會跟著改變, 指向字串輸出位置的 "左下角", 因此第 8 行的 Y 為 0, 第 7 行的 Y 為 8, 以此類推...)''' that you would like your text displayed on or use the X and Y input boxes to set a precise starting location for the text.__ Typing zeros into both boxes will start the text at the bottom edge of the screen against the left edge.

{{attachment:AB_display_04.png}} <<BR>> Image of the configuration pane for the Display block set to display a drawing

If you choose to draw a shape (as in the configuration panel above), you’ll be able to set the following additional properties: (複雜的圖形, 建議還是以 image 的方式輸出)

 7. The Type property will allow you to set the shape that you will draw. The choices include drawing a dot, a line and a circle.

 8. If you choose to draw a dot (選項是 "Point"), the X and Y input boxes determine the location of the dot on the screen. Typing zeros into both boxes would position the dot at the bottom edge of the screen against the left edge.

    .If you choose to draw a line, a second set of input boxes (第二組坐標) will appear so that you can set the end points of the line. The starting point of the line should be defined in the upper x and y coordinate boxes and the end point in the lower x and y coordinate boxes.

    .If you choose to draw a circle, an additional box will appear identified as the radius(半徑) of the circle. Type the coordinates that define the center location of the circle into the first two coordinate boxes and the radius of the circle into the radius box.

    .{{attachment:circle_radius.png}} <<BR>> 上圖左邊為半徑 1 的圓, 右邊則為半徑為 2 的圓; 圓心固定佔去一個點的位置, 再往外側推 n 個點 (包含圓周的線段)

==== Configuring the Display block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Display block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_action.png}} || Action || Number || 0 - 5  || 0 = Image, 1 = Text, 2 = Point, 3 = Line, 4 = Circle, 5 = Restore System Screen || ||
|| {{attachment:helpadd_clear.png}} || Clear || Logic || True/False || True = Clear the screen <<BR>> False = Don't clear the screen || ||
|| {{attachment:helpadd_filename.png}} || Filename || Text || ''15 character maximum'' || Filename of image file || Action is not Image ||
|| {{attachment:helpadd_text.png}} || Text || Text || Text || Action is not Text || ||
|| {{attachment:helpadd_x.png}} || X || Number || 0 - 99 || __X coordinate (做為 Point 的位置, Image 與 Text 的左下角, Line 的起點, Circle 的圓心)__ || ||
|| {{attachment:helpadd_y.png}} || Y || Number || 0 - 63 || Y coordinate || ||
|| {{attachment:helpadd__x.png}} || End point X || Number || 0 - 99 || End X coordinate (Line only) || Action is not Line ||
|| {{attachment:helpadd__y.png}} || End point Y || Number || 0 - 63 || End Y coordinate (Line only) || Action is not Line ||
|| {{attachment:helpadd_radius.png}} || Radius || Number || 0 - 120 || Radius (Circle only) || Action is not Circle ||

=== Motor Block ===

__'''This block allows for precise control of ''one'' motor’s speed. (與 Move 最大的不同, 就是 Motor 只能控制一個伺服馬達; 兩者用途不同, 前者用在控制兩個輪子的協調, 使能直線前進後退、操舵轉向等, 後者多應用在單一個伺服馬達的細部控制)''' You can “ramp up”(慢慢加速) to a set speed or “ramp down”(慢慢減速) to a stop. By deselecting “Wait for Completion,” your program can move on to the next block once the Motor block has started a motor.__

{{attachment:motor_01.png}} <<BR>> Image of block, data hub closed, with an orange rectangle drawn around data hub tab and identified as number 5

 1. The letter at the top right corner of the block shows which NXT port is set to control a motor.
 2. This icon shows which direction the motor will go.
 3. This icon shows the ''power level''.
 4. This icon shows whether you have set the Duration property to unlimited, degrees, rotations, or seconds.
 5. You can change values dynamically by connecting data wires to this block’s data hub.

{{attachment:motor_02.png}} <<BR>> Image of block showing stop icon

 1. This icon shows that the Direction property is set to “stop”. This setting will stop the indicated motor.

==== Configuring the Motor Block ====

{{attachment:motor_03.png}} <<BR>> Image of configuration panel

 1. Select the motor you’d like to control.

 2. Choose whether the motor should go forwards, go backwards, or stop.

 3. __You can precisely control the ''acceleration'' of the motor by selecting “Ramp Up” or “Ramp Down.” A motor set to “Ramp Up” will ''slowly increase'' its speed until it reaches specified power. A motor set to “Ramp Down” will ''slowly decrease'' its speed until it ''reaches zero power''. A motor set to “Constant” will reach full power immediately and will stop quickly by either coasting or braking (depending on the setting).__

    .__上面 "reaches specified power" 與 "reaches zero power" 的說法, 其實都不完全正確; 實驗發現, '''如果原來的 power 底於 ramp down 的要求時, 或者高於 ramp up 的要求時, 都會維持原來的 power.''' 有一個狀況要特別注意, 如果原來的 power 是 0, 即使要求 ramp down 到特定 power, 結果還是 0... 馬達一動也不動, 永遠無法轉動到要求的角度, 程式就好像是進入無窮的等待一樣...__

 4. This slider and the editable input box will let you set the power level [0-100%].

 5. __Select this checkbox if you’d like to turn on ''power control''. '''Power control will attempt to compensate for any resistance(阻力) or slippage(滑動) that the motor encounters. It will increase power to a maximum of 100% to maintain the same rotation amount per second. (儘可能維持住當初設定的 power level 給使用者 speed 的 "感覺")'''__

    .__'''實驗發現, 伺服馬達的力氣真的很大, 沒有勾選 power control 前勉強還壓制得住, 勾選 power control 後則完全壓制不住; 因此操作馬達要特別小心, 避免被機械結構夾傷手'''__

 6. Using the Duration pull-down menu, set the motor to run for an unlimited interval or for a set number of rotations, degrees, or seconds. (在單位之間做切換時, 系統會自動換算; 善用這個特性, 可以用 rotation 做設定之後, 再轉到 degree 做微調)

 7. With “Wait for completion” selected, the motor will finish its action completely before allowing the program to move on. If you de-select “Wait for completion,” other blocks in the program can proceed while your motor completes its action. For example, a Sound block placed after the Motor block could start playing a sound file while the motor continues its action.

 8. __Choose whether the motor will brake or coast(慣性滑行; 自然停止而言) after finishing its action. '''Set the motor to brake if you want it to stop precisely at an exact position and (attempt to) hold that position. Braking does require additional battery power because the motor does ''extra work'' to maintain the position. Coast is a good choice if this block is followed by another block controlling the same motor. (否則動作會不流暢)'''__

    .__'''實驗發現, 上面的 "extra work" 是在轉動特定角度之後, 由於慣性的關係需要做煞車的動作, 假設讓馬達停止需要多轉 10 度, 仔細觀察馬達的轉動, 你會發現最後有一個 "倒車" 的動作; 由於它的運作方式是 "走過頭, 再倒回來", 因此若真的要做定點的控制 (例如機器手臂), 由於慣性是無法克服的, 因此只能透過 ramp down 來提前做降速的動作 (例如本來要高度轉動 10 圈, 可能就要拆成 8 圈高速轉動, 外加 2 圈 ramp down 到 0; 如果前幾圈也拆出來做 ramp up, 動作會更流暢)'''__

 9. __The ''feedback boxes'' will count how many degrees or full rotations your motor turns. Press the reset button to return the values to zero. (To receive feedback, make sure that the motor is connected to the chosen port and that communication has been established with the NXT; 方便實際量測要轉動多少角度, 才能完成特定動作)__

    .Note: The feedback value will be displayed in black-colored text if the motor is running in the forward (positive) direction and in red-colored text if it is running backwards.

==== Motor versus Robot Direction ====

When you set a Move or Motor blocks' direction, you are specifying the direction the motor will spin(轉動). __This may be different than the direction your robot actually moves. Depending on how you build your ''robotic invention'', setting the motors to go forwards may cause your creation to move backwards.__ The image below shows a motor spinning in the default, forwards direction.

{{attachment:Motor_direction.png}} <<BR>> Image of a Mindstorms servo motor with forwards (clockwise) direction indicated with arrows

__'''一個幫助記憶的方式: 把馬達平放 (跟上圖一樣, 此時LEGO 的字樣剛好巔倒; 很像一台車頭很長的車子), 往橘色轉軸的方向就是 "前方" (無論往右還是往左). 以這個角度來看, NXT-G 裡 forward 剛好對應到 "往前轉動", backward 則剛好對應到 "往後轉動"''' (在 TriBot 裡就是以這個方式架構馬達, 因此在寫程式的時候很直覺, 要讓車子往前就是 forward, 往後就是 backward, 甚至特地把 B 埠連接到右邊的輪子, C 埠連接到左邊的輪子, 從駕駛的立場要左右轉彎時, 只要拖動 Move 的 steering 滑桿往左或往右即可, 相當直覺...)__

==== Configuring the Motor block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Motor block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_port.png}} || Port || Number || 1 - 3 || 1 = A, 2 = B, 3 = C || ||
|| {{attachment:helpadd_direction.png}} || Direction || Logic || True/False || True = Forwards, False = Backwards || ||
|| {{attachment:helpadd_action.png}} || Action || Number || 0 - 2 || 0 = Constant, 1 = Ramp Up, 2 = Ramp Down || Duration Type = Unlimited or Seconds ||
|| {{attachment:helpadd_power.png}} || Power || Number || 0 - 100 || || ||
|| {{attachment:helpadd_controlmotorpower.png}} || Control Motor Power || Logic || True/False || || ||
|| {{attachment:helpadd_motor_duration.png}} || Duration || Number || 0 - 2147483647 || __Depends on Duration Type: Degrees/Rotations = Degrees (不能直接指定圈數, 必須要換算成角度), Seconds = Seconds__ || Duration Type = Unlimited ||
|| {{attachment:helpadd_waitforcompletion.png}} || Wait for Completion || Logic || True/False || __Duration Type = Unlimited (always False), Seconds (always True)__ ||
|| {{attachment:helpadd_nextaction.png}} || Next Action || Logic || True/False || True = Brake, False = Coast || Duration Type = Unlimited, or Wait for Completion = False ||
|| {{attachment:helpadd_directionout.png}} || Direction out || Logic || True/False || Direction the motor moved during the block’s execution. <<BR>> True = Forwards <<BR>> False = Backwards || ||
|| {{attachment:helpadd_degreesout.png}} || Degrees out || Number || 0 - 2147483647 || __How many degrees the motor moved during the block's execution (實際轉動的角度)__ || ||

=== Move Block ===

{{attachment:d010.00.png}} __Use this block to set your robot to go forwards or backwards in a straight line or to turn by following a curve.__ Define how far your robot will go by using the Duration property.

{{attachment:move_01.png}} <<BR>> Image of block, data hub closed

 1. __The letters at the top right corner of the block show which of your NXT’s ports will be controlled. '''(預設選取 B 跟 C, 因此習慣上二輪機器人會將左邊的馬達接到 C, 右邊的馬達接到 B)'''__
 2. This icon shows which direction your robot will go. (如果有做 steering 的控制, 就會出轉彎的箭頭)
 3. __This icon shows the ''power level''. '''(注意這裡設定的是 power 而非 speed; 可以想像是車子的油門要踩多深, 產生速度則會受車子的重量、路面的坡度、輪子對路面的抓地力等影響)''' Your robot’s speed may also be affected by other conditions, like the surface it is moving over or whether it is moving up or down a slope(斜坡).__
 4. This icon shows whether you have set the Duration property to unlimited, degrees, rotations, or seconds.

{{attachment:move_02.png}} <<BR>> Image of block showing stop icon

 1. This icon shows that the Direction property is set to “stop”. This setting will stop all motors.

==== Configuring the Move Block ====

{{attachment:move_03.png}} <<BR>> Image of configuration panel

 1. Select the motors you would like to control. __If you choose to control two motors (Example: B & C), the motors will be ''synchronized'', going forward or backwards at exactly the same power. If you select three motors, motors B & C will be synchronized.__

    .__這裡的 "synchronized" 是一個很特別的設計, 要自行設計出類似的機制有其難度; 可以做一下實驗. __

 2. Choose whether the motors will go forward, go backwards, or stop. Selecting Stop will also ''reset''[?] the motors. (See also the Reset Motor Block file.)

 3. If you’re using two motors to drive a vehicle (with one on each side), the Steering slider will appear with the chosen port letters indicated at each side. __'''Move the slider to set a ''curved path'' for your robot. With the slider all the way to either side, your vehicle will spin in place(原地).'''__
 
 4. This slider and the editable input box will let you set the power level [0-100%].

 5. Using the Duration pull-down menu, you can set the motors to run for an unlimited interval or for a set number of seconds, rotations [default] or degrees. By choosing Time, Rotation or Degrees you can control how far your robot will ''travel''. (See the Tip below.)

 6. Choose whether the motors will brake or coast after they’ve finished their action. If you want your robot to stop precisely at an exact location, set the motors to brake. __'''Setting your motors to brake will also keep your robot from slowly rolling backwards on a slope (原來不只是停止的方式不同, brake 會持續咬住)''' but the setting will wear out(耗盡) the NXT’s batteries quicker because the motors are doing work to keep the robot in place.__

 7. The feedback boxes will count how many degrees or full rotations your motors turn (只會呈現角度, 實驗發現這跟 duration 的設定無關). Press the reset button (只有一個 "R" 字的按鈕) to return the values to zero. (To receive feedback, make sure that the motors are connected to the chosen ports and that communication has been established with the NXT.)

Steering 是個很特別的控制 , 以 TriBot 為例 (C 接左輪, B 接右輪):

 * 在中間時直行
 * 往左偏時左轉, 往右偏時右轉; 偏移的幅度越大, 兩輪間轉速的比率會越來越大, 結果畫出來的圓(軌跡)就越小
 * __'''往最兩側偏移時, 兩個輪子會 "等速地" 朝兩個不同方向轉動, 因而產生原地旋轉的效果 (實驗發現, 兩支馬達偏移的角度轉 10 圈會相差約 30 ~ 60 度, 這個問題要怎麼克服? 所以馬達並非完全等速[?])'''__
 * 感覺上 Steering 好像只適合用在行進間左右的操控, 因此精確度並不是那麼的高? 不過為什麼會一下子準確, 一下子又不準確? 跟 Reset Motor 的使用有關嗎[?]
 
==== Tip: How do I get my Robot to Travel a Certain Distance? ====

You’ll do this by looking at the feedback boxes (7).

===== For Wheeled or Tracked(履帶) Vehicles: =====

First press the feedback box’s reset button. With either the USB cable still connected or an active Bluetooth connection, place your robot at a starting point and roll it forward with your hand. You’ll notice that the feedback box will count how many rotations or degrees your motors turn. (The Duration property must be set to Rotation or Degrees for this to work.) __At your desired finishing point, stop rolling your robot and note the displayed number of rotations or degrees. If you type this value into the Duration property’s input box, and download and then run your program, your robot will drive the distance you measured.__

===== For Robots with Legs: =====

Here you’ll have to begin a process of ''trial(試驗) and error'', choosing ''a set number of'' rotations or degrees and checking to see how close you come to your target destination. Make sure to press the reset button before beginning. (機器人是怎麼前進的[?])

===== Other Uses of Duration =====

__When programming a tool like a grabber, it is a good idea to set a time in the Duration property. This will save you from having to measure the exact number of degrees to operate your tool and allow you to complete your program. '''(這種 "比較省事" 的說法很奇怪, 實務上的問題是我們無法確定, 一開始夾子張開的角度為何; 建議先以 time 來控制閉合, 再以 rotation 或 degree 來控制要張開的角度)'''__

__Note: Setting the motors’ duration to anything other than “Unlimited” will cause the program to wait until the robot completes the set duration; only then will the program continue. (不像 Motor 有提供 Wait for Completion 的選項, 這會造成什麼限制嗎[?])__

==== Configuring the Move block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Move block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_leftmotorout.png}} || Left Motor || Number || 1 - 3 || 1 = A, 2 = B, 3 = C || ||
|| {{attachment:helpadd_rightmotorout.png}} || Right Motor || Number || 1 - 3 || 1 = A, 2 = B, 3 = C || ||
|| {{attachment:helpadd_othermotor.png}} || Other Motor || Number || 1 - 3 || 1 = A, 2 = B, 3 = C || ||
|| {{attachment:helpadd_direction.png}} || Direction || Logic || True/False || True = Forwards, False = Backwards || ||
|| {{attachment:helpadd_steering.png}} || Steering || Number || -100 - 100 || __< 0 = Steer towards left motor <<BR>> > 0 = Steer towards right motor__ ||
|| {{attachment:helpadd_power.png}} || Power || Number || 0 - 100 || || ||
|| {{attachment:helpadd_move_duration.png}} || Duration || Number || 0 - 2147483647 || Depends on Duration Type: Degrees/Rotations = Degrees, Seconds = Seconds || Duration Type = Unlimited ||
|| {{attachment:helpadd_nextaction.png}} || Next Action || Logic || True/False || True = Brake, False = Coast || Duration Type = Unlimited. __Steering not equal to zero (this may only be temporary. pending(即將來臨的) firmware fix for this not to be ignored[?])__ ||

=== Sound Block ===

__You can use this block to play a sound file or a single tone(音調). To compose a melody of tones, arrange several sound blocks in a row with each set to play different tones.__

If you select “Wait for completion” in the configuration panel, the sound file or tone will finish playing before the program moves on to the next block. With this item unchecked, the sound file or tone will continue to play while the next block of your program proceeds.

Choosing “Repeat” will cause a sound file to play again and again.

{{attachment:sound_01.png}} <<BR>> Image of Sound block, default settings

 1. This icon shows whether the block will play a sound file or a tone.
 2. This icon shows whether the block will start or stop playing a sound.
 3. This icon shows the block’s volume. An icon with four orange bars is set to the loudest volume.
 4. You can drag data wires from other blocks to this block’s data hub that will affect the Sound block’s properties.

==== Configuring the Sound Block ====

{{attachment:sound_02.png}} <<BR>> Image of the configuration pane for the Sound block with sound file chosen

{{attachment:sound_03.png}} <<BR>> Image of the configuration pane for the Sound block with tone selected

 1. The Action property radio buttons let you choose to play a sound file or a tone that you’ll compose.
 
 2. Choose to play or stop playing a sound file or tone.
 
 3. Set the volume using the slider. Use the text field to type in an exact value.

If you choose to play a sound file (as in the first configuration panel above), you’ll be able to set the following additional properties:

 4. The Function property will let you set the sound file to repeat so that it plays again and again without stopping. The “Wait for completion” option will be grayed out and no longer available.
 
 5. The File property will let you choose the sound file by its name. __You’ll see an alphabetical list of available sounds. These are stored in the Sound Files folder of the LEGO MINDSTORMS software on your hard drive. '''(音效檔來源位置是在 NXT software 安裝位置下 `..\engine\Sounds` 的子目錄裡, 副檔名都是 `.rso`; 可以用 http://bricxcc.sourceforge.net/utilities.html[Wav2Rso] 將 `.wav` 檔轉換成 `.rso` 檔)'''__ Click on each name to hear it played.
 
 6. If you check the “Wait for Completion” checkbox, the sound file will play to its end before allowing the program to move on the next block. With the box unchecked, the sound file will play while the next block in the program proceeds. __If the next block is another Sound block, the first Sound file will stop automatically and the new Sound file will play. (不會重疊在一起; 包括下面 Note)__

If you choose to play a tone (as in the second configuration panel above), you’ll be able to set the following additional properties:

 4. The Note property will allow you to compose(作曲) a tone to play when the Sound block is activated. __The small keyboard represents three octaves(八度音) of the musical scale. The text field above the keyboard will display the note (用 C ~ G, A, B 來表示) that is either pressed on this keyboard with your mouse or typed in using your computer’s keyboard (用鍵盤怎麼輸入[?]). The input box next to the stopwatch(碼表) is for specifying the duration of the note in 1/10s of a second. (實驗發現, 甚至可以輸入 0.001 秒)__
 
 5. If you check the “Wait for Completion” checkbox, your tone will play to its end before allowing your program to move on the next block in your program. With the box unchecked, your tone will play while the next block of your program proceeds.

This chart shows the different characteristics of the plugs on the Sound block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_action.png}} || Action || Number ||  0 - 1 || 0 = Sound file, 1 = Tone || ||
|| {{attachment:helpadd_sound_filename.png}} || Filename || Text || 15 character maximum || Filename of sound file to play || Action = Tone ||
|| {{attachment:helpadd_tonefrequency.png}} || Tone Frequency || Number || 0 - 65535 || __Tone frequency in Hertz. The NXT's internal speaker can play back frequencies between approximately 264 and 4000 Hertz. (內部是以頻率來表示, frequency 與 note 之間的對照關係, 可以參考http://en.wikipedia.org/wiki/Note[這裡]: C/262, D/294, E/330, F/349, G/392, A/440, B/494)__ || Action = Sound file ||
|| {{attachment:helpadd_control.png}} || Control || Number || 0 - 1 || 0 = Play, 1 = Stop || ||
|| {{attachment:helpadd_volume.png}} || Volume || Number || 0 - 100 || __Sound volume. Special note: there are really only 5 sound levels (0, 25, 50, 75, and 100); numbers in between are rounded downwards.__ || Action = Sound file ||
|| {{attachment:helpadd_duration.png}} || Duration || Number || 0 - 65535 || Tone duration in milliseconds || Action = Sound file ||

== Sensor Blocks ==

=== Light Sensor Block ===

{{attachment:b020_light.png}} __This sensor detects ambient (surrounding) light. Using data wires, it can send out the current light value and a ''logic signal'' (true/false) based on whether the current light value falls above or below a ''trigger point''.__

A trigger point is the specific value in a range of numbers where ''a change in condition occurs (true/false 兩邊的分水嶺而言)''. For example, you might program your robot to move forward only when the light level rises above 60%. The trigger point would be 60.

Specify the trigger point by using the slider or by typing a number into the input box. To specify the range (above or below the trigger point) that will generate the “true” signal, use the radio buttons or the pull-down menu. __The “true” portion of the range will be in color; the “false” portion will be gray.__

The default setting for the light sensor block is for light levels above 50% to generate a “true” signal. The radio button to the right of the range is selected and the slider is set at 50. To switch the “true” portions of the range (setting values below 50% as “true”), you would select the left radio button.

The feedback box in the configuration panel shows the current light value. (To receive feedback, make sure that the light sensor is connected to the chosen port and that communication has been established with the NXT.)

You must drag at least one output data wire from this block’s data hub to another block for any information to be sent.

==== Tip: How do I set the Trigger Point for a Light Sensor? ====

__If you want a flashlight(手電筒) pointed at your robot to generate the “true” signal, try pointing a flashlight at your robot a few times and watching the light values displayed in the feedback box. If the flashlight generates light levels of ''around'' 80%, you might set the trigger value at 70. That way, bright light above 70% (like from the flashlight) will generate a “true” signal. Weaker light will be ignored. (注意這裡測得 80, 但下修為 70 的動作)__

The trigger point can also be set dynamically with an input data wire.

==== Detecting the Light Sensor’s own Reflected Light ====

If you check the “Generate Light” checkbox, the light sensor will turn on its own small light source and detect this light if it is reflected back to it. __'''This function is especially useful in ''difficult lighting conditions'' like very bright rooms. The function also allows the light sensor to serve as a ''short-distance range finder''. (實驗發現前面沒有東西時的讀數不是零, 因此遇到貼著黑色的東西時, 無法判別是不是有東西在前面 [...])''' With “Generate Light” turned on, a light sensor approaching a reflective object will detect higher reflected light levels. Therefore, it is possible to use the sensor to avoid running into obstacles(障礙).__

==== Display Settings ====

{{attachment:SB_light_01.png}} <<BR>> Image of block, reflection turned on

 1. The number shows which of your NXT’s ports are connected to the light sensor. You can change this number in the configuration panel if you need to.
 
 2. This icon indicates at what level the trigger point is set. The more colored bars displayed, the higher the trigger point.
 
 3. This icon is displayed if “Generate Light” is turned on.
 
 4. The block’s data hub will open automatically when the block is placed in the work area. At least one data wire must be dragged from the block’s output plug to another block’s data hub.

==== Configuring the Light Sensor Block ====

{{attachment:SB_light_02.png}} <<BR>> Image of configuration panel

 1. Choose the port where your light sensor is plugged in. By default, the block will be set to port 3 for a light sensor. You can change this selection if you need to.
 
 2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the right of the slider if you want the block to be triggered by light levels higher than the trigger value; select the left radio button to trigger the block with light levels lower than the trigger value. You can also use the pull-down menu to set the “true” portion of the slider.
 
 3. If you check the “Generate Light” checkbox, the light sensor will turn on its own small light source and detect this light if it is reflected back to it.
 
 4. The feedback box displays the current light reading (0-100%). You can use it to try out different trigger values.

==== Configuring the Light Sensor block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Light Sensor block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_port.png}} || Port || Number || 1 - 4 || 1 = Port 1, 2 = Port 2, 3 = Port 3, 4 = Port 4 || ||
|| {{attachment:helpadd_triggerpoint.png}} || Trigger Point || Number || 0 - 100 || Value to compare against || ||
|| {{attachment:helpadd_greaterless.png}} || Greater / Less || Logic || True/False || Logic used in comparison. <<BR>> True = Greater, False = Less || ||
|| {{attachment:helpadd_generatelight.png}} || Generate Light || Logic || True/False || Determines if the sensor's own LED is on or not || ||
|| {{attachment:helpadd_yesno.png}} || Yes / No || Logic || True/False || Result of comparison || ||
|| {{attachment:helpadd_lightintensity.png}} || Intensity || Number || 0 - 100 || Scaled value read from sensor. || ||
|| {{attachment:helpadd_rawdata.png}} || Raw Value || Number || 0 - 1024 || Raw (unscaled) value read from sensor || ||

=== NXT Buttons Block ===

{{attachment:b100_rcx.png}} This block outputs a “true” signal through a data wire when one of the NXT buttons is activated. You will have to select the button and the action that will send the “true” signal.

SB_NXTbuttons_01.png <<BR>> Image of NXT Buttons block, default settings

 1. The icon at the bottom of the block indicates which NXT button has been selected.
 
 2. The block’s data hub will automatically open when the block is placed on the sequence beam. You will need to drag a data wire from the NXT Buttons block to another block that can accept a logic (true/false) signal.

==== Configuring the NXT Buttons Block ====

{{attachment:SB_NXTbuttons_02.png}} <<BR>> Image of configuration panel

 1. Select which NXT button will send out a “true” signal when activated.
 
 2. Choose Bumped if you want the NXT button to be activated after a quick press and release. Choose Pressed if you want the button to be activated at the instant the button is pressed in. Choose Released if you want the button to be activated at the instant the button is released.

 3. The feedback box will display a “1” when the chosen NXT button is bumped, pressed or released (according to the configuration you’ve set).

==== Configuring the NXT Buttons block’s Data Hub ====

This chart shows the different characteristics of the plugs on the NXT Buttons block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_buttonNXT.png}} || Button || Number || 1 - 3 || 1 = Right, 2 = Left, 3 = Select || ||
|| {{attachment:helpadd_NXT_action.png}} || Action || Number || 0 - 2 || 0 = Pressed, 1 = Released, 2 = Bumped || ||
|| {{attachment:helpadd_yesno.png}} || Yes / No || Logic || True/False || Result of comparison || ||

=== Receive Message Block ===

To receive a wireless message, set the message type and mailbox number to match those of the sending NXT. This block’s output can be the incoming message itself or a “true/false” logic value (if you are comparing the incoming message to a test message).
Configuring the NXT for Wireless Communication

Before wireless messages can be sent or received, the participating NXTs must be set up for wireless communication.

On the (master) NXT that will communicate with other NXTs, navigate to the Bluetooth category and choose Search that will start a search for other devices. When the search is complete, choose which connection number (1, 2, or 3) you want the second (slave) NXT to be known as. The first time a connection is established between two NXTs, a prompt to enter the Passkey will appear on both NXTs; this needs to be accepted by both. Now when you navigate to the Connection category on the master NXT, the slave NXT should be shown by its name occupying the selected connection number. On the slave NXT, the master NXT should be shown occupying connection number 0. At this point, the master NXT is ready to initiate communication with the slave NXT.

If the master NXT needs to communicate with multiple NXTs (up to a maximum of three), you should repeat the above process again.

It’s only necessary to go through this process on one NXT. The receiving NXT will automatically update its connection when the master NXT is setting up its connection number.
Connection Number

The connection number for each NXT might be considered its address in the wireless world. You send a message to a specific NXT by indicating its connection number.
Mailbox Number

Each NXT has ten mailbox numbers where wireless messages can be deposited. Each mailbox number can hold up to five messages. If the mailbox number fills up with five messages, adding one more message will cause the NXT to erase the oldest message.
Receiving a Message

To receive a wireless message (after all NXTs have been configured with connection numbers), first indicate the format of the incoming message (Text, Number, or Logic).

If you want to test that a certain message has been received (and have the Receive Message block send out a “true” signal), type the test text or number in the input box, or check either true or false. If the incoming message, matches the test message, a “true” signal will be sent from the block through the “√/x” plug.

To finish configuring the block, choose the mailbox number where the incoming message will be stored.

Note: See the Send Message block for information on sending a wireless message.
Display Settings

Image of Send Message block, data hub open

   1.

      The data hub will open automatically when the block is attached to a sequence beam. The incoming message will be sent as output from one of three data hub plugs depending on the message format: if the incoming message is in text format, it will be sent through the “T” plug; if the message is a number, it will be sent through the “#” plug; and if the message is a logic value, it will be sent through the “√x” plug.

      You can also send out a logic (true/false) signal through the “√/x” plug if you want to compare the incoming message to a test message you provide. (See the Data Hub section below for more information.)

Configuring the Receive Message Block

Image of configuration panel, default conditions

   1. The pull-down menu will let you select the message type (Text, Number, or Logic) of the message being received.
   2. If you want to compare the incoming message to a test message, either type in the test text or number (if you chosen Text or Number respectively as the format), or use the radio buttons to choose the test logic value (true or false).
   3. Choose the mailbox number where the incoming message will be stored.

Configuring the Receive Message block’s Data Hub

You can control the Receive Message block dynamically by connecting data wires (from other blocks’ data hubs) to the Receive Message block’s data hub.

Open a block’s data hub by clicking the tab at the lower left edge of the block after it has been placed on the work area.

Image showing unopened tab on a generic block

Data wires carrying input information to a block are connected to the plugs on the left side of its data hub. Data wires carrying output information are connected to the plugs on the right side.

Image of data wires

[A] Input plug
[B] Output plug
[C] Number data wire (yellow)
[D] Logic data wire (green)
[E] Text data wire (orange)
[F] Broken data wire (gray)
Passing data from the input plug to the output plug

If an input plug has a corresponding output plug (see A above), the input data will pass through from the input plug to the output plug without being changed. In this case, you can only use the output plug if the input plug is connected to an input data wire; connecting an output data wire to such an output plug without a connected input data wire will cause the output data wire to be “broken” (and colored gray).
Data wires carry specific types of data

Each data wire carries a specific type of data between blocks. For example, if a data wire is dragged from a logic plug on a block’s data hub, it can only be connected to a logic plug on another block’s data hub. The chart below shows what kind of data each plug can accept or send out.
Data wire colors

Data wires are identified with specific colors: wires carrying number data are colored yellow, wires carrying logic data are colored green, and wires carrying text data are colored orange.
“Broken” data wires

If you try to connect a data wire to a plug of the wrong data type, the data wire will be broken (and colored gray). You will not be able to download your program if a data wire is broken.

If you click a broken wire you can read why it is broken in the small help window in the lower right corner of the work area.
Data must be within the possible range of the plug

If an input data wire transmits a value outside the possible range of the plug it is connected to, the block will either ignore the value or change it to a value within its range. For plugs that allow just a few input values (example: just 0, 1, or 2), the plug will ignore the input if a value arrives outside its range.

For plugs that accept larger input ranges (example: 0 – 100), the plug will force any input outside its range to fit. For example, if a Move block’s Power plug receives an input value of 150, the block will change the input value to 100 (i.e., a number within the Power plug’s range).
This chart shows the different characteristics of the plugs on the Receive Message block’s data hub:
  	Plug 	Data Type 	Possible Range 	What the Values Mean 	This Plug is Ignored When...
Port 	Mailbox 	Number 	1 - 10 	Mailbox to read from 	 
Port 	Text in 	Text 	58 character maximum 	Value to compare against 	Message Type not Text
Port 	Number in 	Number 	-2147483648 - 2147483647 	Value to compare against 	Message Type not Number
Port 	Logic in 	Logic 	True/False 	Value to compare against 	Message Type not Logic
Port 	Message Received 	Logic 	True/False 	True if a message is received (i.e., mailbox isn't empty) 	 
Port 	Yes / No 	Logic 	True/False 	Result of comparison 	 
Port 	Text out 	Text 	58 character maximum 	Message data 	Message Type not Text
Port 	Number out 	Number 	-2147483648 - 2147483647 	Message data 	Message Type not Number
Port 	Logic out 	Logic 	True/False 	Message data 	Message Type not Logic

=== Rotation Sensor Block ===

This block counts the number of degrees (one full rotation is 360 degrees) or full rotations that your motor turns. Through data wires, this block can send out the current number of degrees or rotations, and a logic signal (true/false) based on whether the number of degrees or rotations falls above or below a trigger point.

A trigger point is the specific value in a range of numbers where a change in condition occurs. For example, you might program your robot to stop when the number of rotations passes 10. The trigger point would be 10 rotations.

Specify the trigger point by typing a number into the input box. To specify the range (above or below the trigger point) that will generate the “true” signal, use the pull-down menu to choose greater than or less than [the trigger point].

The default setting for the Rotation Sensor block is for degrees more than 360 to generate a “true” signal.

The feedback box will count how many degrees or rotations your motors turn. As a default, the box is set to display degrees. With the Duration property set to Rotation, the current count will be displayed in full rotations. Press the reset button to return it to zero. (To receive feedback, make sure that the motor is connected to the chosen port and that communication has been established with the NXT.)
Data Wires

For the Rotation Sensor block to function, you must drag a data wire from the block’s data hub and attach it to another block’s data hub. You can drag two kinds of data wires from the Rotation Sensor block’s data hub: a logic data wire that will send out true/false signals, and a number (#) data wire that will send out the current number of rotations or degrees. The trigger point can also be supplied dynamically by connecting input data wires from other blocks. (See the Data Hub section below for more information.)
Display Settings

Image of block

   1. This letter shows which port the Rotation Sensor block will be monitoring. You can change to another port in the configuration panel if you need to.
   2. This icon will show whether the block is counting the number of rotations (the solid circular arrow) or degrees (the dashed circular arrow).
   3. The block’s data hub will open automatically allowing you to drag out a logic (true/false) data wire or a number (#) data wire that will transmit the Rotation Sensor’s current count.

Configuring the Rotation Sensor Block

Image of configuration panel

   1. Choose which port you would like the block to monitor (A, B, or C).
   2. Choose either to read a rotation sensor's current value or to reset a sensor's value back to zero.
   3.

      Set the direction you want to monitor using the radio buttons: forwards or backwards.

      Important: Make sure that you choose the right direction or the block may never be able to count to your set trigger value.
   4. Use the pull-down menu to set whether the block should count the number of rotations or degrees.
   5. Type the trigger value into the input box and use the pull-down menu to specify whether you want the “true” region to be greater than or less than the trigger value.
   6.

      The feedback box will show the current count in full rotations or degrees. Push the reset button to clear the count and start from zero.

      The feedback value will be displayed in black-colored text for rotations or degrees in the forward (positive) direction; it will be in red-colored text rotations or degrees in the backward (negative) direction.

Configuring the Rotation Sensor block’s Data Hub

You can control the Rotation Sensor block dynamically by connecting data wires (from other blocks’ data hubs) to the Rotation Sensor block’s data hub.

Open a block’s data hub by clicking the tab at the lower left edge of the block after it has been placed on the work area.

Image showing unopened tab on a generic block

Data wires carrying input information to a block are connected to the plugs on the left side of its data hub. Data wires carrying output information are connected to the plugs on the right side.

Image of data wires

[A] Input plug
[B] Output plug
[C] Number data wire (yellow)
[D] Logic data wire (green)
[E] Text data wire (orange)
[F] Broken data wire (gray)
Passing data from the input plug to the output plug

If an input plug has a corresponding output plug (see A above), the input data will pass through from the input plug to the output plug without being changed. In this case, you can only use the output plug if the input plug is connected to an input data wire; connecting an output data wire to such an output plug without a connected input data wire will cause the output data wire to be “broken” (and colored gray).
Data wires carry specific types of data

Each data wire carries a specific type of data between blocks. For example, if a data wire is dragged from a logic plug on a block’s data hub, it can only be connected to a logic plug on another block’s data hub. The chart below shows what kind of data each plug can accept or send out.
Data wire colors

Data wires are identified with specific colors: wires carrying number data are colored yellow, wires carrying logic data are colored green, and wires carrying text data are colored orange.
“Broken” data wires

If you try to connect a data wire to a plug of the wrong data type, the data wire will be broken (and colored gray). You will not be able to download your program if a data wire is broken.

If you click a broken wire you can read why it is broken in the small help window in the lower right corner of the work area.
Data must be within the possible range of the plug

If an input data wire transmits a value outside the possible range of the plug it is connected to, the block will either ignore the value or change it to a value within its range. For plugs that allow just a few input values (example: just 0, 1, or 2), the plug will ignore the input if a value arrives outside its range.

For plugs that accept larger input ranges (example: 0 – 100), the plug will force any input outside its range to fit. For example, if a Move block’s Power plug receives an input value of 150, the block will change the input value to 100 (i.e., a number within the Power plug’s range).
This chart shows the different characteristics of the plugs on the Rotation Sensor block’s data hub:
  	Plug 	Data Type 	Possible Range 	What the Values Mean 	This Plug is Ignored When...
Port 	Port 	Number 	1 - 3 	1 = A, 2 = B, 3 = C 	 
Port 	Trigger Point 	Number 	0 - 2147483647 	Value to compare against 	 
Port 	Trigger Point Direction 	Logic 	True/False 	Direction to use in comparison:
True = Forwards,
False = Backwards 	 
Port 	Greater / Less 	Logic 	True/False 	Logic used in comparison:
True = Greater,
False = Less 	 
Port 	Reset 	Logic 	True/False 	True = Reset,
False = Read 	 
Port 	Yes / No 	Logic 	True/False 	Result of comparison 	 
Port 	Direction 	Logic 	True/False 	True = Forwards,
False = Backwards 	 
Port 	Degrees 	Number 	0 - 2147483647 	Scaled value read from sensor. 	 

=== Sound Sensor Block ===

This block is a sound detector. Using data wires, it can send out the current sound value and a logic signal (true/false) based on whether the current sound value falls above or below a trigger point.

A trigger point is the specific value in a range of numbers where a change in condition occurs. For example, you might program your robot to move forward only when the sound level rises above 60%. The trigger point would be 60.

Specify the trigger point by using the slider or by typing a value into the input box. To specify the range (above or below the trigger point) that will generate the “true” signal, use the radio buttons or the pull-down menu. The “true” portion of the range will be in color; the “false” portion will be gray.

The default setting for the sound sensor block is for sound levels above 50% to generate a “true” signal. The radio button to the right of the range is selected and the slider is set at 50. To switch the “true” portions of the range (setting values below 50% as “true”), you would select the left radio button.

The feedback box in the configuration panel shows the current sound value. (To receive feedback, make sure that the sensor is connected to the chosen port and that communication has been established with the NXT.)

You must drag at least one output data wire from this block’s data hub to another block for any information to be sent. (See the Data Hub section for more information.)

StopTip: How do I set the Trigger Point for the Sound Sensor?

If you want a loud clapping sound to generate the “true” signal, try clapping a few times and watching the sound values displayed in the feedback box. If your clapping generates sound levels of around 80%, you might set the trigger value at 70. That way, only louder sounds above 70% (like your clapping) will generate a “true” signal. Quieter sounds will be ignored.

The trigger point can be set dynamically by an input data wire.
Display Settings

Image of block

   1. The number shows which of your NXT’s ports is connected to the sound sensor. You can change this number in the configuration panel if you need to.
   2. This icon indicates at what level the trigger point is set. The more colored bars displayed, the higher the trigger point.
   3. The block’s data hub will open automatically when the block is attached to a sequence beam. At least one data wire must be dragged from the block’s output plug to another block’s data hub. (See the Data Hub section below for more information.)

Configuring the Sound Sensor Block

Image of configuration panel

   1. Choose the port where your touch sensor is plugged in. By default, the block will be set to port 2 for a sound sensor. You can change this selection if you need to.
   2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the right of the slider if you want the block to be triggered by sound levels higher than the trigger value; select the left radio button to trigger the block with sound levels lower than the trigger value. You can also use the pull-down menu to set the “true” portion of the slider.
   3. The feedback box displays the current sound reading (0-100%). You can use it to try out different trigger values.

Configuring the Sound Sensor block’s Data Hub

You can control the Sound Sensor block dynamically by connecting data wires (from other blocks’ data hubs) to the Sound Sensor block’s data hub.

Open a block’s data hub by clicking the tab at the lower left edge of the block after it has been placed on the work area.

Image showing unopened tab on a generic block

Data wires carrying input information to a block are connected to the plugs on the left side of its data hub. Data wires carrying output information are connected to the plugs on the right side.

Image of data wires

[A] Input plug
[B] Output plug
[C] Number data wire (yellow)
[D] Logic data wire (green)
[E] Text data wire (orange)
[F] Broken data wire (gray)
Passing data from the input plug to the output plug

If an input plug has a corresponding output plug (see A above), the input data will pass through from the input plug to the output plug without being changed. In this case, you can only use the output plug if the input plug is connected to an input data wire; connecting an output data wire to such an output plug without a connected input data wire will cause the output data wire to be “broken” (and colored gray).
Data wires carry specific types of data

Each data wire carries a specific type of data between blocks. For example, if a data wire is dragged from a logic plug on a block’s data hub, it can only be connected to a logic plug on another block’s data hub. The chart below shows what kind of data each plug can accept or send out.
Data wire colors

Data wires are identified with specific colors: wires carrying number data are colored yellow, wires carrying logic data are colored green, and wires carrying text data are colored orange.
“Broken” data wires

If you try to connect a data wire to a plug of the wrong data type, the data wire will be broken (and colored gray). You will not be able to download your program if a data wire is broken.

If you click a broken wire you can read why it is broken in the small help window in the lower right corner of the work area.
Data must be within the possible range of the plug

If an input data wire transmits a value outside the possible range of the plug it is connected to, the block will either ignore the value or change it to a value within its range. For plugs that allow just a few input values (example: just 0, 1, or 2), the plug will ignore the input if a value arrives outside its range.

For plugs that accept larger input ranges (example: 0 – 100), the plug will force any input outside its range to fit. For example, if a Move block’s Power plug receives an input value of 150, the block will change the input value to 100 (i.e., a number within the Power plug’s range).
This chart shows the different characteristics of the plugs on the Sound Sensor block’s data hub:
  	Plug 	Data Type 	Possible Range 	What the Values Mean 	This Plug is Ignored When...
Port 	Port 	Number 	1 - 4 	1 = Port 1, 2 = Port 2, 3 = Port 3, 4 = Port 4 	 
Port 	Trigger Point 	Number 	0 - 100 	Value to compare against 	 
Port 	Greater / Less 	Logic 	True/False 	Logic used in comparison:
True = Greater, False = Less 	 
Port 	dBA 	Logic 	True/False 	True = dBA mode
False = dB mode 	 
Port 	Yes / No 	Logic 	True/False 	Result of comparison 	 
Port 	Sound Level 	Number 	0 - 100 	Scaled value read from sensor 	 
Port 	Raw Value 	Number 	0 - 1024 	Raw (unscaled) value read from sensor 	 

== Timer Block ==

__'''When your program starts, the three built-in timers in the NXT will automatically start counting. (可以應用在什麼地方[?])''' With this block you can choose to either read a timer’s current value or cause a timer to start counting again from zero.__

Through data wires, this block can send out the current timer value and a ''logic signal'' (true/false) based on whether the timer value falls above or below a trigger point.

__'''A ''trigger point'' is the specific ''value'' in a ''range'' of numbers where a change in condition occurs. (其中 ''trigger value'' 與 ''true region/portion'' 是分開定義的; trigger value 整個值域一分為二, less/greater than 的設定則決定了哪一邊為 true region - 數值落在哪一段才叫 "條件成立" 而言)'''__ For example, you might program your robot to stop when the timer counts past 20 seconds. The trigger point would be 20 seconds.

Specify the trigger point by typing a number into the input box. To specify the range (above or below the trigger point) that will generate the ''“true” signal'', use the pull-down menu to choose greater than or less than [the trigger point].

__For the Timer block to function, you must drag a data wire from the block’s data hub and attach it to another block’s data hub. You can drag two kinds of output data wires from the Timer block’s data hub: a logic data wire that will send out a true/false signal, and a number (#) data wire that will send out the timer’s current value.__

You can also supply the ''trigger value'' dynamically by connecting an input data wire to the Timer block’s data hub.

{{attachment:SB_timer_01.png}} <<BR>> Image of block

 1. This number shows which of the three timers in the NXT you will be monitoring. You can change to another timer in the configuration panel if you need to.
 
 2. The block’s data hub will open automatically when the block is attached to the sequence beam, allowing you to drag out a logic (true/false) data wire or a number (#) data wire that will transmit the timer’s current time value. You can also supply the trigger value dynamically by connecting an input data wire to the Timer block’s data hub.

Note: you must drag at least one output data wire from the Timer block’s data hub to another block for any information to be sent.

=== Configuring the Timer Block ===

{{attachment:SB_timer_02.png}} <<BR>> Image of configuration panel

 1. Choose which of the three timers in the NXT you would like to view or control.
 
 2. If you choose the action property “Read,” the Timer block will monitor an existing timer that has already been set up somewhere else in your program. If you choose “Reset,” the block will reset the chosen timer and make it start over(重新開始). You can position another Timer block later in your program to check on its ''progress''.

 3. Type the trigger value (in seconds) into the input box and use the pull-down menu to specify whether you want the ''“true” region'' to be greater than or less than the trigger value.

=== Configuring the Timer block’s Data Hub ===

This chart shows the different characteristics of the plugs on the Timer block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_timer.png}} || Timer || Number || 1 - 3 || 1 = Timer 1, 2 = Timer 2, 3 = Timer 3 || ||
|| {{attachment:helpadd_triggerpoint.png}} || Trigger Point || Number || 0 - 100 || Value to compare against || ||
|| {{attachment:helpadd_greaterless.png}} || Greater / Less || Logic || True/False || Logic used in comparison: True = Greater, False = Less || ||
|| {{attachment:helpadd_reset.png}} || Reset || Logic || True/False || True = Reset timer, False = Read timer || ||
|| {{attachment:helpadd_yesno.png}} || Yes / No || Logic || True/False || Result of comparison || ||
|| {{attachment:helpadd_timervalue.png}} || Timer Value || Number || 0 - 4294967296 || Timer value in milliseconds (注意單位不是常用的 "秒", 而是 "毫秒") || ||

=== Touch Sensor Block ===

This block checks a touch sensor’s condition at a specific point in the program. It sends out its finding as a logic signal (true or false) through a data wire. If the sensor has been triggered, the block will send out a “true” signal; if it has not been triggered, the block will send a “false” signal.

You must drag an output data wire from this block’s data hub to another block for any information to be sent. (See the Data Hub section below for more information.)

Use the radio buttons to decide which action will produce the “true” signal.

Image of block

   1. The number shows which of your NXT’s ports are connected to the touch sensor. You can change this number in the configuration panel if you need to.
   2. This icon will show which action will send a “true” signal (Bumped, Pressed, or Released).
   3. The block’s data hub will open automatically when the block is placed in the work area. A data wire must be dragged from the block’s output plug to another block’s data hub.

Configuring the Touch Sensor Block

Image of configuration panel

   1. Choose the port where your touch sensor is plugged in. By default, the block will be set to port 1 for a touch sensor. You can change this selection if you need to.
   2. The touch sensor block can be triggered in three ways. Choose Bumped if you want the block to be triggered after a quick press and release of the touch sensor (less than 0.5 seconds in duration). Choose Pressed if you want the block to be triggered at the instant the touch sensor is pressed in. Choose Released if you want the block to be triggered at the instant the touch sensor is released.
   3. The feedback box will let you test your touch sensor. When the touch sensor is triggered on your robot, the number “1” will be displayed here. Press “Reset” to clear the box after a touch sensor has been bumped.

Configuring the Touch Sensor block’s Data Hub

You can control the Touch Sensor block dynamically by connecting data wires (from other blocks’ data hubs) to the Touch Sensor block’s data hub.

Open a block’s data hub by clicking the tab at the lower left edge of the block after it has been placed on the work area.

Image showing unopened tab on a generic block

Data wires carrying input information to a block are connected to the plugs on the left side of its data hub. Data wires carrying output information are connected to the plugs on the right side.

Image of data wires

[A] Input plug
[B] Output plug
[C] Number data wire (yellow)
[D] Logic data wire (green)
[E] Text data wire (orange)
[F] Broken data wire (gray)
Passing data from the input plug to the output plug

If an input plug has a corresponding output plug (see A above), the input data will pass through from the input plug to the output plug without being changed. In this case, you can only use the output plug if the input plug is connected to an input data wire; connecting an output data wire to such an output plug without a connected input data wire will cause the output data wire to be “broken” (and colored gray).
Data wires carry specific types of data

Each data wire carries a specific type of data between blocks. For example, if a data wire is dragged from a logic plug on a block’s data hub, it can only be connected to a logic plug on another block’s data hub. The chart below shows what kind of data each plug can accept or send out.
Data wire colors

Data wires are identified with specific colors: wires carrying number data are colored yellow, wires carrying logic data are colored green, and wires carrying text data are colored orange.
“Broken” data wires

If you try to connect a data wire to a plug of the wrong data type, the data wire will be broken (and colored gray). You will not be able to download your program if a data wire is broken.

If you click a broken wire you can read why it is broken in the small help window in the lower right corner of the work area.
Data must be within the possible range of the plug

If an input data wire transmits a value outside the possible range of the plug it is connected to, the block will either ignore the value or change it to a value within its range. For plugs that allow just a few input values (example: just 0, 1, or 2), the plug will ignore the input if a value arrives outside its range.

For plugs that accept larger input ranges (example: 0 – 100), the plug will force any input outside its range to fit. For example, if a Move block’s Power plug receives an input value of 150, the block will change the input value to 100 (i.e., a number within the Power plug’s range).
This chart shows the different characteristics of the plugs on the Touch Sensor block’s data hub:
  	Plug 	Data Type 	Possible Range 	What the Values Mean 	This Plug is Ignored When...
Port 	Port 	Number 	1 - 4 	1 = Port 1, 2 = Port 2, 3 = Port 3, 4 = Port 4 	 
Port 	Action 	Number 	0 - 2 	0 = Pressed
1 = Released
2 = Bumped 	 
Port 	Yes / No 	Logic 	True/False 	Result of comparison 	 
Port 	Raw Value 	Number 	0 - 1024 	Raw (unscaled) value read from sensor 	 

=== Ultrasonic Sensor Block ===

This block can detect objects at a maximum range of about 100 inches (250 cm). Using data wires, it can send out the current ultrasonic reading and a logic signal (true/false) based on whether the current ultrasonic reading falls above or below a trigger point.

A trigger point is the specific value in a range of numbers where a change in condition occurs. For example, you might program your robot to attack when an object approaches at closer than 30 inches (76 cm) of the ultrasonic sensor’s maximum range. The trigger point would be 30.

Specify the trigger point by using the slider or by typing a value into the input box. To specify the portion of the ultrasonic sensor’s range (above or below the trigger point) that will generate the “true” signal, use the radio buttons or the pull-down menu. The “true” portion of the range will be in color; the “false” portion will be gray.

The default setting for the ultrasonic sensor block is for objects detected at less than 50 inches (127 cm) to generate a “true” signal. The radio button to the left of the range is selected and the slider is set at 50 (127). To switch the “true” portion of the range (setting readings at more than 50 inches (127 cm) as “true”), you would select the right radio button.

The feedback box in the configuration panel shows the current ultrasonic reading. (To receive feedback, make sure that the sensor is connected to the chosen port and that communication has been established with the NXT.)

You must drag at least one output data wire from this block’s data hub to another block for any information to be sent.

Tip: How do I set the Trigger Point for an Ultrasonic Sensor?

If you want an invader approaching your robot to generate the “true” signal, try pointing the ultrasonic sensor at the invading robot (or an object of the same reflective quality) as it is positioned at different distances from the sensor. Watch the ultrasonic readings displayed in the feedback box. If the invading robot generates an ultrasonic reading of around 50 inches (127 cm) at the closest distance you would like it to approach your robot, you might set the trigger value at 50 (127). That way, if an object with the same reflective quality approaches past 50 inches (127 cm), the ultrasonic sensor block will generate a “true” signal. By connecting a data wire to a Move or Motor block, you can initiate an attack or retreat.
Display Settings

Image of block

   1. The number shows which of your NXT’s ports are connected to the ultrasonic sensor. You can change this number in the configuration panel if you need to.
   2. This icon shows whether the ultrasonic sensor is set to detect objects nearby or farther away. The more colored bars, the farther away the detection.
   3. The block’s data hub will open automatically when the block is placed in the work area. At least one data wire must be dragged from the block’s output plug to another block’s data hub. The trigger point can be set dynamically by connecting an input data wire. (See the Data Hub section below for more information.)

Configuring the Ultrasonic Sensor Block

Image of configuration panel

   1. Choose the port where your ultrasonic sensor is plugged in. By default, the block will be set to port 4 for an ultrasonic sensor. You can change this selection if you need to.
   2. If you choose the radio button to the left of the slider, the block will be triggered when it detects an object that is closer than the trigger distance; select the right radio button to trigger the block when it detects an object farther away than the trigger distance. Use the slider to set the trigger distance or type a value directly into the input box (0–250 if configured for Centimeters or 0–100 if configured for Inches). Remember that highly reflective surfaces can be detected further away than non-reflective surfaces.
   3. Select to read values in Centimeters or Inches.
   4. The feedback box displays the current ultrasonic reading (0-250 cm or 0-100 in). A reading of 0 indicates the closest distance the sensor can detect. If configured for centimeters, a reading of 250 indicates the farthest distance the sensor can detect (i.e., roughly 250 cm). If configured for inches, a reading of 100 indicates the farthest distance the sensor can detect (i.e., roughly 100 in).

Note: More than one ultrasonic sensor operating in the same room may disturb each other’s readings.
Configuring the Ultrasonic Sensor block’s Data Hub

You can control the Ultrasonic Sensor block dynamically by connecting data wires (from other blocks’ data hubs) to the Ultrasonic Sensor block’s data hub.

Open a block’s data hub by clicking the tab at the lower left edge of the block after it has been placed on the work area.

Image showing unopened tab on a generic block

Data wires carrying input information to a block are connected to the plugs on the left side of its data hub. Data wires carrying output information are connected to the plugs on the right side.

Image of data wires

[A] Input plug
[B] Output plug
[C] Number data wire (yellow)
[D] Logic data wire (green)
[E] Text data wire (orange)
[F] Broken data wire (gray)
Passing data from the input plug to the output plug

If an input plug has a corresponding output plug (see A above), the input data will pass through from the input plug to the output plug without being changed. In this case, you can only use the output plug if the input plug is connected to an input data wire; connecting an output data wire to such an output plug without a connected input data wire will cause the output data wire to be “broken” (and colored gray).
Data wires carry specific types of data

Each data wire carries a specific type of data between blocks. For example, if a data wire is dragged from a logic plug on a block’s data hub, it can only be connected to a logic plug on another block’s data hub. The chart below shows what kind of data each plug can accept or send out.
Data wire colors

Data wires are identified with specific colors: wires carrying number data are colored yellow, wires carrying logic data are colored green, and wires carrying text data are colored orange.
“Broken” data wires

If you try to connect a data wire to a plug of the wrong data type, the data wire will be broken (and colored gray). You will not be able to download your program if a data wire is broken.

If you click a broken wire you can read why it is broken in the small help window in the lower right corner of the work area.
Data must be within the possible range of the plug

If an input data wire transmits a value outside the possible range of the plug it is connected to, the block will either ignore the value or change it to a value within its range. For plugs that allow just a few input values (example: just 0, 1, or 2), the plug will ignore the input if a value arrives outside its range.

For plugs that accept larger input ranges (example: 0 – 100), the plug will force any input outside its range to fit. For example, if a Move block’s Power plug receives an input value of 150, the block will change the input value to 100 (i.e., a number within the Power plug’s range).
This chart shows the different characteristics of the plugs on the Ultrasonic Sensor block’s data hub:
  	Plug 	Data Type 	Possible Range 	What the Values Mean 	This Plug is Ignored When...
Port 	Port 	Number 	1 - 4 	1 = Port 1, 2 = Port 2, 3 = Port 3, 4 = Port 4 	 
Port 	Trigger Point 	Number 	0 - 255 (cm)
0 - 100 (in) 	Value to compare against 	 
Port 	Greater / Less 	Logic 	True/False 	Logic used in comparison:
True = Greater, False = Less 	 
Port 	Yes / No 	Logic 	True/False 	Result of comparison 	 
Port 	Distance 	Number 	0 - 255 (cm)
0 - 100 (in) 	Scaled value read from sensor 	 

== Flow Blocks ==

=== Loop Block ===

__Use this block to repeat ''sequences of code''. Set the ''condition'' that will end the loop: elapsed(經過) time, the number of repetitions, a ''logic signal'' or a sensor. You can also set a loop to go on forever. '''(對應一般程式語言 "`do...until`" 的語法, 不過條件式的寫法比較多樣; 其中 logic signal 指的是型態為 Logic 的輸入, 用來決定迴圈要不要結束)'''__

__@2008/11/11 發現, 雖然 NXT-G 不直接提供 `break` 的語法離開最近一層的迴圈, 但實驗發現用 variable 來做為迴圈離開的條件, 就可以達成類似的效果. [...]__

==== Display settings ====

{{attachment:loop_01.png}} <<BR>> Image of Loop block, empty when dragged from palette; infinity symbol marked with number 1

{{attachment:loop_02.png}} <<BR>> Image of Loop block, containing a motor block and set for light sensor conditional; counter marked with number 2; sensor icon marked with number 3

 1. When a Loop block’s action property is set to “Forever,” an infinity symbol (∞) is displayed at the bottom of the ''trailing portion'' of the block.

 2. __If the “Show Counter” checkbox is selected in the configuration panel, '''a plug will appear that will allow you to use the number of ''completed loops'' as an input elsewhere in your program (注意是 "已完成" 的圈數, 所以 completed loops 的起始值為零)''' (if you connect a data wire from the plug to another block’s data hub). You can also use ''current count'' to control the loop itself.__ (See the Count setting in the Configuring the Loop Block section below).

 3. If you choose for a sensor to control the loop, the trailing portion of the Loop block will expand in size revealing an icon for the chosen sensor. For example, if you choose a Light Sensor to control the loop, a Light Sensor icon will be displayed in the ''expanded portion'' of the block. Also, any relevant information about the chosen control property will displayed at the bottom of the block.

==== Adding blocks to the Loop block ====

If a Loop block is placed on the sequence beam, a short section of the beam will appear inside the Loop block; programming blocks dragged on top of this portion of the sequence beam will ''snap'' to it. Any new blocks dragged inside a loop that already contains programming blocks will cause the frame to expand sideways(往側邊). This will make room for the new blocks to snap to the sequence beam.

==== Moving the Loop block ====

__The Loop block can only be selected and moved by clicking on the block itself; clicking on the ''surrounding frame''(將內部 blocks 圍起來的橘色框框) or on the blocks inside the frame will not work.__

==== Configuring the Loop Block ====

The Control property pull-down menu will let you choose from five primary conditions that will affect your loop:

 * Forever [default]
 * Time
 * Sensor (which will activate a second pull-down menu; 有標星號的部份只會出現在教育版)
   * Touch Sensor
   * Light Sensor
   * Sound Sensor
   * Ultrasonic Sensor
   * NXT Buttons
   * (Built-in) Rotation Sensor
   * Timer
   * Receive Message
   * Touch* Sensor
   * Light* Sensor
   * Rotation* Sensor
   * Temperature* Sensor
 * Count
 * Logic

===== Forever =====

{{attachment:loop_03.png}} <<BR>> Image of configuration pane for the Loop block, set to Forever

If you choose “Forever,” any programming blocks within the loop will repeat forever without interruption.

 1. Check the “Show Counter” checkbox to use the number of ''loops completed'' as input to another block. (Example: to increase a Motor block’s Power.)

===== Time =====

{{attachment:loop_04.png}} <<BR>> Image of configuration pane for the Loop block, set to Time

__If you choose “Time,” the programming blocks within the loop will repeat until a certain number of ''seconds have passed''. After the time period is up, the loop will end. '''(並不是時間一到就直接中斷迴圈, 而是每次來到迴圈的結尾才判斷時間是否超過設定的秒數; 因此離開迴圈時, 經過的時間一定會 "大於或等於" 設定的秒數)'''__

__@2008/08/23 實驗發現, 迴圈內部有放置 Wait 時, 離開的時間好像就不如預期; 假設迴圈設定 5 秒, 如果迴圈內部每次執行要 4 秒 (用 Wait 等待), 理論上離開迴圈時應該是 8 秒左右, 但為何實驗結果會是 12 秒? 好像總是會多遶一次, 是不是內部會扣除 Wait 的時間[?]__

 1. Use this box to type in the number of seconds that the loop should run. If you choose 5 seconds, for example, the loop will end after 5 seconds have passed.
 
 2. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Touch Sensor =====

{{attachment:loop_05.png}} <<BR>> Image of configuration pane for the Loop block, set to Touch Sensor

If you choose “Touch Sensor,” the programming blocks within the loop will repeat until a touch sensor is bumped, pressed, or released. Then the loop will end and the program will go on.

 1. Choose the port that the touch sensor is connected to.
 
 2. Use the radio buttons to specify whether you want the touch sensor to be bumped, pressed, or released to end the loop. __Choose Bumped if you want the block to be triggered ''after'' a quick press and release of the touch sensor (less than 0.5 seconds in duration). Choose Pressed if you want the block to be triggered ''at the instant'' the touch sensor is pressed in. Choose Released if you want the block to be triggered at the instant the touch sensor is released.__
 
 3. The feedback box will let you test your touch sensor. When the sensor is activated on your robot, the number “1” will be displayed here. Use the reset button to clear the feedback box.
 
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

__'''注意上面 "after" 與 "at the instant" 的差別; @2008/08/23 實驗發現, 想要觸發 Pressed/Released, 就必須在迴圈結尾判斷條件是否成立的 "當下", 讓感應器 "處於" 被按下或放開的 "狀態" 才行 (過程中有按下或放開都不算數). 至於 Bumped 則沒有這個問題, 只要迴圈遶行的過程中有產生 "按下+放開" 的組合即可, 兩個動作是否發生在迴圈的同一輪, 或者按下與放開的時間間隔是否在 0.5 秒以內都沒有關係.'''__

__往下提到其他 Sensor 做為條件式時, 都有上述的問題. 例如設定聲音 (Sound Sensor) 大於 50 時要離開迴圈, 如果在迴圈遶行的過程中出現大於 50 的聲音也沒有用, 必須要在迴圈結尾做條件判斷的時候有大於 50 的聲音才行.__

{{attachment:loop-sensor-1.png}}

__'''要解決上述的問題, 要利用 additional sequence beams 其 simultaneous tasks 的概念: (搭配 logic signal 做控制)__

{{attachment:loop-sensor-2.png}}
 
===== Sound Sensor =====

{{attachment:loop_06.png}} <<BR>> Image of configuration pane for the Loop block, set to Sound Sensor

If you choose “Sound Sensor,” the programming blocks within the loop will repeat until the sound sensor detects sound in a certain range.

 1. Choose the port where your sound sensor is plugged in. By default, the block will be set to port 2 for a sound sensor.

 2. Use the slider to set the ''trigger value'' or type a value directly into the input box. Select the radio button to the right of the slider if you want the loop to end when sound levels are higher than the trigger value; select the left radio button to end the loop when sound levels are lower than the trigger value. You can also use the pull-down menu to set the portion of the slider that will end the loop.
 
 3. The feedback box displays the current sound reading (0-100%). You can use it to try out different trigger values.
 
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Light Sensor =====

{{attachment:loop_07.png}} <<BR>> Image of configuration pane for the Loop block, set to Light Sensor

If you choose “Light Sensor,” the programming blocks within the loop will repeat until a light sensor measures a certain intensity of light. Then the loop will end and the program will advance.

 1. Choose the port where your light sensor is plugged in. By default, the block will be set to port 3 for a light sensor.
 
 2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the right of the slider if you want the loop to end when light levels are higher than the trigger value; select the left radio button to end the loop when light levels are lower than the trigger value. You can also use the pull-down menu to set the portion of the slider that will end the loop.
 
 3. __If you check the “Generated Light” checkbox, the light sensor will turn on its own small light source and detect this light if it is reflected back to it.__
 
 4. The feedback box will display the current light reading.
 
 5. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Ultrasonic Sensor =====

{{attachment:loop_08.png}} <<BR>> Image of configuration pane for the Loop block, set to Ultrasonic Sensor

If you choose “Ultrasonic Sensor,” the programming blocks within the loop will repeat until the ultrasonic sensor detects an object at a certain distance.

 1. Choose the port where your ultrasonic sensor is plugged in. By default, the block will be set to port 4 for an ultrasonic sensor.
 
 2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the left of the slider if you want the loop to end when the ultrasonic sensor detects an object closer than the trigger value; select the right radio button to end the loop when the ultrasonic sensor detects an object farther away than the trigger value. You can also use the pull-down menu to set the portion of the slider that will end the loop.
 
 3. Select to read values in Centimeters or Inches.
 
 4. The feedback box will display the current ultrasonic sensor reading.
 
 5. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== NXT Buttons =====

{{attachment:loop_09.png}} <<BR>> Image of configuration pane for the Loop block, set to NXT Buttons

If you choose “NXT Buttons,” the programming blocks within the loop will repeat until the chosen NXT buttons is bumped, pressed, or released.

 1. Select which NXT button will send out a “true” signal when activated (and end the loop).
 
 2. Choose Bumped if you want the chosen button to be activated after a quick press and release. Choose Pressed if you want the chosen button to be activated at the instant the button is pressed in. Choose Released if you want the chosen button to be activated at the instant the button is released.
 
 3. The feedback box will display a “1” when the chosen NXT button is bumped, pressed or released (according to the configuration you’ve set).
 
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== (Built-in) Rotation Sensor =====

{{attachment:loop_10.png}} <<BR>> Image of configuration pane for the Loop block, set to Built-in Rotation Sensor

__If you choose to “read” a rotation sensor, the programming blocks within the loop will repeat until the rotation sensor reaches a certain value; then the loop will end and the program will advance. '''If you choose to “reset” the rotation sensor, the sensor will be reset to zero after each loop; the block will continue to loop until the rotation sensor can reach the trigger value during one of the loops. (主要在控制取得數據之後, 要不要 "將角度歸零" 而言)'''__

 1. Choose the port where your motor is plugged in.
 2. Choose to read or reset a rotation sensor.
 3. __Use the radio buttons to set the direction you want: forwards or backwards. (因此角度只有正值)__
 4. Choose to count either Rotations or Degrees by using the pull-down menu.
 5. Type the number of rotations or degrees you want to go by before the loop is ended (allowing your program to go forward).
 6. The feedback box will display the current number of rotations or degrees. Use the reset button to clear the feedback box.
 7. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Timer =====

{{attachment:loop_11.png}} <<BR>> Image of configuration pane for the Loop block, set to Timer

__If you choose to “read” a timer, the programming blocks within the loop will repeat until one of the NXT’s internal timers reaches a certain time value; then the loop will end and the program will advance. If you choose to “reset” a timer, the timer will be reset after each loop; the block will continue to loop until the timer can reach its trigger value during one of the loops. (跟 Rotation Sensor 的用法很類似)__

 1. Choose the NXT timer that you would like to monitor.
 2. Choose to read or reset a timer.
 3. Type a time value (in seconds) in the input box.
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Receive Message =====

{{attachment:loop_12.png}} <<BR>> Image of configuration pane for the Loop block, set to Receive Message

If you choose “Receive Message,” the programming blocks within the loop will repeat until your NXT receives a certain Bluetooth message. Then the loop will end and the program will advance.

 1. The pull-down menu will let you select the message type (Text, Number, or Logic) of the message that you expect to receive.
 
 2. To compare the incoming message to a test message, either type in the test text or number (if you have chosen Text or Number respectively as the format), or use the radio buttons to choose the test logic value (true or false).
 
 3. Choose the ''mailbox number'' where the incoming message will arrive. (哪裡有介紹 mailbox[?])
 
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Touch* Sensor =====

{{attachment:loop_15.png}} <<BR>> Image of configuration pane for the Loop block, set to old Touch* Sensor – callouts 1-3

If you choose “Touch* Sensor,” the programming blocks within the loop will repeat until a touch* sensor is bumped, pressed, or released. Then the loop will end and the program will go on.

 1. Choose the port that the touch* sensor is connected to. By default, the block will be set to port 1 for a touch sensor.
 
 2. Use the radio buttons to specify whether you want the touch sensor to be bumped, pressed, or released to end the loop. Choose Bumped if you want the block to be triggered after a quick press and release of the touch sensor (less than 0.5 seconds in duration). Choose Pressed if you want the block to be triggered at the instant the touch sensor is pressed in. Choose Released if you want the block to be triggered at the instant the touch sensor is released.
 
 3. The feedback box will let you test your touch sensor. When the sensor is activated on your robot, the number “1” will be displayed here. Use the reset button to clear the feedback box.
 
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Light* Sensor =====

{{attachment:loop_16.png}} <<BR>> Image of configuration pane for the Loop block, set to old Light* Sensor – callouts 1-3

If you choose “Light* Sensor,” the programming blocks within the loop will repeat until a light* sensor measures a certain intensity of light. Then the loop will end and the program will advance.

 1. Choose the port where your light* sensor is plugged in. By default, the block will be set to port 3 for a light sensor.
 
 2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the right of the slider if you want the loop to end when light levels are higher than the trigger value; select the left radio button to end the loop when light levels are lower than the trigger value. You can also use the pull-down menu to set the portion of the slider that will end the loop.
 
 3. The feedback box will display the current light reading.
 
 4. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Rotation* Sensor =====

{{attachment:loop_17.png}} <<BR>> Image of configuration pane for the Loop block, set to old Rotation* Sensor – callouts 1-6

If you choose to “read” a rotation* sensor, the programming blocks within the loop will repeat until the rotation sensor reaches a set number of ''ticks (16 to a rotation)''; then the loop will end and the program will advance. If you choose to “reset” the rotation* sensor, the sensor will be reset to zero after each loop; the block will continue to loop until the rotation* sensor can reach the trigger value during one of the loops.

 1. Choose the port where your motor is plugged in.
 
 2. Choose to read or reset a rotation* sensor.
 
 3. Use the radio buttons to set the direction you want: forwards or backwards.
 
 4. Type the number of ticks (16 to a rotation) you want to go by before the loop is ended (allowing your program to go forward).
 
 5. The feedback box will display the current number of ticks (16 to a rotation). Use the reset button to clear the feedback box.
 
 6. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Temperature* Sensor =====

{{attachment:loop_18.png}} <<BR>> Image of configuration panel for the Loop block, set to Temperature* Sensor – callouts 1-5

If you choose “Temperature* Sensor,” the programming blocks within the loop will repeat until a temperature* sensor measures a certain temperature. Then the loop will end and the program will advance.

 1. Choose the port where the temperature sensor is plugged in. By default, the block will be set to port 4 for a temperature sensor.
 
 2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the right of the slider if you want the block to be triggered by temperatures higher than the trigger value; select the left radio button to trigger the block with temperatures lower than the trigger value. You can also use the pull-down menu to set the “true” portion of the slider.
 
 3. Select to read values in Celsius(攝氏) or Fahrenheit(華氏).
 
 4. The feedback box displays the current temperature reading.
 
 5. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

===== Count =====

{{attachment:loop_13.png}} <<BR>> Image of configuration pane for the Loop block, set to Count

__If you choose “Count,” any programming blocks within the loop will repeat until the Counter reaches a set number of repetitions. (要遶行幾次而言, 起始值為 1)__

 1. Use this box to type in the number of repetitions that will end the loop. If you type “2,” for example, the loop will end after the programming blocks in the loop have been run twice.
 
 2. Check the “Show Counter” checkbox so that you can wire the left side of the loop to the right side (where the “count” plug appeared). With the left and right sides connected, the program will be able to count the number of completed loops and leave the loop when the count reaches the number you set.

===== Logic =====

{{attachment:loop_14.png}} <<BR>> Image of configuration pane for the Loop block, set to Logic

__If you choose “Logic” and connect an input data wire to the Loop block’s trailing portion, any programming blocks within the loop will repeat as long as the Loop block is receiving a true or false logic signal through the data wire. '''When a specified logic signal is received, the loop will end. (注意這裡的 logic signal 不一定是 true, 也可以是 false)'''__

 1. Choose which ''type of logic signal'', true or false, will end the loop.
 
 2. If the “Show Counter” checkbox is selected in the configuration panel, a plug will appear that will allow you to use the number of completed loops as an input elsewhere in your program (if you connect a data wire from the plug to another block’s data hub).

=== Stop Block ===

__This block will stop your program and any running motors, lamps or sounds. Stopped motors will start to coast. (不再鎖住馬達而言; '''我們可以說 main sequence beam 最後面 "隱含" 了一個 Stop, 明確加上之後可以強調程式在此結束, 與 starting point 互為對照''')__

{{attachment:FB_stop_01.png}} <<BR>> Image of Stop block, default settings

==== Configuring the Stop Block ====

{{attachment:FB_stop_02.png}} <<BR>> Image of configuration pane for the Stop block

The Stop block has no parameters to set.

==== Configuring the Stop block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Stop block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_stop.png}} || Stop || Logic || True/False || True if you want the program to abort, False if you don't || || 

=== Switch Block ===

__'''Use this block to choose between two or more ''sequences of code''. (對應一般程式語言 "`if...else if...else`" 或 "`switch...case`" 的語法)'''__ For example, when configured with a touch sensor, the switch block might run one ''series of blocks'' when the sensor is pressed and another when the touch sensor is not.

==== Display settings ====

{{attachment:switch_01.png}} <<BR>> Image of Switch block configured for a touch sensor; top row containing a motor block set to go forward followed by a sound block set to play a tone; bottom row containing a motor block set to go backwards

 1. This icon indicates the sensor or other condition that will cause the block to choose between the two rows of programming blocks. In this case the current status of a touch sensor will cause the program to switch.
 
 2. The upper blocks will run if the touch sensor is pressed.
 
 3. The lower block will run if the touch sensor is not being pressed.

{{attachment:switch_02.png}} <<BR>> Image of Switch block configured for logic, showing the tail end of a data wire connecting to the logic plug; frame should contain two move blocks (set for different directions) with one in the upper row and the other in the bottom row

 1. __If you’ve chosen to control the Switch block using the Value condition, a data wire plug will appear at the bottom of the ''leading edge'' of the Switch block; you will have to attach a logic or number data wire to this plug from some other block to control the switch.__

{{attachment:switch_02a.png}} <<BR>> Image of Switch block configured for logic, showing the tail end of a data wire connecting to the logic plug; frame should contain two move blocks (set for different directions) with one in the upper row and the other in the bottom row

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a ''tabbed'' interface to show the ''alternative'' sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.

__'''Note: When you want to attach a data wire from outside to a block inside the Switch block, you need to de-select the “Display Flat View” so the Switch block appears with its tabbed interface. (一旦有 data wires 從外面往裡面連結後, 就無法切換回 flat view 了)'''__

__'''@2008/09/14 實驗發現, 當 data wire 落在不同的 switching options 時, 會讓 data wires 的流向變得難以判讀, 大幅降低程式碼的可讀性. 建議在 switch 外部先將原先要引入的資料寫入變數, 再從 switch 內部讀取變數的內容即可.'''__

__'''雖然最開頭寫著 "choose between two or more...", 但搭配 tabbed view 時, 很直覺地實現了 "`if...`" 的語法; 採用 tabbed view 時, 也可以節省不少空間.'''__

==== Adding blocks to the Switch block: ====

Add blocks by dragging them over the empty spaces within the Switch block’s surrounding frame. The Switch block’s interior(內部) will expand so the block can fit and snap into place. If there are already blocks within the frame, drag any additional blocks over the desired ''connection point'' on the sequence beam and the adjacent(相鄰的) blocks will shift sideways allowing the new blocks to snap into place.

==== Moving the Switch block: ====

The Switch block can only be selected and moved by clicking on the block itself; clicking on the surrounding frame or on the blocks inside the frame will not work.

==== Configuring the Switch block: ====

The Control property pull-down menu will let you choose from two primary conditions that will affect your switch:

 * Value
 * Sensor (which will activate a second pull-down menu)
   * Touch Sensor
   * Light Sensor
   * Sound Sensor
   * Ultrasonic Sensor
   * NXT Buttons
   * Built-in Rotation Sensor
   * Timer
   * Receive Message
   * Touch* Sensor
   * Light* Sensor
   * Rotation* Sensor
   * Temperature* Sensor

===== Value =====

__A Switch block set to “Value” can accept either logic or number input through a data wire connected to its leading edge. It will detect the kind of data wire attached to its plug (i.e., logic or number; 也可以是 Text 型態) and offer different ''switching options'' for each.__

If you connect a logic (true/false) data wire, the program will run the programming blocks on the upper sequence beam when the Switch block is receiving a “true” signal. If the block is receiving a “false” signal, the program will run the blocks on the lower sequence beam.

If you connect a number or a text data wire, you can specify the ''exact input'' that will cause the programming blocks on the different sequence beams to run. __Furthermore, if the Display Flat View option is de-selected, you can switch to more than two sets of programming blocks. '''(在 flat view 下, 無法增加第三個選項; 相反地, 在 tabbed view 下, 有三個以上的選項時, 就無法切回 flat view)'''__

{{attachment:switch_03.png}} <<BR>> Image of the configuration panel for Switch – Value

 1. This field will show the type of input ''detected'' by the block. (除了可以手動選取之外, 也會依 input data wire 的型態自動改變)

 2. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you’ll be able to view and edit the blocks and see what condition will cause those particular blocks to run.

 3. Each row in the table represents a switching option. When “Display Flat View” is checked, the upper most option, number 1, represents the condition that will cause the programming blocks on the upper sequence beam to run. The second option, number 2, represents the condition that will cause the blocks on the lower sequence beam to run.

    .If a Number or Text data wire is connected to the Switch block and the “Display Flat View” is de-selected (enabling the tabbed interface), you can add additional rows to the table that will control more sequences of blocks as in the image below.

    .{{attachment:switch_03a.png}} Image of the configuration panel for Switch – Value

 4. __This box serves two roles. When the Switch block is set for logic input, '''this box’s pull-down arrow will let you ''flop(變節)'' the blocks on the two sequence beams, changing which one group will be activated by a “true” signal; 不論切換成 true 或 false, 只要透過這個下拉選單做切換, 就會將 true/false 對應的程式碼對調)''' When the Switch block is set for number input, use this box to type in the number that will activate a certain switching option.__
 
 5. These buttons will let you add and delete switching options. (為什麼自動排列 options, 會造成什麼問題[?]) They are only active when the Flat View is de-selected and a number or text data wire is connected to the Switch block’s input plug.
 
 6. __The “*” button will set the default option in the list. When the Switch block is set for number data and a ''signal'' arrives that does not match one of the set numerical options, the block will run whichever option is set as the default. '''(如果希望在沒有符合的條件時 "不做任何事情" 的話, 記得要追加一個沒有實作的 switch option)'''__

===== Touch Sensor =====

{{attachment:switch_04.png}} <<BR>> Image of configuration pane for the Switch block, set to Touch Sensor

Choose this control property if you want the condition of a touch sensor to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.

 2. Choose the port where your touch sensor is plugged in. By default, the block will be set to port 1 for a touch sensor. You can change this selection if you need to.
 
 3. __With the radio buttons you can specify which touch sensor condition (Pressed, Released, or Bumped) will cause the Switch block to run the blocks in the upper switch area; the lower switch area will run when ''no action occurs''. '''(其中 bumped 跟 Loop Touch 的做法不太一樣; 實驗發現, 必須要在 swith 一開始檢查的 "瞬間" 完成 "按下與放開" 的動作才能讓 bumped 的條件成立, 因此 bumped 並不實用)'''__ If you choose Pressed, the block will switch ''at the instant'' the touch sensor is pressed in. If you choose Released, the block will switch at the instant the touch sensor is released. If you choose Bumped, the block will switch ''at the instant'' the touch sensor is bumped.

===== Sound Sensor =====

{{attachment:switch_05.png}} <<BR>> Image of configuration pane for the Switch block, set to Sound Sensor

Choose this control property if you want the readings from a sound sensor to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.

 2. Choose the port where your sound sensor is plugged in. By default, the block will be set to port 2 for a sound sensor. You can change this selection if you need to.

 3. Use the slider to set the ''trigger value'' or type a value directly into the input box. At the default setting of 50%, the program will run the programming blocks on the upper sequence beam if the sound sensor detects sound levels above 50% and run the blocks on the lower sequence beam if the sound level is less than 50%.

===== Light Sensor =====

{{attachment:switch_06.png}} <<BR>> Image of configuration pane for the Switch block, set to Light Sensor

Choose this control property if you want the readings from a light sensor to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.
 
 2. Choose the port where your light sensor is plugged in. By default, the block will be set to port 3 for a light sensor. You can change this selection if you need to.

 3. Use the slider to set the trigger value or type a value directly into the input box. At the default setting of 50%, the program will run the programming blocks on the upper sequence beam if the light sensor detects light levels above 50% and run the blocks on the lower sequence beam if the light level is less than 50%.

 4. If you check the “Generated Light” checkbox, the light sensor will turn on its own small light source and detect this light if it is reflected back to it.

 5. The feedback box displays the current light reading (0-100%).

@2008/11/14 實驗發現, 以 Switch Light 去偵測亮度時並沒有效果, 反而是 Light Sensor 搭配 Value Switch 比較靈敏?

===== Ultrasonic Sensor =====

{{attachment:switch_07.png}} <<BR>> Image of configuration pane for the Switch block, set to Ultrasonic Sensor

Choose this control property if you want the distance readings from an ultrasonic sensor to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.
 
 2. Choose the port where your ultrasonic sensor is plugged in. By default, the block will be set to port 4 for an ultrasonic sensor. You can change this selection if you need to.
 
 3. Use the slider to set the trigger value or type a value directly into the input box. At the default setting of 50 (127 cm), the program will run the programming blocks on the upper sequence beam if the ultrasonic sensor detects an object at farther than 50 inches (127 cm) and run the blocks on the lower sequence beam if it detects an object at less than 50 inches (127 cm).

 4. Select to read values in Centimeters or Inches.

 5. The feedback box displays the current ultrasonic reading.

===== NXT Buttons =====

{{attachment:switch_08.png}} <<BR>> Image of configuration pane for the Switch block, set to NXT Buttons

If you choose “NXT Buttons,” the program will run the programming blocks on the upper sequence beam when the chosen NXT button is bumped, pressed, or released. It will run the blocks on the lower sequence beam when no action occurs.

 1. Select which NXT button will send out a “true” signal when activated.
 
 2. __Choose Bumped if you want the button to be activated ''after'' a quick press and release. '''(跟 Switch Touch 的狀況又不一樣了, 只要在 switch 做條件檢查之前有完成 "按下與放開" 的動作即可, 不管兩個動作的間隔時間是否在 0.5 秒以內)'''__ Choose Pressed if you want the button to be activated at the instant the button is pressed in. Choose Released if you want the button to be activated at the instant the button is released.

===== Built-in Rotation Sensor =====

{{attachment:switch_09.png}} <<BR>> Image of configuration pane for the Switch block, set to Built-in Rotation Sensor

Choose this control property if you want the number of counted rotations or degrees to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.
 
 2. __If you choose "Reset," the Switch block will read the rotation sensor's value and then reset the sensor's value to zero. If you choose "Read," the sensor's value will not be reset.__

 3. Choose the port you would like to monitor.
 
 4. Use the radio buttons to set the direction you want: forwards or backwards.
 
 5. Choose to count either Rotations or Degrees by using the pull-down menu.
 
 6. Type a value into the input box to set the trigger point. The default value is 360 degrees. At this setting, the program will run the programming blocks on the upper sequence beam if the number of counted degrees is more than 360 and run the blocks on the lower sequence beam if the number of degrees is less than 360.

 7. The feedback box will display the current number of rotations or degrees.

===== Timer =====

{{attachment:switch_10.png}} <<BR>> Image of configuration pane for the Switch block, set to Timer

Choose this control property if you want a timer’s current value to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you will be able to view and edit the blocks and see which condition will cause those particular blocks to run.
 
 2. __If you choose "Reset," the Switch block will read a timer's value and then reset the timer to zero. If you choose "Read," the timer will not be reset.__

 3. Choose which of the NXT’s three timers you would like to monitor.

 4. Type a value into the input box to set the trigger point. The default value is 5 seconds. At this setting, the program will run the programming blocks on the upper sequence beam if the current time is more than 5 seconds and run the blocks on the lower sequence beam if the current time is less than 5 seconds.

===== Receive Message =====

{{attachment:switch_11.png}} <<BR>> Image of configuration pane for the Loop block, set to Receive Message

If you choose “Receive Message,” the program will run the programming blocks on the upper sequence beam when a certain Bluetooth message is received. It will run the blocks on the lower sequence beam if the message is not received.

 1. The pull-down menu will let you select the message type (Text, Number, or Logic) of the message that you expect to receive.

 2. To compare the incoming message to a test message, either type in the test text or number (if you have chosen Text or Number respectively as the format), or use the radio buttons to choose the test logic value (true or false). If any incoming message matches the test message or value, the program will run the blocks on the upper sequence beam. Otherwise, the blocks on the lower sequence beam will run.

 3. Choose the ''mailbox number'' where the incoming message will arrive.

===== Touch* Sensor =====

{{attachment:switch_12.png}} <<BR>> Image of configuration pane for the Switch block, set to old Touch* Sensor – add callouts 1-3

Choose this control property if you want the condition of a touch* sensor to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you’ll be able to view and edit the blocks and see what condition will cause those particular blocks to run.

 2. Choose the port where your touch sensor is plugged in. By default, the block will be set to port 1 for a touch sensor.

 3. With the radio buttons you can specify which touch sensor condition (Pressed, Released, or Bumped) will cause the Switch block to run the blocks in the upper switch area; the lower switch area will run when no action occurs. If you choose Pressed, the block will switch at the instant the touch sensor is pressed in. If you choose Released, the block will switch at the instant the touch sensor is released. If you choose Bumped, the block will switch ''at the instant'' the touch sensor is bumped.

===== Light* Sensor =====

{{attachment:switch_13.png}} <<BR>> Image of configuration pane for the Switch block, set to old Light* Sensor – callouts 1-4

Choose this control property if you want the readings from a light* sensor to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you’ll be able to view and edit the blocks and see what condition will cause those particular blocks to run.

 2. Choose the port where your light sensor is plugged in. By default, the block will be set to port 3 for a light sensor. You can change this selection if you need to.

 3. Use the slider to set the trigger value or type a value directly into the input box. At the default setting of 50%, the program will run the programming blocks on the upper sequence beam if the light sensor detects light levels above 50% and run the blocks on the lower sequence beam if the light level is less than 50%.

 4. The feedback box displays the current light reading (0-100%).

===== Rotation* Sensor =====

{{attachment:switch_14.png}} <<BR>> Image of configuration pane for the Switch block, set to old Rotation* Sensor – callouts 1-5

Choose this control property if you want the number of counted ticks (16 to a rotation) to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you’ll be able to view and edit the blocks and see what condition will cause those particular blocks to run.

 2. Choose the port you would like to monitor.

 3. Use the radio buttons to set the direction you want: forwards or backwards.

 4. Type a value into the input box to set the trigger point. The default value is 16 ticks (16 to a rotation). With the pull-down menu set to “>”, the program will run the programming blocks on the upper sequence beam if the number of counted ticks is more than 16 and run the blocks on the lower sequence beam if the number of ticks is less than 16. Setting the pull-down menu to “<” will reverse the above scenario.

 5. The feedback box will display the current number of ticks.

===== Temperature* Sensor =====

{{attachment:switch_15.png}} <<BR>> Image of configuration panel for the Switch block, set to Temperature* sensor

Choose this control property if you want the temperature to determine which way your program will switch.

 1. By de-selecting the “Display Flat View” checkbox, the Switch block will use a tabbed interface to show the alternative sequences of programming blocks. By clicking on a tab, you’ll be able to view and edit the blocks and see what condition will cause those particular blocks to run.
 
 2. Choose the port where the temperature sensor is plugged in. By default, the block will be set to port 4 for a temperature sensor. You can change this selection if you need to.
 
 3. Use the slider to set the trigger value or type a value directly into the input box. The default value is 25° C or 77° F. With the pull-down menu set to “>”, the program will run the programming blocks on the upper sequence beam if the temperature is less than 25° C/77° F and run the blocks on the lower sequence beam if the temperature is higher than 25° C/77° F. Setting the pull-down menu to “>” will reverse the above scenario, as will choosing the opposite radio button.
 
 4. Select to read values in Celsius or Fahrenheit.
 
 5. The feedback box displays the current temperature reading.

=== Wait Block ===

__This block lets your robot sense(偵測) its environment for a certain condition ''before'' it continues. Use the slider or type in a value to set a trigger point so that the program continues when ''sensor values'' are below or above it.__

{{attachment:wait_01.png}} <<BR>> Image of Wait block, default settings

 1. The number or letter at the top right corner of the Wait block shows the port the block is monitoring. The configuration panel, which is described below, will let you change ports if necessary.
 
 2. If you have chosen to wait for a light, sound, or ultrasonic sensor, __this icon indicates at what ''level'' the trigger point is set (跟 less/greater than 的設定無關); the more ''colored bars'' displayed, the higher the trigger point.__ If you have chosen to wait for a touch sensor, the icon will display the touch sensor condition (bumped, pressed, or released) that will trigger the block and allow the program to move on.

==== Configuring the Wait Block ====

The Control property pull-down menu will let you choose from two primary conditions to wait for:

 * Sensor (which will activate a second pull-down menu)
   * Touch Sensor
   * Sound Sensor
   * Light Sensor
   * Ultrasonic Sensor
   * NXT Buttons
   * (Built-in) Rotation Sensor
   * Timer
   * Receive Message
   * Touch* Sensor
   * Light* Sensor
   * Rotation* Sensor
   * Temperature* Sensor
 * Time

===== Touch Sensor =====

{{attachment:wait_02.png}} <<BR>> Image of the configuration pane for the Wait-Touch Sensor block

Choose “Touch Sensor” and your program will wait for a touch sensor to be bumped, pressed, or released before going on the next block in your program.

 1. Choose the port that the touch sensor is connected to. By default, the block will be set to port 1 for a touch sensor.
 
 2. Use the radio buttons to specify whether you want the touch sensor to be bumped, pressed, or released to let the program continue. Choose Bumped if you want the block to be triggered after a ''quick press and release'' of the touch sensor. Choose Pressed if you want the block to be triggered at the ''instant''(按下的那一刻) the touch sensor is pressed in. Choose Released if you want the block to be triggered at the instant the touch sensor is released.
 
 3. __The feedback box will let you test your touch sensor. When the sensor is ''activated'' (意指 trigger point 條件成立而言) on your robot, the number 1 will be displayed here. '''(實驗發現, 數字的反應會隨 bumped, pressed, released 有所不同. 選擇 pressed/released 時, 0 代表此時處於指定的狀態, 1 則代表此時不處於指定的狀態, 因此數字會在 0 與 1 之間跳動; 選擇 bumped 時, 數字代表發生 bumped 的次數, 因此次數會從 0 往上累加)'''__

__'''其實 pressed 與 released 都不是在等待按下或放開的 "動作", 而是在等待 "狀態";''' 用下面的程式做實驗:__

 * 等待 pressed 時, 若按住按鈕, 就會一直重複嗶嗶叫.
 * 等待 released 時, 若沒有按下按鈕, 就會一直重複嗶嗶叫.
 * __等待 bumped 時, 若按下按鈕再放開才會嗶一聲; '''發現並沒有如官方文件所說的, bumped 必須要在 0.5 秒內完成按下與放開才算.'''__

{{attachment:wait_touch.png}}

===== Sound Sensor =====

{{attachment:wait_03.png}} <<BR>> Image of the configuration pane for the Wait-Sound Sensor block

Choose “Sound Sensor” and your program will wait for the sound sensor to be activated by a certain intensity of sound.

 1. Choose the port where your sound sensor is plugged in. By default, the block will be set to port 2 for a sound sensor.
 
 2. Use the slider to set the trigger value or type a value into the input box. Select the radio button to the right of the slider if you want the block to be triggered by sound levels higher than the trigger value; select the left radio button to trigger the block with sound levels lower than the trigger value. You can also use the pull-down menu to set the ''“true” portion'' of the slider.
 
 3. The feedback box displays the current sound reading (0-100%). You can use it to try out different trigger values.

===== Light Sensor =====

{{attachment:wait_04.png}} <<BR>> Image of the configuration pane for the Wait-Light Sensor block

Choose “Light Sensor” and your program will wait for a light sensor to be activated by a certain intensity of light.

 1. Choose the port where your light sensor is plugged in. By default, the block will be set to port 3 for a light sensor.
 
 2. Use the slider to set the trigger value or type a value into the input box. Select the radio button to the right of the slider if you want the block to be triggered by light levels higher than the trigger value; select the left radio button to trigger the block with light levels lower than the trigger value. You can also use the pull-down menu to set the “true” portion of the slider.
 
 3. __If you check the “Generated Light” checkbox, the light sensor will turn on its own small light source and detect this light if it is ''reflected back'' to it.__
 
 4. The feedback box displays the current light reading (0-100%). You can use it to try out different trigger values. (實驗發現這個數值不會動, 會不會是因為在 VM 下操作的關係[?])

===== Ultrasonic Sensor =====

{{attachment:wait_05.png}} <<BR>> Image of the configuration pane for the Wait-Ultrasonic Sensor block

Choose “Ultrasonic Sensor” and your program will wait for the ultrasonic sensor to be activated by detecting an object at a certain distance.

 1. Choose the port where your Ultrasonic sensor is plugged in. By default, the block will be set to port 4 for an ultrasonic sensor.
 
 2. If you choose the radio button to the left of the slider, the block will be triggered when it detects an object that is closer than the trigger distance; select the right radio button to trigger the block when it detects an object farther away than the trigger distance. Use the slider to set the trigger distance or type a value directly into the input box (0-250 if configured for centimeters or 0-100 if configured for inches. Remember that highly reflective surfaces can be detected farther away than non-reflective surfaces.
 
 3. Select to read values in Centimeters or Inches.
 
 4. __The feedback box displays the current ultrasonic reading (0-250 cm or 0-100 inches). A reading of 0 indicates the ''closest distance'' the sensor can detect. (從沒看過 0, 是因為感應器有問題嗎[?]) If configured for centimeters, a reading of 250 indicates the ''farthest distance'' the sensor can detect (i.e., roughly 250 cm). If configured for inches, a reading of 100 indicates the farthest distance the sensor can detect (i.e., roughly 100 in).__

===== NXT Buttons =====

{{attachment:wait_06.png}} <<BR>> Image of configuration pane for Wait - NXT Buttons

If you choose “NXT Buttons,” the program will wait for a chosen NXT buttons to be bumped, pressed, or released before moving on. (沒有提供 feedback box, 可能是因為連線期間 NXT 是開著的, 按鍵的測試就是 NXT 的操作)

 1. Select which NXT button will send out a “true” signal when activated and cause the program to move on.
 
 2. Choose Bumped if you want the chosen button to be activated after a quick press and release. Choose Pressed if you want the chosen button to be activated at the instant the button is pressed in. Choose Released if you want the chosen button to be activated at the instant the button is released.

===== (Built-in) Rotation Sensor =====

{{attachment:wait_07.png}} <<BR>> Image of configuration pane for Wait - Built-in Rotation Sensor

If you choose “Rotation Sensor,” the program will advance(前進) when a motor has turned a set number of rotations or degrees.

 1. Choose the port where your motor is plugged in.
 2. Use the radio buttons to set the direction you want: forwards or backwards.
 3. Choose to count either Rotations or Degrees by using the pull-down menu.
 4. Type the number of rotations or degrees you want to go by before your program moves forward).
 5. The feedback box will display the current number of rotations or degrees. Use the reset button to clear the feedback box.

===== Timer =====

{{attachment:wait_08.png}} <<BR>> Image of configuration pane for Wait - Timer

If you choose “Timer,” the program will advance when one of the NXT’s ''internal timers'' reaches a certain time value.

 1. Choose the NXT timer that you would like to monitor.
 2. Type a time value (in seconds) in the input box. You can use the arrows to increase or decrease the value.

===== Receive Message =====

{{attachment:wait_09.png}} <<BR>> Image of configuration pane for Wait - Receive Message

If you choose “Receive Message,” the program will advance when your NXT receives a certain Bluetooth message.

 1. The pull-down menu will let you select the ''message type'' (Text, Number, or Logic) of the message that you expect to receive.
 
 2. To compare the incoming message to a ''test message'', either type in the test text or number (if you have chosen Text or Number respectively as the format), or use the radio buttons to choose the test logic value (true or false).
 
 3. Choose the ''mailbox number'' where the incoming message will arrive.

===== Touch* Sensor =====

{{attachment:wait_11.png}} <<BR>> Image of the configuration panel for the Wait-old Touch* Sensor block – callouts 1-3

Choose “Touch* Sensor” and your program will wait for a touch sensor to be bumped, pressed, or released before going on the next block in your program.

 1. Choose the port that the touch sensor is connected to. By default, the block will be set to port 1 for a touch sensor.
 
 2. Use the radio buttons to specify whether you want the touch sensor to be bumped, pressed, or released to let the program continue. Choose Bumped if you want the block to be triggered after a quick press and release of the touch sensor. Choose Pressed if you want the block to be triggered at the instant the touch sensor is pressed in. Choose Released if you want the block to be triggered at the instant the touch sensor is released.
 
 3. The feedback box will let you test your touch sensor. When the sensor is activated on your robot, the number 1 will be displayed here.

===== Light* Sensor =====

{{attachment:wait_12.png}} <<BR>> Image of the configuration panel for the Wait-old Light* Sensor block – callouts 1-3

Choose “Light* Sensor” and your program will wait for a light sensor to be activated by a certain intensity of light.

 1. Choose the port where your light sensor is plugged in. By default, the block will be set to port 3 for a light sensor.
 
 2. Use the slider to set the trigger value or type a value into the input box. Select the radio button to the right of the slider if you want the block to be triggered by light levels higher than the trigger value; select the left radio button to trigger the block with light levels lower than the trigger value. You can also use the pull-down menu to set the “true” portion of the slider.
 
 3. The feedback box displays the current light reading (0-100%). You can use it to try out different trigger values.

===== Rotation* Sensor =====

{{attachment:wait_13.png}} <<BR>> Image of configuration panel for Wait-old Rotation* Sensor – callouts 1-4

If you choose “Rotation* Sensor,” the program will advance when a rotation* sensor has turned a set number of ''ticks'' (16 per rotation; 好特別的單位).

 1. Choose the port where your rotation sensor is plugged in. By default, the block will be set to port 2 for a rotation sensor. You can change this selection if you need to.
 
 2. Use the radio buttons to set the direction you want: forwards or backwards.
 
 3. Set the trigger point by typing a value into the input box. Choose greater than (>) if you want the block to be triggered when the number of ticks (16 to a rotation) is more than the trigger value; choose less than (<) to trigger the block when the number of ticks is less than the trigger value.
 
 4. The feedback box will display the current number of rotations or ticks. Use the reset button to clear the feedback box.

===== Temperature* Sensor =====

{{attachment:wait_14.png}} <<BR>> Image of configuration panel for Wait-Temperature* sensor block – callouts 1-4

If you choose “Temperature* Sensor,” the program will advance when the temperature reaches a certain level.

 1. Choose the port where the temperature sensor is plugged in. By default, the block will be set to port 4 for a temperature sensor.
 
 2. Use the slider to set the trigger value or type a value directly into the input box. Select the radio button to the right of the slider if you want the block to be triggered by temperatures higher than the trigger value; select the left radio button to trigger the block with temperatures lower than the trigger value. You can also use the pull-down menu to set the “true” portion of the slider.
 
 3. Select to read values in Celsius or Fahrenheit.
 
 4. The feedback box displays the current temperature reading.

===== Time =====

{{attachment:wait_10.png}} <<BR>> Image of the configuration pane for the Wait-Timer block

Choose “Time” if you want your program to hesitate for a period of time before going on to the next block.

 1. Choose how many seconds you would like wait before the program moves on. You can specify this in 1/10s of a second (example: 12,3 or 12.3 (US); 實驗發現, 甚至可以輸入 0.001 秒).

== Data Blocks ==

=== Compare Block ===

{{attachment:e065_comparison.png}} This block can determine if a number is greater than (>), less than (<), or equal to (=) another number. The input numbers can be typed in or supplied dynamically by data wires.

{{attachment:DB_compare_01.png}} <<BR>> Image of block

 1. A Compare block dropped into the work area will have an open data hub with two input ports (on the left) and three output ports (on the right). Both input ports will have to be connected to other blocks using data wires (except when one of the input ports is supplied by a constant value that you type in).

    .Output from the comparison will be delivered from the bottommost output plug; connect this plug using a data wire to another block’s data hub. The two output plugs opposite the input plugs allow you to pass the input values on to other blocks if this is necessary.

==== Configuring the Compare Block ====

{{attachment:DB_compare_02.png}} <<BR>> Image of configuration panel

 1. Input numbers can be typed in or supplied dynamically by data wires. The input boxes will be grayed out when data wires are connected.
 
 2. The pull-down menu will let you choose from five comparisons you can perform: __'''(@2008/09/25 實驗發現下面 "... or equal to" 的說法是不成立的, 實務上若有 "大於等於" 或 "小於等於" 的需要, 要另外搭配 Logic Block 來做邏輯運算)'''__
 
    * Greater Than (>): In this case, if the first input number is ''greater than or equal to'' the second input number, the Compare block will return a value of “true.” Otherwise, it will return a value of “false.”
    
    * Less Than (<): In this case, if the first input number is ''less than or equal to'' the second input number, the Compare block will return a value of “true.” Otherwise, it will return a value of “false.”
    
    * Equal To (=): In this case, if the first input number is equal to the second input number, the Compare block will return a value of “true.” Otherwise, it will return a value of “false.”

==== Configuring the Compare block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Compare block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_A.png}} || A || Number || -2147483648 - 2147483647 || Left operand || ||
|| {{attachment:helpadd_B.png}} || B || Number || -2147483648 - 2147483647 || Right operand || ||
|| {{attachment:helpadd_result.png}} || Result || Logic || True/False || Result of operation || ||

=== Logic Block ===

{{attachment:e020_boolean.png}} This block performs a logical operation on its inputs and sends out the true/false answer by a data wire. The inputs (which must also be “true” or “false”) can be set using the radio buttons or supplied dynamically from data wires.

__The Logic block uses only two possible values, “true” and “false,” for both input and output. Often these values are ''written'' as the numbers “1” and “0” where any true statement is written as a 1 and any false statement is written as a 0. (實驗確認, 下面 "use the values 1 and 0 as input" 的說法完全不成立, 因為會遇到型態不符的錯誤)__

This system is very simple for computers to understand because computer memory has an easy time recording “binary” values, values that come in only two states like the 1 and 0. Computers handle more complicated numbers and equations by building up(發展) from 1 and 0. (用二進位的 0 與 1 來表示 0 與 1 以外的數字而言)

__Note: you can use the values 1 and 0 as input to this block but they must be supplied by logic data wires.__

__The four logical operations that this block can perform allow you to perform ''a series of'' comparisons. (再複雜的邏輯運算, 也都是兩兩運算而來)__ The details of these operations (And, Or, Xor, and Not) are described below.

{{attachment:DB_logic_01.png}} <<BR>> Image of Logic block, default settings

 1. A Logic block dropped into the work area will open with two input ports and three output ports. The input ports will have to be connected to other blocks using data wires (except when one of them is supplied by a constant value that you set with radio buttons).

    .Output from the logical operation will be delivered from the bottommost output plug; connect this plug using a data wire to another block’s data hub. The two output plugs opposite the input plugs allow you to pass the input values on to other blocks if this is necessary.

==== Configuring the Logic Block ====

{{attachment:DB_logic_02.png}} <<BR>> Image of configuration panel

 1. Use the radio buttons to choose inputs A and B or let input data wires supply the input values dynamically.
 
 2. The pull-down menu will let you choose from four operations you can perform on the inputs:
 
    * An “And” Operation
    * An “Or” Operation
    * An “Xor” Operation
    * A “Not” Operation

'''“And” Operation'''

{{attachment:DB_logic_03.png}} With the “And” operation, if your two input values are both “true,” then the output is also equal to “true”; in all other cases the output will be “false.”

This is easy to understand if you look at a “logic table”:

|| Input A || Input B || Output ||
|| False (0) || False (0) || False (0) ||
|| False (0) || True (1) || False (0) ||
|| True (1) || False (0) || False (0) ||
|| True (1) || True (1) || True (1) ||

You can see that only when both input values are equal to “true” is the answer “true”; in all other cases the output is value is “false.”

'''“Or” Operation'''

{{attachment:DB_logic_04.png}} With the “Or” operation, if one or both of your two input values is “true,” then the output is equal to “true.”

|| Input A || Input B || Output ||
|| False (0) || False (0) || False (0) ||
|| False (0) || True (1) || True (1) ||
|| True (1) || False (0) || True (1) ||
|| True (1) || True (1) || True (1) ||

'''“Xor” Operation'''

{{attachment:DB_logic_05.png}} __With the “Xor” operation, if either one of your two input values is “true,” but not both, then the output is equal to “true.”__

|| Input A || Input B || Output ||
|| False (0) || False (0) || False (0) ||
|| False (0) || True (1) || True (1) ||
|| True (1) || False (0) || True (1) ||
|| True (1) || True (1) || False (0) ||

'''“Not” Operation'''

{{attachment:DB_logic_06.png}} __The “Not” operation is sometimes called an “inverter.” This operation has only one input value. If this input value is “true,” the output is equal to “false”; if the input value is “false,” the output is equal to “true.” It just flips the input value.__

|| Input A || Output ||
|| True (1) || False (0) ||
|| False (0) || True (1) ||

==== Configuring the Logic block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Logic block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_A.png}} || A || Logic || True/False || Left operand || ||
|| {{attachment:helpadd_B.png}} || B || Logic || True/False || Right operand || Operation is not "Not" ||
|| {{attachment:helpadd_result.png}} || Result || Logic || True/False || Result of operation || ||

=== Math Block ===

{{attachment:e030_numeric.png}} This block performs simple arithmetic operations like addition, subtraction, multiplication, and division. The input numbers can be typed in or supplied dynamically by data wires.

__'''注意這個 Block 不支援浮點運算, 設計時期無法輸入小數, 執行期運算的結果也直接去掉小數的部份. 例如 `1 / 2 = 0.5 = 0`, `7 / 4 = 1.75 = 1`. 不過這個問題其實是有解的, 只需要一點小技巧 [[NXT-G|...]]'''__

{{attachment:DB_math_01.png}} <<BR>> Image of Math block, default settings

 1. A Math block dropped into the work area will have an open data hub with two input plugs (on the left) and three output plugs (on the right). The input numbers for the arithmetic equation can be typed in or supplied dynamically by data wires.

    .Output from the equation will be delivered from the bottommost output plug; connect this plug using a data wire to another block’s data hub. The two output plugs opposite the input plugs allow you to pass the input numbers on to other blocks if this is necessary.

{{attachment:DB_math_02.png}} <<BR>> Image of configuration pane for the Math block

 1. Input values can be typed in or supplied dynamically by data wires. The input boxes will be grayed out when data wires are connected.
 
 2. The pull-down menu will let you choose from four arithmetic operations you can perform:
 
    * Addition (+) [default]: In this case, the two input numbers will be added together with the sum sent to the output.
    
    * Subtraction (-): In this case, the second input number will be subtracted from your first number with the difference sent to the output.
    
    * Multiplication (x): In this case, the two input numbers will multiplied together with the total sent to the output.
    
    * Division (/): In this case, the first input number will be divided by the second input number with the quotient sent to the output.

==== Configuring the Math block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Math block’s data hub:

||  || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_A.png}} || A || Number || -2147483648 - 2147483647 || Left operand || ||
|| {{attachment:helpadd_B.png}} || B || Number || -2147483648 - 2147483647 || Right operand || ||
|| {{attachment:helpadd_math_result.png}} || Result || Number || -2147483648 - 2147483647 || Result of operation ||

=== Random Block ===

{{attachment:dice.png}} __This block generates a random number. You can use random numbers to create unpredictable behavior by your robot.__ For instance, if you use a data wire to connect a Random block to the Duration plug of a Move block's data hub, your robot might go forward for four seconds one time but then eight seconds the next time you run the program.

__The random number will be generated between (and including) minimum and maximum limits that you set.__ If you want to generate random numbers between 5 and 10, and including 5 and 10 as the possible numbers, set the minimum value to 5 and the maximum value to 10. If you don’t want 5 or 10 to be within the set of possible random numbers, choose a minimum value of 6 and a maximum value of 9.

Set the minimum and maximum limits either by using the slider or by typing values into the input box. To get a dynamic number, attach input data wires to the block’s data hub.

Output for the block (i.e., the random number) can only be sent through a data wire from the output value (#) plug.

{{attachment:DB_random_01.png}} <<BR>> Image of Random block, with data hub open

 1. This block’s data hub will open automatically when the block is attached to a sequence beam.

==== Configuring the Random Block ====

{{attachment:DB_random_02.png}} <<BR>> Image of the configuration pane for the Random block

 1. Set the minimum and maximum limits either by using the two sliders handles or by typing in numbers. __The upper limit of the slider is marked as 100, but if an upper limit is typed into the value box, it can be above 100. You can also type a negative number into the minimum limit box; this will override the slider.__ To set the minimum and maximum limits dynamically, attach input data wires to the block’s data hub.

==== Configuring the Random block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Random block’s data hub:

|| Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_A.png}} || A || Number || 0 - 32767 || Lower limit || ||
|| {{attachment:helpadd_B.png}} || B || Number || 0 - 32767 || Upper limit || ||
|| {{attachment:helpadd_number.png}} || Number || Number || Lower limit - Upper limit || A random value between lower and upper limits (including the limit values) || ||

=== Range Block ===

{{attachment:e060_range.png}} This block can determine if a number is either inside or outside of a range of numbers. The input numbers can be typed in, set using the sliders, or supplied dynamically by data wires. The output logic (true/false) signal will be sent by a data wire.

{{attachment:DB_range_01.png}} <<BR>> Image of Range block, default settings

 1. A Range block dropped on the sequence beam will have an open data hub with three input ports (on the left) and four output ports (on the right). The input ports can be connected to other blocks using data wires (except when one or more of the input ports is supplied by a number that you type in).

    .Logic output from the Range block will be delivered from the bottommost output plug; connect this plug using a data wire to another block’s data hub. The three output plugs opposite the input plugs allow you to pass the input numbers on to other blocks if this is necessary.
    
{{attachment:DB_range_02.png}} <<BR>> Image of configuration pane for the Range block

 1. The test number can be typed in or supplied dynamically using a data wire. The test box will be grayed out if a data wire is connected.
 
 2. The upper and lower bounds of the range can be set using the slider, typed in, or supplied dynamically by data wires. The input boxes will be grayed out when data wires are connected.
 
3. The pull-down menu will let you choose from two operations:

   * Inside Range (含; []): In this case, if the test number is between the upper and lower boundary numbers, ''or is equal to'' either one of boundary numbers, the Range block will return a value of “true.” Otherwise, it will return a value of “false.”
   
   * Outside Range (不含; ][): In this case, if the test number is outside the range of the upper and lower boundary numbers (and does ''not include either one'' of the boundary numbers), the Range block will return a value of “true.” Otherwise, it will return a value of “false.”

==== Configuring the Range block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Range block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_A.png}} || A || Number || -2147483648 - 2147483647 || Lower limit || ||
|| {{attachment:helpadd_B.png}} || B || Number || -2147483648 - 2147483647 || Upper limit || ||
|| {{attachment:helpadd_testvalue.png}} || Test Value || Number || -2147483648 - 2147483647 || Value to test if in/out of range || ||
|| {{attachment:helpadd_yesno.png}} || Yes / No || Logic || True/False || Result of range test || ||

=== Variable Block ===

{{attachment:e010_variables.png}} Think of a variable as a place to store a value in the NXT’s built-in memory. Other programming blocks can read the variable’s current value (and even change it) by connecting to the block with data wires.

==== Creating a Variable ====

 1. To create a variable, you must first choose the Define Variable command in the Edit menu of the software. In the dialog window, give your new variable a ''short, easy-to-understand name'' (變數的命名要容易懂是必要的, 但名字太長的話, 無法完整顯示在 block 上面) and set the type of data that the variable will hold (i.e., text, number, or logic).

 2. Then drag a Variable block into your program and select the variable’s name from the list.
 
 3. Choose to either “read” from or “write” to the variable. Choosing to write to a variable will let you change the variable’s value over time by overwriting its current value with new information. To do this, you must wire an input data wire to the block’s data hub that will deliver the new information.

 4. __You can give the variable a ''starting constant value (= initial value)'' by typing in the input box (or by using the radio buttons if your variable’s data type is set to logic; 只有 Action 為 Write 時才可以輸入, 不是讀取不到時給定預設值, 而是明確給定一個值).__

Note: if you need to change the data type or name of your variable, go back to the Define Variable command of the Edit menu and change the setting there.

==== Using a Variable ====

A variable’s value can change over time. You might create a variable called “Recorded Light Level” and give it an ''initial value'' of 50. Then as your robot (fitted with a light sensor) drives to a certain location, you can use a Variable block (set to “write”) to record the current light level at the location. To do this, you would connect an output data wire from the Light Sensor block to the input plug of the Variable block.

Later in your program you can use a Variable block (set to “read”) to read the light value recorded at the location. Other blocks connected to the block’s output plug by data wire would be able to access the information saved in the variable (i.e., the recorded light level).

{{attachment:FB_variable_01.png}} <<BR>> Image of Variable block, default settings

 1. The block’s data hub will open automatically when the block is placed in the work area. A data wire must be connected to this block’s output plug for other blocks to read the variable’s current value. To write new information to the variable, you must also connect an input data wire to the block’s data hub.

==== Configuring the Variable Block ====

{{attachment:FB_variable_02.png}} <<BR>> Image of configuration panel for the Variable block

 1. In the list, select the variable that you created using the Define Variable command of the Edit menu.
 
 2. Choose to either read the variable’s current value or write new information to the variable.
 
 3. To give your variable a constant value, either type a number or text into the input box, or use the radio buttons if the variable is of the logic data type. __Remember that if an input data wire is connected to the block and the Variable block is set to “write,” new information coming in dynamically through the data wire will take precedence over any constant value.__

Note: if you need to change the data type or name of your variable, go back to the Define Variable command of the Edit menu and change the setting there.

==== Sharing Information between a Program and a My Block ====

__In order to share data between your ''main program'' and a My Block (i.e., between two `.rbt` files; 事實上 My Block 也是 `.rbt` 檔, 所以才會有 `.rbt` 檔之間通訊的問題, 雖然同時間只能執行一支 "主程式"), do these two things:__

 1. Define a variable with the same name and data type in both the main program and in the My Block.
 
 2. Use that variable in a Variable block in the main program and in the My Block.

Any place that the variable is used will read/write to the same ''memory location'' on the NXT.

__'''只要在兩邊同時採用 "同名且同型態" 的變數即可. 這意謂著 My Block 與主程式如果 "不小心" 用到同名的變數, 可能會產生怪異的結果. (尤其注意內建的 `Logic 1`, `Number 1`, `Logic 1` 三個變數) 因此 My Block 的變數名稱, 最好加上 block 的名稱識別, 例如 "`Note_Frequency`". 在 NXT-G 使用同名且同形態的變數交換資料, 就如同在 Java 裡用 instance variable 一樣, 所以不見得這麼做就是不好, 只是要小心...'''__

 {{{
class Program {

  private frequency;
  
  public static void main(String[] args) {
    ....
    System.out.println(frequency);
    ....
    myBlock();
    ....
  }
  
  private void myBlock() {
    ...
    System.out.println(frequency);
    ...
  }

}
 }}}

__'''由於 My Block 在建立之初就要決定參數的數量及型態, 事後完全無法做變更. 或許在教程的安排上, 不要急著把 "參數" 的概念帶進來, 因為 "變數" 要搞懂就要花一段時間了... 上面 "同名且同型態" 的做法提供了一個很好的折衷. 就好像 http://users.evtek.fi/~jaanah/IntroC/DBeech/3gl_flow.htm[Designing programs with flow charts] 一文中的 subprocess 完全都沒有提到 "參數傳遞" 的概念, 當然流程圖也就沒有出現 "Input/Output" 平行四邊形'''__

__'''雖然開發環境提供有 work area map, 但 NXT-G 實在是太脆弱了, 儘可能不要讓程式超出一個螢幕, 善用 subprocess 就可以辦到...'''__

==== Configuring the Variable block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Variable block’s data hub: (可惜 Variable 不支援動態決定變數名稱, 無法拿來實作 Array 的功能)

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_value.png}} || Value* || Any || Value to read or write || ||

*This data plug will change appearance based on the variable's data type.

== Advanced Blocks ==

=== Calibration Block ====

__'''Use this block to calibrate the minimum (0%) and maximum (100%) ''values (= raw values)'' detected by a sound or light sensor. (下面 "use that value as..." 的說法在暗示什麼[?])'''__

__You will need two Calibration blocks to ''fully calibrate'' a sound or light sensor: one to set the minimum value for the sensor and another to set the maximum value. You don't need to calibrate both minimum and maximum values; if you only set one of these values, the default will be used for the other. (這裡的 default value 應該是不變吧? 否則校準 minimum 時動了 maximum, 校準 maximum 時動了 minimum, 永遠沒完沒了[?])__

__One way to fully calibrate a sound or light sensor is to set up two Calibration blocks at the beginning of your program with a Wait block (set to wait for a Touch sensor) positioned after each one.__ If your are calibrating a light sensor, for example, and you set the first Calibration block to calibrate the minimum value and the second Calibration block to calibrate the maximum value, the calibration procedure would happen like this:

 1. Place your robot in the darkest place ''it will encounter during its program'' and press the touch sensor. This will calibrate the light sensor’s minimum value.

 2. Then place your robot in the lightest place it will encounter during its program and press the touch sensor. This will calibrate the light sensor’s maximum value and your robot will continue on with its program.

__You can also calibrate a sensor by placing Calibration blocks in certain positions in your program.__ For example, if your robot with a built-in light sensor is set to drive under a table (and this will be the darkest place the robot will encounter), you can place a Calibration block (set to calibrate the light sensor’s minimum value) in your program in a position so that it is ''activated'' when the robot is passing under the table.

__'''Note: Calibration is per sensor, not per port.''' For example, if you use this block to read the light sensor on port 2 and record this value as the maximum, then ALL light sensors will ''use that value as'' maximum (whether or not they use port 2).__

Important: Be aware that you can also use the Calibrate Sensors function in the Tools menu to calibrate light and sound sensors. See the Calibrate Sensors entry in the Help section for more details.

==== Display Settings ====

{{attachment:AdB_calibration_01.png}} <<BR>> Image of Calibration block, default settings

 1. The data hub will open automatically when the block is placed in the work area. A number of parameters can be set dynamically using data wires.

==== Configuring the Calibration Block ====

{{attachment:AdB_calibration_02.png}} <<BR>> Image of configuration pane for the Calibration block

 1. Choose the port that the sensor is connected to.
 
 2. Select whether you are calibrating a Sound Sensor or a Light Sensor. (Select “Light* Sensor” if you are calibrating an older MINDSTORMS light sensor equipped with an adaptor to work with MINDSTORMS NXT.)
 
 3. __With this pull-down menu, '''choose to either calibrate a new value or delete a previously set value. (其中 "delete" 等同於 "reset" - 回到預設值而言; 不過這個 block 沒有提供讀取目前校準值的功能 (其他 blocks 也沒這個能力), 唯一可行的方式就是在校準的動作之前, 安插一個 Light/Sound Sensor 取回讀數, 這應該會和校準當下的讀數很接近才是)'''__
 
 4. Use the radio buttons to set either the maximum or minimum value of the sensor.

==== Configuring the Calibration block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Calibration block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_port.png}} || Port || Number || 1 - 4 || 1 = Port 1, 2 = Port 2, 3 = Port 3, 4 = Port 4 || Delete = True ||
|| {{attachment:helpadd_maxmin.png}} || Max/Min || Logic || True/False || True = Calibrate maximum value <<BR>> False = Calibrate minimum value || Delete = True ||
|| {{attachment:helpadd_delete.png}} || Delete || Logic || True/False || True = Delete, False = Calibrate || ||

=== File Access Block ===

{{attachment:e080_fileaccess.png}} __With this block you can save data ''from your robot'' in files on your NXT. '''After writing data to a file, you must use another File Access block to ''close'' the file before you can read or delete the file using a third File Access block.'''__

__'''相對於 close, 執行 read/write 就隱含有 open 的動作; 實驗確認, 在 read/write/delete 之間, 如果沒有安插 close 動作的話, 後面對檔案的操作都會失敗 (即便是要 delete, 也要先 close 才行), 但程式還是會繼續往下跑.'''__

檔案其實只是一個純文字檔 (ANSI 編碼) 而已; 連續寫出 `Jamie` (Text), `23` (Number), `Judy` (Text) 之後, 檔案內容如下:

 {{{
Jamie
23
Judy

 }}}

有幾個值得注意的地方:

 * 一行一個值
 * __檔案最後面固定會有一個空白行; '''讀取到這一行時, Error 會同時傳回 True, 表示這是最後一行了, 因此程式要先判斷 Error 的狀態, 再對讀取的數據做處理. 實驗發現, 把最後一行空白拿掉, 並不會造成什麼問題, 反而避開上面可能漏判斷而 "多做一次" 的問題.'''__
 * __'''從檔案內容, 我們無法判斷 "23" 當初是以 Number 或 Text 的型態寫入'''__
 * __'''連續做 read 的動作時 (指中間沒有其他 write/delete/close 的動作, 而非中間不能有其他 blocks), 會逐行讀取, 感覺像是有一個 "指標" 在記錄目前讀取到第幾行...'''__

For example, to write to a file and then read from the same file, you must close the file between those two actions. You would need three File Access blocks to accomplish this task: the first File Access block (with “Write” selected in its configuration panel) would write data to a file; a second File Access block positioned somewhere later in the program would have to be set to close the same file; a third File Access block (with “Read” selected in its configuration panel) would be able to read the file. These three blocks could be positioned right next to each other or could be spaced throughout your program.

__'''Writing to an existing file will ''add (= append)'' data to the end of the file; it will not erase any pre-existing data. To ''re-write (= overwrite)'' a file, first use a File Access block that deletes the file.''' Then use another File Access block to write to a new file of the same name.__

{{attachment:AdB_fileaccess_01.png}} <<BR>> Image of File Access block, default settings

 1. This icon indicates whether the block is set to Write, Read, Close, or Delete a file.

==== Configuring the File Access Block ====

{{attachment:AdB_fileaccess_02.png}} <<BR>> Image of configuration pane for the File Access block

 1. Use the pull-down menu to specify whether you want to Write, Read, Close or Delete a file.
 
 2. __Use the input box to either name a file (if you are writing to it for the first time) or specify an existing file by typing it in the input field or by selecting it in the pull-down menu. '''(這裡的 Name 指的是 "主檔名" 的部份; 在 NXT 檔案系統裡, 這些檔案是以 `txt` 為副檔名, 下方列出可供選取的檔案, 就是所有 `.txt` 檔的清單)'''__

 3. __Choose whether the file should be a ''text or number file''. '''(這裡 Type 在設定的是, 從文字檔下一行讀取進來的值, 要轉換成什麼型態 (Text 或 Number) 而言; 上面 "text or number file" 的說法, 僅適用於只記錄單一種型態數據的狀況)'''__
 
==== Configuring the File Access block’s Data Hub ====

This chart shows the different characteristics of the plugs on the File Access block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_filename.png}} || Filename || Text || 15 character maximum || Filename || ||
|| {{attachment:helpadd_initfilesize.png}} || Initial File Size || Number || 0 - 32767 || Valid only when file is first created (i.e., "Write" and file doesn't currently exist). || __Determines file size (單位是 byte; 這裡的 32767 就是 32K). Can be used to avoid time penalty(時間損失) associated with ''auto-resizing'' a file.__ || Action not Write, or file already exists ||
|| {{attachment:helpadd_fileaccess_text.png}} || Text || Text || Text to write || Action not Write ||
|| {{attachment:helpadd_fileaccess_number.png}} || Number || Number || -2147483648 - 2147483647 || Number to write || Action not Write ||
|| {{attachment:helpadd_error.png}} || Error || Logic || True/False || __True if an error occurred in the block (Writing and file is full, Reading and at ''end of file (EOF)'', Deleting and file didn't exist; 可以用來做錯誤處理, 其中以 EOF 的判斷最為重要)__ || ||  
|| {{attachment:helpadd_textout.png}} || Text out || Text || Text that was read || Action not Read ||
|| {{attachment:helpadd_numberout.png}} || Number out || Number || -2147483648 - 2147483647 || Number that was read || Action not Read ||

=== Keep Alive Block ===

__This block will keep the NXT from entering ''sleep mode''. Add this block if your program needs to wait for longer than the NXT’s set “sleep time” (configured using the NXT’s ''on-board menus''; 程式執行期間也算嗎[?]).__

{{attachment:AdB_keepalive_01.png}} <<BR>> Image of Keep Alive block, default settings

==== Configuring the Keep Alive Block ====

{{attachment:AdB_keepalive_02.png}} <<BR>> Image of configuration pane for the Keep Alive block

The Keep Alive block has no parameters to set.

==== Configuring the Keep Alive block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Keep Alive block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| Port || Time until sleep || Number || 0 - 4294967296 || Time in milliseconds until the NXT goes to sleep  || ||  

=== Number To Text Block ===

This block will take a number (like a reading from a sensor) and turn it into text that can be displayed on the NXT’s screen. The input number can be typed in or supplied dynamically by a data wire.

Text is ''a group of characters'' of any length that you type in using your keyboard. These are all examples of text: abcd23, Dog, John!. Text is important because it can be displayed on the NXT’s screen.

__The numbers generated by the NXT as it runs your program are not text; they can’t be displayed directly on the NXT’s screen. You must first convert them to text using a Number To Text block.__

When you convert a number into text, you can add it to a sentence that will be displayed on your NXT’s screen. By using a different block called a Text block, you can create sentences like: “The motor turned 6 times” or “The light sensor reading is 35%” that can be displayed on the NXT’s screen. In these sentences, the numbers 6 and 35 were generated by the NXT (and not typed in) and had to be processed by a Number To Text block before being added to the other pieces of text. (See the Text block entry.)

The Number To Text block’s input number can be typed in or supplied dynamically by a data wire. The output text can only be sent out using a data wire.

{{attachment:AdB_stringformat_01.png}} <<BR>> Image of block with data hub open

 1. The data hub will open automatically when the block is attached to a sequence beam. The input number can be supplied dynamically by a data wire connected to an input plug on the left side of the data hub. The output text will be sent from the output plug at the lower right.
 
    .The number output plug on the right of the data hub can be used pass any input number through to other blocks, if necessary.

==== Configuring the Number To Text Block ====

{{attachment:AdB_stringformat_02.png}} <<BR>> Image of configuration panel

 1. The input number can be typed in or supplied dynamically by a data wire.

==== Configuring the Number To Text Block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Number To Text Block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_number.png}} || Number || Number || -2147483648 - 2147483647 || Number to change to text || ||
|| {{attachment:helpadd_text.png}} || Text || Text || Text representation of number || ||

=== Reset Motor Block ===

__'''The interactive servo motors have an automatic ''error correction mechanism'' that helps your robot move very precisely.''' However, there may be times when you want to turn this feature off -- the Reset Motor block will let you do this.__

{{attachment:AdB_resetmotor_01.png}} <<BR>> Image of Reset Motor block, default settings

 1. The letter at the top right corner of the block shows which NXT port(s) will be affected by the Reset Motor block.

==== Configuring the Reset Motor Block ====

{{attachment:AdB_resetmotor_02.png}} <<BR>> Image of configuration panel for the Reset Motor block

 1. Choose which ports will be affected by the block.

==== How to use the Reset Motor block ====

If you use a single Move block (with the Next Action parameter set to Brake) to drive your robot 8 rotations forwards, it will drive exactly 8 rotations before it stops.

__You could do the same thing with 4 Move blocks, with each set to drive 2 rotations. With the Next Action parameter set to Coast on the first 3 blocks, the automatic error correction will make sure that the robot drives exactly 8 rotations.__

Assuming a level(水平的) surface or even a slight decline(下坡的), the actual distances covered by each block in this example might be as follows:

|| Block || Duration specified || Actual Duration ||
|| Move #1, Coast || 2 rotations || 2.2 rotations ||
|| Wait, 1 second || || ||
|| Move #2, Coast || 2 rotations || 2.3 rotations ||
|| Wait, 1 second || || ||
|| Move #3, Coast || 2 rotations || 2.1 rotations ||
|| Wait, 1 second || || ||
|| Move #4, Brake || 2 rotations || 1.5 rotations ||
|| TOTAL || || 8.0 rotations ||

__Note: If you set the Next Action parameter to Brake on all four Move blocks, your robot will move more precisely over each step. '''Errors only build up(逐漸形成) when you use Coast as the Next Action.'''__

__If you would rather have your robot drive 2 rotations for each Move block while allowing the wheels to coast freely without affecting the next movement, you must include a Reset Motor block. This will reset the automatic error correction.__

Using Reset Motor blocks, the example above will be changed to this:

|| Block || Duration specified || Actual Duration ||
|| Move #1, Coast || 2 rotations || 2.2 rotations ||
|| Wait, 1 second || || ||
|| Reset Motor || || ||
|| Move #2, Coast || 2 rotations || 2.3 rotations ||
|| Wait, 1 second || || ||
|| Reset Motor || || ||
|| Move #3, Coast || 2 rotations || 2.1 rotations ||
|| Wait, 1 second || || ||
|| Reset Motor || || ||
|| Move #4, Brake || 2 rotations || 2.0 rotations ||
|| TOTAL || || 8.5 rotations ||

Note: Error durations will be different depending on friction(摩擦力) and/or slope angle.

__'''Tip: You can also reset Motor and Move block motions by setting the direction to Stop.'''__

==== Configuring the Reset Motor block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Reset Motor block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_reset.png}} || Reset A || Logic || True/False || Motor A will be reset ||
|| {{attachment:helpadd_reset.png}} || Reset B || Logic || True/False || Motor B will be reset ||
|| {{attachment:helpadd_reset.png}} || Reset C || Logic || True/False || Motor C will be reset ||

=== Text Block ===

This block can ''add together'' groups of characters called text. These are all pieces of text: abcd23, Dog, john!. Text can contain numbers and even special characters like symbols and punctuation marks. Text is important because it can be displayed on the NXT’s screen.

A sentence, like this one, is a long piece of text, while each of its individual words is a smaller piece of text. The Text block can take three smaller pieces of text and put them together to make a large piece of text like a sentence.

If input A is the piece of text “This” and inputs B and C are the pieces of text “ program is “ and “great!”, the resulting, combined piece of text would be “This program is great!” __Notice that text B (“ program is “) includes two blank spaces that are important if the final sentence is to come out right.__

Numbers generated by the NXT are not ordinarily text; they can’t be displayed directly on the NXT’s screen. If you use another programming block called Number To Text, you can convert a number into text. This would allow you to use a Text block to create larger pieces of text that include numbers read from sensors like: “The motor turned 6 times” or “The light sensor reading is 35%.” Both of these pieces of text can be displayed on the NXT’s screen.

The three pieces of input text can be typed in or supplied dynamically by data wires. The output text will be sent out by data wire.

{{attachment:AdB_string_01.png}} <<BR>> Image of block with data hub open

 1. The data hub will open automatically when the block is attached to a sequence beam. The three pieces of input text can be supplied dynamically by data wires connected to the plugs on the left side of the data hub. The output text will be sent from the plug on the right at the top. The three other output plugs on the right will pass any input text information through to other blocks, if necessary.

==== Configuring the Text Block ====

{{attachment:AdB_string_02.png}} <<BR>> Image of configuration panel

 1. The three pieces of input text (A, B, & C) can be typed in or supplied dynamically by data wires. __Remember that spaces are important and will be added to the output text only if you include them in the input text.__

==== Configuring the Text block’s Data Hub ====

This chart shows the different characteristics of the plugs on the Text block’s data hub:

|| || Plug || Data Type || Possible Range || What the Values Mean || This Plug is Ignored When... ||
|| {{attachment:helpadd_A.png}} || A || Text || || || ||
|| {{attachment:helpadd_B.png}} || B || Text || || || ||
|| {{attachment:helpadd_C.png}} || C || Text || || || ||
|| {{attachment:helpadd_combinedtext.png}} || Combined Text || Text || || Combination of texts A, B, and C || ||

== Custom Blocks ==

=== My Block ===

{{attachment:icon_plt_myblocks_over_08.png}} The My Block Builder lets you take a number of blocks you select in the work area and group them together into your own My Block with a customized icon. For example, a My Block you create called “Robot Motion” might group a Move block (to control your robot’s wheels) together with a Sound block (that plays a sound file when the robot has traveled a certain distance).

When you create a new program using the same robot, you can just drag the “Robot Motion” block from the Custom palette and you will be done programming this part of the robot’s motion because you already set all of the parameters in the My Block.

__Over time you may develop a ''library'' of My Blocks that you can use in other programs and trade with other MINDSTORMS users. (引入 My Block 時, 如果圖示出現 "裂痕", 表示 block 內部有錯誤)__

==== Creating a My Block ====

 1. First select a number of blocks that logically go together. As in the example above, you might choose a number of blocks that control your robot’s movement and choose to group them into a My Block.

 2. Select the blocks by placing your mouse pointer to one corner of an imaginary rectangle that will surround all of the blocks you want in the My Block. Hold down your mouse button and sweep the pointer to the opposite corner of the imaginary rectangle, surrounding the blocks. When you release the mouse button, all of the blocks for your new My Block should be selected. Remember that a selection that partly covers a block will include that block in the My Block.

     .{{attachment:MyBlocks_01.png}} <<BR>> Image of mouse selecting Move and Sound blocks
     
 3. With the blocks selected, choose the Make a New My Block command from the Edit menu at the top of the NXT software interface. This will open the first My Block Builder wizard screen (shown below).

    .{{attachment:MyBlocks_02.png}} <<BR>> Image of first My Block Builder screen showing selected Move and Sound blocks

 4. Give your new My Block a name and write a short description of what it does. For example: “This block controls the motors of a TriBot and plays a tone when the robot has traveled one meter.” Click Next to move to the next step.

    .{{attachment:MyBlocks_03.png}} <<BR>> Image of second My Block Builder screen showing the icon design screen

 5. Next, design your new My Block’s icon. Use your mouse to drag an icon or two into the editing box. __Your keyboard's arrow keys will allow you to fine tune the positioning of the icon(s).__ The example block to the right shows what it will look like when you are done. Click Finish when you are done. Your new My Block will appear in your current program and in the Custom palette, which is accessible by clicking the right-most tab at the bottom of the programming palette. (See image below.)

    .{{attachment:MyBlocks_05.png}} <<BR>> Image showing the palette tabs and highlighted Custom palette tab

__'''Note: remember that any input or output data wires that crossed the selection frame (that first enclosed the blocks making up your My Block) will be created as input and output plugs on your new My Block’s data hub. (可以修改 plug 的名字, 而 plug 的圖示則直接延用原先端點的圖示[?])''' If you want to change the available plugs of a My Block, you will have to create the My Block again, this time with the right plugs (and corresponding data wires) extending out of the selected area.__

{{attachment:copied_parameter.png}} <<BR>> @2008/09/14 實驗確認直接複製 My Block 內部的 parameter blocks 時, 確實可以增加 parameters 在 configuration panel 供組態, 不過 plugs 並不會增加.

__'''My Block 的內容可以事後做修正, 但建立之初所規劃的參數是不能變動的, 因此 My Block 的 API 一定要事先做規劃!! 善用內建的 3 個變數 (`Text 1`, `Number 1`, `Logic 1`), 可以先將 My Block 的 API 先規劃好, 之後再實作 My Block 的內部邏輯: (又或者不要急著抽出 My Block, 採 Extract Method 的方式來做[...])'''__

{{attachment:effective_myblock.png}} <<BR>> 安排 "成對" 且不同形態變數的讀寫, 即可完成 1 個 Logic 與兩個 Number 參數的規劃 (同一變數的多條 data wires 也會被視為不同的 parameters)

{{attachment:effective_myblock_2.png}} <<BR>> __'''注意剛產生的 My Block 內部會有多個名稱同為 "`Value`" 的變數, 必須要改成不重複才行, 否則後續拉出來的 My Block 會出現裂痕.'''__

==== Editing an Existing My Block ====

If you want to change the performance of a My Block, you can edit the blocks it contains by double-clicking the My Block or by choosing Edit Selected My Block from the Edit menu. If you just want to change a My Block’s icon, you should select the block and choose the Edit My Block Icon command in the Edit menu––this will launch the My Block Builder where you can make any changes.

==== Managing the Custom Palette ====

You can add and delete My Blocks from the Custom Palette by selecting the Manage Custom Palette command in the Edit menu. __To send a My Block to a friend, make a copy of the desired My Block and attach it to an email message. If you receive a My Block from a friend, choose the Manage Custom Palette command and drag the new My Block to the My Blocks folder. '''(要注意 My Block 跟主程式一樣也是個 `.rbt` 檔)'''__

__You can create new ''sub palettes'' in the Custom palette by creating a new folder in the Block folder (指的是內含 `My Blocks` 與 `Web Blocks` 的資料夾). Customize each sub palette's appearence by placing two 45x45 pixel Portable Network Graphics (PNG) files (called `PaletteIcon.png` and `PaletteIconHilight.png`) in the sub palette's folder. You can specify a tooltip for each custom sub palette by placing a text file call `PaletteIcon.txt` (with the tooltip text in it; 預設為 "My Blocks", 不管資料夾名稱為何) in the same folder.__

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==

 * Sound Block 中的 "wait for complete" 可以勾選, 連續說出兩個字時, 就會變成句子!!

