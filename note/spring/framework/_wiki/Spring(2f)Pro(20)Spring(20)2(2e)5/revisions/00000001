= Pro Spring 2.5 =
http://www.apress.com/book/view/1590599217
<<TableOfContents>>

== Foreword ==

It was with a heavy heart(沉重的心情) that I made the decision not to participate in writing Pro Spring 2.5. I am deeply thankful that Jan was around(在旁邊) to pick up this book and run with it. Pro Spring has been a big part of my life for over three years, and I didn’t relinquish(放棄) the reins(韁繩) lightly(輕易地). When Juergen and I set out(著手) working on Spring Framework 2.0, I knew that I wouldn’t have the time to participate in the writing process and write the software at the same time. Fortunately, Jan was there to step into the breach(接替某人的位置).

Jan and Apress had additionally planned to release Pro Spring 2.0, but Juergen and I inadvertently(不注意地) made it impossible for them to keep up by making many changes to the Spring Framework. (版本的變動確實很快...) I vividly(鮮明地) remember cringing(奉承的) when updating all the JSP form tags, knowing that I was creating yet more work for Jan.

__With the 2.5 release just on the horizon(即將到來), Jan made the sensible choice to forego(放棄) a 2.0 edition and head straight for 2.5. This was a wise move. (確實 Apress 沒有出過 Pro Spring 2.0)__ The Spring Framework 2.5 release reflects the state of the art in both the Spring Framework and in enterprise Java frameworks as a whole. A guide book to this critical tool is necessary reading for any conscientious(認真的) Java developer.

I recall, back in the early days of running Cake Solutions, when we decided we needed to hire another programmer. We were very inexperienced(外行的) at hiring in general, and hiring programmers is fraught(充滿) with problems. We knew that we wanted to get a graduate(大學畢業生), but we never imagined that we would get someone as accomplished(有才能的) as Jan.

I remember, in his first week, he wrote a complete desktop mailing package from scratch—and it worked. Over the last five years, Jan has been at the center of most of the projects run at Cake, many of which are large-scale Java products based on the Spring Framework. __His knowledge of Spring comes from an immense(龐大的) amount of practical experience: he has been in the trenches(受駕馭) with Spring since version 1.0 and has delivered successful systems on top of it.__

To his credit, Jan realized that writing Pro Spring 2.5 was too big a job for just one man, so he roped in(把某人拉進來) the rest of the Cake Solutions team to help him. This prospect(景象) excited me greatly— a team of real programmers, with real experience in Spring, passing along that knowledge. There is no doubt that many will find this book to be an indispensable(不可缺少的) reference.

And so, although I am disappointed at being unable to work on this book myself, I am glad that Jan was there to deliver what so many people have been asking for, an updated version of Pro Spring. (從 Spring 1.0 到 2.5 中間隔了有一段時間...)

Enjoy,
Rob Harrop
Principal Software Engineer and Lead Engineer of the SpringSource Application Platform

== Introduction ==

__'''Recently, the Java world has witnessed(目擊) a dramatic(戲劇性的) shift away from so-called “heavyweight” architectures such as Enterprise !JavaBeans (EJB) toward lighter weight frameworks such as Spring. Complex and container-dependent services, such as CMP, and transaction management systems have been replaced with simpler alternatives such as Hibernate and aspect-oriented programming (AOP).''' At the core, Spring provides a comprehensive, lightweight container based on the principle of ''Inversion of Control (IoC)'', on which you can build your own applications. On top of this container, Spring provides a myriad of(許多) useful services, bringing together a large range of highly competent(稱職的) open source projects into ''a single cohesive(有凝聚力的) framework''.__

The quality of the Spring Framework has seen it replacing traditional Java EE architectures in many cases; as a result, more and more developers see the need for comprehensive Spring skills. __Despite Spring having quite an extensive suite of documentation and examples, we feel that many developers are still struggling to(掙扎) understand how to use Spring and, more importantly, '''how to use it effectively. (官方的文件雖然很齊全, 但由於不是針對初學者撰寫, 所以很難入門...)'''__ Because of this, we decided to write a new edition of Pro Spring.

At first, we thought we would just update a few chapters and call it Pro Spring 2.5. However, we quickly realized that Spring 2.5 brought so many new features and improvements that, although we kept the old Pro Spring name, this is a completely new book. (差異這麼大, 市面上其他 2.0 的書就別再看了...)

Through this book, you will learn how to use Spring to build better web and ''stand-alone'' applications and how to sift through(篩選) the many choices available to you through the framework. Our aim is to provide you with all the knowledge you need to use Spring effectively in your own applications and to give you insight into ''what is happening behind the scenes in Spring''.

For example, you will

 * __Learn the fundamentals of IoC ''in the context of AOP''.__

 * Become aware of the ''seamlessness'' and power of Spring by referencing the easy-to-understand sample applications we provide.

 * __Learn how to ''replace'' common EJB features with Spring alternatives, including Spring’s comprehensive ''AOP-based transaction management framework''.__

 * __Effectively manage your Spring components and applications using Spring’s ''built-in JMX engine''.__

 * Learn how to add scheduling to your Spring application with http://www.opensymphony.com/quartz/[Quartz].

After reading this book, you will be equipped with all the knowledge you need to build applications effectively using Spring and its related open source projects.

== Part 1 Getting Started with Spring ==

In this part of the book, we will introduce the Spring Framework, starting with the steps needed to download the binary and source distributions. __We will next explain the ''Inversion of Control (IoC) pattern'' and ''aspect-oriented programming (AOP)''. IoC and AOP lie at the heart of the Spring Framework.__ Toward the end of Part 1, we will show you, in full detail, various ways to configure ''Spring-managed beans''. Finally, we will round off(完成) Part 1 with a look at some of the most important Spring ''design patterns''.

== Chapter 1 Introducing Spring ==

When we think of the community of Java developers, we are reminded of(提醒) the hordes of(一大群) gold rush(淘金熱) prospectors(採礦者) of the late 1840s, frantically(瘋狂似地) panning(淘洗) the rivers of North America looking for fragments of gold. As Java developers, our rivers run rife with(充滿著) open source projects, but, like the prospectors, finding a useful project can be time consuming and arduous(費力的). __And yet, more and more developers are turning to open source tools and code. Open source brings innovative code and few restrictions on its usage, allowing developers to focus on the core of the applications they build.__

A common gripe(抱怨) about many open source Java projects is that they exist merely to fill a gap in the implementation of the latest ''buzzword-heavy technology'' or pattern. __Another problem is that some projects lose all their momentum(動力): code that looked very promising(有前途的) in version 0.1 never reaches version 0.2, much less 1.0. Having said that(話雖如此), many high-quality, user-friendly projects meet and address a real need for real applications. In the course of this book, you will meet a carefully chosen subset of these projects. '''(感覺很像是各家不同的 Linux Distributions 會各自嚴選不同的套件來做搭配一樣)'''__ You will get to know one in particular rather well—Spring.

Spring has come a long way since the early code written by Rod Johnson in his book Expert One-to-One J2EE Design and Development (Wrox, October 2002). It has seen contributions from the most respected Java developers in the world and reached version 2.5.

Throughout this book, you will see many applications of different open source technologies, all of which are unified(統一的) under the Spring Framework. __When working with Spring, an application developer can use a large variety of open source tools, '''without needing to write reams of(大量) ''infrastructure code'' and without coupling his application ''too closely'' to any particular tool. (架構本身很強調 abstraction layers)'''__ This chapter is a gentle introduction to the Spring Framework. If you are already familiar with Spring, you might want to skip this chapter and go straight to Chapter 2, which deals with the setup and introduces the “Hello, World” application in Spring.

Our main aims in this book are to provide as comprehensive a reference to the Spring Framework as we can and, at the same time, give plenty of practical, ''application-focused'' advice without it seeming like a clone of the documentation. To help with this, we build a full application using Spring throughout the book to illustrate how to use Spring technologies.

=== What Is Spring? ===

The first thing we need to explain is the name Spring. We will use “Spring” in most of the text of this book, but we may not always mean the same thing. Sometimes, we will mean the ''Spring Framework'' and sometimes the ''Spring project''. We believe the distinction will always be clear and that you will not have any trouble understanding our meaning.

The core of the Spring Framework is based on the principle of Inversion of Control (IoC). __'''Applications that follow the IoC principle use configuration that describes the dependencies between its components. It is then up to the IoC framework to satisfy the ''configured dependencies''. The “inversion” means that the application does not control its ''structure''; (原來 IoC 是在強調 dependency 由別人代為組裝, 至於該 dependency 是主動取得或由外部注入, 則屬於不同的實作選項; IoC 講的是一個概念, 而 DI 與 dependency lookup 都是可行的做法之一) it is up to the IoC framework to do that.'''__

Consider an example where an instance of class `Foo` depends on an instance of class `Bar` to perform some kind of processing. Traditionally, `Foo` creates an instance of `Bar` using the `new` operator or obtains one from some kind of ''factory class''. __Using the IoC technique, an instance of `Bar` (or a subclass) is provided to `Foo` at runtime by some ''external process''. '''This ''injection''' of dependencies at runtime has sometimes led to IoC being given the much more descriptive name ''dependency injection (DI)''.'''__ The precise nature of the dependencies managed by DI is discussed in Chapter 3.

__Spring’s DI implementation puts focus on ''loose coupling'': the components of your application should assume as little as possible about other components. '''The easiest way to achieve loose coupling in Java is to ''code to interfaces''. (跟 !HiveMind 一樣強調 interface 的使用)'''__ Imagine your application’s code as a system of components: in a web application, you will have components that handle the HTTP requests and then use the components that contain the business logic of the application. The business logic components, in turn, use the data access objects (DAOs) to persist the data to a database. __The important concept is that each component does not know what ''concrete implementation'' it is using; it only sees an interface. Because each component of the application is aware only of the interfaces of the other components, we can switch the implementation of the components (or entire groups or layers of components; 抽換實作) without affecting the components that use the changed components. Spring’s DI core uses the information from your application’s configuration files to satisfy the dependencies between its components. '''The easiest way to allow Spring to set the dependencies is to follow the ''!JavaBean naming conventions'' in your components, but it is ''not a strict requirement'' (自動注入相依性)'''__ (for a quick introduction to !JavaBeans, go to Chapter 3).

__'''When you use DI, you allow ''dependency configuration'' to be ''externalized'' from your code. (好處是修改組態之後不用重新編譯程式碼; 不過下面 "Using Annotation-Based Configuration" 一節也提到, 事實上 Spring 也支援在程式內部用 annotation 來組態相依性)''' !JavaBeans provide a standard mechanism for creating ''Java resources'' that are configurable in a standard way. In Chapter 3, you will see how '''Spring uses the ''!JavaBean specification'' to form the core of its ''DI configuration model''; in fact, any ''Spring-managed resource'' is referred to as a ''bean''.'''__ If you are unfamiliar with !JavaBeans, take a look at the quick primer at the beginning of Chapter 3.

__Interfaces and DI are mutually(互相地) beneficial. We are sure that everyone reading this book will agree that designing and coding an application to interfaces makes for a flexible application that is '''much more amenable(可以處理的) to ''unit testing''.'''__ But the complexity of writing code that manages the dependencies between the components of an application designed using interfaces is quite high and places an additional coding burden on developers. __By using DI, you reduce the amount of extra code you need for an ''interface-based design'' to almost zero. Likewise, by using interfaces, you can get the most out of DI because your beans can utilize any interface implementation to satisfy their dependency.__

__In the context of DI, Spring acts more like a ''container'' than a framework—providing instances of your application classes with all the dependencies they need__—but it does so in amuch(狂亂地) less intrusive(侵入的) way than, say, the EJB container that allows you to create persistent entity beans. __Most importantly, Spring will manage the dependencies between the components of your application automatically. '''All you have to do is create a ''configuration file''(不直接標示在程式碼裡頭而言) that describes the dependencies;''' Spring will take care of the rest. Using Spring for DI requires nothing more than following the !JavaBeans naming conventions within your classes (a requirement that, as you will see in Chapter 4, you can bypass using Spring’s ''method injection support'')—'''there are no special classes from which to inherit or proprietary naming schemes to follow.''' If anything, the only change you make in an application that uses DI is to expose more properties on your !JavaBeans, thus allowing more dependencies to be injected at runtime. (不過這也是針對實作而言, 並不會影響到介面)__

 Note: __'''A container builds the environment in which all other software components live. Spring is a container, because it creates the components of your application and the components are ''children'' of the container.'''__

 __A framework is a collection of components that you can use to build your applications. Spring is a framework, because it provides components to build ''common parts'' of applications, such as data access support, MVC support, and many others.__

Although we leave a full discussion of DI until Chapter 3, it is worth taking a look at the benefits of using DI rather than a more traditional approach:

 * Reduce glue code

 . __One of the biggest plus points(加分) of DI is its ability to reduce dramatically(顯著地) the amount of code you have to write to ''glue'' the different components of your application together. Often, this code is trivial(瑣碎的)__—where creating a dependency involves simply creating a new instance of a class. However, the ''glue code'' can get quite complex when you need to look up dependencies in a ''JNDI repository'' or when the dependencies cannot be invoked directly, as is the case with remote resources. __In these cases, DI can really simplify the glue code by providing ''automatic JNDI lookup'' and ''automatic proxying of remote resources''.__

 * Externalize dependencies

 . __You can externalize the configuration of dependencies, '''which allows you to reconfigure easily without needing to recompile your application.'''__ This gives you two interesting benefits. First, as you will see in Chapter 4, DI in Spring gives you the ideal mechanism for externalizing all the configuration options of your application for free. Second, this externalization of dependencies makes it much simpler to ''swap'' one implementation of a dependency for another. Consider the case where you have a DAO component that performs data operations against a PostgreSQL database and you want to upgrade to Oracle. Using DI, you can simply reconfigure the appropriate dependency on your business objects to use the Oracle implementation rather than the PostgreSQL one.

 * Manage dependencies in a single place

 . In the traditional approach to ''dependency management'', you create instances of your dependencies where they are needed—within the dependent class. Even worse, in typical large applications, you usually use a factory or ''locator'' to find the dependent components. That means that your code depends on the factory or locator as well as the actual dependency. In all but the most trivial of applications, you will have dependencies ''spread across'' the classes in your application, and changing them can prove problematic. __When you use DI, all the information about dependencies is the responsibility of a single component (the Spring IoC container), making the management of dependencies much simpler and less error prone.__

 * Improve testability

  . __When you design your classes for DI, you make it possible to ''replace dependencies'' easily. This comes in especially handy when you are testing your application.__ Consider a business object that performs some complex processing; for part of this, it uses a DAO object to access data stored in a relational database. You are not interested in testing the DAO; you simply want to test the business object with ''various sets of data''. __In a traditional approach, where the service object is responsible for obtaining an instance of the DAO itself, '''you have a hard time(很難) testing this, because you are unable to replace the DAO implementation easily with a ''dummy(虛構的) implementation'' that returns your test data.''' Instead, you need to make sure that your test database contains the correct data and uses the full DAO implementation for your tests. Using DI, you can create a ''mock implementation'' of the DAO that returns the test data, and then you can pass this to your service object for testing.__ This mechanism can be extended for testing any tier of your application and is especially useful for testing web components, where you can create ''fake implementations'' of `HttpServletRequest` and `HttpServletResponse`.

 * Foster(促進) good application design

 . __Designing for DI means, in general, ''designing against interfaces''. '''A typical ''injection-oriented'' application is designed so that all major components are defined as interfaces, and then concrete implementations of these interfaces are created and wired together using the DI container.'''__ This kind of design was possible in Java before the advent(出現) of DI and DI-based containers such as Spring, but by using Spring, you get a whole host of DI features for free, and you can concentrate on building your application logic, not a framework to support it.

As you can see from this list, DI provides a lot of benefits, but it is not without its drawbacks too. In particular, DI can make seeing just what implementation of a particular dependency is being ''hooked'' into which objects difficult (無法一眼就看出執行期特定 interface 會綁定的實作為何), especially for someone not intimately(密切地) familiar with the code. __Typically, this is only a problem when developers are inexperienced with DI; after becoming more experienced, developers find that the ''centralized view'' of an application given by Spring DI lets them see the ''whole picture''.__ For the most part, the massive benefits far outweigh(勝過) this small drawback, but you should consider this when planning your application.

==== Beyond Dependency Injection ====

The Spring core alone, with its advanced DI capabilities, is a worthy tool, but where Spring really excels(出眾) is in its myriad(無數的) of additional features, all elegantly designed and built using the principles of DI. Spring provides tools to help build every ''layer'' of an application, from ''helper''(即下面所提的 "wrapper API") application programming interfaces (APIs) for data access right through to advanced model-view-controller (MVC) capabilities. __What is great about these features is that, although Spring often provides its own approach, you can easily integrate them with other tools, making them all first-class members of the Spring family. (抽換內部的實作而言)__

==== Aspect-Oriented Programming with Spring ====

Aspect-oriented programming (AOP) is one of the technologies of the moment in the programming space. __'''AOP lets you implement ''crosscutting(横切的) logic''—that is, logic that applies to many parts of your application—in a single place, and then have that logic automatically applied right across the application.'''__ AOP is enjoying an immense(極大的) amount of time in the limelight(聚光燈) at the moment; however, behind all the hype(天花亂墜的公關宣傳) is a truly useful technology that has a place in any Java developer’s toolbox.

__There are two main kinds of AOP implementation. ''Static AOP'', such as AspectJ (www.aspectj.org), provides a ''compile-time solution'' for building ''AOP-based'' logic and adding it to an application. ''Dynamic AOP'', such as that in Spring, allows crosscutting logic to be applied arbitrarily to any other code at runtime. '''Finally, in Spring 2.5, you can use ''load-time dynamic weaving(編排)'', which applies the crosscutting logic ''when the class loader loads the class''.'''__ Both kinds of AOP have their places, and indeed, Spring provides features to integrate with AspectJ. This is covered in more detail in Chapters 5 and 6.

There are many applications for AOP. The typical one given in many traditional examples involves performing some kind of ''tracing'', but AOP has found many more ambitious uses, even within the Spring Framework itself, particularly in ''transaction management''. Spring AOP is covered in depth in Chapters 5–7, where we show you typical uses of AOP within the Spring Framework and your own application. __We also look into the ''issue of performance'' and consider some areas where traditional technologies can work better than AOP. (多加一層, 對效能多少會有一點影響...)__

==== Accessing Data in Spring ====

Data access and persistence seem to be the most often discussed topics in the Java world. It seems that you cannot visit a community site such as www.theserverside.com without being bombarded(質問) with articles and blog entries describing the latest, greatest data access tool.

Spring provides excellent integration with a choice selection of these data access tools. __Moreover, Spring makes the use of JDBC, a viable(可行的) option for many projects thanks to its simplified ''wrapper APIs'' around the standard JDBC API. '''(用了這個優化過的 API, 並不違背 "Your application code should not depend on Spring APIs" 的原則, 因為它是一個 abstraction layer 的概念, 即便你不用 Spring 提供的, 你也可能會自己做一個...)'''__ As of Spring version 1.1, you have support for JDBC, Hibernate, iBATIS, and Java Data Objects (JDO).

__The JDBC support in Spring makes building an application on top of JDBC realistic(實事求是的), even for complex applications. The support for Hibernate, iBATIS, and JDO makes their already simple APIs even simpler, thus easing the burden on developers. '''When using the Spring APIs to access data via any tool, you can take advantage of Spring’s excellent ''transaction support''.'''__ A full discussion of this support can be found in Chapter 15.

__'''One of Spring’s nicest features is the ability to ''mix and match(混搭)'' data access technologies easily within an application. (Hibernate 本身也很強調與 JDBC 混搭的用法)''' For instance, you may be running an application with Oracle, using Hibernate for much of your data access logic. However, if you want to take advantage of ''Oracle-specific features'', it is simple to implement that particular part of your data access tier using ''Spring’s JDBC APIs''.__

==== Simplifying and Integrating with Java EE ====

There has been a lot of discussion recently about the complexity of various Java EE APIs, especially those of EJB. __It is evident(明顯的) from the EJB 3.0 specification that this discussion has been taken on board(考慮接受) by the expert group, and EJB 3.0 brought some simplifications and many new features. Even with the simplifications over EJB 2.0, using Spring’s simplified support for many Java EE technologies is still more convenient. For instance, Spring provides a selection of classes for building and accessing EJB resources. '''These classes cut out(略去) a lot of the grunt(繁重的) work from both tasks and provide a ''more DI-oriented API for EJBs''. (無論如何, EJB 3.0 搭配 Spring 的應用是存在的[...])'''__

__For any resources stored in a JNDI-accessible location, Spring allows you to do away with(去掉) the complex lookup code and have JNDI-managed resources injected as dependencies into other objects at runtime. '''As a side effect of this, your application code becomes ''decoupled from JNDI'', giving you more scope for ''code reuse'' in the future. (也比較容易測試)'''__

As of version 1.0.2, Spring does not support JMS access. However, the CVS repository already contains a large array of classes that are to be introduced in 1.1. __Using these classes simplifies all interaction with Java Message Service (JMS) destinations and should reduce a lot of the ''boilerplate(樣板) code'' you need to write in order to use JMS from your Spring applications.__

Chapters 11–13 explain how Spring works with the most important Java EE application components; Chapter 14 addresses application integration issues; and Chapter 20 deals with management of Java EE applications.

==== Job Scheduling Support ====

Many advanced applications require some kind of scheduling capability. Whether for sending updates to customers or doing ''housekeeping(內務) tasks'', the ability to schedule code to run at a predefined time is an invaluable tool for developers.

Spring supports two scheduling mechanisms: one uses the `Timer` class, which has been available since Java 1.3; and the other uses the Quartz scheduling engine. Scheduling based on the `Timer` class is quite primitive and is limited to fixed periods defined in milliseconds. __With Quartz, on the other hand, you can build complex schedules using the ''Unix cron format'' to define when tasks should be run.__

Spring’s scheduling support is covered in full in Chapter 11.

==== Mail Support ====

Sending e-mail is a typical requirement for many different kinds of applications and is given first-class treatment(對待) within the Spring Framework. __Spring provides a ''simplified API'' for sending e-mail messages that fits nicely with its DI capabilities. (!JavaMail 的 API 是出了名的難用!!) It supports ''pluggable implementations'' of the mail API and comes complete with two implementations: one uses !JavaMail, and the other uses Jason Hunter’s `MailMessage` class from the `com.oreilly.servlet` package available from http://www.servlets.com/cos/javadoc/com/oreilly/servlet/MailMessage.html. (沒想到除了 !JavaMail 以外, 還有別的套件在處理 mailing...)__

__'''Spring lets you create a ''prototype(樣本) message'' in the DI container and use this as the base for all messages sent from your application. This allows for easy customization of ''mail parameters'' such as the subject and sender address.''' However, there is no support for customizing the message body outside of the code. In Chapter 12, we look at Spring’s mail support in detail and discuss a solution that combines templating engines such as Velocity and !FreeMarker and Spring, allowing mail content to be externalized from the Java code. (很務實的用法...)__

__In addition to simple mail-sending code, we will show how to use ''Spring events'' to implement fully ''asynchronous messaging infrastructure''. We will make use of the Spring Java Management Extensions (JMX) features to show how to create an efficient management console for the ''mail queues''. (透過外部的信件來觸發內部的處理?)__

==== Dynamic Languages ====

__Dynamic languages in Spring allow you to implement components of your application in languages other than Java (Spring 2.5 supports !BeanShell, JRuby, and Groovy). '''This allows you to externalize part of your application’s code so that it can be easily updated by administrators and power users. (目前支援 !BeanShell/Groovy/JRuby, 但就是不支援 Python)''' You could do this even without Spring, but the support built into Spring means that the rest of your application will not be aware that a component is implemented in another language; it will appear to be an ordinary Spring bean.__

__Many large applications have to deal with complex business processes. '''This would not be too difficult to handle in Java, but in most cases, these processes change over time, and users want to be able to make the changes themselves. This is where a ''domain-specific language'' implementation comes in. (這與 http://java.sun.com/developer/technicalArticles/scripting/languages/[How Java Plays With Scripting Languages] 一文的態度是一致的 - developers and end users can collaborate to create more useful, dynamic applications)'''__

In Chapter 14, you will see how to use the dynamic language support in Spring 2.5 and how to use it to implement a simple domain-specific language.

==== Remoting Support ====

Accessing or ''exposing'' remote components in Java has never been simple. Using Spring, you can take advantage of extensive support for a wide range of remoting techniques that help you expose and access remote services quickly.

__Spring supports a variety of remote access mechanisms, including Java RMI, JAX-RPC, http://www.caucho.com/resin-3.0/protocols/hessian.xtp[Caucho Hessian], and http://www.caucho.com/resin-3.0/protocols/burlap.xtp[Caucho Burlap]. In addition to these remoting protocols, '''Spring 1.1 introduced its own HTTP-based protocol that is based on standard Java serialization. (這不就是 Zappy 所用的資料交換機制嗎)''' By applying Spring’s ''dynamic proxying'' capabilities, you can have a proxy to a remote resource injected as a dependency into one of your components, thus removing the need to couple your application to a specific remoting implementation and also reducing the amount of code you need to write for your application.__

__As well as making it easy to access remote components, '''Spring provides excellent support for exposing a Spring-managed resource as a remote service.''' This lets you export your service using any of the remoting mechanisms mentioned earlier, without needing any implementation-specific code in your application.__

__'''Integrating applications written in different programming languages, and possibly running on different platforms, is one of the most compelling reasons for using remote services. (但就是沒談到 XML-RPC)''' In Chapter 15, we will show how to use remoting between Java applications and a C# Windows rich client application making full use of a Spring service running on a Unix system.__

==== Managing Transactions ====

__Spring provides an excellent abstraction layer for transaction management, allowing for ''programmatic'' and ''declarative'' transaction control. By using the Spring abstraction layer for transactions, '''you can easily change the underlying ''transaction protocol'' and ''resource managers''. You can start with simple, local, ''resource-specific'' transactions and move to global, ''multiresource'' transactions without having to change your code.'''__ Transactions are covered in full detail in Chapter 15.

==== The Spring MVC Framework ====

Although Spring can be used in almost any application, from a ''service-only application'', through web and rich-client ones, it provides a rich array of classes for creating web-based applications. Using Spring, you have maximum flexibility when you are choosing how to implement your web front end.

For a web application of any complexity, it makes sense to use a framework with a paradigm(範式) that clearly separates the processing logic from the views. To achieve this, you can use the Spring Struts support or use Spring’s own excellent MVC framework. __'''To implement complex ''page flows'', you can use Spring Web Flow.''' You can use a large array of different view technologies, from JavaServer Pages (JSP) and Apache’s Jakarta Velocity to Apache POI (to generate Microsoft Excel output) and iText (to create output in Adobe PDF format). '''(誰說 Web 的產出一定是 Page 呢? http://spring-json.sourceforge.net/[Spring Json View] 更增加了 "JSON" 的觀點... 跟 Tapestry 5 的整合可以參考http://tapestry.apache.org/tapestry5/tapestry-spring/[這裡])''' The Spring MVC framework is quite comprehensive and provides support classes that address the majority of your requirements. For the rest, you can easily extend the MVC framework to add in your own functionality.__

The view support in Spring MVC is extensive and steadily(不斷地) improving. As well as standard support for JSP, which is greatly bolstered(支援) by the Spring tag libraries, you can take advantage of fully integrated support for Jakarta Velocity, !FreeMarker, Jakarta Tiles (separate from Struts), and XSLT. __Moreover, you will find a set of base view classes that make it simple to add Excel and PDF output to your applications. (看來 Spring MVC 真的很值得花時間瞭解...)__

We cover the Spring MVC implementation in Chapter 16.

==== Spring Web Flow ====

__'''Web Flow represents a new way of developing web applications, especially ones that rely on fairly complex ''transitions between the pages''.''' Web Flow greatly simplifies the implementation of such systems. Because it is a Spring project, it integrates closely with the Spring MVC framework. Just like Spring MVC, Web Flow can use any type of view technology. (也就是說, Spring MVC 或 Spring Web Flow 都沒有要取代 Struts/Tapestry/JSP/JSF 等 view technologies 的意思)__

We discuss Web Flow in detail in Chapter 18.

==== AJAX ====

AJAX is not only a buzzword of Web 2.0 but also an important technique for creating rich web applications. Put simply(簡而言之), it allows web applications to interact with servers without causing unnecessary page reloads. You may argue that it has little to do with the Spring Framework, but if you need to build highly interactive Web 2.0 applications, you cannot escape it. We will show you how to write the necessary code to add AJAX functionality to your Spring web applications. __Because Spring does not provide any framework-level infrastructure to deal with the implementation of AJAX web applications, we will show some important design and performance choices you have to make in your web applications.__

Chapter 18 covers AJAX applications in much more detail.

==== Internationalization ====

Internationalization is an important aspect of any large application; Spring has extensive support for creating multilanguage applications, and we will show you how to deal with the complexities of this task. __The issues facing the developers of multilanguage applications are twofold(雙重的): '''first, they must write code without any textual information hard-coded; second, they must design the application in a way that will allow for ''easy translation'' in the future.'''__

__This issue is further highlighted in situations where developers have to deal with exceptions: '''in most cases, the message of the exception will be in one language—the language of the developer. We will show you how to overcome this limitation. (Spring 考量得真是周到!!)'''__

All aspects of internationalization are covered in Chapter 17.

==== Simplified Exception Handling ====

__One area where Spring really helps to reduce the amount of repetitive, boilerplate code you need to write is exception handling. The Spring philosophy is that '''checked exceptions are overused in Java and that a framework should not force you to catch any exception from which you are unlikely to be able to recover (不是 checked exception 不好, 而是不要用過頭...)'''—a point of view that we agree with wholeheartedly(衷心地).__

__In reality, many frameworks reduce the impact of having to write code to handle checked exceptions. However, many of these frameworks take the approach of sticking with(堅持做) checked exceptions but artificially(人為地) reducing the granularity of the ''exception class hierarchy'' (例如整併成一個 `SQLException` 或 `IOException`). One thing you will notice with Spring is that, because of the convenience afforded to(提供) the developer by using unchecked exceptions, the exception hierarchy is remarkably granular(粒狀的). Throughout this book, you will see how Spring’s exception-handling mechanisms can reduce the amount of code you have to write, while improving your ability to identify, classify, and diagnose application errors. (要有這種粒度, checked exception 不也辦得到嗎[?])__

=== The Spring Project ===

__Among the most attractive things about the Spring project are the level of activity currently present in the community and the amount of ''cross-pollination(交叉授粉)'' with other projects, such as CGLIB, Apache Geronimo, and AspectJ.__ One of the most often touted(吹捧) benefits of open source is that if a project on which you rely folds(徹底失敗) tomorrow, you would be left with the code. __But let’s face it—you do not want to be left with a codebase the size of Spring to support and improve. For this reason, it is comforting to know how well established and active the Spring community is and how many successful applications are using the Spring Framework at their core. '''(這是一個良性的循環, 越來越多人採用 Spring 時, 就會有越來越多的人希望 Spring 持續成長, 自然就會有越來越多的人提供回饋...)'''__

==== Origins of Spring ====

As mentioned previously, the origins of Spring can be traced back to the book Expert One-to-One J2EE Design and Development by Rod Johnson (Wrox, 2002). In this book, Rod presented his ''Interface 21 Framework'', which he had developed to use in his own applications. Released into the open source world, this framework formed the foundation of Spring as we know it today. Spring proceeded quickly through the early beta and release candidate stages, and the first official 1.0 release was made available March 24, 2004. Since then, Spring has several major releases and is currently in its 2.5 release (at the time of this writing).

==== The Spring Community ====

The Spring community is one of the best in any open source project we have encountered. The mailing lists and forums are always active, and progress on new features is usually rapid. The development team is dedicated to making Spring the most successful of all the Java application frameworks, and this shows in the quality of the code that is produced. Much of the ongoing development in Spring consists of reworking existing code to be faster, smaller, neater(簡潔的), or all three.

__Spring benefits from excellent relationships with other open source projects, which is a good thing when you consider how much the full Spring distribution relies on integration with other products. From a user’s perspective, one of the best things about Spring is the excellent documentation and ''test suite'' that come with it. Documentation is provided for almost all Spring features, making it easier for new users to pick up the framework. '''The test suite is ''impressively comprehensive'', because the development team writes tests for everything. If they find a bug, they fix it by first writing a test that highlights the bug and getting the test to pass. (由於 Spring 開發團隊落實 TDD 的做法, 因此代碼的品質很高...)'''__

What does all this mean to you? Well, it means that you can be confident in the quality of the Spring Framework and know that, for the foreseeable(可預見的) future, the Spring development team intends to go on improving what is already an excellent framework.

==== Spring for Microsoft .NET ====

The main Spring Framework is 100 percent Java-based. However, due to the success of the Java version, developers in the .NET world started to feel a little bit left out(排斥), so Mark Pollack and Rod Johnson started the Spring .NET project. __The two projects have completely different development teams, so the .NET project should have minimal impact on the development of the Java version of the Spring Framework. In fact, the authors believe that this is excellent news. '''Contrary to(與...相反) popular belief in the Java world, .NET is not ''a load of(大量) garbage produced by the Beast(怪獸)''—a fact that we can attest(證明) to after delivering several successful .NET applications to our clients. (顯然 Spring 團隊的態度是務實、沒有偏見的, 可以解決問題就是一個好的 solution!!)'''__

__This project opens up whole new avenues(手段) for cross-pollination, especially since .NET already has the lead in some areas, such as http://static.springframework.org/spring/docs/2.5.x/reference/metadata.html[source-level metadata], and should help to create better product on both platforms. '''Another side effect of this project is that it makes the ''move between platforms'' much easier for developers, because you can use Spring on both sides. (有利於系統整合)'''__ This is all the more true since other projects, such as Hibernate and iBATIS, now have .NET equivalents. You can find more information on Spring .NET at www.springframework.net.

==== The Spring IDE ====

In all but the simplest Spring applications, the application’s configuration files become fairly large and complex; it is convenient to use some kind of integrated development environment (IDE) to help you write the code.

The Spring IDE project is another offshoot(分枝) of the main Spring project, and it functions as a plug-in for the Eclipse platform. __Using http://springide.org/blog/[Spring IDE], you can get full source highlighting and code insight functionality for your Spring configuration files. You can also reduce the number of errors that can creep into your configuration files, thus speeding up the development cycle.__ In addition to Spring IDE in Eclipse, you can use IntelliJ IDEA for your Java and Spring development. The Spring support in IntelliJ IDEA 7.0 is indeed excellent.

==== The Spring Security (Formerly Acegi) ====

__The Spring Security module evolved directly from http://www.acegisecurity.org/[Acegi], which was a security system built on top of Spring. It provides the full spectrum of security services required for Spring-based applications, '''including ''multiple authentication back ends'', ''single sign-on support'', and ''caching''.'''__ We do not cover Acegi in any detail in this book, but you can find more details at http://acegisecurity.sourceforge.net/. Support for Acegi is provided through the Spring forums at http://forum.springframework.org.

==== Alternatives to Spring ====

Going back to our previous comments on the number of open source projects, you should not be surprised to learn that Spring is not the only framework offering DI or full ''end-to-end support'' for building applications. In fact, there are almost too many projects to mention. In the spirit of being open, we include a brief discussion of some of these frameworks here, but we believe that none of them offer quite as comprehensive a solution as Spring. (完全沒人理會 !HiveMind)

 * !PicoContainer

 . !PicoContainer (www.picocontainer.org) is an exceptionally small (100kB) DI container that allows you to use DI for your application without introducing any dependencies other than PicoContainer itself. Because !PicoContainer is nothing more than a DI container, you may find that as your application grows, you need to introduce another framework, such as Spring, in which case you would have been better off using Spring from the start. __If all you need is a tiny DI container, !PicoContainer is a good choice. But since Spring packages the DI container separate from the rest of the framework, you can just as easily use that and keep your options open. (可以在一開始只用到 Spring 核心的部份, 它跟 !PicoContainer 一樣小, 但 Spring 未來是可擴充的...)__

 * !NanoContainer

 . !NanoContainer (www.nanocontainer.org) is an extension to !PicoContainer for managing ''trees'' of individual !PicoContainer containers. Because Spring provides all the same functionality in the standard DI container, !NanoContainer is not really a major improvement over Spring. Where !NanoContainer becomes interesting is in its support for ''scripting languages'' that interact with it. However, Spring comes with full support for scripting languages as well.

 * Keel Framework

 . The Keel Framework (www.keelframework.org) is more of a ''metaframework'', in that most of its capabilities come from other frameworks that are all brought together under a single roof. For instance, DI functionality comes from the Apache Avalon container, while web functionality comes from Struts or a similar framework. Keel has many implementations of the same components and links them all together into a cohesive(有粘性的) structure, allowing you to swap out implementations with minimal impact on your application. __Despite its wide feature set, Keel does not seem to have enjoyed the same level of acceptance as Spring. Although we have investigated Keel only briefly, we feel that this is partially to do with the level of accessibility. Spring is immediately accessible to developers of all levels, whereas Keel seems to be more complex. '''Having said that(話雖如此), Keel’s feature set is impressive, and it is certainly a direct competitor for Spring. (但為何今天 @2008/10/22 存取官網時會得到 - Keelframework has been deprecated?)'''__

 * Google Guice

 . __The Guice (pronounced “juice”) framework focuses purely on dependency injection. As such, it is not a direct competition for the Spring Framework; in fact, you can use Spring-managed beans in Guice. Apart from the focus of the framework, the main difference between Guice and Spring is the approach to the configuration of the applications. Guice uses ''automatic wiring'' or ''annotation-based configuration''. Automatic wiring means that the framework examines the components it is aware of and will try to guess the dependencies between them. The guess is based on the dependency’s ''type and name''. '''As even the creators of Guice admit (承認; and we wholeheartedly agree), automatic wiring is not suitable for large enterprise applications. For complex applications, Guice authors recommend using annotation-based configuration.''' Because Guice uses annotations, it does not need any complex configuration files like Spring.__

. __'''Unfortunately, by adding annotations, you limit the code you write only to Guice.''' Even with this drawback, Guice is an excellent framework, and its big advantage is that it can be used in cooperation(協同) with Spring.__

=== The Sample Code ===

Throughout the text, we will use two main approaches to sample code. To demonstrate fine and very specific points, we will create single-purpose small applications. To demonstrate complex code, we will create applications that may share code across multiple chapters. You can http://www.apress.com/resource/bookfile/4083[download] the code from Source Code section of the Apress web site (http://www.apress.com; 沒想到 sample code 的大小竟然也高達 38.3MB).

=== Summary ===

In this chapter, we presented you with a high-level view of the Spring Framework complete with discussions of all the major features, and we pointed you to the sections of this book where those features are discussed in detail. We also had a very brief look at some of the concepts that we will be dealing with throughout this book. After reading this chapter, you should have an idea of what Spring can do for you; all that remains is to see how it can do it.

In the next chapter, we explain everything you need to know to get up and running with a basic Spring application. We show you how to obtain the Spring Framework and discuss the packaging options, the test suite, and the documentation. Also, Chapter 2 introduces some basic Spring code, including the time-honored(由來已久的) “Hello, World” example in all its DI-based glory. On that note, let’s press on(挺進)!

== Chapter 2 Getting Started ==

__When trying out a new framework, the first step is usually the most complex one. The documentation and numerous blogs on the Spring Framework already assume you know how to find your way around Spring applications. (官方文件確實不太適合入門)__ While sounding really impressive, sentences like “Spring favors programming to interfaces” or “Spring promotes lose coupling” do not mean much.

In this chapter, we will walk you through the first steps involved in creating a simple Spring application. We will first take a look at how to obtain the latest Spring distribution. Then we will take the plunge(冒險嘗試) and write a simple “Hello, World” application. Once you have mastered that, we will take a more detailed look at all the code that comes with the Spring distribution. __We will explain which libraries you typically need for a console application, a web application, a rich client application, and an enterprise application.__ Finally, we will take a look at how you can obtain the latest (and latest stable) Spring source code from CVS and how to build your own release of Spring.

=== Obtaining the Spring Framework ===

Our first step will be to download the Spring Framework distribution. __The Spring Framework is now part of the http://www.springsource.com/products/springportfolio[Spring portfolio(作品集)], which includes projects that are closely associated with the framework.__ The portfolio includes Spring Web Flow (see Chapter 18), Spring Security (formerly Acegi Security for Spring), Spring Web Services (see Chapter 15), Spring Batch, and Spring Integration.

There are many other exciting projects, among the most notable are http://www.springsource.com/products/springdynamicmodules[Spring Dynamic Modules for OSGi], http://spring-rich-c.sourceforge.net/[Spring Rich Client], Spring IDE, and many others; all are available at www.springframework.org/projects.

For now, though, we only need the Spring Framework, which you can download at www.springframework.org/download. The link will take you to the SourceForge download page, where you should download the `spring-framework-2.5.2-with-dependencies.zip` archive. (@2008/12/25 目前最新版本是 v2.5.6, 檔案大小高達 79.5MB!!)

==== Checking Out Spring from CVS ====

Spring is under constant development with many new features being added almost daily. If you want to get a grip on(抓拄) new features before they make their way into a release, then obtaining the latest source code from CVS is the best way of going about it.

To check out the latest version of the Spring code, install CVS, which you can download from www.cvshome.org, and run the following command:

 {{{
cvs -d:pserver:anonymous@springframework.cvs.sourceforge.net:/cvsroot/springframework login
 }}}

When prompted for your password, simply press Enter to send a blank password. Next, enter the following command to check out the HEAD of the CVS repository, which contains the latest changes that have been committed:

 {{{
cvs -z3 -d:pserver:anonymous@springframework.cvs.sourceforge.net:/cvsroot/springframework co -P spring
 }}}

This command gives you the absolute latest version of the code, including two separate source trees: one contains the ''main source'' for Spring including any new features considered stable enough to be in the main tree; and the other, the ''sandbox'', contains code still classified as work in progress. New code in the main tree is likely to make it into the next release, but code in the sandbox might not. __Be aware that any new code is subject to change without notice; for this reason, avoid basing any of your new applications around unreleased code.__

Older versions of Spring are stored in CVS tagged by their version number, so you can download any version of Spring directly from CVS. If you are unsure of the tags to use, you can find them by browsing the CVS repository online at http://springframework.cvs.sourceforge.net/springframework/.

==== Building Spring from Source Code ====

Let’s take a look at how we can compile the framework from the source code. Even though it is possible to compile the HEAD version from CVS, we recommend that you compile one of the final releases. In the following example, we will take the latest version of Spring available at the time of this writing, version 2.5.2. The CVS tag for the source is `release-2-5-2`; you will need to run the commands in Listing 2-1 to check out the tag.

Listing 2-1. Commands to Check Out the 2.5.2 Release of Spring

 {{{
cvs -d:pserver:anonymous@springframework.cvs.sourceforge.net:/cvsroot/springframework login
cvs -z3 -d:pserver:anonymous@springframework.cvs.sourceforge.net:/cvsroot/springframework co -r release-2-5-2 -P spring
 }}}

Assuming that you have Apache Ant installed, that you have set the `$ANT_HOME` environment variable, and that the `$PATH` includes `$ANT_HOME/bin`, you can run `ant alljars`. This will build all source code and produce the Spring JAR files. The JAR files will be created in the `dist` directory, whose full structure is shown in Listing 2-2.

Listing 2-2. Showing the Compiled Modules

 {{{
janm@janm-ff:~/spring/dist$ find -iname \*.jar | sort -r
./weaving/spring-tomcat-weaver.jar
./weaving/spring-aspects.jar
./weaving/spring-agent.jar
./weaving-sources/spring-tomcat-weaver-sources.jar
./weaving-sources/spring-aspects-sources.jar
./weaving-sources/spring-agent-sources.jar
./spring-sources.jar
./spring.jar
./modules/spring-webmvc-struts.jar
./modules/spring-webmvc-portlet.jar
./modules/spring-webmvc.jar
./modules/spring-web.jar
./modules/spring-tx.jar
./modules/spring-test.jar
./modules/spring-orm.jar
./modules/spring-jms.jar
./modules/spring-jdbc.jar
./modules/spring-core.jar
./modules/spring-context-support.jar
./modules/spring-context.jar
./modules/spring-beans.jar
./modules/spring-aop.jar
./module-sources/spring-web-sources.jar
./module-sources/spring-webmvc-struts-sources.jar
./module-sources/spring-webmvc-sources.jar
./module-sources/spring-webmvc-portlet-sources.jar
./module-sources/spring-tx-sources.jar
./module-sources/spring-test-sources.jar
./module-sources/spring-orm-sources.jar
./module-sources/spring-jms-sources.jar
./module-sources/spring-jdbc-sources.jar
./module-sources/spring-core-sources.jar
./module-sources/spring-context-support-sources.jar
./module-sources/spring-context-sources.jar
./module-sources/spring-beans-sources.jar
./module-sources/spring-aop-sources.jar
 }}}

These JAR files are the same ones you can get in the Spring binary distribution; in the next section, we will take a more detailed look at the packages.

==== Verifying Your Spring Distribution ====

__'''With every distribution, you get the full source code for the test suite, along with the Ant script you need to run the tests and produce the test report. (沒想到測試也可以用在 "產品驗證" 上!!)''' If you think your distribution has a bug, first run the test suite to see if the bug is highlighted in one of the tests. Although many open source projects claim that most bugs are in user code and not in their code, Spring can back this up with a test suite that consists of thousands of tests. Don’t just take our word for it; you can run all Spring tests by running `ant tests` at the command line.__

We do not recommend that you build Spring from source code and use the compiled code in your day-to-day development. __It is much easier and much more convenient to use automated tools such as ''Maven 2'' to determine which version of Spring, and other libraries, your application needs to compile, test, and run. (雖然 Spring 自己用 Ant 在做 building, 但作者還是滿推薦平日用 Maven 的...)__

==== Spring Packaging ====

When you unzip the full Spring distribution or compile the source distribution, the `dist` subdirectory contains the full Spring distribution. However, there are many different JARs and, even more confusingly, `spring.jar`. __The reason for this split is that some applications may not require the entire Spring Framework. The decision whether to use various smaller JARs or the entire `spring.jar` depends on the type of application you are writing and on its environment.__

__Most applications work absolutely fine with the entire `spring.jar` on the classpath. However, if you deploy your application in an application server that already contains other versions of the Spring Framework libraries, you may come across versioning conflicts. Another situation where you may not want to include the entire `spring.jar` in your application is if you wish to use only parts of the Spring’s code. '''(事實上 `spring.jar` 是合併 "大部份" 而非全部其他小 JAR 檔的結果, 大小約 2.8MB; 如果想用 Spring 一小部份的功能, 可以分別引入個別的 JAR 檔, 只是比較麻煩而已)'''__ Table 2-1 summarizes all the Spring JARs that are included in the default distribution.

Table 2-1. Spring JAR Files

|| JAR File || Description ||
|| `spring-aop.jar` || This JAR contains all the classes you need to use Spring’s AOP features within your application. You also need to include this JAR in your application if you plan to use other features in Spring that use AOP, such as ''declarative transaction management''. ||
|| `spring-beans.jar` || __'''This archive contains all of Spring’s dependency injection. (沒想到 !JavaBean 跟 DI 的關聯這麼深)''' It contains the ''bean factories'' and supporting classes. In most cases, you will need to add `spring-context.jar`, which contains code needed to build the ''application context''.__ ||
|| `spring-context.jar` || This JAR contains code needed to build the Spring ''application context''; it packages the main `ApplicationConext` interface and its implementations together with code for instrumentation, JNDI, scheduling, themes, and validation. ||
|| `spring-context-support.jar` || This package contains utility Spring code—this means caching, instrumentation, e-mail and scheduling support, and the very interesting scripting languages support. ||
|| `spring-core.jar` || This contains the core files of the Spring Framework: it deals with annotations, enumerations, task execution, resource loading, and other utilities and exceptions you may find useful even ''outside the context'' of the Spring Framework. (和 `spring-beans.jar` 比較, 誰比較核心?) ||
|| `spring-jdbc.jar` || This package contains code for the JDBC support classes, namely the `JdbcTemplate` and `JdbcDaoSupport` classes; we discuss JDBC support in Chapter 7. ||
|| `spring-jms.jar` || This JAR contains code for JMS; see Chapter 15 for examples of ''transactional'' message queues. ||
|| `spring-orm.jar` || This archive contains the files needed for object-relational mapping (ORM) tools. Including this package on your classpath will give you Spring support for Hibernate 3, iBATIS, JDO, JPA, and !TopLink. ||
|| `spring-test.jar` || __'''This package contains support code to write unit and integration tests using the Spring Framework.''' It supports the JUnit 3, JUnit 4, and TestNG testing frameworks. In addition, you can use classes from the `org.springframework.mock` package, which represent mock implementations of JNDI and web classes. (下面有提到 Spring 採用 !EasyMock 來做 mocking)__ ||
|| `spring-tx.jar` || __This one contains support for core data access exceptions and transaction technologies. '''These two areas are closely bound together, because the transactions generally work with some data access code.'''__ ||
|| `spring-web.jar` || This JAR contains code for the Spring web application support (utilities, ''binders'', ''multipart resolvers''; 跟 Spring MVC 不同). For more details, see Chapter 16. ||
|| `spring-webmvc-portlet.jar` || This JAR contains code needed to build ''portlet-based'' (rather than ''servlet-based'') web applications. If you have an application server that supports the Portlet API (JSR 168), you can use this package. ||
|| `spring-webmvc-struts.jar` || This package contains code needed to use Spring with the Jakarta Struts Framework. ||
|| `spring-webmvc.jar` || This package contains the Spring MVC code; you will find much more detail about Spring MVC in Chapter 17. ||

As we said before, each of these JARs contains fragments of the entire Spring distribution. __However, `spring.jar` is still not the entire distribution of Spring. The `spring.jar` library does not include the code in the `spring-mvc-*.jar` files.__

==== Spring Dependencies ====

If we leave the `dist` directory and go to the `lib` directory, you will notice that it contains a large number of libraries. __These dependencies are necessary to build and test the entire Spring Framework distribution, but not all of the dependencies will be needed in your applications.__ Table 2-2 lists the Spring 2.5 dependencies, including their short descriptions.

Table 2-2. Spring Dependencies (下面的文件一再地提到 "如果你用到什麼功能, 就要引入特定 JAR 檔", 顯然需要 Maven 介入才能有效簡化 building 的工作)

|| Dependency Group || JAR Files || Description ||
|| ant|| `ant.jar`, `ant-junit.jar`, `ant-launcher.jar` || __Spring uses Apache Ant as its build tool, as well as for many tasks such as generating documentation and running tests. (為什麼 Spring 的模組這麼多, 卻不採用 Maven 來建構?)__ Ant is not used at all at runtime, so you do not need to include this JAR file in your distribution. ||
|| aopalliance || `aopalliance.jar` || The AOP Alliance (http://aopalliance.sourceforge.net/) is a combined, open source collaboration between many projects to provide a standard set of interfaces for AOP in Java. __Spring’s AOP implementation is based on the standard http://aopalliance.sourceforge.net/doc/index.html[AOP Alliance APIs]. (跟 !HiveMind 裡 `hivemind.lib.MethodInterceptorFactory` 的用法很像)__ You only need this JAR file if you plan to use Spring’s AOP or ''AOP-based'' features. ||
|| axis || `axis.jar`, `saaj.jar`, `wsdl4j.jar` || __Spring uses the http://ws.apache.org/axis/[Apache Axis] project to support the JAX-RPC capabilities in Spring remoting.__ You only need these files if you are using JAX-RPC remoting. ||
|| caucho || `burlap-2.1.7.jar`, `hessian-3.0.13.jar` || Spring remoting provides support for a wide variety of different protocols, including Caucho’s Burlap and Hessian. You only need the JARs in this group if you are using the corresponding protocols in your application. ||
|| cglib || `cglib-full-2.0.2.jar` || CGLIB is used to generate ''dynamic proxy classes'' for use in both the core DI and AOP implementations. __You almost always need to include CGLIB with your application, because it is used to implement a wide range of Spring’s functionality.__ ||
|| cos || `cos.jar` || COS stands for `com.oreilly.servlet`, which is a collection of useful classes for working with servlets and web-based applications. __Spring uses COS in two areas: for handling file uploads and sending e-mail. In both cases, COS is just an implementation choice, so you only need to include `cos.jar` if you choose to use COS over one of the other implementations.__ ||
|| dom4j || `dom4j.jar` || You must have dom4j when you are using Hibernate, so you need to include this JAR file if you plan to use Hibernate for ORM in your application. ||
|| easymock || `easymock.jar`, `easymockclassextension.jar` || !EasyMock is used in the Spring test suite, so you only need to use this JAR for building and running the test suite; you do not need to distribute this with your application. ||
|| freemarker || `freemaker.jar` || Spring provides ''wrapper classes'' around the !FreeMarker templating engine and also provides support for using !FreeMarker templates as views for your web applications. This is required whenever you are using !FreeMarker. ||
|| hibernate || `ehcache.jar`, `hibernate3.jar`, `odmg.jar` || These JAR files are required when you are using Spring’s Hibernate integration and support classes. If you are using a different ORM tool, such as iBATIS, you can leave these JARs out of your application. When you are using Hibernate, you must also include the CGLIB JAR file in your application. ||
|| hsqldb || `hsqldb.jar` || The `hsqldb.jar` file is used by the Spring sample applications. ||
|| ibatis || `ibatis-common.jar`, `ibatis-sqlmap.jar`, `ibatis-sqlmap-2.jar` || These files are required when you are using Spring’s iBATIS integration classes, but you can leave them out of your application if you are using JDBC or another ORM tool such as Hibernate or JDO. ||
|| itext || `itext-1.3.1.jar` || Spring uses iText to provide PDF support in the web tier. Only include this JAR if your web applications need to generate PDF output. ||
|| j2ee || `activation.jar`, `connector-api.jar`, `ejb.jar`, `jaxrpc.jar`, `jdbc2_0-stdext.jar`, `jms.jar`, `jstl.jar`, `jta.jar`, `mail.jar`, `servlet.jar`, `xml-apis.jar` || As you can see, there is a large array of different Java EE-related JAR files. You need the `activation.jar` and `mail.jar` files if you want to use the !JavaMail implementation of Spring’s mail support. You need `connector-api.jar` to use the JCA connector for Hibernate, `ejb.jar` to use Spring’s EJB support, and `jms.jar` to use Spring’s JMS support. For web applications, you need `servlet.jar`, and you need `jstl.jar` if you want to use Spring’s JSTL support. The `jaxrpc.jar` file is required for JAX-RPC support in Spring remoting, and `jta.jar` is used for JTA transaction support. The remaining two jars, `jdbc2_0-stdext.jar` and `xml-apis.jar`, are needed for JDBC and XML configuration support, respectively—but only when you are using a version 1.3 JVM. ||
|| jakarta || `commons-attributes-api.jar`, `commons-attributes-compiler.jar`, `commons-beanutils.jar`, `commons-collections.jar`, `commons-dbcp.jar`, `commons-digester.jar`, `commons-discovery.jar`, `commons-fileupload.jar`, `commons-lang.jar`, `commons-logging.jar`, `commons-pool.jar`, `commons-validator.jar` || Many of the components from the Jakarta Commons project are used by Spring. You need the `commons-attribute-api.jar` if you want to use ''source-level metadata'' in your application, plus you need the `compiler` JAR file to compile the attributes into your application. The `beanutils`, `collections`, `digester`, `discovery`, and `validator` JAR files are used by Struts, and Hibernate uses `collections` as well. `dbcp` is used by Spring’s JDBC support when you are using DBCP connection pools, and `pooling` is required by some of the sample applications. `fileupload` is required if you want to use the corresponding Spring wrapper to handle file uploads in your web applications. __Finally, `logging` is used throughout Spring, so you need to include it in every Spring-based application.__ ||
|| jakarta-taglibs || `standard.jar` || This is the Jakarta JSTL implementation, and it is used by some of the Spring sample applications. ||
|| jboss || `jboss-common-jdbc-wrapper.jar` || This is required when you are using Spring’s JDBC classes in an application running on the JBoss application server. ||
|| jdo ||`jdo.jar` || This is required for Spring’s JDO support. ||
|| jdom || `jdom.jar` || JDOM is required when you are using iBATIS 1.3 with Spring. The version of iBATIS covered in this chapter is 2.0. ||
|| jotm || `jotm.jar`, `xapool.jar` || The `jotm.jar` file is required if you plan to use http://jotm.objectweb.org/[JOTM] in conjunction with Spring’s transaction abstraction layer. You only need `xapool.jar` if you plan to use XAPool for connection pooling in your application. ||
|| junit || `junit.jar` || JUnit is not required at all at runtime; it is only used for building and running the test suite. ||
|| log4j || `log4j-1.2.14.jar` || This is required when you want to use Spring to configure log4j logging. ||
|| poi || `poi-2.5.1.jar` || This adds support for Microsoft Excel output to Spring’s MVC framework. ||
|| quartz || `quartz.jar` || This is used for Spring Quartz-based scheduling support. ||
|| regexp || `jakarta-oro-2.0.7.jar` This is required when you are using regular expressions to specify http://en.wikipedia.org/wiki/Pointcut[point cuts] in AOP. You can find more details on this in Chapter 6. ||
|| struts || `struts-1.1.jar` || The Struts JAR is required whenever you want to use Struts in conjunction with Spring to build a web application. ||
|| velocity || `velocity-1.4.jar`, `velocity-tools-generic-1.1.jar` || __Spring provides ''wrapper classes'' around Velocity to make it ''DI enabled'' and to reduce the amount of code you need to write to use Velocity in your application.__ In addition to this, Spring provides classes to support the use of Velocity as the view provider in the web tier. If you are using any of these features, you need to include the Velocity JAR files in your distribution. ||
|| xdoclet || `xjavadoc-1.0.jar` || ''Commons Attributes'' uses this to parse your source code files and extract the attribute information. Include this JAR file if you are using Spring’s Commons Attributes support. ||

__'''We found that the best way to create applications is to start with the minimal set of dependencies and only add another JAR if necessary.''' The main reason for this is neither speed nor size but the ''possibility of conflict'' when two dependent libraries rely on different versions of the same library. In this case, most developers take the latest (or later) version and try to get the application to compile. If that works and the tests verify that the application is working correctly, they assume that the conflict is resolved. (有衝突時就採用比較新的版本, 如果執行期正常的話...) '''This approach usually works, and until there is more widespread(普及的) support for OSGi modules, we have no other choice. Welcome to http://en.wikipedia.org/wiki/Java_Classloader#JAR_hell[JAR hell]!'''__

=== Spring Sample Applications ===

An area where many open source, and indeed commercial, products fail is in providing enough well documented sample code to make it easy for people to get started. Thankfully, Spring comes with a complete set of nifty sample applications that demonstrate a wide selection of the features in Spring. __A point to note is that the sample applications are treated as ''first-class citizens'' of the framework by the development team, and they are constantly being improved and worked on by the team. (這裡所提的範例跟書本所附的範例不同)__ For this reason, you generally find that, after you get what you can from the test suite, the samples are a great place to get started when you are looking at new features.

==== The PetClinic Application ====

!PetClinic(寵物診所) is an interesting sample application that was built to showcase(陳列) Spring’s data access support. In it, you find a web-based application for querying and updating the database of a fictional(虛構的) veterinary(獸醫的) office. __The interesting thing about this application is that it comes with a selection of ''interchangeable data access implementations'' that highlight how easy it is to decouple your application from the data access logic when you are using Spring.__

The Hibernate data access implementation really shows off Spring’s Hibernate support by implementing each of the eight data access methods with a single line. The JDBC implementation is equally interesting. First, much of the JDBC logic is contained in an abstract base class. This class provides ''hook methods'' for subclasses when you need to use ''provider-specific SQL features''—in the !PetClinic case, this happens with the ''automatic generation of primary keys''. __Second, when you are looking at the base class, it is interesting to see how much of the repetitive error-handling code that is prevalent(普遍的) when you are using JDBC is removed. Third, it is very interesting to see how data access is handled in a much ''more object-oriented way''.__

This project also contains a very solid example of how to build a web application using Spring’s MVC support, so if you are planning to use Spring MVC for one of your own applications, make sure you take a look at this sample first.

We cover JDBC support in Chapter 9, Hibernate in Chapter 11, and Spring MVC in Chapter 17.

==== The PetPortal Application ====

This application offers sample implementation of the Portlet MVC support in Spring using the favorite pet shop scenario. It is a simplified jPetStore application; it demonstrates ''wizard-style'' controllers and validators, file upload handling, and redirection to external web sites.

==== The jPetStore Application ====

The jPetStore application is based on the http://sourceforge.net/projects/ibatisjpetstore/[jPetStore] sample created by Clinton Begin for iBATIS. As far as(就...而言) sample applications go, this one is huge. It contains a full DAO layer, created using Spring and iBATIS, with implementations for Oracle, Microsoft SQL Server, MySQL, and PostgreSQL. __The business tier is fully Spring managed and, coupled with the DAO layer, it presents a good example of Spring-managed transactions.__

Also included with this application is a solid example of how to use both Spring MVC and Struts. This application also highlights how to use Spring remoting using JAX-RPC.

Spring MVC is covered in Chapters 17, iBATIS in Chapter 10, and Spring remoting in Chapter 15.

==== The Tiles Example Application ====

http://tiles.apache.org/[Tiles] is one of our favorite open source tools, because it reduces a lot of the drudge(苦差事) work when you are building user interfaces for the Web, and it really helps separate individual UI elements into ''reusable fragments''. Because of this, the Tiles support in Spring is especially welcome, and this sample application makes getting started with Tiles in your own sample application easy.

We cover Tiles in detail in Chapter 17.

==== The ImageDB Application ====

This is one of our favorite sample applications, because it shows off loads of(許多) useful Spring features. __Specifically, you see how to load and store large binary objects (LOBs) in a database,__ how to handle file uploads, and how to schedule jobs using the Quartz job scheduler. As if that weren’t enough, you also see how to use Velocity as the view technology in the web tier.

We cover LOBs in Chapters 9 and 11, file uploads in Chapter 17, job scheduling in Chapter 12, and Velocity support in Chapter 17.

==== The JasperRepots Application ====

__Reports are one of the most dreaded(令人畏懼的) programming tasks; this application shows how to use the !JasperReports framework to ease the development of PDF and Excel reports without a single line of Java web code.__ We discuss the reporting support in Chapter 17.

==== JCA-10 Application ====

The aim of the sample is to show how to use the support of JCA CCI 1.0 in Spring. It uses the sample JCA connector of the Java EE SDK version 1.3 modified to be used with http://hsqldb.org/[Hypersonic] and to execute SQL requests directly on the CCI interaction specification. The connector of the sample only supports local transactions and works in a stand-alone mode.

__To use it in a managed mode, you must package the JAR in `spring-cciblackbox-tx.rar` and deploy it on your JCA 1.0–compliant application server (for example, JBoss 4).__

==== The Countries Application ====

This is an intriguing(有趣的) example that demonstrates some of the more advanced features of Spring MVC. It looks at using `HandlerInterceptors` to provide common preprocessing for your controllers as well as utilizing Excel and PDF output for the view technology. This example is quite small and is certainly worth a look if you are planning to use Excel or PDF within your application. We cover `HandlerInterceptors` as well as Excel and PDF integration in Chapter 16.

=== Setting Up Spring and Your IDE ===

Now that you have the full Spring distribution, it is time to look at how you set it up in your favorite IDE. While you can use command-line tools (such as ant and maven) to build your applications, working in an IDE is much more comfortable. Also, having the Spring libraries set up is useful, so you can step into(跟蹤) their code. We will use IntelliJ IDEA, though other IDEs are just as easy to set up.

Regardless of your choice of IDE, let’s first examine the directory structure of the applications we will show in this book. Figure 2-1 shows the directory structure of the sample application for this chapter. (其中 `.iml` 檔即 IntelliJ IDEA 的專案檔)

{{attachment:figure_2-1.png}} <<BR>> Figure 2-1. Directory structure of the sample application

The directory structure shows that we have one `src` directory that contains code for the `main` code and `test` code. Each of the `test` and `main` source directories further has the `java` and `resources` subdirectories. All Java code goes into the `java` directory; all other files that are not Java source code, but make up part of the application, go to the `resources` directory. (配置的方式幾乎跟 Maven 一致) Next, we have the `lib` directory at the same level as the entire project. We do not just leave all JAR files in the `lib` directory; instead, we create subdirectories with some descriptive names. For the application in this chapter, we will only need the `lib/org/springframework/spring.jar` library. Figure 2-2 shows how we have set up the module in IntelliJ IDEA—you can clearly see the source and test source directories.

{{attachment:figure_2-2.png}} <<BR>> Figure 2-2. IntelliJ IDEA module setup

This would be enough to start writing plain Java code, but we know that we are going to write some Spring code! __To prepare for that, we need to add the libraries we are going to need: `spring.jar` and `commons-logging-1.1.jar`. (從 Spring 2.5.6 的 http://repo1.maven.org/maven2/org/springframework/spring/2.5.6/spring-2.5.6.pom/[POM] 觀察, 只有 `commons-logging:commons-logging:1.1.1` 的相依性是必要的)__ Figure 2-3 shows these libraries set up in IntelliJ IDEA.

{{attachment:figure_2-3.png}} <<BR>> Figure 2-3. Library setup in IntelliJ IDEA

In Figure 2-3, you can see that we have added the `spring.jar` library and its dependency, `commons-logging-1.1`. We have also attached the `spring-sources.jar`, which contains the source code compiled into `spring.jar`. Finally, Figure 2-4 shows that we have added the two libraries as module dependencies.

{{attachment:figure_2-4.png}} <<BR>> Figure 2-4. Module dependencies

Once you have all this set up, you are ready to follow the source code we are going to show in this chapter. Alternatively, you can open the sample application project, which includes code for all chapters.

=== Hello, World ===

Let us put all worries about different versions of dependent libraries and even the JARs that make up the Spring distribution aside and write a “Hello, World” application. Throughout this chapter, we will improve this application using ''traditional programming'' and then refactor the application to use the Spring Framework. Listing 2-3 shows a typical “Hello, World” application.

Listing 2-3. Typical “Hello,World”

 {{{
public class TypicalHelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, world.");
  }
}
 }}}

The code is trivial but also ''completely impossible to extend or modify''. If we wanted to print the message to standard error stream, we would need to modify the source code and recompile. It would be nice if we had one piece of code that provided the message and other code that took care of outputting the message. Our first attempt could be the code in Listing 2-4.

Listing 2-4. Attempt to Make the “Hello,World” Application More Generic

 {{{
final class MessageSource {

  private final String message;

  public MessageSource(String message) {
    this.message = message;
  }

  public String getMessage() {
    return message;
  }

}

class MessageDestination {

  public void write(PrintStream out, String message) {
    out.println(message);
  }

}

public class CloselyCoupledHelloWorld {

  public static void main(String[] args) {
    MessageSource source = new MessageSource("Hello, world");
    MessageDestination destination = new MessageDestination();
    destination.write(System.out, source.getMessage());
  }

}
 }}}

This code looks more generic and more configurable but is actually even worse than the original code in Listing 2-3: it is still too closely coupled but is more complicated. We can achieve significant improvement if we make the `MessageSource` and `MessageDestination` interfaces and change the `MessageDestination`’s `write` method so that it does not require the `PrintStream` argument. Figure 2-5 shows a UML diagram of the changed solution.

{{attachment:figure_2-5.png}} <<BR>> Figure 2-5. UML class diagram of the refactored application

Now, this approach is much better. The `DecoupledHelloWorld` class directly uses only the interfaces; each interface has only one implementation. However, the `DecoupledHelloWorld` still needs to create the instances of the interfaces (see Listing 2-5).

Listing 2-5. Still Closely Coupled Implementation of “Hello,World”

 {{{
public class DecoupledHelloWorld {

  public static void main(String[] args) {
    MessageSource source = new SimpleMessageSource("Hello, world");
    MessageDestination destination = new StdoutMessageDestination();
    destination.write(source.getMessage());
  }

}
 }}}

__The problematic lines are in bold: even though the rest of the code uses the interfaces, the `DecoupledHelloWorld` application is ''directly aware of the implementations''. It would be better if we could use some kind of ''factory''.__ This factory would could use arbitrarily complex configuration rules and ultimately return properly configured instances of the `MessageSource` and `MessageDestination` implementations. Review the UML diagram in Figure 2-6, which illustrates the factory.

{{attachment:figure_2-6.png}} <<BR>> Figure 2-6. UML class diagram of the decoupled “Hello,World” with a factory

__Now, `DecoupledHelloWorld` only uses the factory, and the factory manages the creation of the appropriate beans and returns them to `DefaultHelloWorld`. The `name` argument in the `getBean` method uniquely identifies the bean. Therefore, the factory takes care of the life cycle of the beans it manages.__ Take a look at Listing 2-6; it shows a possible implementation of the `BeanFactory`, which uses a properties file to determine the classes of beans it needs to instantiate.

Listing 2-6. Implementation and Use of the `BeanFactory` Class

`com.apress.prospring2.ch02.decoupled.beanfactory.BeanFactory`:

 {{{
public class BeanFactory {

  private Map<String, String> beanDefinitions;

  public BeanFactory(String beanDefinitionsSource) {
    readBeanDefinitions(beanDefinitionsSource);
  }

  private void readBeanDefinitions(String beanDefinitionsSource) {
    Properties props = new Properties();
    InputStream is = BeanFactory.class.getResourceAsStream(beanDefinitionsSource);
    if (is == null) {
      throw new RuntimeException("Could not load properties file " + beanDefinitionsSource);
    }

    try {
      props.load(is);
      is.close();
      this.beanDefinitions = new HashMap<String, String>();

      for (Map.Entry<Object, Object> entry : props.entrySet()) {
        this.beanDefinitions.put(entry.getKey().toString(), entry.getValue().toString());
      }
    } catch (IOException e) {
      throw new RuntimeException("Could not read the properties file " + beanDefinitionsSource);
    }
  }

  public Object getBean(String name) {
    String className = this.beanDefinitions.get(name);
    if (className == null)
      return null;

    try {
      return Class.forName(className).newInstance();
    } catch (Exception e) {
      throw new RuntimeException("Could not create bean " + name);
    }
  }

}
 }}}

`com.apress.prospring2.ch02.decoupled.demo.FactoryDecoupledHelloWorld`:

 {{{
public class FactoryDecoupledHelloWorld {

  public static void main(String[] args) {
    BeanFactory bf = new BeanFactory("/META-INF/plain/helloworld-context.properties");
    MessageSource source = (MessageSource)bf.getBean("source");
    MessageDestination destination = (MessageDestination)bf.getBean("destination");
    destination.write(source.getMessage());
  }

}
 }}}

`META-INF/plain/helloworld-context.properties`:

 {{{
source=com.apress.prospring2.ch02.decoupled.source.SimpleMessageSource
destination=com.apress.prospring2.ch02.decoupled.destination.StdoutMessageDestination
 }}}

This design is flexible enough, but there is one drawback: the `BeanFactory` class is directly tied to using Java properties files as the source of the bean configuration data. (這樣挑惕下去會沒完沒了... 無論如何, 繼續提出 interface!!)

It would be better if there were another interface that maintained the life cycles of all beans, some kind of `BeanRegistry`. Then, we would have `BeanDefinitionReader` implementations that understand particular format of the ''bean definition file''. The readers would read the file and register all beans found in the file. The factory would then use the registry to obtain bean definitions (regardless of where the definitions came from) and create the required beans. __But wait! We would be wasting our time, because this is exactly what Spring does!__

=== Putting Spring Into “Hello, World” ===

Finally, we get to a point where we can take a look at using Spring in our “Hello, World” application. We have improved it in the previous listings, but we have ended up writing a lot of code to do that. Listing 2-7 shows how we can achieve the same result with just one Java source file, one properties file, and the Spring Framework.

Listing 2-7. Using Spring to Simplify the Sample Code

 {{{
import org.springframework.beans.factory.support.BeanDefinitionReader;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.support.PropertiesBeanDefinitionReader;
import org.springframework.core.io.ClassPathResource;
import com.apress.prospring2.ch02.decoupled.MessageSource;
import com.apress.prospring2.ch02.decoupled.MessageDestination;

public class FirstSpringHelloWorld {
  public static void main(String[] args) {
    // 初始化的工作只比 HiveMind 好一點而已, 還是有點雜...
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
    BeanDefinitionReader reader = new PropertiesBeanDefinitionReader(bf);
    reader.loadBeanDefinitions(new ClassPathResource("/META-INF/spring/helloworld-context.properties"));

    MessageSource source = (MessageSource)bf.getBean("source");
    MessageDestination destination = (MessageDestination)bf.getBean("destination");
    destination.write(source.getMessage());
  }
}
 }}}

This code works just like the code we would eventually get to using our refactoring techniques: it creates a `BeanFactory` as an instance of `DefaultListableBeanFactory`. The `DefaultListableBeanFactory` class also implements `BeanDefinitionRegistry`. Next, we create `BeanDefinitionReader`, in our case `PropertiesBeanDefinitionReader`, giving it reference to the `BeanDefinitionRegistry` instance. On the next line, __we call the `loadBeanDefinitions` method, and we give it a `Resource` implementation called `ClassPathResource`. Once the `loadBeanDefinitions` method finishes, the `BeanDefinitionRegistry` is set up,__ and the `BeanFactory` can use it to give us instances of the defined beans. We do just that with the two calls of the `getBean` method. We only need to give it the bean name. Finally, we use the returned beans to get the "Hello, world" message.

Before we can run this application, we need to create the `/META-INF/spring/helloworld-context.properties` file. Listing 2-8 shows this file.

Listing 2-8. The `helloworld-context.properties` File

 {{{
source.(class)=com.apress.prospring2.ch02.decoupled.source.SimpleMessageSource
destination.(class)=com.apress.prospring2.ch02.decoupled.destination.StdoutMessageDestination
 }}}

As you can see, the format of this file is almost exactly the same as the format we have chosen for our non-Spring application. When you now compile and run the `FirstSpringHelloWorld` application, you will see the familiar "Hello, world" message.

==== Dependency Injection ====

__'''The code you have seen until now does not use the DI pattern. It uses ''dependency lookup''.'''__ We will explore the dependency injection pattern in far more detail in the next chapter, but for now, consider that the code in `FirstSpringHelloWorld` had to know the names of the `MessageSource` and `MessageDestination` beans. __It had to look them up and then use them. This clouds(玷污) the implementation, because in addition to the problem we are trying to solve, we need to know details about the ''setup'' of the application. It would be much better if the `MessageSource` and `MessageDestination` interfaces somehow got ''automatically set''.__ To get you started, we will show you how to create a `MessageService`, which uses `MessageSource` and `MessageDestination` beans, but we will use Spring to inject the `MessageSource` and `MessageDestination` beans into the `MessageService` bean. Listing 2-9 shows the implementation of `MessageService`.

Listing 2-9. `MessageService` Implementation

 {{{
public interface MessageService {
  void execute();
}

public class DefaultMessageService implements MessageService {
  private MessageSource source;

  private MessageDestination destination;

  public void execute() {
    this.destination.write(this.source.getMessage());
  }

  public void setSource(MessageSource source) {
    this.source = source;
  }

  public void setDestination(MessageDestination destination) {
    this.destination = destination;
  }

}
 }}}

We intend to use the implementation of the `MessageService`, the `DefaultMessageService`, in the `main` method in the `DISpringHelloWorld` example. If you look at the code in Listing 2-10, you will see that we only get the `service` bean, but we do not control the creation and life cycle of the service bean—we leave that to Spring.

Listing 2-10. The Dependency Injection Spring Application

 {{{
public class DISpringHelloWorld {

  public static void main(String[] args) {
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
    BeanDefinitionReader reader = new PropertiesBeanDefinitionReader(bf);
    reader.loadBeanDefinitions(new ClassPathResource("/META-INF/spring/helloworld2-context.properties"));

    MessageService service = (MessageService)bf.getBean("service");
    service.execute();
  }

}
 }}}

The last piece of puzzle is the `helloworld2-context.properties` file. Somehow, this file must contain enough information to tell Spring that to create an instance of bean named `service`, it must first create instances of the `source` and `destination` beans and then inject them (e.g., invoke the `setSource` and `setDestination` methods) on the `service` bean. Listing 2-11 shows just how easy it is to do that.

Listing 2-11. The `helloworld2-context.properties` file

 {{{
source.(class)=com.apress.prospring2.ch02.decoupled.source.SimpleMessageSource
destination.(class)=com.apress.prospring2.ch02.decoupled.destination.StdoutMessageDestination
service.(class)=com.apress.prospring2.ch02.spring.DefaultMessageService # 1 <-- 這些行號當然不能輸入!!
service.source(ref)=source # 2
service.destination(ref)=destination # 3
 }}}

Line number one defines a bean named `service` as an instance of `DefaultMessageService`. The dependency injection instructions are on the lines numbered two and three. When we then call `getBean("service")` in the `main` method, Spring will use this information to create the three beans and return the fully constructed instance of the `DefaultMessageService`.

There is much more to dependency injection in Spring, and we give far more detail in the following chapters, but this is a good starting point for further experiments. __The most difficult part to grasp for Spring newbies is that the objects seem to live in thin air; it is usually difficult to ''give up'' control over construction of objects and let the framework handle it. (描述得很生動)__

==== The Impact of Spring ====

If you design your application in a similar way to the design we have taken in the last section of this chapter, the impact of using the Spring Framework will be absolutely minimal. __'''Spring heavily promotes coding to interfaces—your code should be ''split into interfaces and their implementations''. The interfaces form the beans that other beans can use,''' as you have seen in `MessageSource`, `MessageDestination`, and more crucially(重要的), `MessageService`. '''The implementations then take full advantage of the dependency injection, but at no point(沒有意義) do the various implementations of the interfaces need to be aware of each other. This gives the ultimate flexibility and testability of the applications you will create.'''__

__Even more importantly, the code in the interfaces and implementations is plain Java code; '''the implementations are not aware of the fact that they are running in a ''dependency injection context''.'''__

=== Summary ===

In this chapter, we have presented you with all the background information you need to get up and running with Spring. We showed you how to obtain both the Spring release distribution and the current development version directly from CVS. We described how Spring is packaged and the dependencies you need for each of Spring’s features. __Using this information, you can make informed(了解情況的) decisions about which of the Spring JAR files your application needs and which dependencies you need to distribute with your application.__ Spring’s documentation, sample applications, and test suite provide Spring users with an ideal base from which to start their Spring development, so we took some time to investigate what is available in the Spring distribution. Finally, we presented an example of how, using Spring DI, it is possible to make the traditional “Hello, World” application a loosely coupled, extendable message-rendering application.

The important thing to realize is that we only scratched the surface of Spring DI in this chapter, and we barely(只不過) made a dent(引起注意) in Spring as a whole. In the next chapter, we take an in-depth look at the sample application that we will be building, paying particular attention to how we can use Spring to solve ''common design issues'' and how we have made our application simpler and more ''manageable'' using Spring.

== Chapter 2 Introducing Inversion of Control ==

In Chapter 1, during the first discussion of Inversion of Control (IoC), you might recall that we mentioned that Martin Fowler renamed the Inversion of Control pattern to the more descriptive dependency injection (DI). __However, this is not strictly true; in reality, '''DI is a specialized form of IoC, (IoC 是一種概念, 而 DI 只是其中一種實作的方式而已)''' although you will often find that the two terms are used interchangeably.__ In this chapter, we take a much more detailed look at IoC and DI, formalizing the relationship between the two concepts and looking in great detail at how Spring fits into the picture.

After defining both and looking at Spring’s relationship with them, we will explore the concepts that are essential to Spring’s implementation of DI. This chapter only covers the basics of Spring’s DI implementation; we discuss more advanced DI features in Chapter 4 and look at DI in the context of application design Chapter 8. More specifically, this chapter will cover IoC concepts, IoC in Spring, and IoC configuration in Spring `BeanFactories`.

__First, we’ll discuss the various kinds of IoC including DI and ''dependency lookup''. We’ll look at the differences between the various IoC approaches and present the pros and cons of each.__

Next, we’ll look at IoC capabilities available in Spring and how these capabilities are implemented, in particular, at DI and the setter- and constructor-based approaches Spring offers. This part of the chapter also provides the first full discussion of the `BeanFactory` interface, which is central to the whole Spring framework.

The final part of this chapter focuses on using the annotation- and XML-based configuration approach for the `BeanFactory` configuration. We’ll start out with a discussion of DI configuration and move on to look at additional services provided by the `BeanFactory`, such as ''bean inheritance'', ''life cycle management'', and ''automatic wiring''.

=== IoC and DI ===

__At its core, IoC, and therefore DI, aims to offer a simpler mechanism for provisioning(供給) ''component dependencies'' (often referred to as an object’s ''collaborators'') and managing these dependencies throughout their ''life cycles''. A component that requires certain dependencies is often referred to as the ''dependent object'' or, in the case of IoC, the ''target''. (按http://martinfowler.com/articles/injection.html[這裡]的說法, "dependent object" 與 "target" 指的是 "依賴他人" 的那一端, 下面的 "supplying dependent objects with their collaborators" 印證了這個解釋) This is a rather grand(遠大的) way of saying that '''IoC provides services through which a component can access its dependencies and services for interacting with the dependencies throughout their lives. (這一段話完全沒提到 "反向注入" 的概念; 我們通常都會將 IoC 裡的 "inversion" 誤解成單純只是 DI 裡 dependency 反向注入概念. 參考 http://en.wikipedia.org/wiki/Inversion_of_control[Wikipedia] 的說法, 會發現 IoC 這個東西比 DI 所探討的東西還要廣泛得多...)''' In general, IoC can be decomposed(分解) into two subtypes: DI and ''dependency lookup''. These subtypes are further decomposed into ''concrete implementations'' of the IoC services. From this definition, you can clearly see that '''when we are talking about DI we are always talking about IoC, but when we are talking about IoC, we are not always talking about DI.'''__

=== Types of IoC ===

You may be wondering why there are two different types of IoC and why these types are split further into different implementations. There seems to be no clear answer to these questions; certainly the different types provide a level of flexibility, but to us, it seems that IoC is more of a mixture of old and new ideas; the two different types of IoC represent this.

Dependency lookup is the more traditional approach, and at first glance, it seems more familiar to Java programmers. DI is a newer, less well established approach that, although apparently counterintuitive(違反直覺的) at first, is actually much more flexible and usable than dependency lookup.

__With dependency-lookup–style IoC, a component must acquire a reference to a dependency, whereas with DI, the dependencies are literally(確確實實地) injected into the component by the IoC container. Dependency lookup comes in two types: ''dependency pull'' (see Listing 3-1) and ''contextualized dependency lookup'' (CDL). DI also has two common flavors: ''constructor DI'' and ''setter DI''.__

Listing 3-1. Example of the Dependency Pull Approach (即使沒用到 DI, 但也用到了 IoC container)

 {{{
package com.apress.prospring2.ch03.ioc;

import com.apress.prospring2.ch02.spring.MessageService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionReader;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.support.PropertiesBeanDefinitionReader;
import org.springframework.core.io.ClassPathResource;

public class DependencyPullDemo {

  public static void main(String[] args) {
    BeanFactory bf = getBeanFactory();

    MessageService service = (MessageService)bf.getBean("service");
    service.execute();
  }

  private static BeanFactory getBeanFactory() {
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();

    BeanDefinitionReader reader = new PropertiesBeanDefinitionReader(bf);
    reader.loadBeanDefinitions(new ClassPathResource("/META-INF/spring/ioc-pull-context.properties"));
    return bf;
  }

}
 }}}

{{attachment:figure_3-1.png}} <<BR>> Figure 3-1 shows the UML sequence diagram for the dependency lookup.

__This kind of IoC is not only prevalent(盛行的) in Java EE-based applications, which make extensive use of JNDI lookups to obtain dependencies from a ''registry'', '''but it is also pivotal(重要的) to working with Spring in many environments. (要從外圍跟 Spring 環境接合時就需要用到 lookup 的技巧, 尤其是 servlet, main 等 entry-points; 下面 "initial bean lookups" 有提到...)'''__

==== Contextualized Dependency Lookup ====

__Contextualized dependency lookup (CDL) is similar, in some respects, to ''dependency pull'', but in CDL, lookup is performed against the container that is managing the resource, not from some ''central registry'', and it is usually performed at some ''set point''. '''(就像是 Servlet 可以透過 `init(ServletConfig config)` 取得環境組態一樣)'''__ CDL works by having the component implement an interface similar to the one in Listing 3-2.

Listing 3-2. Contextualized Dependency Lookup Component Marker Interface

 {{{
public interface ManagedComponent {
  void lookup(BeanFactory container);
}
 }}}

By implementing this interface, a component is signaling to the container that it wishes to obtain a dependency. When the container is ready to pass dependencies to a component, it calls `lookup()` on each component in turn. The component can then look up its dependencies using the `BeanFactory` interface (see Listing 3-3).

Listing 3-3. Contextualized Dependency Lookup Example

 {{{
public class ContextualizedDependencyLookupDemo {

  private static Set<ManagedComponent> components = new HashSet<ManagedComponent>();

  private static class MessageServiceComponent implements ManagedComponent {

    private MessageService service;

    public void lookup(BeanFactory container) { // 看要什麼自己拿
      this.service = (MessageService)container.getBean("service");
    }

    public void run() {
      this.service.execute();
    }

  }

  public static void main(String[] args) {
    BeanFactory bf = getBeanFactory();
    MessageServiceComponent msc = new MessageServiceComponent();
    registerComponent(msc);
    allowComponentsToLookup(bf);

    msc.run();
  }

  private static void allowComponentsToLookup(BeanFactory bf) {
    for (ManagedComponent component : components) {
      component.lookup(bf);
    }
  }

  private static void registerComponent(ManagedComponent managedComponent) {
    components.add(managedComponent);
  }

  private static BeanFactory getBeanFactory() {
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
    BeanDefinitionReader reader = new PropertiesBeanDefinitionReader(bf);
    reader.loadBeanDefinitions(new ClassPathResource("/META-INF/spring/ioc-pull-context.properties"));
    return bf;
  }
}
 }}}

The code in bold shows the `MessageServiceComponent` managed component. The `ContextualizedDependencyLookupDemo` acts as the container. The container prepares the dependencies, and when it finishes all necessary work, it calls the `lookup()` method on all components. Figure 3-2 shows the UML sequence diagram of the CDL.

{{attachment:figure_3-2.png}} <<BR>> Figure 3-2. Contextualized dependency lookup UML sequence diagram

We see that the `ContextualizedDependencyLookupDemo` acts as a container that manages (and in this example, uses) the `ManagedComponent` instances.

==== Constructor DI ====

__In constructor DI, a component’s dependencies are provided to it in its constructor(s). The component declares a constructor or a set of constructors, taking as arguments its dependencies, and the IoC container passes the dependencies to the component when it instantiates it__, as shown in Listing 3-4.

Listing 3-4. Component Dependency Injection Example

 {{{
public class CtorDependencyInjectionDemo {

  private static class DependentComponent {

    private MessageService service;

    private DependentComponent(MessageService service) {
      Assert.notNull(service, "The 'service' argument must not be null."); // org.springframework.util.Assert
      this.service = service;
    }

    public void run() {
      this.service.execute();
    }

  }

  public static void main(String[] args) {
    BeanFactory bf = getBeanFactory();
    MessageService service = (MessageService)bf.getBean("service");
    DependentComponent dc = new DependentComponent(service);

    dc.run();
  }

  private static BeanFactory getBeanFactory() { /* code as before */ }
  }

 }}}

Here, we see that the `DependentComponent`’s constructor takes a single `MessageService` argument. It also checks that the argument is not null; if this check were not there, we could write `new DependentComponent(null)`, which is clearly incorrect, because it would cause a `NullPointerException` in the `run()` method.

==== Setter DI ====

In setter DI, the IoC container injects a component’s dependencies into the component via !JavaBean-style setter methods. A component’s setters expose the set of the dependencies the IoC container can manage. Listing 3-5 shows a typical setter-DI–based component.

Listing 3-5. Setter Dependency Injection Example

 {{{
public class SetterDependencyInjectionDemo {

  private static class DependentComponent {

    private MessageService service;

    private DependentComponent() {
    }

    public void setService(MessageService service) {
      this.service = service;
    }

    public void run() {
      this.service.execute();
    }

  }

  public static void main(String[] args) {
    BeanFactory bf = getBeanFactory();
    MessageService service = (MessageService)bf.getBean("service");
    DependentComponent dc = new DependentComponent();
    dc.setService(service);

    dc.run();
  }

  private static BeanFactory getBeanFactory() { /* code as before */ }
  }

 }}}

__Unlike the constructor injection, we can create an instance of the `DependentComponent` without having the dependency. We are free to invoke the setter at any point in the application. '''We can also call the setter more than once, which allows us to swap the dependency at runtime.'''__

==== Injection vs. Lookup ====

Choosing which style of IoC to use—injection or lookup—is not usually a difficult decision. __In many cases, the type of IoC you use is mandated(被要求) by the container you are using. For instance, if you are using EJB 2.0, you must use lookup-style IoC to obtain the EJB from the Java EE container. '''EJB 3.0 introduces DI through its `@Inject` annotation. In Spring, aside from ''initial bean lookups'', your components and their dependencies are always wired together using injection-style IoC.'''__

__Note: When you are using Spring, you can access EJB resources without needing to perform an explicit lookup. '''Spring can act as an ''adapter'' between lookup- and injection-style IoC systems, thus allowing you to manage all resources using injection. (由此可見 IoC 之間的整合是很常見的; 上面介紹 Google Guice 的地方, 也有提到 Guice 與 Spring 的整合)'''__

The real question is this: given the choice, which method should you use, injection or lookup? The answer to this is most definitely injection. __If you look at the code in Listings 3-4 and 3-5, you can clearly see that using injection has zero impact on your components’ code. The dependency pull code, on the other hand, must actively obtain a reference to the registry and interact with it to obtain the dependencies; using CDL requires your classes to implement a specific interface and look up all dependencies programatically. (這裡 "implement a specific interface" 點出了 "dependency pull" 與 CDL 兩者間最大的不同) '''When you are using injection, the most your classes have to do is allow dependencies to be injected using either constructors or setters.'''__

__Using injection, you are free to use your classes completely decoupled from the IoC container, ''manually'' supplying dependent objects with their collaborators, whereas with lookup, your classes are always dependent on classes and interfaces defined by the container. '''Another drawback with lookup is that it becomes very difficult to test your classes in isolation from the container.''' Using injection, testing your components is trivial, because you can simply provide the dependencies yourself using the appropriate constructor or setter.__

Lookup-based solutions are, by necessity(不可避免地), more complex than injection-based ones. Although complexity is nothing to be afraid of, we question(質疑) the validity of adding unneeded complexity to a process as core to your application as dependency management.

All of these reasons aside, the biggest reason to choose injection over lookup is that it makes your life easier. You write substantially less code when you are using injection, and the code that you do write is simple and can, in general, be automated by a good IDE. __You will notice that all of the code in the injection samples is ''passive'', in that it doesn’t actively try to accomplish a task; the most exciting thing you see '''in injection code is objects getting stored in a field—not much can go wrong there!''' Passive code is much simpler to maintain than active code, because there is very little that can go wrong.__ Consider the following code taken from Listing 3-3:

 {{{
public void lookup(BeanFactory container) {
  this.service = (MessageService)container.getBean("service");
}
 }}}

__In this code, plenty could go wrong: the ''dependency key'' could change; the `container` instance could be `null`; or the returned dependency might be the incorrect type. Naturally, the last two cases would result in a `NullPointerException` or a `ClassCastException`, but you would find out only when you run the application; you could not discover this in an automated test. '''We say this code has a lot of ''moving parts'', because plenty of things can break. Using lookup might decouple(沒有把相依性寫死在組態檔裡面而言) the components of your application, but it adds complexity in the additional code required to couple these components back together to perform any useful tasks.'''__

==== Setter Injection vs. Constructor Injection ====

Now that we have established which method of IoC is preferable, we still need to choose whether to use setter injection or constructor injection. __Constructor injection is particularly useful when you absolutely must have an instance of the dependency class before your component is used. '''Many containers, Spring included, provide a mechanism for ensuring that all dependencies are defined when you use setter injection (setter injection 最大的問題就是怕有某些相依性被漏掉), but by using constructor injection, you assert the requirement for the dependency in a ''container-agnostic(不可知論的)'' manner. (聽起來 constructor/setter injection 都要自行檢查? 只不過 constructor injection 不用額外實作同 setter injection 實作 !HiveMind 之類 `initializeService` 的方法而已? 參考 List 3-4 的用法, 範例都用 `org.springframework.util.Assert` 來做檢查)'''__

Setter injection is useful in a variety of different cases. __'''If you want the component to expose its dependencies to the container but provide its own ''defaults'', setter injection is usually the best way to accomplish this.''' Another ''benefit'' of setter injection is that it allows dependencies to be declared on an interface, although this is not as useful as you might first think. (不知道這有什麼特別之處? 這裡確實是寫 "to be" 沒錯, 雖然下面一再地強調儘可能不要這麼做...)__ Consider a typical business interface with one business method, `defineMeaningOfLife()`. If, in addition to this method, you define a setter for injection such as `setEncylopedia()`, you are mandating that all implementations must use or at least be aware of the encyclopedia(百科全書) dependency. __You do not need to define this setter at all—any decent IoC container, Spring included, can work with the component in terms of the ''business interface'' but still provide the dependencies of the implementing class. (這正是 !HiveMind 在 `<service-poin ... interface="...">` 所要強調的東西)__ An example of this may clarify this matter slightly. Consider the business interface in Listing 3-6.

Listing 3-6. The `Oracle` Interface

 {{{
public interface Oracle {
  String defineMeaningOfLife();
}
 }}}

Notice that the business interface does not define any ''setters for DI''. This interface could be implemented as shown in Listing 3-7.

Listing 3-7. Implementation of the `Oracle` Interface

 {{{
public class BookwormOracle implements Oracle {

  private Encyclopedia encyclopedia;

  public String defineMeaningOfLife() {
    Long ageOfUniverse = this.encyclopedia.findLong("AgeOfUniverse");
    Long constantOfLife = this.encyclopedia.findLong("ConstantOfLife");

    return String.valueOf(ageOfUniverse / constantOfLife);
  }

  public void setEncyclopedia(Encyclopedia encyclopedia) {
    this.encyclopedia = encyclopedia;
  }

}
 }}}

As you can see, the `BookwormOracle` class not only implements the `Oracle` interface but also defines the setter for DI. Spring is more than comfortable dealing with a structure like this—there is absolutely no need to define the dependencies on the business interface. __The ability to use interfaces to define dependencies is an often-touted(吹捧) benefit of setter injection, but in actuality, '''you should strive to use setters solely for injection out of your business interfaces.'''__

__Defining the ''dependency setter methods'' on the interface makes it harder to reimplement that interface in the future, perhaps when the implementation technoloy changes.__ Take an e-mail sending interface, the `Emailer`, with the `send(MailMessage)` method. We could take the naive approach and define `setSmtpHost(String)`, `setSmtpPassword(String)`, and `setSmtpUsername(String)` in the `Emailer` interface, thus forcing every implementation to include these methods. If the only implementation of the `Emailer` interface is the `SmtpEmailer`, then all fits together perfectly. However, if you then start using a JNDI-bound `javax.mail.Session`, you no longer need the SMTP server details, yet your `JNDIEmailer` must implement the `setSmtpHost(String)`, `setSmtpPassword(String)`, and `setSmtpUsername(String)` methods. __'''To avoid having to implement unnecessary methods, the interfaces should be as clean as possible, completely hiding the implementation details.'''__

Setter injection also allows you to swap dependencies for a different implementation on the fly without creating a new instance of the parent component (Chapter 20 shows how Spring makes use of this in its JMX support). __'''Perhaps the biggest benefit of setter injection is that it is the ''least intrusive'' of the injection mechanisms.''' If you are defining constructors for injection on a class that would otherwise just have the default constructor, '''you are affecting all code that uses that class in a ''non-IoC environment''. (難道 setter-injection 在 non-IoC 環境下使用時就沒這個問題嗎?)''' Extra setters that are defined on a class for IoC purposes do not affect the ability of other classes to interact with it.__

__'''In general, setter injection is the best choice, because it has the least effect on your code’s usability in non-IoC settings.''' Constructor injection is a good choice when you want to ensure that dependencies are being passed to a component, but bear in mind(記住) that many containers provide their own mechanism for doing this with setter injection. (用 setter inject 輔以自動檢查有沒有完整注入, 還是可以達成相同的效果而言?)__ Most of the code in this book’s sample application uses setter injection, although there are a few examples of constructor injection.

=== IoC in Spring ===

__As we mentioned earlier, '''IoC is a big part of what Spring does, and the core of Spring’s implementation is based on DI''', although dependency lookup features are provided as well. When Spring automatically provides collaborators to a dependent object, it does so using DI.__ In a Spring-based application, it is always preferable to use dependency injection to pass collaborators to dependent objects rather than have the dependent objects obtain the collaborators via lookup. __'''Although DI is the preferred mechanism for wiring together collaborators and dependent objects, you need dependency lookup to access the dependent objects.''' In many environments, Spring cannot automatically wire up all of your ''application components'' using DI (例如 domain model), and you must use dependency lookup to access the ''initial set of components''. (就像 Tapestry 下的 `ApplicationServlet` 負責創建整個 !HiveMind 環境一樣...)__ When you are building web applications using Spring’s MVC support, Spring can avoid this by gluing your entire application together automatically. __Wherever possible, you should use DI with Spring; otherwise, you can ''fall back'' on the dependency lookup capabilities.__ You will see examples of both in action during the course of this chapter, and we will point them out when they first arise.

__An interesting feature of Spring’s IoC container is that '''it has the ability to act as an ''adaptor'' between its own dependency injection container and external dependency lookup containers.''' We look at this in more detail in Chapter 4.__

Spring supports both constructor and setter injection and bolsters(支持) the standard IoC feature set with a whole host of useful additions to make your life easier.

The rest of this chapter introduces the basics of Spring’s ''DI container'' complete with plenty of examples.

=== DI with Spring ===

Spring’s support for DI is comprehensive and, as you will see in Chapter 4, goes beyond the standard IoC feature set we have discussed so far. The rest of this chapter addresses the basics of Spring’s DI container, looking at both setter and constructor injection, along with a detailed look at how DI is configured in Spring.

==== Beans and BeanFactories ====

The core of Spring’s DI container is the `BeanFactory`. A `BeanFactory` is responsible for managing components and their dependencies. __In Spring, the term “bean” is used to refer to any component managed by the container. Typically, your beans adhere, on some level, to the ''!JavaBeans specification'' (針對 setter injection 而言), but this is not required, especially if you plan to use constructor injection to wire your beans together.__

Your application interacts with the Spring DI container via the `BeanFactory` interface. At some point, your application must create an instance of a class that implements the `BeanFactory` interface and configure it with bean and dependency information. After this is complete, your application can access the beans via the `BeanFactory` and get on with(友好相處) its processing. __'''In some cases, all of this setup is handled automatically, but in many cases, you need to code the setup yourself.'''__ All of the examples in this chapter require ''manual setup'' of the `BeanFactory` implementation.

__Although a `BeanFactory` can be configured programmatically, it is more common to see it configured externally using some kind of configuration file.__ Internally, bean configuration is represented by instances of classes that implement the `BeanDefinition` interface. __The bean configuration stores not only information about a bean itself but also about the beans that it depends on.__ For any `BeanFactory` class that also implements the `BeanDefinitionRegistry` interface, you can read the `BeanDefinition` data from a configuration file, using either `PropertiesBeanDefinitionReader` or `XmlBeanDefinitionReader`. The two main `BeanFactory` implementations that come with Spring implement `BeanDefinitionRegistry`.

__So you can identify your beans within the `BeanFactory`, each bean is assigned a ''name''. Each bean has ''at least one'' name but can have any number of them. Any names after the first are considered ''aliases'' for the same bean. You use bean names to retrieve a bean from the `BeanFactory` and to establish ''dependency relationships''—that is, bean X depends on bean Y.__

==== BeanFactory Implementations ====

The description of the `BeanFactory` might make using it seem overly complex, but in practice, this is not the case. In fact, we discussed all of the concepts in the previous section and in the simple example in Chapter 2. Listing 3-8 shows a sample application that uses the `Oracle` interface.

Listing 3-8. Using the `BeanFactory`

 {{{
public class BeanFactoryDemo {

  public static void main(String[] args) {
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
    BeanDefinitionReader reader = new PropertiesBeanDefinitionReader(bf);
    reader.loadBeanDefinitions(new ClassPathResource("/META-INF/spring/beanfactorydemo1-context.properties"));

    Oracle oracle = (Oracle)bf.getBean("oracle");
    System.out.println("Meaning of life is " + oracle.defineMeaningOfLife());
  }

}
 }}}

In this example, you can see that we are using the `DefaultListableBeanFactory`—one of the two main `BeanFactory` implementations supplied with Spring (另一個是 `XmlBeanFactory`)—and that we are reading in the `BeanDefinition` information from a properties file using the `PropertiesBeanDefinitionReader`. Once the `BeanFactory` implementations is created and configured, we retrieve the `Oracle` bean using its name, `oracle`, which is configured in the properties file (see Listing 3-9).

Listing 3-9. The `beanfactorydemo1-context.properties` File

 {{{
oracle.(class)=com.apress.prospring2.ch03.di.BookwormOracle
encyclopedia.(class)=com.apress.prospring2.ch03.di.HardcodedEncyclopedia
oracle.encyclopedia(ref)=encyclopedia
 }}}

In addition to the `PropertiesBeanDefinitionReader`, Spring also provides `XmlBeanDefinitionReader`, which allows you to manage your bean configuration using XML rather than properties. __The properties files are only usable for small, simple applications. They quickly become unusable when you are dealing with a large number of beans. For this reason, it is preferable to use the XML configuration format for all but the most trivial of applications. (XML 組態檔所能表現的東西遠遠超出 `.properties`)__ This leads nicely to a discussion of the second of the two main `BeanFactory` implementations: `XmlBeanFactory`.

The `XmlBeanFactory` is derived from `DefaultListableBeanFactory` and simply extends it to perform ''automatic configuration'' using the `XmlBeanDefinitionReader`. We can use this to write the code in Listing 3-10.


Listing 3-10. Using the `XmlBeanFactory`

 {{{
public class XmlBeanFactoryDemo {

  public static void main(String[] args) {
    // 不像 DefaultListableBeanFactory 要額外用一個 BeanDefinitionReader 讀取組態 - 這就是 automatic configuration?
    XmlBeanFactory bf = new XmlBeanFactory(new ClassPathResource("/META-INF/spring/beanfactorydemo1-context.xml"));

    Oracle oracle = (Oracle)bf.getBean("oracle");
    System.out.println("Meaning of life is " + oracle.defineMeaningOfLife());
  }

}
 }}}

For the rest of this book, including the sample application, we will be using the XML configuration format exclusively. You are free to investigate the properties format yourself— you will find plenty of examples throughout the Spring codebase.

Of course, you are free to define your own `BeanFactory` implementations, although be aware that doing so is quite involved(復雜的); you need to implement a lot more interfaces than just `BeanFactory` to get the same level of functionality you have with the supplied `BeanFactory` implementations. __If all you want to do is define a new ''configuration mechanism'', create your definition reader and ''wrap'' this in a simple `BeanFactory` implementation derived from `DefaultListableBeanFactory`. (就像 `XmlBeanFactory` 所做的一樣)__ By “new configuration mechanism,” we mean one using formats other than properties and XML; for example, you can implement a `BeanDefinitionReader` that uses a relational database as the source of the configuration data. There is a way to allow Spring to handle ''custom namespaces'' in the XML configuration files; go to Chapter 7 for more details.

==== XML Bean Definition ====

The key to getting set up with any Spring-based application is creating the `BeanFactory` configuration file for your application. A basic configuration without any bean definitions looks similar to the code in Listing 3-11.

Listing 3-11. Empty Bean Definition XML

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> 
  <-- 這幾行一定要加 (光宣告 namespace 也沒用), 否則執行期會出現 "Cannot find the declaration of element 'beans'" 的錯誤 -->
</beans>
 }}}

Each bean is defined using a `<bean>` tag under the root of the `<beans>` tag. __The `<bean>` tag typically has two attributes: `id` and `class`. The `id` attribute is used to give the bean its ''default name'' (命名慣例同 Java, 例如 `oracle` 或 `constructorConfusion`), and the `class` attribute specifies the ''type'' of the bean.__ Listing 3-12 shows the XML file that defines the beans implementing the `Oracle` and `Encyclopedia` interfaces.

Listing 3-12. XML Configuration File for the Code in Listing 3-10

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="oracle" class="com.apress.prospring2.ch03.di.BookwormOracle">
    <property name="encyclopedia">
      <bean class="com.apress.prospring2.ch03.di.HardcodedEncyclopedia"/>
    </property>
  </bean>
</beans>
 }}}

__You can see that we have defined the bean with `id` `oracle` as an instance of the `BookwormOracle` and that its `encyclopedia` property is an ''anonymous bean'', which means that no other component can use the `encyclopedia` dependency of the `oracle` bean. If we wanted to allow other beans to use the `encyclopedia` bean, we would have to move it from the ''inner anonymous bean'' to a ''top-level bean'' (see Listing 3-13).__

Listing 3-13. Using the `Encyclopedia` Bean As a Top-Level Bean

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="encyclopedia" class="com.apress.prospring2.ch03.di.HardcodedEncyclopedia"/>
  
  <bean id="oracle" class="com.apress.prospring2.ch03.di.BookwormOracle">
    <property name="encyclopedia" ref="encyclopedia"/>
  </bean>
</beans>
 }}}

__The choice of whether the ''dependent beans'' are inner anonymous or top-level beans is entirely up to us. (這裡 "dependent beans" 的說法跟上面的 "dependent object" 完全相反?)__ In any case, Spring will need to maintain the instance of the bean.

==== Using Constructor Injection ====

In the previous example, the `Encyclopedia` implementation, `HardcodedEncyclopedia`, contained hard-coded values for its entries. In the Spring configuration file, you can easily create a configurable `Encyclopedia` that allows the message to be ''defined externally'' (see Listing 3-14).

Listing 3-14. The `ConfigurableEncyclopedia` Class

 {{{
public class ConfigurableEncyclopedia implements Encyclopedia {

  private Map<String, Long> entries;

  public ConfigurableEncyclopedia(Map<String, Long> entries) {
    Assert.notNull(entries, "The 'entries' argument cannot be null.");
    this.entries = entries;
  }

  public Long findLong(String entry) {
    return this.entries.get(entry);
  }
}
 }}}

As you can see, creating an instance of `ConfigurableEncyclopedia` without providing a value for the `entries` is impossible (and giving `null` will throw an `IllegalArgumentException`). This behavior is exactly what we want, and this class is ideally suited for use with constructor injection. Listing 3-15 shows how you can redefine the `encyclopedia` bean definition to create an instance of `ConfigurableEncyclopedia`, injecting the `entries` using constructor injection.

Listing 3-15. Creating an Instance of the `ConfigurableEncyclopedia`

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:util="http://www.springframework.org/schema/util"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">

  <bean id="encyclopedia" class="com.apress.prospring2.ch03.di.ConfigurableEncyclopedia">
    <constructor-arg>
      <util:map>
        <entry key="AgeOfUniverse" value="13700000000"/>
        <entry key="ConstantOfLife" value="326190476"/>
      </util:map>
    </constructor-arg>
  </bean>

  <bean id="oracle" class="com.apress.prospring2.ch03.di.BookwormOracle">
    <property name="encyclopedia" ref="encyclopedia"/>
  </bean>
</beans>
 }}}

In Listing 13-5, we used a `<constructor-arg>` tag. We have made the example slightly more complicated by passing a `Map<String, Long>` to the constructor. __We use the `util:map` element to create an ''inner anonymous bean'' of type `Map` that we then pass to the `ConfigurableEncyclopedia(Map<String, Long>)` constructor.__ Do not worry if you do not recognise the `util:map` element; we will explain this in much more detail in Chapter 7. __Still, the code in Listing 3-15 clearly demonstrates that '''Spring beans really can be instances of ''any class'' you can use in Java.'''__

__When you have more than one constructor argument or your class has more than one constructor, typically, you need to give each `<constructor-arg>` tag an `index` attribute to specify the index of the argument, ''starting at zero'', in the constructor signature. It is always best to use the `index` attribute whenever you are dealing with constructors that have multiple arguments to avoid confusion between the parameters and ensure that Spring picks the correct constructor. (為什麼會有 confusion? 如果是像下一節 "Avoiding Constructor Confusion" 所提到的狀況, 加 index 好像也沒什麼幫助... 難道沒有給定的參數會自動帶入 `null`[?])__

===== Avoiding Constructor Confusion =====

In some cases, Spring finds it impossible to tell which constructor you want it to use for constructor injection. This usually arises when you have two constructors with the same number of arguments and the types used in the arguments are represented in exactly the same way. Consider the code in Listing 3-16.

Listing 3-16. Constructor Confusion

 {{{
public class ConstructorConfusionDemo {

  private String someValue;

  public ConstructorConfusionDemo(String someValue) {
    System.out.println("ConstructorConfusionDemo(String) called");
    this.someValue = someValue;
  }

  public ConstructorConfusionDemo(int someValue) {
    System.out.println("ConstructorConfusionDemo(int) called");
    this.someValue = "Number: " + Integer.toString(someValue);
  }

  public static void main(String[] args) {
    BeanFactory factory = new XmlBeanFactory(new ClassPathResource("/META-INF/spring/beanfactorydemo3-context.xml"));
    ConstructorConfusionDemo cc = (ConstructorConfusionDemo)factory.getBean("constructorConfusion");
    System.out.println(cc);
  }

  public String toString() {
    return someValue;
  }

}
 }}}

Here, you can clearly see what this code does—it simply retrieves a bean of type `ConstructorConfusionDemo` from the `BeanFactory` and writes the value to stdout. Now, look at the configuration code in Listing 3-17.

Listing 3-17. Confused Constructors

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="constructorConfusion" class="com.apress.prospring2.ch03.beanfactory.ConstructorConfusionDemo">
    <constructor-arg value="1"/>
  </bean>
</beans>
 }}}

Which of the constructors is called in this case? Running the example yields the following output:

 {{{
ConstructorConfusionDemo(String) called
1

Process finished with exit code 0
 }}}

This shows that the constructor with the `String` argument was called. This is not the desired effect, since we want to prefix any integer values passed in using constructor injection with `Number:`, as shown in the int constructor. To get around this, we need to make a small modification to the configuration, shown in Listing 3-18.

Listing 3-18. Overcoming Constructor Confusion

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="constructorConfusion" class="com.apress.prospring2.ch03.beanfactory.ConstructorConfusionDemo">
    <constructor-arg value="1" type="int"/>
  </bean>
</beans>
 }}}

__Notice now that the `<constructor-arg>` tag has an additional attribute, `type`, that specifies the type of argument that Spring should look for.__ Running the example again with the corrected configuration yields the correct output:

 {{{
ConstructorConfusionDemo(int) called
Number: 1

Process finished with exit code 0
 }}}

==== Injection Parameters ====

In the two previous examples, you saw how to inject other components and values into a bean using both setter injection and constructor injection. __Spring supports a myriad(各式各樣的) of options for ''injection parameters'', allowing you to inject not only other components and simple values but also Java collections, ''externally defined properties'', and even ''beans in another factory''.__ You can set all of these injection parameter types for both setter injection and constructor injection by using the corresponding tag under the `<property>` and `<constructor-args>` tags, respectively.

===== Injecting Simple Values =====

Injecting simple values into your beans is easy. To do so, simply specify the value in the configuration tag using the `value` attribute; alternatively. you can specify the value inside a `<value>` tag. __By default, the `value` attribute and `<value>` tag can not only read `String` values '''but can also convert these values to any primitive or primitive wrapper class. (自動轉換!! 不用額外宣告 type)'''__ Listing 3-19 shows a simple bean that has a variety of properties exposed for injection.

Listing 3-19. Injecting Simple Values

 {{{
public class InjectSimpleDemo {

  private String name;

  private int age;

  private float height;

  private boolean isProgrammer;

  private Long ageInSeconds;

  public static void main(String[] args) {
    XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource("/META-INF/spring/injectdemo1-context.xml"));
    InjectSimpleDemo simple = (InjectSimpleDemo)factory.getBean("injectSimpleDemo");

    System.out.println(simple);
  }

  public void setAgeInSeconds(Long ageInSeconds) {
    this.ageInSeconds = ageInSeconds;
  }

  public void setIsProgrammer(boolean isProgrammer) {
    this.isProgrammer = isProgrammer;
  }

  public void setAge(int age) {
    this.age = age;
  }

  public void setHeight(float height) {
    this.height = height;
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public String toString() {
    return String.format("Name: %s\nAge: %d\nAge in Seconds: %d\n" + "Height: %g\nIs Programmer?: %b",
    this.name, this.age, this.ageInSeconds,
    this.height, this.isProgrammer);
  }

}
 }}}

In addition to the properties, the `InjectSimple` class also defines the `main()` method that creates an `XmlBeanFactory` and retrieves an `InjectSimple` bean from Spring. The property values of this bean are then written to stdout. The configuration for this bean is shown in Listing 3-20.

Listing 3-20. Configuring Simple Value Injection

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="injectSimpleDemo" class="com.apress.prospring2.ch03.beanfactory.InjectSimpleDemo">
    <property name="name" value="John Smith"/>
    <property name="age" value="35"/>
    <property name="height" value="1.79"/>
    <property name="isProgrammer" value="true"/>
    <property name="ageInSeconds" value="1103760000"/>
  </bean>
</beans>
 }}}

You can see from Listings 3-18 and 3-19 that it is possible to define properties on your bean that accept `String` values, primitive values, or primitive wrapper values and inject values for these properties using the `value` attribute. Here is the output created by running this example, which is just what was expected:

 {{{
Name: John Smith
Age: 35
Age in Seconds: 1103760000
Height: 1.79000
Is Programmer?: true

Process finished with exit code 0
 }}}

In Chapter 4, you will see how to expand the range of types that can be injected using the `value` attribute and `<value>` tag.

__In addition to the standard `<property>` tag, you can use the `p` namespace to set the properties of the beans. The `p` namespace allows you to configure the dependencies as attributes of the `<bean>` tag.__ Listing 3-21 shows the configuration of the `injectSimpleDemo` bean from Listing 3-20 using the `p` namespace.

Listing 3-21. Configuration Using the p Namespace

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="injectSimpleDemo" class="com.apress.prospring2.ch03.beanfactory.InjectSimpleDemo"
      p:age="35" p:ageInSeconds="1103760000" p:height="1.79" p:isProgrammer="false"/>
</beans>
 }}}

Running the `InjectSimpleDemo` with the configuration file from Listing 3-21 produces the same output. __The only advantage of using the `p` namespace is that you have less code to write, especially if you need to configure only a small number of properties. (數量多時可讀性會降低)__ You may notice that the `p` namespace usage in Listing 3-21 allows you to inject only simple values, not references—we will discuss injecting references using the `p` namespace in the next section.

===== Injecting Beans in the Same Factory =====

As you have already seen, you can inject one bean into another using the `ref` attribute; you can also use the `<ref>` tag. __To configure Spring to inject one bean into another, you first need to configure two beans: one to be injected and one to be the ''target'' of the injection. Once this is done, you simply configure the injection using the `ref` attribute on the ''target bean''.__ Listing 3-22 shows the configuration for the oracle bean again.

Listing 3-22. Configuring Bean Injection

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/util
                http://www.springframework.org/schema/util/spring-util.xsd">

  <bean id="encyclopedia" class="com.apress.prospring2.ch03.di.ConfigurableEncyclopedia">
    <constructor-arg>
      <util:map>
        <entry key="AgeOfUniverse" value="13700000000"/>
        <entry key="ConstantOfLife" value="326190476"/>
      </util:map>
    </constructor-arg>
  </bean>

  <bean id="oracle" class="com.apress.prospring2.ch03.di.BookwormOracle">
    <property name="encyclopedia" ref="encyclopedia"/>
  </bean>
</beans>
 }}}

An important point to note is that the type being injected does not have to be the exact type defined on the target; the types just need to be compatible. Being compatible means, for example, that if the declared type on the target is an interface, the injected type must implement this interface. If the declared type is a class, the injected type must either be the same type or a subtype. In this example, the BookwormOracle class defines the setEncyclopedia(Encyclopedia) method to receive an instance of Encyclopedia, which is an interface, and the injected type is ConfigurableEncyclopedia, a class that implements Encyclopedia. This is a point that causes confusion for some developers, but it is really quite simple. Injection is subject to the same typing rules as any Java code, so as long as you are familiar with how Java typing works, understanding typing in injection is easy.

Apart from using the <property> tag, you can also use the p namespace to inject other beans. The style of code to inject bean references is similar to the properties configuration syntax. As an example, the code in Listing 3-23 shows the configuration file from Listing 3-22 using the p namespace.

Listing 3-23. Configuring Bean Injection Using the `p` Namespace

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:util="http://www.springframework.org/schema/util"
xmlns:p="http://www.springframework.org/schema/p"
xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/util
http://www.springframework.org/schema/util/spring-util.xsd">
<bean id="encyclopedia"
name="knowitall"
class="com.apress.prospring2.ch03.di.ConfigurableEncyclopedia">
<constructor-arg>
<util:map>
<entry key="AgeOfUniverse" value="13700000000"/>
<entry key="ConstantOfLife" value="326190476"/>
</util:map>
</constructor-arg>
</bean>
<bean id="oracle" class="com.apress.prospring2.ch03.di.BookwormOracle"
p:encyclopedia-ref="knowitall"/>
</beans>
 }}}

The code is very similar to the code from Listing 3-21; the only notable difference is that we had to append -ref to the encyclopedia property name in the oracle bean to indicate that the BeanFactory should use the bean with the id (or name) knowitall rather than use the value (String)"knowitall" as the property value.

In the previous examples, the id of the bean to inject was specified using the ref attribute of the <property> tag. As you will see later, in the section titled “Understanding Bean Naming,” you can give a bean more than one name so that you can refer to it using a variety of aliases. When you use the ref attribute, the <property> tag looks at the bean’s id and any of its aliases. Listing 3-24 shows an alternative configuration for the previous example using an alternative name for the injected bean.

Listing 3-24. Injecting Using Bean Aliases

 {{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:util="http://www.springframework.org/schema/util"
xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/util
http://www.springframework.org/schema/util/spring-util.xsd">
<bean id="encyclopedia"
name="knowitall"
class="com.apress.prospring2.ch03.di.ConfigurableEncyclopedia">
<constructor-arg>
<util:map>
<entry key="AgeOfUniverse" value="13700000000"/>
<entry key="ConstantOfLife" value="326190476"/>
</util:map>
</constructor-arg>
</bean>
<bean id="oracle" class="com.apress.prospring2.ch03.di.BookwormOracle">
<property name="encyclopedia" ref="knowitall"/>
</bean>
</beans>
 }}}

In this example, the encyclopedia bean is given an alias using the name attribute, and then it is
injected into the oracle bean by using this alias in conjunction with the bean attribute of the <property>
tag. Don’t worry too much about the naming semantics at this point—we discuss this in much more
detail later in the chapter.
Injection and BeanFactory Nesting
So far, the beans we have been injecting have been located in the same bean factory as the beans
they are injected into. However, Spring supports a hierarchical structure for BeanFactories so that
one factory is considered the parent of another. By allowing BeanFactories to be nested, Spring
allows you to split your configuration into different files—a godsend on larger projects with lots of
beans.
When nesting BeanFactories, Spring allows beans in the child factory to reference beans in the
parent factory. The only drawback is that this can be done only in configuration. It is impossible to
call getBean() on the child BeanFactory to access a bean in the parent BeanFactory.
BeanFactory nesting using the XmlBeanFactory is very simple. To nest one XmlBeanFactory
inside another, simply pass the parent XmlBeanFactory as a constructor argument to the child
XmlBeanFactory. This is shown in Listing 3-25.
Listing 3-25. Nesting XmlBeanFactories
XmlBeanFactory parent = new XmlBeanFactory(
new ClassPathResource("/META-INF/spring/injectdemo1-context.xml"));
XmlBeanFactory child = new XmlBeanFactory(
new ClassPathResource("/META-INF/spring/injectdemo2-context.xml"),
parent);

Inside the configuration file for the child BeanFactory, referencing a bean in the parent
BeanFactory works exactly like referencing a bean in the child BeanFactory, unless you have a bean
in the child BeanFactory that shares the same name. In that case, you can no longer use the convenient
ref attribute of the <property> tag but must start using the <ref parent=""/> tag. Listing 3-26
shows how to write the XML configuration file with reference to the parent bean.
Listing 3-26. Child BeanFactory Configuration
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">
<bean id="name" class="java.lang.String">
<constructor-arg value="Johnny Smith"/>
</bean>
<bean id="injectSimpleChild"
class="com.apress.prospring2.ch03.beanfactory.InjectSimpleDemo">
<property name="name" ref="name"/>
<property name="age" value="2"/>
<property name="height" value="0.8"/>
<property name="isProgrammer" value="false"/>
<property name="ageInSeconds" value="63072000"/>
</bean>
<bean id="injectSimpleChild2"
class="com.apress.prospring2.ch03.beanfactory.InjectSimpleDemo">
<property name="name">
<ref parent="name"/>
</property>
<property name="age" value="2"/>
<property name="height" value="0.8"/>
<property name="isProgrammer" value="false"/>
<property name="ageInSeconds" value="63072000"/>
</bean>
</beans>
Notice that we have two beans, injectSimpleChild and injectSimpleChild2. Both beans use
the name bean to set the value of their name property. However, the injectSimpleChild bean uses the
local name bean, while injectSimpleChild2 uses the name bean from the parent BeanFactory. If we
tried using this configuration file on its own, it would fail, because there is no parent bean factory.
We can verify this by modifying the line that creates the child BeanFactory as follows:
XmlBeanFactory child = new XmlBeanFactory(new ClassPathResource(
"/META-INF/spring/injectdemo3-context.xml"));
When we run the application, the child BeanFactory has no reference to the parent
BeanFactory, and the application will fail with a BeanCreationException:



[[|:]]

== Resource ==

=== Reference ===

=== Attachments ===

|| Filename || Description ||
||  ||  ||

=== Links ===

=== Search ===

== Scratch ==

 * p40. we retrieve the MessageRenderer bean using its name, renderer..., 要改成 we retrieve the Oracle bean using its name, oracle
